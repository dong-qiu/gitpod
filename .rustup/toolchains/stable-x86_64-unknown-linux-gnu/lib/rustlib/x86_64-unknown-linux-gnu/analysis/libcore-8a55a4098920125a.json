{"config":{"output_file":null,"full_docs":false,"pub_only":true,"reachable_only":false,"distro_crate":true,"signatures":false,"borrow_data":false},"version":"0.19.0","compilation":{"directory":"/rustc/eae3437dfe991621e8afdc82734f4a172d7ddf9b/","program":"/checkout/obj/build/x86_64-unknown-linux-gnu/stage1/bin/rustc","arguments":["--edition=2018","--crate-name","core","src/libcore/lib.rs","--color","always","--crate-type","lib","--emit=dep-info,metadata,link","-C","opt-level=2","-C","metadata=8a55a4098920125a-rustc","-C","extra-filename=-8a55a4098920125a","--out-dir","/checkout/obj/build/x86_64-unknown-linux-gnu/stage1-std/x86_64-unknown-linux-gnu/release/deps","--target","x86_64-unknown-linux-gnu","-C","linker=clang","-L","dependency=/checkout/obj/build/x86_64-unknown-linux-gnu/stage1-std/x86_64-unknown-linux-gnu/release/deps","-L","dependency=/checkout/obj/build/x86_64-unknown-linux-gnu/stage1-std/release/deps","-Cdebuginfo=1","--sysroot","/checkout/obj/build/x86_64-unknown-linux-gnu/stage1","-Zexternal-macro-backtrace","-Cprefer-dynamic","-Clinker=clang","-C","debug-assertions=n","-C","codegen-units=1","-Zsave-analysis","-C","link-args=-Wl,-rpath,$ORIGIN/../lib","-Zunstable-options","-Z","force-unstable-if-unmarked","-Dwarnings","-Dbare_trait_objects","-Drust_2018_idioms"],"output":"/checkout/obj/build/x86_64-unknown-linux-gnu/stage1-std/x86_64-unknown-linux-gnu/release/deps/libcore-8a55a4098920125a.rmeta"},"prelude":{"crate_id":{"name":"core","disambiguator":[3916277366462804126,4478459115610208312]},"crate_root":"src/libcore","external_crates":[],"span":{"file_name":"src/libcore/lib.rs","byte_start":0,"byte_end":7351,"line_start":1,"line_end":238,"column_start":1,"column_end":25}},"imports":[{"kind":"Use","ref_id":{"krate":0,"index":211},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":246215,"byte_end":246221,"line_start":124,"line_end":124,"column_start":25,"column_end":31},"alias_span":null,"name":"decode","value":"","parent":{"krate":0,"index":190}},{"kind":"Use","ref_id":{"krate":0,"index":205},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":246223,"byte_end":246237,"line_start":124,"line_end":124,"column_start":33,"column_end":47},"alias_span":null,"name":"DecodableFloat","value":"","parent":{"krate":0,"index":190}},{"kind":"Use","ref_id":{"krate":0,"index":10203},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":246239,"byte_end":246250,"line_start":124,"line_end":124,"column_start":49,"column_end":60},"alias_span":null,"name":"FullDecoded","value":"","parent":{"krate":0,"index":190}},{"kind":"Use","ref_id":{"krate":0,"index":10187},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":246252,"byte_end":246259,"line_start":124,"line_end":124,"column_start":62,"column_end":69},"alias_span":null,"name":"Decoded","value":"","parent":{"krate":0,"index":190}},{"kind":"Use","ref_id":{"krate":0,"index":10390},"span":{"file_name":"src/libcore/num/dec2flt/num.rs","byte_start":372418,"byte_end":372426,"line_start":7,"line_end":7,"column_start":29,"column_end":37},"alias_span":{"file_name":"src/libcore/num/dec2flt/num.rs","byte_start":372430,"byte_end":372433,"line_start":7,"line_end":7,"column_start":41,"column_end":44},"name":"Big","value":"","parent":{"krate":0,"index":365}},{"kind":"Use","ref_id":{"krate":0,"index":545},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":442558,"byte_end":442563,"line_start":914,"line_end":914,"column_start":29,"column_end":34},"alias_span":null,"name":"isize","value":"","parent":{"krate":0,"index":542}},{"kind":"Use","ref_id":{"krate":0,"index":544},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":442744,"byte_end":442749,"line_start":921,"line_end":921,"column_start":29,"column_end":34},"alias_span":null,"name":"usize","value":"","parent":{"krate":0,"index":542}},{"kind":"Use","ref_id":{"krate":0,"index":10351},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":233714,"byte_end":233729,"line_start":5091,"line_end":5091,"column_start":30,"column_end":45},"alias_span":null,"name":"ParseFloatError","value":"","parent":{"krate":0,"index":159}},{"kind":"Use","ref_id":{"krate":0,"index":1445},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":443262,"byte_end":443266,"line_start":12,"line_end":12,"column_start":25,"column_end":29},"alias_span":null,"name":"Copy","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":1437},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":443268,"byte_end":443272,"line_start":12,"line_end":12,"column_start":31,"column_end":35},"alias_span":null,"name":"Send","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":1442},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":443274,"byte_end":443279,"line_start":12,"line_end":12,"column_start":37,"column_end":42},"alias_span":null,"name":"Sized","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":1446},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":443281,"byte_end":443285,"line_start":12,"line_end":12,"column_start":44,"column_end":48},"alias_span":null,"name":"Sync","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":1473},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":443287,"byte_end":443292,"line_start":12,"line_end":12,"column_start":50,"column_end":55},"alias_span":null,"name":"Unpin","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":1623},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":443387,"byte_end":443391,"line_start":15,"line_end":15,"column_start":22,"column_end":26},"alias_span":null,"name":"Drop","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":1626},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":443393,"byte_end":443395,"line_start":15,"line_end":15,"column_start":28,"column_end":30},"alias_span":null,"name":"Fn","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":1629},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":443397,"byte_end":443402,"line_start":15,"line_end":15,"column_start":32,"column_end":37},"alias_span":null,"name":"FnMut","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":1632},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":443404,"byte_end":443410,"line_start":15,"line_end":15,"column_start":39,"column_end":45},"alias_span":null,"name":"FnOnce","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":1105},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":443530,"byte_end":443534,"line_start":20,"line_end":20,"column_start":21,"column_end":25},"alias_span":null,"name":"drop","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":2056},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":443662,"byte_end":443667,"line_start":25,"line_end":25,"column_start":23,"column_end":28},"alias_span":null,"name":"Clone","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":1936},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":443761,"byte_end":443770,"line_start":28,"line_end":28,"column_start":22,"column_end":31},"alias_span":null,"name":"PartialEq","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":1970},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":443772,"byte_end":443782,"line_start":28,"line_end":28,"column_start":33,"column_end":43},"alias_span":null,"name":"PartialOrd","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":1940},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":443784,"byte_end":443786,"line_start":28,"line_end":28,"column_start":45,"column_end":47},"alias_span":null,"name":"Eq","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":1960},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":443788,"byte_end":443791,"line_start":28,"line_end":28,"column_start":49,"column_end":52},"alias_span":null,"name":"Ord","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":2087},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":443890,"byte_end":443895,"line_start":31,"line_end":31,"column_start":26,"column_end":31},"alias_span":null,"name":"AsRef","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":2090},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":443897,"byte_end":443902,"line_start":31,"line_end":31,"column_start":33,"column_end":38},"alias_span":null,"name":"AsMut","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":2093},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":443904,"byte_end":443908,"line_start":31,"line_end":31,"column_start":40,"column_end":44},"alias_span":null,"name":"Into","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":2096},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":443910,"byte_end":443914,"line_start":31,"line_end":31,"column_start":46,"column_end":50},"alias_span":null,"name":"From","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":2080},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":444012,"byte_end":444019,"line_start":34,"line_end":34,"column_start":25,"column_end":32},"alias_span":null,"name":"Default","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":3202},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":444114,"byte_end":444122,"line_start":37,"line_end":37,"column_start":23,"column_end":31},"alias_span":null,"name":"Iterator","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":3401},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":444124,"byte_end":444130,"line_start":37,"line_end":37,"column_start":33,"column_end":39},"alias_span":null,"name":"Extend","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":3392},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":444132,"byte_end":444144,"line_start":37,"line_end":37,"column_start":41,"column_end":53},"alias_span":null,"name":"IntoIterator","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":3360},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":444240,"byte_end":444259,"line_start":40,"line_end":40,"column_start":23,"column_end":42},"alias_span":null,"name":"DoubleEndedIterator","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":3380},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":444261,"byte_end":444278,"line_start":40,"line_end":40,"column_start":44,"column_end":61},"alias_span":null,"name":"ExactSizeIterator","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":32847},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":444384,"byte_end":444388,"line_start":43,"line_end":43,"column_start":33,"column_end":37},"alias_span":null,"name":"self","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":32851},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":444390,"byte_end":444394,"line_start":43,"line_end":43,"column_start":39,"column_end":43},"alias_span":null,"name":"Some","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":32849},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":444396,"byte_end":444400,"line_start":43,"line_end":43,"column_start":45,"column_end":49},"alias_span":null,"name":"None","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":32938},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":444506,"byte_end":444510,"line_start":46,"line_end":46,"column_start":33,"column_end":37},"alias_span":null,"name":"self","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":32941},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":444512,"byte_end":444514,"line_start":46,"line_end":46,"column_start":39,"column_end":41},"alias_span":null,"name":"Ok","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":32944},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":444516,"byte_end":444519,"line_start":46,"line_end":46,"column_start":43,"column_end":46},"alias_span":null,"name":"Err","value":"","parent":{"krate":0,"index":628}},{"kind":"Use","ref_id":{"krate":0,"index":1278},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":446234,"byte_end":446247,"line_start":42,"line_end":42,"column_start":21,"column_end":34},"alias_span":null,"name":"drop_in_place","value":"","parent":{"krate":0,"index":668}},{"kind":"Use","ref_id":{"krate":0,"index":14164},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":521392,"byte_end":521404,"line_start":18,"line_end":18,"column_start":24,"column_end":36},"alias_span":null,"name":"ManuallyDrop","value":"","parent":{"krate":0,"index":1027}},{"kind":"Use","ref_id":{"krate":0,"index":14199},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":521501,"byte_end":521512,"line_start":22,"line_end":22,"column_start":23,"column_end":34},"alias_span":null,"name":"MaybeUninit","value":"","parent":{"krate":0,"index":1027}},{"kind":"Use","ref_id":{"krate":0,"index":882},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":521603,"byte_end":521612,"line_start":26,"line_end":26,"column_start":28,"column_end":37},"alias_span":null,"name":"transmute","value":"","parent":{"krate":0,"index":1027}},{"kind":"Use","ref_id":{"krate":0,"index":1012},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":575545,"byte_end":575564,"line_start":73,"line_end":73,"column_start":28,"column_end":47},"alias_span":null,"name":"copy_nonoverlapping","value":"","parent":{"krate":0,"index":1134}},{"kind":"Use","ref_id":{"krate":0,"index":1017},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":575640,"byte_end":575644,"line_start":76,"line_end":76,"column_start":28,"column_end":32},"alias_span":null,"name":"copy","value":"","parent":{"krate":0,"index":1134}},{"kind":"Use","ref_id":{"krate":0,"index":1022},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":575720,"byte_end":575731,"line_start":79,"line_end":79,"column_start":28,"column_end":39},"alias_span":null,"name":"write_bytes","value":"","parent":{"krate":0,"index":1134}},{"kind":"Use","ref_id":{"krate":0,"index":1160},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":575815,"byte_end":575822,"line_start":83,"line_end":83,"column_start":19,"column_end":26},"alias_span":null,"name":"NonNull","value":"","parent":{"krate":0,"index":1134}},{"kind":"Use","ref_id":{"krate":0,"index":1232},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":575905,"byte_end":575911,"line_start":87,"line_end":87,"column_start":17,"column_end":23},"alias_span":null,"name":"Unique","value":"","parent":{"krate":0,"index":1134}},{"kind":"Use","ref_id":{"krate":0,"index":1493},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":720950,"byte_end":720953,"line_start":159,"line_end":159,"column_start":23,"column_end":26},"alias_span":null,"name":"Add","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1498},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":720955,"byte_end":720958,"line_start":159,"line_end":159,"column_start":28,"column_end":31},"alias_span":null,"name":"Sub","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1503},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":720960,"byte_end":720963,"line_start":159,"line_end":159,"column_start":33,"column_end":36},"alias_span":null,"name":"Mul","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1508},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":720965,"byte_end":720968,"line_start":159,"line_end":159,"column_start":38,"column_end":41},"alias_span":null,"name":"Div","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1514},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":720970,"byte_end":720973,"line_start":159,"line_end":159,"column_start":43,"column_end":46},"alias_span":null,"name":"Rem","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1520},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":720975,"byte_end":720978,"line_start":159,"line_end":159,"column_start":48,"column_end":51},"alias_span":null,"name":"Neg","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1526},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721060,"byte_end":721069,"line_start":161,"line_end":161,"column_start":23,"column_end":32},"alias_span":null,"name":"AddAssign","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1530},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721071,"byte_end":721080,"line_start":161,"line_end":161,"column_start":34,"column_end":43},"alias_span":null,"name":"SubAssign","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1534},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721082,"byte_end":721091,"line_start":161,"line_end":161,"column_start":45,"column_end":54},"alias_span":null,"name":"MulAssign","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1538},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721093,"byte_end":721102,"line_start":161,"line_end":161,"column_start":56,"column_end":65},"alias_span":null,"name":"DivAssign","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1542},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721104,"byte_end":721113,"line_start":161,"line_end":161,"column_start":67,"column_end":76},"alias_span":null,"name":"RemAssign","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1547},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721183,"byte_end":721186,"line_start":164,"line_end":164,"column_start":21,"column_end":24},"alias_span":null,"name":"Not","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1551},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721188,"byte_end":721194,"line_start":164,"line_end":164,"column_start":26,"column_end":32},"alias_span":null,"name":"BitAnd","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1556},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721196,"byte_end":721201,"line_start":164,"line_end":164,"column_start":34,"column_end":39},"alias_span":null,"name":"BitOr","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1561},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721203,"byte_end":721209,"line_start":164,"line_end":164,"column_start":41,"column_end":47},"alias_span":null,"name":"BitXor","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1566},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721211,"byte_end":721214,"line_start":164,"line_end":164,"column_start":49,"column_end":52},"alias_span":null,"name":"Shl","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1572},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721216,"byte_end":721219,"line_start":164,"line_end":164,"column_start":54,"column_end":57},"alias_span":null,"name":"Shr","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1578},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721299,"byte_end":721311,"line_start":166,"line_end":166,"column_start":21,"column_end":33},"alias_span":null,"name":"BitAndAssign","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1582},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721313,"byte_end":721324,"line_start":166,"line_end":166,"column_start":35,"column_end":46},"alias_span":null,"name":"BitOrAssign","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1586},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721326,"byte_end":721338,"line_start":166,"line_end":166,"column_start":48,"column_end":60},"alias_span":null,"name":"BitXorAssign","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1590},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721340,"byte_end":721349,"line_start":166,"line_end":166,"column_start":62,"column_end":71},"alias_span":null,"name":"ShlAssign","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1595},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721351,"byte_end":721360,"line_start":166,"line_end":166,"column_start":73,"column_end":82},"alias_span":null,"name":"ShrAssign","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1601},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721432,"byte_end":721437,"line_start":169,"line_end":169,"column_start":23,"column_end":28},"alias_span":null,"name":"Deref","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1612},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721439,"byte_end":721447,"line_start":169,"line_end":169,"column_start":30,"column_end":38},"alias_span":null,"name":"DerefMut","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1617},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721525,"byte_end":721533,"line_start":172,"line_end":172,"column_start":22,"column_end":30},"alias_span":null,"name":"Receiver","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1623},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721602,"byte_end":721606,"line_start":175,"line_end":175,"column_start":21,"column_end":25},"alias_span":null,"name":"Drop","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1626},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721680,"byte_end":721682,"line_start":178,"line_end":178,"column_start":26,"column_end":28},"alias_span":null,"name":"Fn","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1629},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721684,"byte_end":721689,"line_start":178,"line_end":178,"column_start":30,"column_end":35},"alias_span":null,"name":"FnMut","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1632},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721691,"byte_end":721697,"line_start":178,"line_end":178,"column_start":37,"column_end":43},"alias_span":null,"name":"FnOnce","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1677},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721769,"byte_end":721774,"line_start":181,"line_end":181,"column_start":23,"column_end":28},"alias_span":null,"name":"Index","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1681},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721776,"byte_end":721784,"line_start":181,"line_end":181,"column_start":30,"column_end":38},"alias_span":null,"name":"IndexMut","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":26067},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721856,"byte_end":721861,"line_start":184,"line_end":184,"column_start":23,"column_end":28},"alias_span":null,"name":"Range","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":26085},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721863,"byte_end":721872,"line_start":184,"line_end":184,"column_start":30,"column_end":39},"alias_span":null,"name":"RangeFrom","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":26055},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721874,"byte_end":721883,"line_start":184,"line_end":184,"column_start":41,"column_end":50},"alias_span":null,"name":"RangeFull","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":26102},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721885,"byte_end":721892,"line_start":184,"line_end":184,"column_start":52,"column_end":59},"alias_span":null,"name":"RangeTo","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":26121},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721975,"byte_end":721989,"line_start":187,"line_end":187,"column_start":23,"column_end":37},"alias_span":null,"name":"RangeInclusive","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":26129},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":721991,"byte_end":722007,"line_start":187,"line_end":187,"column_start":39,"column_end":55},"alias_span":null,"name":"RangeToInclusive","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1755},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":722009,"byte_end":722020,"line_start":187,"line_end":187,"column_start":57,"column_end":68},"alias_span":null,"name":"RangeBounds","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":26148},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":722022,"byte_end":722027,"line_start":187,"line_end":187,"column_start":70,"column_end":75},"alias_span":null,"name":"Bound","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1819},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":722104,"byte_end":722107,"line_start":190,"line_end":190,"column_start":22,"column_end":25},"alias_span":null,"name":"Try","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1662},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":722194,"byte_end":722203,"line_start":193,"line_end":193,"column_start":27,"column_end":36},"alias_span":null,"name":"Generator","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":26009},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":722205,"byte_end":722219,"line_start":193,"line_end":193,"column_start":38,"column_end":52},"alias_span":null,"name":"GeneratorState","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1827},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":722302,"byte_end":722315,"line_start":196,"line_end":196,"column_start":23,"column_end":36},"alias_span":null,"name":"CoerceUnsized","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":1864},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":722396,"byte_end":722411,"line_start":199,"line_end":199,"column_start":23,"column_end":38},"alias_span":null,"name":"DispatchFromDyn","value":"","parent":{"krate":0,"index":1491}},{"kind":"Use","ref_id":{"krate":0,"index":2615},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1088869,"byte_end":1088877,"line_start":28,"line_end":28,"column_start":25,"column_end":33},"alias_span":null,"name":"from_u32","value":"","parent":{"krate":0,"index":2608}},{"kind":"Use","ref_id":{"krate":0,"index":2633},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1088879,"byte_end":1088889,"line_start":28,"line_end":28,"column_start":35,"column_end":45},"alias_span":null,"name":"from_digit","value":"","parent":{"krate":0,"index":2608}},{"kind":"Use","ref_id":{"krate":0,"index":2616},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1088975,"byte_end":1088993,"line_start":30,"line_end":30,"column_start":24,"column_end":42},"alias_span":null,"name":"from_u32_unchecked","value":"","parent":{"krate":0,"index":2608}},{"kind":"Use","ref_id":{"krate":0,"index":31873},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1089073,"byte_end":1089087,"line_start":32,"line_end":32,"column_start":24,"column_end":38},"alias_span":null,"name":"ParseCharError","value":"","parent":{"krate":0,"index":2608}},{"kind":"Use","ref_id":{"krate":0,"index":31898},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1089162,"byte_end":1089178,"line_start":34,"line_end":34,"column_start":24,"column_end":40},"alias_span":null,"name":"CharTryFromError","value":"","parent":{"krate":0,"index":2608}},{"kind":"Use","ref_id":{"krate":0,"index":2637},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1089256,"byte_end":1089268,"line_start":36,"line_end":36,"column_start":24,"column_end":36},"alias_span":null,"name":"decode_utf16","value":"","parent":{"krate":0,"index":2608}},{"kind":"Use","ref_id":{"krate":0,"index":31911},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1089270,"byte_end":1089281,"line_start":36,"line_end":36,"column_start":38,"column_end":49},"alias_span":null,"name":"DecodeUtf16","value":"","parent":{"krate":0,"index":2608}},{"kind":"Use","ref_id":{"krate":0,"index":31921},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1089283,"byte_end":1089299,"line_start":36,"line_end":36,"column_start":51,"column_end":67},"alias_span":null,"name":"DecodeUtf16Error","value":"","parent":{"krate":0,"index":2608}},{"kind":"Use","ref_id":{"krate":0,"index":7080},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1089416,"byte_end":1089431,"line_start":40,"line_end":40,"column_start":33,"column_end":48},"alias_span":null,"name":"UNICODE_VERSION","value":"","parent":{"krate":0,"index":2608}},{"kind":"Use","ref_id":{"krate":0,"index":34865},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1089524,"byte_end":1089538,"line_start":42,"line_end":42,"column_start":34,"column_end":48},"alias_span":null,"name":"UnicodeVersion","value":"","parent":{"krate":0,"index":2608}},{"kind":"Use","ref_id":{"krate":0,"index":3202},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1217333,"byte_end":1217341,"line_start":317,"line_end":317,"column_start":23,"column_end":31},"alias_span":null,"name":"Iterator","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":2968},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1217498,"byte_end":1217502,"line_start":322,"line_end":322,"column_start":22,"column_end":26},"alias_span":null,"name":"Step","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32185},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1217575,"byte_end":1217581,"line_start":325,"line_end":325,"column_start":25,"column_end":31},"alias_span":null,"name":"Repeat","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":3052},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1217583,"byte_end":1217589,"line_start":325,"line_end":325,"column_start":33,"column_end":39},"alias_span":null,"name":"repeat","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32194},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1217678,"byte_end":1217688,"line_start":327,"line_end":327,"column_start":25,"column_end":35},"alias_span":null,"name":"RepeatWith","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":3066},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1217690,"byte_end":1217701,"line_start":327,"line_end":327,"column_start":37,"column_end":48},"alias_span":null,"name":"repeat_with","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":3069},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1217779,"byte_end":1217784,"line_start":329,"line_end":329,"column_start":25,"column_end":30},"alias_span":null,"name":"Empty","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":3097},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1217786,"byte_end":1217791,"line_start":329,"line_end":329,"column_start":32,"column_end":37},"alias_span":null,"name":"empty","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32205},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1217868,"byte_end":1217872,"line_start":331,"line_end":331,"column_start":25,"column_end":29},"alias_span":null,"name":"Once","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":3114},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1217874,"byte_end":1217878,"line_start":331,"line_end":331,"column_start":31,"column_end":35},"alias_span":null,"name":"once","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32214},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1217962,"byte_end":1217970,"line_start":333,"line_end":333,"column_start":25,"column_end":33},"alias_span":null,"name":"OnceWith","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":3137},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1217972,"byte_end":1217981,"line_start":333,"line_end":333,"column_start":35,"column_end":44},"alias_span":null,"name":"once_with","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32225},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218062,"byte_end":1218068,"line_start":335,"line_end":335,"column_start":25,"column_end":31},"alias_span":null,"name":"FromFn","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":3140},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218070,"byte_end":1218077,"line_start":335,"line_end":335,"column_start":33,"column_end":40},"alias_span":null,"name":"from_fn","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32232},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218161,"byte_end":1218171,"line_start":337,"line_end":337,"column_start":25,"column_end":35},"alias_span":null,"name":"Successors","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":3151},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218173,"byte_end":1218183,"line_start":337,"line_end":337,"column_start":37,"column_end":47},"alias_span":null,"name":"successors","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":3388},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218256,"byte_end":1218268,"line_start":340,"line_end":340,"column_start":24,"column_end":36},"alias_span":null,"name":"FromIterator","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":3392},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218270,"byte_end":1218282,"line_start":340,"line_end":340,"column_start":38,"column_end":50},"alias_span":null,"name":"IntoIterator","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":3360},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218284,"byte_end":1218303,"line_start":340,"line_end":340,"column_start":52,"column_end":71},"alias_span":null,"name":"DoubleEndedIterator","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":3401},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218305,"byte_end":1218311,"line_start":340,"line_end":340,"column_start":73,"column_end":79},"alias_span":null,"name":"Extend","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":3380},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218383,"byte_end":1218400,"line_start":342,"line_end":342,"column_start":24,"column_end":41},"alias_span":null,"name":"ExactSizeIterator","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":3413},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218402,"byte_end":1218405,"line_start":342,"line_end":342,"column_start":43,"column_end":46},"alias_span":null,"name":"Sum","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":3417},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218407,"byte_end":1218414,"line_start":342,"line_end":342,"column_start":48,"column_end":55},"alias_span":null,"name":"Product","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":3491},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218486,"byte_end":1218499,"line_start":344,"line_end":344,"column_start":23,"column_end":36},"alias_span":null,"name":"FusedIterator","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":3494},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218577,"byte_end":1218587,"line_start":346,"line_end":346,"column_start":23,"column_end":33},"alias_span":null,"name":"TrustedLen","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32667},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218661,"byte_end":1218664,"line_start":349,"line_end":349,"column_start":26,"column_end":29},"alias_span":null,"name":"Rev","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32694},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218666,"byte_end":1218671,"line_start":349,"line_end":349,"column_start":31,"column_end":36},"alias_span":null,"name":"Cycle","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32613},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218673,"byte_end":1218678,"line_start":349,"line_end":349,"column_start":38,"column_end":43},"alias_span":null,"name":"Chain","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32652},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218680,"byte_end":1218683,"line_start":349,"line_end":349,"column_start":45,"column_end":48},"alias_span":null,"name":"Zip","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32715},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218685,"byte_end":1218688,"line_start":349,"line_end":349,"column_start":50,"column_end":53},"alias_span":null,"name":"Map","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32724},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218690,"byte_end":1218696,"line_start":349,"line_end":349,"column_start":55,"column_end":61},"alias_span":null,"name":"Filter","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32733},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218698,"byte_end":1218707,"line_start":349,"line_end":349,"column_start":63,"column_end":72},"alias_span":null,"name":"FilterMap","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32742},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218709,"byte_end":1218718,"line_start":349,"line_end":349,"column_start":74,"column_end":83},"alias_span":null,"name":"Enumerate","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32752},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218792,"byte_end":1218800,"line_start":351,"line_end":351,"column_start":26,"column_end":34},"alias_span":null,"name":"Peekable","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32762},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218802,"byte_end":1218811,"line_start":351,"line_end":351,"column_start":36,"column_end":45},"alias_span":null,"name":"SkipWhile","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32772},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218813,"byte_end":1218822,"line_start":351,"line_end":351,"column_start":47,"column_end":56},"alias_span":null,"name":"TakeWhile","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32782},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218824,"byte_end":1218828,"line_start":351,"line_end":351,"column_start":58,"column_end":62},"alias_span":null,"name":"Skip","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32792},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218830,"byte_end":1218834,"line_start":351,"line_end":351,"column_start":64,"column_end":68},"alias_span":null,"name":"Take","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32802},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218836,"byte_end":1218840,"line_start":351,"line_end":351,"column_start":70,"column_end":74},"alias_span":null,"name":"Scan","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":3578},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218842,"byte_end":1218849,"line_start":351,"line_end":351,"column_start":76,"column_end":83},"alias_span":null,"name":"FlatMap","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32814},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218923,"byte_end":1218927,"line_start":353,"line_end":353,"column_start":26,"column_end":30},"alias_span":null,"name":"Fuse","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32824},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1218929,"byte_end":1218936,"line_start":353,"line_end":353,"column_start":32,"column_end":39},"alias_span":null,"name":"Inspect","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32685},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1219015,"byte_end":1219021,"line_start":355,"line_end":355,"column_start":25,"column_end":31},"alias_span":null,"name":"Cloned","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32704},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1219105,"byte_end":1219111,"line_start":357,"line_end":357,"column_start":25,"column_end":31},"alias_span":null,"name":"StepBy","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":3628},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1219195,"byte_end":1219202,"line_start":359,"line_end":359,"column_start":25,"column_end":32},"alias_span":null,"name":"Flatten","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":32676},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1219281,"byte_end":1219287,"line_start":361,"line_end":361,"column_start":25,"column_end":31},"alias_span":null,"name":"Copied","value":"","parent":{"krate":0,"index":2895}},{"kind":"Use","ref_id":{"krate":0,"index":3202},"span":{"file_name":"src/libcore/iter/traits/mod.rs","byte_start":1253976,"byte_end":1253984,"line_start":9,"line_end":9,"column_start":25,"column_end":33},"alias_span":null,"name":"Iterator","value":"","parent":{"krate":0,"index":3168}},{"kind":"Use","ref_id":{"krate":0,"index":3360},"span":{"file_name":"src/libcore/iter/traits/mod.rs","byte_start":1254014,"byte_end":1254033,"line_start":10,"line_end":10,"column_start":29,"column_end":48},"alias_span":null,"name":"DoubleEndedIterator","value":"","parent":{"krate":0,"index":3168}},{"kind":"Use","ref_id":{"krate":0,"index":3380},"span":{"file_name":"src/libcore/iter/traits/mod.rs","byte_start":1254061,"byte_end":1254078,"line_start":11,"line_end":11,"column_start":27,"column_end":44},"alias_span":null,"name":"ExactSizeIterator","value":"","parent":{"krate":0,"index":3168}},{"kind":"Use","ref_id":{"krate":0,"index":3388},"span":{"file_name":"src/libcore/iter/traits/mod.rs","byte_start":1254104,"byte_end":1254116,"line_start":12,"line_end":12,"column_start":25,"column_end":37},"alias_span":null,"name":"FromIterator","value":"","parent":{"krate":0,"index":3168}},{"kind":"Use","ref_id":{"krate":0,"index":3392},"span":{"file_name":"src/libcore/iter/traits/mod.rs","byte_start":1254118,"byte_end":1254130,"line_start":12,"line_end":12,"column_start":39,"column_end":51},"alias_span":null,"name":"IntoIterator","value":"","parent":{"krate":0,"index":3168}},{"kind":"Use","ref_id":{"krate":0,"index":3401},"span":{"file_name":"src/libcore/iter/traits/mod.rs","byte_start":1254132,"byte_end":1254138,"line_start":12,"line_end":12,"column_start":53,"column_end":59},"alias_span":null,"name":"Extend","value":"","parent":{"krate":0,"index":3168}},{"kind":"Use","ref_id":{"krate":0,"index":3413},"span":{"file_name":"src/libcore/iter/traits/mod.rs","byte_start":1254163,"byte_end":1254166,"line_start":13,"line_end":13,"column_start":23,"column_end":26},"alias_span":null,"name":"Sum","value":"","parent":{"krate":0,"index":3168}},{"kind":"Use","ref_id":{"krate":0,"index":3417},"span":{"file_name":"src/libcore/iter/traits/mod.rs","byte_start":1254168,"byte_end":1254175,"line_start":13,"line_end":13,"column_start":28,"column_end":35},"alias_span":null,"name":"Product","value":"","parent":{"krate":0,"index":3168}},{"kind":"Use","ref_id":{"krate":0,"index":3491},"span":{"file_name":"src/libcore/iter/traits/mod.rs","byte_start":1254247,"byte_end":1254260,"line_start":15,"line_end":15,"column_start":24,"column_end":37},"alias_span":null,"name":"FusedIterator","value":"","parent":{"krate":0,"index":3168}},{"kind":"Use","ref_id":{"krate":0,"index":3494},"span":{"file_name":"src/libcore/iter/traits/mod.rs","byte_start":1254262,"byte_end":1254272,"line_start":15,"line_end":15,"column_start":39,"column_end":49},"alias_span":null,"name":"TrustedLen","value":"","parent":{"krate":0,"index":3168}},{"kind":"Use","ref_id":{"krate":0,"index":32613},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1377405,"byte_end":1377410,"line_start":14,"line_end":14,"column_start":22,"column_end":27},"alias_span":null,"name":"Chain","value":"","parent":{"krate":0,"index":3510}},{"kind":"Use","ref_id":{"krate":0,"index":3578},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1377482,"byte_end":1377489,"line_start":16,"line_end":16,"column_start":25,"column_end":32},"alias_span":null,"name":"FlatMap","value":"","parent":{"krate":0,"index":3510}},{"kind":"Use","ref_id":{"krate":0,"index":3628},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1377491,"byte_end":1377498,"line_start":16,"line_end":16,"column_start":34,"column_end":41},"alias_span":null,"name":"Flatten","value":"","parent":{"krate":0,"index":3510}},{"kind":"Use","ref_id":{"krate":0,"index":32652},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1377520,"byte_end":1377523,"line_start":17,"line_end":17,"column_start":20,"column_end":23},"alias_span":null,"name":"Zip","value":"","parent":{"krate":0,"index":3510}},{"kind":"Use","ref_id":{"krate":0,"index":34044},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1980637,"byte_end":1980646,"line_start":89,"line_end":89,"column_start":20,"column_end":29},"alias_span":null,"name":"SipHasher","value":"","parent":{"krate":0,"index":6430}},{"kind":"Use","ref_id":{"krate":0,"index":34028},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1980760,"byte_end":1980771,"line_start":94,"line_end":94,"column_start":20,"column_end":31},"alias_span":null,"name":"SipHasher13","value":"","parent":{"krate":0,"index":6430}},{"kind":"Use","ref_id":{"krate":0,"index":6674},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2011572,"byte_end":2011583,"line_start":34,"line_end":34,"column_start":26,"column_end":37},"alias_span":null,"name":"DebugStruct","value":"","parent":{"krate":0,"index":6581}},{"kind":"Use","ref_id":{"krate":0,"index":6691},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2011585,"byte_end":2011595,"line_start":34,"line_end":34,"column_start":39,"column_end":49},"alias_span":null,"name":"DebugTuple","value":"","parent":{"krate":0,"index":6581}},{"kind":"Use","ref_id":{"krate":0,"index":6721},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2011597,"byte_end":2011605,"line_start":34,"line_end":34,"column_start":51,"column_end":59},"alias_span":null,"name":"DebugSet","value":"","parent":{"krate":0,"index":6581}},{"kind":"Use","ref_id":{"krate":0,"index":6737},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2011607,"byte_end":2011616,"line_start":34,"line_end":34,"column_start":61,"column_end":70},"alias_span":null,"name":"DebugList","value":"","parent":{"krate":0,"index":6581}},{"kind":"Use","ref_id":{"krate":0,"index":6753},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2011618,"byte_end":2011626,"line_start":34,"line_end":34,"column_start":72,"column_end":80},"alias_span":null,"name":"DebugMap","value":"","parent":{"krate":0,"index":6581}},{"kind":"Use","ref_id":{"krate":0,"index":7090},"span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":2151338,"byte_end":2151352,"line_start":11,"line_end":11,"column_start":56,"column_end":70},"alias_span":null,"name":"Case_Ignorable","value":"","parent":{"krate":0,"index":7121}},{"kind":"Use","ref_id":{"krate":0,"index":7092},"span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":2151354,"byte_end":2151359,"line_start":11,"line_end":11,"column_start":72,"column_end":77},"alias_span":null,"name":"Cased","value":"","parent":{"krate":0,"index":7121}},{"kind":"Use","ref_id":{"krate":0,"index":7109},"span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":2151436,"byte_end":2151444,"line_start":14,"line_end":14,"column_start":51,"column_end":59},"alias_span":null,"name":"to_lower","value":"","parent":{"krate":0,"index":7125}},{"kind":"Use","ref_id":{"krate":0,"index":7111},"span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":2151446,"byte_end":2151454,"line_start":14,"line_end":14,"column_start":61,"column_end":69},"alias_span":null,"name":"to_upper","value":"","parent":{"krate":0,"index":7125}},{"kind":"Use","ref_id":{"krate":0,"index":7105},"span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":2151549,"byte_end":2151568,"line_start":19,"line_end":19,"column_start":47,"column_end":66},"alias_span":null,"name":"Pattern_White_Space","value":"","parent":{"krate":0,"index":7129}},{"kind":"Use","ref_id":{"krate":0,"index":7139},"span":{"file_name":"src/libcore/future/mod.rs","byte_start":2394968,"byte_end":2394974,"line_start":7,"line_end":7,"column_start":23,"column_end":29},"alias_span":null,"name":"Future","value":"","parent":{"krate":0,"index":7131}},{"kind":"Use","ref_id":{"krate":0,"index":34900},"span":{"file_name":"src/libcore/task/mod.rs","byte_start":2400505,"byte_end":2400509,"line_start":7,"line_end":7,"column_start":21,"column_end":25},"alias_span":null,"name":"Poll","value":"","parent":{"krate":0,"index":7151}},{"kind":"Use","ref_id":{"krate":0,"index":7199},"span":{"file_name":"src/libcore/task/mod.rs","byte_start":2400596,"byte_end":2400603,"line_start":11,"line_end":11,"column_start":22,"column_end":29},"alias_span":null,"name":"Context","value":"","parent":{"krate":0,"index":7151}},{"kind":"Use","ref_id":{"krate":0,"index":7209},"span":{"file_name":"src/libcore/task/mod.rs","byte_start":2400605,"byte_end":2400610,"line_start":11,"line_end":11,"column_start":31,"column_end":36},"alias_span":null,"name":"Waker","value":"","parent":{"krate":0,"index":7151}},{"kind":"Use","ref_id":{"krate":0,"index":34936},"span":{"file_name":"src/libcore/task/mod.rs","byte_start":2400612,"byte_end":2400620,"line_start":11,"line_end":11,"column_start":38,"column_end":46},"alias_span":null,"name":"RawWaker","value":"","parent":{"krate":0,"index":7151}},{"kind":"Use","ref_id":{"krate":0,"index":34944},"span":{"file_name":"src/libcore/task/mod.rs","byte_start":2400622,"byte_end":2400636,"line_start":11,"line_end":11,"column_start":48,"column_end":62},"alias_span":null,"name":"RawWakerVTable","value":"","parent":{"krate":0,"index":7151}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/mod.rs","byte_start":2474940,"byte_end":2474941,"line_start":37,"line_end":37,"column_start":40,"column_end":41},"alias_span":null,"name":"*","value":"_mm_pause","parent":{"krate":0,"index":7316}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/mod.rs","byte_start":2475043,"byte_end":2475044,"line_start":39,"line_end":39,"column_start":43,"column_end":44},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7316}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2513629,"byte_end":2513630,"line_start":479,"line_end":479,"column_start":23,"column_end":24},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2513663,"byte_end":2513664,"line_start":482,"line_end":482,"column_start":21,"column_end":22},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2513699,"byte_end":2513700,"line_start":485,"line_end":485,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2513735,"byte_end":2513736,"line_start":488,"line_end":488,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2513771,"byte_end":2513772,"line_start":491,"line_end":491,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2513806,"byte_end":2513807,"line_start":493,"line_end":493,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2513838,"byte_end":2513839,"line_start":496,"line_end":496,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"_mm_undefined_ps, _mm_set1_ps, _mm_setzero_ps, _mm_loadu_ps, _mm_storeu_ps","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2513871,"byte_end":2513872,"line_start":498,"line_end":498,"column_start":21,"column_end":22},"alias_span":null,"name":"*","value":"_mm_loadu_si128, _mm_set1_pd, _mm_set1_epi8, _mm_loadu_pd, _mm_setzero_pd, _mm_load1_pd, _mm_set_epi64x, _mm_storeu_pd, _mm_set1_epi32, _mm_set1_epi64x, _mm_setzero_si128, _mm_pause, _mm_storeu_si128, _mm_cmpeq_epi32, _mm_undefined_pd","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2513904,"byte_end":2513905,"line_start":500,"line_end":500,"column_start":21,"column_end":22},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2513939,"byte_end":2513940,"line_start":502,"line_end":502,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2513974,"byte_end":2513975,"line_start":504,"line_end":504,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2514009,"byte_end":2514010,"line_start":506,"line_end":506,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2514040,"byte_end":2514041,"line_start":508,"line_end":508,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"_mm256_setzero_pd, _mm256_undefined_si256, _mm256_castsi128_si256, _mm256_setzero_si256, _mm256_set1_epi32, _mm256_set1_epi64x, _mm256_set1_epi8, _mm256_set1_ps, _mm256_set1_pd, _mm256_undefined_pd, _mm256_setzero_ps","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2514073,"byte_end":2514074,"line_start":510,"line_end":510,"column_start":21,"column_end":22},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2514104,"byte_end":2514105,"line_start":512,"line_end":512,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2514136,"byte_end":2514137,"line_start":515,"line_end":515,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2514169,"byte_end":2514170,"line_start":517,"line_end":517,"column_start":21,"column_end":22},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2514203,"byte_end":2514204,"line_start":520,"line_end":520,"column_start":21,"column_end":22},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2514301,"byte_end":2514302,"line_start":525,"line_end":525,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2514395,"byte_end":2514396,"line_start":530,"line_end":530,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2514427,"byte_end":2514428,"line_start":533,"line_end":533,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"_mm_cmpgt_pi16, _mm_packs_pi16, _mm_setzero_si64, _mm_unpackhi_pi16, _mm_cmpgt_pi8, _mm_unpacklo_pi16, _mm_unpacklo_pi8, _mm_packs_pi32","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2514471,"byte_end":2514472,"line_start":536,"line_end":536,"column_start":26,"column_end":27},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2514503,"byte_end":2514504,"line_start":539,"line_end":539,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2514541,"byte_end":2514542,"line_start":542,"line_end":542,"column_start":23,"column_end":24},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2514573,"byte_end":2514574,"line_start":545,"line_end":545,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2514605,"byte_end":2514606,"line_start":548,"line_end":548,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2514833,"byte_end":2514834,"line_start":561,"line_end":561,"column_start":24,"column_end":25},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2514879,"byte_end":2514880,"line_start":564,"line_end":564,"column_start":27,"column_end":28},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2514909,"byte_end":2514910,"line_start":567,"line_end":567,"column_start":19,"column_end":20},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":7447}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3549745,"byte_end":3549746,"line_start":4,"line_end":4,"column_start":21,"column_end":22},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9471}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3549777,"byte_end":3549778,"line_start":7,"line_end":7,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9471}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3549811,"byte_end":3549812,"line_start":10,"line_end":10,"column_start":21,"column_end":22},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9471}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3549847,"byte_end":3549848,"line_start":13,"line_end":13,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9471}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3549883,"byte_end":3549884,"line_start":16,"line_end":16,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9471}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3549919,"byte_end":3549920,"line_start":19,"line_end":19,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9471}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3549951,"byte_end":3549952,"line_start":22,"line_end":22,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9471}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3549983,"byte_end":3549984,"line_start":25,"line_end":25,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9471}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3550015,"byte_end":3550016,"line_start":28,"line_end":28,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9471}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3550049,"byte_end":3550050,"line_start":31,"line_end":31,"column_start":21,"column_end":22},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9471}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3550083,"byte_end":3550084,"line_start":34,"line_end":34,"column_start":21,"column_end":22},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9471}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3550119,"byte_end":3550120,"line_start":37,"line_end":37,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9471}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3550157,"byte_end":3550158,"line_start":40,"line_end":40,"column_start":23,"column_end":24},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9471}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3550203,"byte_end":3550204,"line_start":43,"line_end":43,"column_start":27,"column_end":28},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9471}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3550235,"byte_end":3550236,"line_start":46,"line_end":46,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9471}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3550265,"byte_end":3550266,"line_start":49,"line_end":49,"column_start":19,"column_end":20},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9471}},{"kind":"Use","ref_id":{"krate":0,"index":7315},"span":{"file_name":"src/libcore/lib.rs","byte_start":7346,"byte_end":7350,"line_start":238,"line_end":238,"column_start":20,"column_end":24},"alias_span":null,"name":"arch","value":"","parent":{"krate":0,"index":0}}],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":"src/libcore/lib.rs","byte_start":0,"byte_end":7351,"line_start":1,"line_end":238,"column_start":1,"column_end":25},"name":"","qualname":"::","value":"src/libcore/lib.rs","parent":null,"children":[{"krate":0,"index":10},{"krate":0,"index":11},{"krate":0,"index":25},{"krate":0,"index":30},{"krate":0,"index":32},{"krate":0,"index":34},{"krate":0,"index":35},{"krate":0,"index":36},{"krate":0,"index":37},{"krate":0,"index":38},{"krate":0,"index":39},{"krate":0,"index":40},{"krate":0,"index":41},{"krate":0,"index":42},{"krate":0,"index":43},{"krate":0,"index":44},{"krate":0,"index":45},{"krate":0,"index":46},{"krate":0,"index":102},{"krate":0,"index":159},{"krate":0,"index":627},{"krate":0,"index":668},{"krate":0,"index":1027},{"krate":0,"index":1134},{"krate":0,"index":1426},{"krate":0,"index":1432},{"krate":0,"index":1491},{"krate":0,"index":1934},{"krate":0,"index":2055},{"krate":0,"index":2079},{"krate":0,"index":2083},{"krate":0,"index":2159},{"krate":0,"index":2181},{"krate":0,"index":2219},{"krate":0,"index":2254},{"krate":0,"index":2276},{"krate":0,"index":2373},{"krate":0,"index":2608},{"krate":0,"index":2778},{"krate":0,"index":2803},{"krate":0,"index":2813},{"krate":0,"index":2895},{"krate":0,"index":4426},{"krate":0,"index":4640},{"krate":0,"index":4641},{"krate":0,"index":4820},{"krate":0,"index":4873},{"krate":0,"index":5810},{"krate":0,"index":6430},{"krate":0,"index":6581},{"krate":0,"index":6961},{"krate":0,"index":7046},{"krate":0,"index":7131},{"krate":0,"index":7151},{"krate":0,"index":7230},{"krate":0,"index":7297},{"krate":0,"index":7305},{"krate":0,"index":7311},{"krate":0,"index":9613}],"decl_id":null,"docs":" # The Rust Core Library","sig":null,"attributes":[{"value":"cfg(not(test))","span":{"file_name":"src/libcore/lib.rs","byte_start":2621,"byte_end":2639,"line_start":51,"line_end":51,"column_start":1,"column_end":19}},{"value":"stable(feature = \"core\", since = \"1.6.0\")","span":{"file_name":"src/libcore/lib.rs","byte_start":2641,"byte_end":2686,"line_start":53,"line_end":53,"column_start":1,"column_end":46}},{"value":"no_core","span":{"file_name":"src/libcore/lib.rs","byte_start":3017,"byte_end":3028,"line_start":59,"line_end":59,"column_start":1,"column_end":12}},{"value":"warn(deprecated_in_future)","span":{"file_name":"src/libcore/lib.rs","byte_start":3030,"byte_end":3060,"line_start":61,"line_end":61,"column_start":1,"column_end":31}},{"value":"warn(missing_docs)","span":{"file_name":"src/libcore/lib.rs","byte_start":3061,"byte_end":3083,"line_start":62,"line_end":62,"column_start":1,"column_end":23}},{"value":"warn(missing_debug_implementations)","span":{"file_name":"src/libcore/lib.rs","byte_start":3084,"byte_end":3123,"line_start":63,"line_end":63,"column_start":1,"column_end":40}},{"value":"deny(intra_doc_link_resolution_failure)","span":{"file_name":"src/libcore/lib.rs","byte_start":3124,"byte_end":3167,"line_start":64,"line_end":64,"column_start":1,"column_end":44}},{"value":"deny(rust_2018_idioms)","span":{"file_name":"src/libcore/lib.rs","byte_start":3207,"byte_end":3233,"line_start":66,"line_end":66,"column_start":1,"column_end":27}},{"value":"allow(explicit_outlives_requirements)","span":{"file_name":"src/libcore/lib.rs","byte_start":3234,"byte_end":3275,"line_start":67,"line_end":67,"column_start":1,"column_end":42}},{"value":"feature(allow_internal_unstable)","span":{"file_name":"src/libcore/lib.rs","byte_start":3277,"byte_end":3313,"line_start":69,"line_end":69,"column_start":1,"column_end":37}},{"value":"feature(arbitrary_self_types)","span":{"file_name":"src/libcore/lib.rs","byte_start":3314,"byte_end":3347,"line_start":70,"line_end":70,"column_start":1,"column_end":34}},{"value":"feature(asm)","span":{"file_name":"src/libcore/lib.rs","byte_start":3348,"byte_end":3364,"line_start":71,"line_end":71,"column_start":1,"column_end":17}},{"value":"feature(bound_cloned)","span":{"file_name":"src/libcore/lib.rs","byte_start":3365,"byte_end":3390,"line_start":72,"line_end":72,"column_start":1,"column_end":26}},{"value":"feature(cfg_target_has_atomic)","span":{"file_name":"src/libcore/lib.rs","byte_start":3391,"byte_end":3425,"line_start":73,"line_end":73,"column_start":1,"column_end":35}},{"value":"feature(concat_idents)","span":{"file_name":"src/libcore/lib.rs","byte_start":3426,"byte_end":3452,"line_start":74,"line_end":74,"column_start":1,"column_end":27}},{"value":"feature(const_fn)","span":{"file_name":"src/libcore/lib.rs","byte_start":3453,"byte_end":3474,"line_start":75,"line_end":75,"column_start":1,"column_end":22}},{"value":"feature(const_fn_union)","span":{"file_name":"src/libcore/lib.rs","byte_start":3475,"byte_end":3502,"line_start":76,"line_end":76,"column_start":1,"column_end":28}},{"value":"feature(doc_cfg)","span":{"file_name":"src/libcore/lib.rs","byte_start":3503,"byte_end":3523,"line_start":77,"line_end":77,"column_start":1,"column_end":21}},{"value":"feature(doc_spotlight)","span":{"file_name":"src/libcore/lib.rs","byte_start":3524,"byte_end":3550,"line_start":78,"line_end":78,"column_start":1,"column_end":27}},{"value":"feature(extern_types)","span":{"file_name":"src/libcore/lib.rs","byte_start":3551,"byte_end":3576,"line_start":79,"line_end":79,"column_start":1,"column_end":26}},{"value":"feature(fundamental)","span":{"file_name":"src/libcore/lib.rs","byte_start":3577,"byte_end":3601,"line_start":80,"line_end":80,"column_start":1,"column_end":25}},{"value":"feature(intrinsics)","span":{"file_name":"src/libcore/lib.rs","byte_start":3602,"byte_end":3625,"line_start":81,"line_end":81,"column_start":1,"column_end":24}},{"value":"feature(is_sorted)","span":{"file_name":"src/libcore/lib.rs","byte_start":3626,"byte_end":3648,"line_start":82,"line_end":82,"column_start":1,"column_end":23}},{"value":"feature(iter_once_with)","span":{"file_name":"src/libcore/lib.rs","byte_start":3649,"byte_end":3676,"line_start":83,"line_end":83,"column_start":1,"column_end":28}},{"value":"feature(lang_items)","span":{"file_name":"src/libcore/lib.rs","byte_start":3677,"byte_end":3700,"line_start":84,"line_end":84,"column_start":1,"column_end":24}},{"value":"feature(link_llvm_intrinsics)","span":{"file_name":"src/libcore/lib.rs","byte_start":3701,"byte_end":3734,"line_start":85,"line_end":85,"column_start":1,"column_end":34}},{"value":"feature(never_type)","span":{"file_name":"src/libcore/lib.rs","byte_start":3735,"byte_end":3758,"line_start":86,"line_end":86,"column_start":1,"column_end":24}},{"value":"feature(nll)","span":{"file_name":"src/libcore/lib.rs","byte_start":3759,"byte_end":3775,"line_start":87,"line_end":87,"column_start":1,"column_end":17}},{"value":"feature(bind_by_move_pattern_guards)","span":{"file_name":"src/libcore/lib.rs","byte_start":3776,"byte_end":3816,"line_start":88,"line_end":88,"column_start":1,"column_end":41}},{"value":"feature(exhaustive_patterns)","span":{"file_name":"src/libcore/lib.rs","byte_start":3817,"byte_end":3849,"line_start":89,"line_end":89,"column_start":1,"column_end":33}},{"value":"feature(no_core)","span":{"file_name":"src/libcore/lib.rs","byte_start":3850,"byte_end":3870,"line_start":90,"line_end":90,"column_start":1,"column_end":21}},{"value":"feature(on_unimplemented)","span":{"file_name":"src/libcore/lib.rs","byte_start":3871,"byte_end":3900,"line_start":91,"line_end":91,"column_start":1,"column_end":30}},{"value":"feature(optin_builtin_traits)","span":{"file_name":"src/libcore/lib.rs","byte_start":3901,"byte_end":3934,"line_start":92,"line_end":92,"column_start":1,"column_end":34}},{"value":"feature(prelude_import)","span":{"file_name":"src/libcore/lib.rs","byte_start":3935,"byte_end":3962,"line_start":93,"line_end":93,"column_start":1,"column_end":28}},{"value":"feature(repr_simd, platform_intrinsics)","span":{"file_name":"src/libcore/lib.rs","byte_start":3963,"byte_end":4006,"line_start":94,"line_end":94,"column_start":1,"column_end":44}},{"value":"feature(rustc_attrs)","span":{"file_name":"src/libcore/lib.rs","byte_start":4007,"byte_end":4031,"line_start":95,"line_end":95,"column_start":1,"column_end":25}},{"value":"feature(rustc_const_unstable)","span":{"file_name":"src/libcore/lib.rs","byte_start":4032,"byte_end":4065,"line_start":96,"line_end":96,"column_start":1,"column_end":34}},{"value":"feature(simd_ffi)","span":{"file_name":"src/libcore/lib.rs","byte_start":4066,"byte_end":4087,"line_start":97,"line_end":97,"column_start":1,"column_end":22}},{"value":"feature(specialization)","span":{"file_name":"src/libcore/lib.rs","byte_start":4088,"byte_end":4115,"line_start":98,"line_end":98,"column_start":1,"column_end":28}},{"value":"feature(staged_api)","span":{"file_name":"src/libcore/lib.rs","byte_start":4116,"byte_end":4139,"line_start":99,"line_end":99,"column_start":1,"column_end":24}},{"value":"feature(std_internals)","span":{"file_name":"src/libcore/lib.rs","byte_start":4140,"byte_end":4166,"line_start":100,"line_end":100,"column_start":1,"column_end":27}},{"value":"feature(stmt_expr_attributes)","span":{"file_name":"src/libcore/lib.rs","byte_start":4167,"byte_end":4200,"line_start":101,"line_end":101,"column_start":1,"column_end":34}},{"value":"feature(transparent_unions)","span":{"file_name":"src/libcore/lib.rs","byte_start":4229,"byte_end":4256,"line_start":102,"line_end":102,"column_start":29,"column_end":56}},{"value":"feature(unboxed_closures)","span":{"file_name":"src/libcore/lib.rs","byte_start":4259,"byte_end":4288,"line_start":103,"line_end":103,"column_start":1,"column_end":30}},{"value":"feature(unsized_locals)","span":{"file_name":"src/libcore/lib.rs","byte_start":4289,"byte_end":4316,"line_start":104,"line_end":104,"column_start":1,"column_end":28}},{"value":"feature(untagged_unions)","span":{"file_name":"src/libcore/lib.rs","byte_start":4317,"byte_end":4345,"line_start":105,"line_end":105,"column_start":1,"column_end":29}},{"value":"feature(unwind_attributes)","span":{"file_name":"src/libcore/lib.rs","byte_start":4346,"byte_end":4376,"line_start":106,"line_end":106,"column_start":1,"column_end":31}},{"value":"feature(doc_alias)","span":{"file_name":"src/libcore/lib.rs","byte_start":4377,"byte_end":4399,"line_start":107,"line_end":107,"column_start":1,"column_end":23}},{"value":"feature(mmx_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4400,"byte_end":4431,"line_start":108,"line_end":108,"column_start":1,"column_end":32}},{"value":"feature(tbm_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4432,"byte_end":4463,"line_start":109,"line_end":109,"column_start":1,"column_end":32}},{"value":"feature(sse4a_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4464,"byte_end":4497,"line_start":110,"line_end":110,"column_start":1,"column_end":34}},{"value":"feature(arm_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4498,"byte_end":4529,"line_start":111,"line_end":111,"column_start":1,"column_end":32}},{"value":"feature(powerpc_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4530,"byte_end":4565,"line_start":112,"line_end":112,"column_start":1,"column_end":36}},{"value":"feature(mips_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4566,"byte_end":4598,"line_start":113,"line_end":113,"column_start":1,"column_end":33}},{"value":"feature(aarch64_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4599,"byte_end":4634,"line_start":114,"line_end":114,"column_start":1,"column_end":36}},{"value":"feature(wasm_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4635,"byte_end":4667,"line_start":115,"line_end":115,"column_start":1,"column_end":33}},{"value":"feature(avx512_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4668,"byte_end":4702,"line_start":116,"line_end":116,"column_start":1,"column_end":35}},{"value":"feature(cmpxchg16b_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4703,"byte_end":4741,"line_start":117,"line_end":117,"column_start":1,"column_end":39}},{"value":"feature(const_slice_len)","span":{"file_name":"src/libcore/lib.rs","byte_start":4742,"byte_end":4770,"line_start":118,"line_end":118,"column_start":1,"column_end":29}},{"value":"feature(const_str_as_bytes)","span":{"file_name":"src/libcore/lib.rs","byte_start":4771,"byte_end":4802,"line_start":119,"line_end":119,"column_start":1,"column_end":32}},{"value":"feature(const_str_len)","span":{"file_name":"src/libcore/lib.rs","byte_start":4803,"byte_end":4829,"line_start":120,"line_end":120,"column_start":1,"column_end":27}},{"value":"feature(const_int_conversion)","span":{"file_name":"src/libcore/lib.rs","byte_start":4830,"byte_end":4863,"line_start":121,"line_end":121,"column_start":1,"column_end":34}},{"value":"feature(const_transmute)","span":{"file_name":"src/libcore/lib.rs","byte_start":4864,"byte_end":4892,"line_start":122,"line_end":122,"column_start":1,"column_end":29}},{"value":"feature(non_exhaustive)","span":{"file_name":"src/libcore/lib.rs","byte_start":4893,"byte_end":4920,"line_start":123,"line_end":123,"column_start":1,"column_end":28}},{"value":"feature(structural_match)","span":{"file_name":"src/libcore/lib.rs","byte_start":4921,"byte_end":4950,"line_start":124,"line_end":124,"column_start":1,"column_end":30}},{"value":"feature(abi_unadjusted)","span":{"file_name":"src/libcore/lib.rs","byte_start":4951,"byte_end":4978,"line_start":125,"line_end":125,"column_start":1,"column_end":28}},{"value":"feature(adx_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4979,"byte_end":5010,"line_start":126,"line_end":126,"column_start":1,"column_end":32}},{"value":"feature(maybe_uninit_slice, maybe_uninit_array)","span":{"file_name":"src/libcore/lib.rs","byte_start":5011,"byte_end":5062,"line_start":127,"line_end":127,"column_start":1,"column_end":52}},{"value":"feature(external_doc)","span":{"file_name":"src/libcore/lib.rs","byte_start":5063,"byte_end":5088,"line_start":128,"line_end":128,"column_start":1,"column_end":26}}]},{"kind":"Mod","id":{"krate":0,"index":34},"span":{"file_name":"src/libcore/num/isize.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"isize","qualname":"::isize","value":"src/libcore/num/isize.rs","parent":null,"children":[{"krate":0,"index":9614},{"krate":0,"index":9615}],"decl_id":null,"docs":" The pointer-sized signed integer type.","sig":null,"attributes":[{"value":"path = \"num/isize.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5329,"byte_end":5353,"line_start":148,"line_end":148,"column_start":1,"column_end":25}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/isize.rs","byte_start":39234,"byte_end":39280,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":35},"span":{"file_name":"src/libcore/num/i8.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"i8","qualname":"::i8","value":"src/libcore/num/i8.rs","parent":null,"children":[{"krate":0,"index":9616},{"krate":0,"index":9617}],"decl_id":null,"docs":" The 8-bit signed integer type.","sig":null,"attributes":[{"value":"path = \"num/i8.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5369,"byte_end":5390,"line_start":149,"line_end":149,"column_start":1,"column_end":22}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/i8.rs","byte_start":39416,"byte_end":39462,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":36},"span":{"file_name":"src/libcore/num/i16.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"i16","qualname":"::i16","value":"src/libcore/num/i16.rs","parent":null,"children":[{"krate":0,"index":9618},{"krate":0,"index":9619}],"decl_id":null,"docs":" The 16-bit signed integer type.","sig":null,"attributes":[{"value":"path = \"num/i16.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5406,"byte_end":5428,"line_start":150,"line_end":150,"column_start":1,"column_end":23}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/i16.rs","byte_start":39598,"byte_end":39644,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":37},"span":{"file_name":"src/libcore/num/i32.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"i32","qualname":"::i32","value":"src/libcore/num/i32.rs","parent":null,"children":[{"krate":0,"index":9620},{"krate":0,"index":9621}],"decl_id":null,"docs":" The 32-bit signed integer type.","sig":null,"attributes":[{"value":"path = \"num/i32.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5444,"byte_end":5466,"line_start":151,"line_end":151,"column_start":1,"column_end":23}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/i32.rs","byte_start":39781,"byte_end":39827,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":38},"span":{"file_name":"src/libcore/num/i64.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"i64","qualname":"::i64","value":"src/libcore/num/i64.rs","parent":null,"children":[{"krate":0,"index":9622},{"krate":0,"index":9623}],"decl_id":null,"docs":" The 64-bit signed integer type.","sig":null,"attributes":[{"value":"path = \"num/i64.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5482,"byte_end":5504,"line_start":152,"line_end":152,"column_start":1,"column_end":23}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/i64.rs","byte_start":39964,"byte_end":40010,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":39},"span":{"file_name":"src/libcore/num/i128.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"i128","qualname":"::i128","value":"src/libcore/num/i128.rs","parent":null,"children":[{"krate":0,"index":9624},{"krate":0,"index":9625}],"decl_id":null,"docs":" The 128-bit signed integer type.","sig":null,"attributes":[{"value":"path = \"num/i128.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5520,"byte_end":5543,"line_start":153,"line_end":153,"column_start":1,"column_end":24}},{"value":"stable(feature = \"i128\", since = \"1.26.0\")","span":{"file_name":"src/libcore/num/i128.rs","byte_start":40150,"byte_end":40196,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":40},"span":{"file_name":"src/libcore/num/usize.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"usize","qualname":"::usize","value":"src/libcore/num/usize.rs","parent":null,"children":[{"krate":0,"index":9626},{"krate":0,"index":9627}],"decl_id":null,"docs":" The pointer-sized unsigned integer type.","sig":null,"attributes":[{"value":"path = \"num/usize.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5560,"byte_end":5584,"line_start":155,"line_end":155,"column_start":1,"column_end":25}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/usize.rs","byte_start":40392,"byte_end":40438,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":41},"span":{"file_name":"src/libcore/num/u8.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"u8","qualname":"::u8","value":"src/libcore/num/u8.rs","parent":null,"children":[{"krate":0,"index":9628},{"krate":0,"index":9629}],"decl_id":null,"docs":" The 8-bit unsigned integer type.","sig":null,"attributes":[{"value":"path = \"num/u8.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5600,"byte_end":5621,"line_start":156,"line_end":156,"column_start":1,"column_end":22}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/u8.rs","byte_start":40577,"byte_end":40623,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":42},"span":{"file_name":"src/libcore/num/u16.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"u16","qualname":"::u16","value":"src/libcore/num/u16.rs","parent":null,"children":[{"krate":0,"index":9630},{"krate":0,"index":9631}],"decl_id":null,"docs":" The 16-bit unsigned integer type.","sig":null,"attributes":[{"value":"path = \"num/u16.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5637,"byte_end":5659,"line_start":157,"line_end":157,"column_start":1,"column_end":23}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/u16.rs","byte_start":40762,"byte_end":40808,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":43},"span":{"file_name":"src/libcore/num/u32.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"u32","qualname":"::u32","value":"src/libcore/num/u32.rs","parent":null,"children":[{"krate":0,"index":9632},{"krate":0,"index":9633}],"decl_id":null,"docs":" The 32-bit unsigned integer type.","sig":null,"attributes":[{"value":"path = \"num/u32.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5675,"byte_end":5697,"line_start":158,"line_end":158,"column_start":1,"column_end":23}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/u32.rs","byte_start":40948,"byte_end":40994,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":44},"span":{"file_name":"src/libcore/num/u64.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"u64","qualname":"::u64","value":"src/libcore/num/u64.rs","parent":null,"children":[{"krate":0,"index":9634},{"krate":0,"index":9635}],"decl_id":null,"docs":" The 64-bit unsigned integer type.","sig":null,"attributes":[{"value":"path = \"num/u64.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5713,"byte_end":5735,"line_start":159,"line_end":159,"column_start":1,"column_end":23}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/u64.rs","byte_start":41134,"byte_end":41180,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":45},"span":{"file_name":"src/libcore/num/u128.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"u128","qualname":"::u128","value":"src/libcore/num/u128.rs","parent":null,"children":[{"krate":0,"index":9636},{"krate":0,"index":9637}],"decl_id":null,"docs":" The 128-bit unsigned integer type.","sig":null,"attributes":[{"value":"path = \"num/u128.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5751,"byte_end":5774,"line_start":160,"line_end":160,"column_start":1,"column_end":24}},{"value":"stable(feature = \"i128\", since = \"1.26.0\")","span":{"file_name":"src/libcore/num/u128.rs","byte_start":41323,"byte_end":41369,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":46},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"f32","qualname":"::f32","value":"src/libcore/num/f32.rs","parent":null,"children":[{"krate":0,"index":47},{"krate":0,"index":48},{"krate":0,"index":49},{"krate":0,"index":50},{"krate":0,"index":51},{"krate":0,"index":52},{"krate":0,"index":53},{"krate":0,"index":54},{"krate":0,"index":55},{"krate":0,"index":56},{"krate":0,"index":57},{"krate":0,"index":58},{"krate":0,"index":59},{"krate":0,"index":60},{"krate":0,"index":61},{"krate":0,"index":62},{"krate":0,"index":63},{"krate":0,"index":64},{"krate":0,"index":83}],"decl_id":null,"docs":" This module provides constants which are specific to the implementation\n of the `f32` floating point data type.","sig":null,"attributes":[{"value":"path = \"num/f32.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5791,"byte_end":5813,"line_start":162,"line_end":162,"column_start":1,"column_end":23}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":41719,"byte_end":41765,"line_start":8,"line_end":8,"column_start":1,"column_end":47}}]},{"kind":"Const","id":{"krate":0,"index":50},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":41973,"byte_end":41978,"line_start":18,"line_end":18,"column_start":11,"column_end":16},"name":"RADIX","qualname":"::f32::RADIX","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" The radix or base of the internal representation of `f32`.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":41917,"byte_end":41962,"line_start":17,"line_end":17,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":51},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":42090,"byte_end":42105,"line_start":22,"line_end":22,"column_start":11,"column_end":26},"name":"MANTISSA_DIGITS","qualname":"::f32::MANTISSA_DIGITS","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" Number of significant digits in base 2.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":42034,"byte_end":42079,"line_start":21,"line_end":21,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":52},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":42230,"byte_end":42236,"line_start":25,"line_end":25,"column_start":11,"column_end":17},"name":"DIGITS","qualname":"::f32::DIGITS","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" Approximate number of significant digits in base 10.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":42174,"byte_end":42219,"line_start":24,"line_end":24,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":53},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":42504,"byte_end":42511,"line_start":33,"line_end":33,"column_start":11,"column_end":18},"name":"EPSILON","qualname":"::f32::EPSILON","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" [Machine epsilon] value for `f32`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":42448,"byte_end":42493,"line_start":32,"line_end":32,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":54},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":42629,"byte_end":42632,"line_start":37,"line_end":37,"column_start":11,"column_end":14},"name":"MIN","qualname":"::f32::MIN","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" Smallest finite `f32` value.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":42573,"byte_end":42618,"line_start":36,"line_end":36,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":55},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":42759,"byte_end":42771,"line_start":40,"line_end":40,"column_start":11,"column_end":23},"name":"MIN_POSITIVE","qualname":"::f32::MIN_POSITIVE","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" Smallest positive normal `f32` value.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":42703,"byte_end":42748,"line_start":39,"line_end":39,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":56},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":42887,"byte_end":42890,"line_start":43,"line_end":43,"column_start":11,"column_end":14},"name":"MAX","qualname":"::f32::MAX","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" Largest finite `f32` value.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":42831,"byte_end":42876,"line_start":42,"line_end":42,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":57},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":43045,"byte_end":43052,"line_start":47,"line_end":47,"column_start":11,"column_end":18},"name":"MIN_EXP","qualname":"::f32::MIN_EXP","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" One greater than the minimum possible normal power of 2 exponent.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":42989,"byte_end":43034,"line_start":46,"line_end":46,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":58},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":43164,"byte_end":43171,"line_start":50,"line_end":50,"column_start":11,"column_end":18},"name":"MAX_EXP","qualname":"::f32::MAX_EXP","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Maximum possible power of 2 exponent.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":43108,"byte_end":43153,"line_start":49,"line_end":49,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":59},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":43291,"byte_end":43301,"line_start":54,"line_end":54,"column_start":11,"column_end":21},"name":"MIN_10_EXP","qualname":"::f32::MIN_10_EXP","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Minimum possible normal power of 10 exponent.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":43235,"byte_end":43280,"line_start":53,"line_end":53,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":60},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":43413,"byte_end":43423,"line_start":57,"line_end":57,"column_start":11,"column_end":21},"name":"MAX_10_EXP","qualname":"::f32::MAX_10_EXP","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Maximum possible power of 10 exponent.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":43357,"byte_end":43402,"line_start":56,"line_end":56,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":61},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":43516,"byte_end":43519,"line_start":61,"line_end":61,"column_start":11,"column_end":14},"name":"NAN","qualname":"::f32::NAN","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" Not a Number (NaN).\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":43460,"byte_end":43505,"line_start":60,"line_end":60,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":62},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":43622,"byte_end":43630,"line_start":64,"line_end":64,"column_start":11,"column_end":19},"name":"INFINITY","qualname":"::f32::INFINITY","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" Infinity (∞).\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":43566,"byte_end":43611,"line_start":63,"line_end":63,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":63},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":43743,"byte_end":43755,"line_start":67,"line_end":67,"column_start":11,"column_end":23},"name":"NEG_INFINITY","qualname":"::f32::NEG_INFINITY","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" Negative infinity (-∞).\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":43687,"byte_end":43732,"line_start":66,"line_end":66,"column_start":1,"column_end":46}}]},{"kind":"Mod","id":{"krate":0,"index":64},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":43872,"byte_end":43878,"line_start":71,"line_end":71,"column_start":9,"column_end":15},"name":"consts","qualname":"::f32::consts","value":"src/libcore/num/f32.rs","parent":null,"children":[{"krate":0,"index":65},{"krate":0,"index":66},{"krate":0,"index":67},{"krate":0,"index":68},{"krate":0,"index":69},{"krate":0,"index":70},{"krate":0,"index":71},{"krate":0,"index":72},{"krate":0,"index":73},{"krate":0,"index":74},{"krate":0,"index":75},{"krate":0,"index":76},{"krate":0,"index":77},{"krate":0,"index":78},{"krate":0,"index":79},{"krate":0,"index":80},{"krate":0,"index":81},{"krate":0,"index":82}],"decl_id":null,"docs":" Basic mathematical constants.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":43818,"byte_end":43863,"line_start":70,"line_end":70,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":65},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":44042,"byte_end":44044,"line_start":76,"line_end":76,"column_start":15,"column_end":17},"name":"PI","qualname":"::f32::consts::PI","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" Archimedes' constant (π)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":43982,"byte_end":44027,"line_start":75,"line_end":75,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":66},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":44173,"byte_end":44182,"line_start":80,"line_end":80,"column_start":15,"column_end":24},"name":"FRAC_PI_2","qualname":"::f32::consts::FRAC_PI_2","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" π/2\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":44113,"byte_end":44158,"line_start":79,"line_end":79,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":67},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":44311,"byte_end":44320,"line_start":84,"line_end":84,"column_start":15,"column_end":24},"name":"FRAC_PI_3","qualname":"::f32::consts::FRAC_PI_3","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" π/3\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":44251,"byte_end":44296,"line_start":83,"line_end":83,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":68},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":44449,"byte_end":44458,"line_start":88,"line_end":88,"column_start":15,"column_end":24},"name":"FRAC_PI_4","qualname":"::f32::consts::FRAC_PI_4","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" π/4\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":44389,"byte_end":44434,"line_start":87,"line_end":87,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":69},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":44588,"byte_end":44597,"line_start":92,"line_end":92,"column_start":15,"column_end":24},"name":"FRAC_PI_6","qualname":"::f32::consts::FRAC_PI_6","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" π/6\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":44528,"byte_end":44573,"line_start":91,"line_end":91,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":70},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":44726,"byte_end":44735,"line_start":96,"line_end":96,"column_start":15,"column_end":24},"name":"FRAC_PI_8","qualname":"::f32::consts::FRAC_PI_8","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" π/8\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":44666,"byte_end":44711,"line_start":95,"line_end":95,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":71},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":44864,"byte_end":44873,"line_start":100,"line_end":100,"column_start":15,"column_end":24},"name":"FRAC_1_PI","qualname":"::f32::consts::FRAC_1_PI","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" 1/π\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":44804,"byte_end":44849,"line_start":99,"line_end":99,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":72},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":45003,"byte_end":45012,"line_start":104,"line_end":104,"column_start":15,"column_end":24},"name":"FRAC_2_PI","qualname":"::f32::consts::FRAC_2_PI","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" 2/π\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":44943,"byte_end":44988,"line_start":103,"line_end":103,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":73},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":45148,"byte_end":45162,"line_start":108,"line_end":108,"column_start":15,"column_end":29},"name":"FRAC_2_SQRT_PI","qualname":"::f32::consts::FRAC_2_SQRT_PI","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" 2/sqrt(π)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":45088,"byte_end":45133,"line_start":107,"line_end":107,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":74},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":45294,"byte_end":45300,"line_start":112,"line_end":112,"column_start":15,"column_end":21},"name":"SQRT_2","qualname":"::f32::consts::SQRT_2","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" sqrt(2)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":45234,"byte_end":45279,"line_start":111,"line_end":111,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":75},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":45434,"byte_end":45447,"line_start":116,"line_end":116,"column_start":15,"column_end":28},"name":"FRAC_1_SQRT_2","qualname":"::f32::consts::FRAC_1_SQRT_2","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" 1/sqrt(2)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":45374,"byte_end":45419,"line_start":115,"line_end":115,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":76},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":45591,"byte_end":45592,"line_start":120,"line_end":120,"column_start":15,"column_end":16},"name":"E","qualname":"::f32::consts::E","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" Euler's number (e)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":45531,"byte_end":45576,"line_start":119,"line_end":119,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":77},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":45735,"byte_end":45741,"line_start":124,"line_end":124,"column_start":15,"column_end":21},"name":"LOG2_E","qualname":"::f32::consts::LOG2_E","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" log<sub>2</sub>(e)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":45675,"byte_end":45720,"line_start":123,"line_end":123,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":78},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":45898,"byte_end":45905,"line_start":128,"line_end":128,"column_start":15,"column_end":22},"name":"LOG2_10","qualname":"::f32::consts::LOG2_10","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" log<sub>2</sub>(10)\n","sig":null,"attributes":[{"value":"unstable(feature = \"extra_log_consts\", issue = \"50540\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":45825,"byte_end":45883,"line_start":127,"line_end":127,"column_start":5,"column_end":63}}]},{"kind":"Const","id":{"krate":0,"index":79},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":46049,"byte_end":46056,"line_start":132,"line_end":132,"column_start":15,"column_end":22},"name":"LOG10_E","qualname":"::f32::consts::LOG10_E","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" log<sub>10</sub>(e)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":45989,"byte_end":46034,"line_start":131,"line_end":131,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":80},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":46214,"byte_end":46221,"line_start":136,"line_end":136,"column_start":15,"column_end":22},"name":"LOG10_2","qualname":"::f32::consts::LOG10_2","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" log<sub>10</sub>(2)\n","sig":null,"attributes":[{"value":"unstable(feature = \"extra_log_consts\", issue = \"50540\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":46141,"byte_end":46199,"line_start":135,"line_end":135,"column_start":5,"column_end":63}}]},{"kind":"Const","id":{"krate":0,"index":81},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":46352,"byte_end":46356,"line_start":140,"line_end":140,"column_start":15,"column_end":19},"name":"LN_2","qualname":"::f32::consts::LN_2","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" ln(2)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":46292,"byte_end":46337,"line_start":139,"line_end":139,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":82},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":46488,"byte_end":46493,"line_start":144,"line_end":144,"column_start":15,"column_end":20},"name":"LN_10","qualname":"::f32::consts::LN_10","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" ln(10)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":46428,"byte_end":46473,"line_start":143,"line_end":143,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":84},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":46898,"byte_end":46904,"line_start":163,"line_end":163,"column_start":12,"column_end":18},"name":"is_nan","qualname":"<f32>::is_nan","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this value is `NaN`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":46827,"byte_end":46872,"line_start":161,"line_end":161,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":46877,"byte_end":46886,"line_start":162,"line_end":162,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":86},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":47761,"byte_end":47772,"line_start":194,"line_end":194,"column_start":12,"column_end":23},"name":"is_infinite","qualname":"<f32>::is_infinite","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this value is positive infinity or negative infinity, and\n `false` otherwise.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":47690,"byte_end":47735,"line_start":192,"line_end":192,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":47740,"byte_end":47749,"line_start":193,"line_end":193,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":87},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":48324,"byte_end":48333,"line_start":216,"line_end":216,"column_start":12,"column_end":21},"name":"is_finite","qualname":"<f32>::is_finite","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this number is neither infinite nor `NaN`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":48253,"byte_end":48298,"line_start":214,"line_end":214,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":48303,"byte_end":48312,"line_start":215,"line_end":215,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":88},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":49295,"byte_end":49304,"line_start":245,"line_end":245,"column_start":12,"column_end":21},"name":"is_normal","qualname":"<f32>::is_normal","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the number is neither zero, infinite,\n [subnormal][subnormal], or `NaN`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":49224,"byte_end":49269,"line_start":243,"line_end":243,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":49274,"byte_end":49283,"line_start":244,"line_end":244,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":89},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":49895,"byte_end":49903,"line_start":264,"line_end":264,"column_start":12,"column_end":20},"name":"classify","qualname":"<f32>::classify","value":"fn (self) -> FpCategory","parent":null,"children":[],"decl_id":null,"docs":" Returns the floating point category of the number. If only one property\n is going to be tested, it is generally faster to use the specific\n predicate instead.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":49838,"byte_end":49883,"line_start":263,"line_end":263,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":92},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":50711,"byte_end":50727,"line_start":290,"line_end":290,"column_start":12,"column_end":28},"name":"is_sign_positive","qualname":"<f32>::is_sign_positive","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n positive sign bit and positive infinity.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":50640,"byte_end":50685,"line_start":288,"line_end":288,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":50690,"byte_end":50699,"line_start":289,"line_end":289,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":93},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":51160,"byte_end":51176,"line_start":306,"line_end":306,"column_start":12,"column_end":28},"name":"is_sign_negative","qualname":"<f32>::is_sign_negative","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `self` has a negative sign, including `-0.0`, `NaN`s with\n negative sign bit and negative infinity.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":51089,"byte_end":51134,"line_start":304,"line_end":304,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":51139,"byte_end":51148,"line_start":305,"line_end":305,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":94},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":51720,"byte_end":51725,"line_start":324,"line_end":324,"column_start":12,"column_end":17},"name":"recip","qualname":"<f32>::recip","value":"fn (self) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Takes the reciprocal (inverse) of a number, `1/x`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":51649,"byte_end":51694,"line_start":322,"line_end":322,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":51699,"byte_end":51708,"line_start":323,"line_end":323,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":95},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":52135,"byte_end":52145,"line_start":341,"line_end":341,"column_start":12,"column_end":22},"name":"to_degrees","qualname":"<f32>::to_degrees","value":"fn (self) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Converts radians to degrees.","sig":null,"attributes":[{"value":"stable(feature = \"f32_deg_rad_conversions\", since = \"1.7.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":52048,"byte_end":52109,"line_start":339,"line_end":339,"column_start":5,"column_end":66}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":52114,"byte_end":52123,"line_start":340,"line_end":340,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":97},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":52688,"byte_end":52698,"line_start":360,"line_end":360,"column_start":12,"column_end":22},"name":"to_radians","qualname":"<f32>::to_radians","value":"fn (self) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Converts degrees to radians.","sig":null,"attributes":[{"value":"stable(feature = \"f32_deg_rad_conversions\", since = \"1.7.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":52601,"byte_end":52662,"line_start":358,"line_end":358,"column_start":5,"column_end":66}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":52667,"byte_end":52676,"line_start":359,"line_end":359,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":98},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":53121,"byte_end":53124,"line_start":377,"line_end":377,"column_start":12,"column_end":15},"name":"max","qualname":"<f32>::max","value":"fn (self, other: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the maximum of the two numbers.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":53050,"byte_end":53095,"line_start":375,"line_end":375,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":53100,"byte_end":53109,"line_start":376,"line_end":376,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":99},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":53531,"byte_end":53534,"line_start":393,"line_end":393,"column_start":12,"column_end":15},"name":"min","qualname":"<f32>::min","value":"fn (self, other: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the minimum of the two numbers.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":53460,"byte_end":53505,"line_start":391,"line_end":391,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":53510,"byte_end":53519,"line_start":392,"line_end":392,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":100},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":54310,"byte_end":54317,"line_start":416,"line_end":416,"column_start":12,"column_end":19},"name":"to_bits","qualname":"<f32>::to_bits","value":"fn (self) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Raw transmutation to `u32`.","sig":null,"attributes":[{"value":"stable(feature = \"float_bits_conv\", since = \"1.20.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":54228,"byte_end":54284,"line_start":414,"line_end":414,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":54289,"byte_end":54298,"line_start":415,"line_end":415,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":101},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":56241,"byte_end":56250,"line_start":460,"line_end":460,"column_start":12,"column_end":21},"name":"from_bits","qualname":"<f32>::from_bits","value":"fn (v: u32) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Raw transmutation from `u32`.","sig":null,"attributes":[{"value":"stable(feature = \"float_bits_conv\", since = \"1.20.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":56159,"byte_end":56215,"line_start":458,"line_end":458,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":56220,"byte_end":56229,"line_start":459,"line_end":459,"column_start":5,"column_end":14}}]},{"kind":"Mod","id":{"krate":0,"index":102},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"f64","qualname":"::f64","value":"src/libcore/num/f64.rs","parent":null,"children":[{"krate":0,"index":103},{"krate":0,"index":104},{"krate":0,"index":105},{"krate":0,"index":106},{"krate":0,"index":107},{"krate":0,"index":108},{"krate":0,"index":109},{"krate":0,"index":110},{"krate":0,"index":111},{"krate":0,"index":112},{"krate":0,"index":113},{"krate":0,"index":114},{"krate":0,"index":115},{"krate":0,"index":116},{"krate":0,"index":117},{"krate":0,"index":118},{"krate":0,"index":119},{"krate":0,"index":120},{"krate":0,"index":139}],"decl_id":null,"docs":" This module provides constants which are specific to the implementation\n of the `f64` floating point data type.","sig":null,"attributes":[{"value":"path = \"num/f64.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5829,"byte_end":5851,"line_start":163,"line_end":163,"column_start":1,"column_end":23}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":56672,"byte_end":56718,"line_start":8,"line_end":8,"column_start":1,"column_end":47}}]},{"kind":"Const","id":{"krate":0,"index":106},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":56926,"byte_end":56931,"line_start":18,"line_end":18,"column_start":11,"column_end":16},"name":"RADIX","qualname":"::f64::RADIX","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" The radix or base of the internal representation of `f64`.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":56870,"byte_end":56915,"line_start":17,"line_end":17,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":107},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":57043,"byte_end":57058,"line_start":22,"line_end":22,"column_start":11,"column_end":26},"name":"MANTISSA_DIGITS","qualname":"::f64::MANTISSA_DIGITS","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" Number of significant digits in base 2.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":56987,"byte_end":57032,"line_start":21,"line_end":21,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":108},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":57183,"byte_end":57189,"line_start":25,"line_end":25,"column_start":11,"column_end":17},"name":"DIGITS","qualname":"::f64::DIGITS","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" Approximate number of significant digits in base 10.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":57127,"byte_end":57172,"line_start":24,"line_end":24,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":109},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":57458,"byte_end":57465,"line_start":33,"line_end":33,"column_start":11,"column_end":18},"name":"EPSILON","qualname":"::f64::EPSILON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" [Machine epsilon] value for `f64`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":57402,"byte_end":57447,"line_start":32,"line_end":32,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":110},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":57591,"byte_end":57594,"line_start":37,"line_end":37,"column_start":11,"column_end":14},"name":"MIN","qualname":"::f64::MIN","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" Smallest finite `f64` value.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":57535,"byte_end":57580,"line_start":36,"line_end":36,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":111},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":57730,"byte_end":57742,"line_start":40,"line_end":40,"column_start":11,"column_end":23},"name":"MIN_POSITIVE","qualname":"::f64::MIN_POSITIVE","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" Smallest positive normal `f64` value.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":57674,"byte_end":57719,"line_start":39,"line_end":39,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":112},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":57867,"byte_end":57870,"line_start":43,"line_end":43,"column_start":11,"column_end":14},"name":"MAX","qualname":"::f64::MAX","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" Largest finite `f64` value.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":57811,"byte_end":57856,"line_start":42,"line_end":42,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":113},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":58034,"byte_end":58041,"line_start":47,"line_end":47,"column_start":11,"column_end":18},"name":"MIN_EXP","qualname":"::f64::MIN_EXP","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" One greater than the minimum possible normal power of 2 exponent.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":57978,"byte_end":58023,"line_start":46,"line_end":46,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":114},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":58154,"byte_end":58161,"line_start":50,"line_end":50,"column_start":11,"column_end":18},"name":"MAX_EXP","qualname":"::f64::MAX_EXP","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Maximum possible power of 2 exponent.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":58098,"byte_end":58143,"line_start":49,"line_end":49,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":115},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":58282,"byte_end":58292,"line_start":54,"line_end":54,"column_start":11,"column_end":21},"name":"MIN_10_EXP","qualname":"::f64::MIN_10_EXP","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Minimum possible normal power of 10 exponent.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":58226,"byte_end":58271,"line_start":53,"line_end":53,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":116},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":58405,"byte_end":58415,"line_start":57,"line_end":57,"column_start":11,"column_end":21},"name":"MAX_10_EXP","qualname":"::f64::MAX_10_EXP","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Maximum possible power of 10 exponent.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":58349,"byte_end":58394,"line_start":56,"line_end":56,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":117},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":58509,"byte_end":58512,"line_start":61,"line_end":61,"column_start":11,"column_end":14},"name":"NAN","qualname":"::f64::NAN","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" Not a Number (NaN).\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":58453,"byte_end":58498,"line_start":60,"line_end":60,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":118},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":58615,"byte_end":58623,"line_start":64,"line_end":64,"column_start":11,"column_end":19},"name":"INFINITY","qualname":"::f64::INFINITY","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" Infinity (∞).\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":58559,"byte_end":58604,"line_start":63,"line_end":63,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":119},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":58736,"byte_end":58748,"line_start":67,"line_end":67,"column_start":11,"column_end":23},"name":"NEG_INFINITY","qualname":"::f64::NEG_INFINITY","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" Negative infinity (-∞).\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":58680,"byte_end":58725,"line_start":66,"line_end":66,"column_start":1,"column_end":46}}]},{"kind":"Mod","id":{"krate":0,"index":120},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":58865,"byte_end":58871,"line_start":71,"line_end":71,"column_start":9,"column_end":15},"name":"consts","qualname":"::f64::consts","value":"src/libcore/num/f64.rs","parent":null,"children":[{"krate":0,"index":121},{"krate":0,"index":122},{"krate":0,"index":123},{"krate":0,"index":124},{"krate":0,"index":125},{"krate":0,"index":126},{"krate":0,"index":127},{"krate":0,"index":128},{"krate":0,"index":129},{"krate":0,"index":130},{"krate":0,"index":131},{"krate":0,"index":132},{"krate":0,"index":133},{"krate":0,"index":134},{"krate":0,"index":135},{"krate":0,"index":136},{"krate":0,"index":137},{"krate":0,"index":138}],"decl_id":null,"docs":" Basic mathematical constants.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":58811,"byte_end":58856,"line_start":70,"line_end":70,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":121},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":59035,"byte_end":59037,"line_start":76,"line_end":76,"column_start":15,"column_end":17},"name":"PI","qualname":"::f64::consts::PI","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" Archimedes' constant (π)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":58975,"byte_end":59020,"line_start":75,"line_end":75,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":122},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":59166,"byte_end":59175,"line_start":80,"line_end":80,"column_start":15,"column_end":24},"name":"FRAC_PI_2","qualname":"::f64::consts::FRAC_PI_2","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" π/2\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":59106,"byte_end":59151,"line_start":79,"line_end":79,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":123},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":59304,"byte_end":59313,"line_start":84,"line_end":84,"column_start":15,"column_end":24},"name":"FRAC_PI_3","qualname":"::f64::consts::FRAC_PI_3","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" π/3\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":59244,"byte_end":59289,"line_start":83,"line_end":83,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":124},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":59442,"byte_end":59451,"line_start":88,"line_end":88,"column_start":15,"column_end":24},"name":"FRAC_PI_4","qualname":"::f64::consts::FRAC_PI_4","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" π/4\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":59382,"byte_end":59427,"line_start":87,"line_end":87,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":125},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":59581,"byte_end":59590,"line_start":92,"line_end":92,"column_start":15,"column_end":24},"name":"FRAC_PI_6","qualname":"::f64::consts::FRAC_PI_6","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" π/6\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":59521,"byte_end":59566,"line_start":91,"line_end":91,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":126},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":59719,"byte_end":59728,"line_start":96,"line_end":96,"column_start":15,"column_end":24},"name":"FRAC_PI_8","qualname":"::f64::consts::FRAC_PI_8","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" π/8\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":59659,"byte_end":59704,"line_start":95,"line_end":95,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":127},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":59857,"byte_end":59866,"line_start":100,"line_end":100,"column_start":15,"column_end":24},"name":"FRAC_1_PI","qualname":"::f64::consts::FRAC_1_PI","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 1/π\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":59797,"byte_end":59842,"line_start":99,"line_end":99,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":128},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":59996,"byte_end":60005,"line_start":104,"line_end":104,"column_start":15,"column_end":24},"name":"FRAC_2_PI","qualname":"::f64::consts::FRAC_2_PI","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 2/π\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":59936,"byte_end":59981,"line_start":103,"line_end":103,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":129},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":60141,"byte_end":60155,"line_start":108,"line_end":108,"column_start":15,"column_end":29},"name":"FRAC_2_SQRT_PI","qualname":"::f64::consts::FRAC_2_SQRT_PI","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 2/sqrt(π)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":60081,"byte_end":60126,"line_start":107,"line_end":107,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":130},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":60287,"byte_end":60293,"line_start":112,"line_end":112,"column_start":15,"column_end":21},"name":"SQRT_2","qualname":"::f64::consts::SQRT_2","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" sqrt(2)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":60227,"byte_end":60272,"line_start":111,"line_end":111,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":131},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":60427,"byte_end":60440,"line_start":116,"line_end":116,"column_start":15,"column_end":28},"name":"FRAC_1_SQRT_2","qualname":"::f64::consts::FRAC_1_SQRT_2","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 1/sqrt(2)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":60367,"byte_end":60412,"line_start":115,"line_end":115,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":132},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":60584,"byte_end":60585,"line_start":120,"line_end":120,"column_start":15,"column_end":16},"name":"E","qualname":"::f64::consts::E","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" Euler's number (e)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":60524,"byte_end":60569,"line_start":119,"line_end":119,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":133},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":60742,"byte_end":60749,"line_start":124,"line_end":124,"column_start":15,"column_end":22},"name":"LOG2_10","qualname":"::f64::consts::LOG2_10","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" log<sub>2</sub>(10)\n","sig":null,"attributes":[{"value":"unstable(feature = \"extra_log_consts\", issue = \"50540\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":60669,"byte_end":60727,"line_start":123,"line_end":123,"column_start":5,"column_end":63}}]},{"kind":"Const","id":{"krate":0,"index":134},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":60892,"byte_end":60898,"line_start":128,"line_end":128,"column_start":15,"column_end":21},"name":"LOG2_E","qualname":"::f64::consts::LOG2_E","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" log<sub>2</sub>(e)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":60832,"byte_end":60877,"line_start":127,"line_end":127,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":135},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":61055,"byte_end":61062,"line_start":132,"line_end":132,"column_start":15,"column_end":22},"name":"LOG10_2","qualname":"::f64::consts::LOG10_2","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" log<sub>10</sub>(2)\n","sig":null,"attributes":[{"value":"unstable(feature = \"extra_log_consts\", issue = \"50540\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":60982,"byte_end":61040,"line_start":131,"line_end":131,"column_start":5,"column_end":63}}]},{"kind":"Const","id":{"krate":0,"index":136},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":61207,"byte_end":61214,"line_start":136,"line_end":136,"column_start":15,"column_end":22},"name":"LOG10_E","qualname":"::f64::consts::LOG10_E","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" log<sub>10</sub>(e)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":61147,"byte_end":61192,"line_start":135,"line_end":135,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":137},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":61345,"byte_end":61349,"line_start":140,"line_end":140,"column_start":15,"column_end":19},"name":"LN_2","qualname":"::f64::consts::LN_2","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" ln(2)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":61285,"byte_end":61330,"line_start":139,"line_end":139,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":138},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":61481,"byte_end":61486,"line_start":144,"line_end":144,"column_start":15,"column_end":20},"name":"LN_10","qualname":"::f64::consts::LN_10","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" ln(10)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":61421,"byte_end":61466,"line_start":143,"line_end":143,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":140},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":61891,"byte_end":61897,"line_start":163,"line_end":163,"column_start":12,"column_end":18},"name":"is_nan","qualname":"<f64>::is_nan","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this value is `NaN`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":61820,"byte_end":61865,"line_start":161,"line_end":161,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":61870,"byte_end":61879,"line_start":162,"line_end":162,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":142},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":62764,"byte_end":62775,"line_start":194,"line_end":194,"column_start":12,"column_end":23},"name":"is_infinite","qualname":"<f64>::is_infinite","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this value is positive infinity or negative infinity, and\n `false` otherwise.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":62693,"byte_end":62738,"line_start":192,"line_end":192,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":62743,"byte_end":62752,"line_start":193,"line_end":193,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":143},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":63342,"byte_end":63351,"line_start":216,"line_end":216,"column_start":12,"column_end":21},"name":"is_finite","qualname":"<f64>::is_finite","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this number is neither infinite nor `NaN`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":63271,"byte_end":63316,"line_start":214,"line_end":214,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":63321,"byte_end":63330,"line_start":215,"line_end":215,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":144},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":64322,"byte_end":64331,"line_start":245,"line_end":245,"column_start":12,"column_end":21},"name":"is_normal","qualname":"<f64>::is_normal","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the number is neither zero, infinite,\n [subnormal][subnormal], or `NaN`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":64251,"byte_end":64296,"line_start":243,"line_end":243,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":64301,"byte_end":64310,"line_start":244,"line_end":244,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":145},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":64922,"byte_end":64930,"line_start":264,"line_end":264,"column_start":12,"column_end":20},"name":"classify","qualname":"<f64>::classify","value":"fn (self) -> FpCategory","parent":null,"children":[],"decl_id":null,"docs":" Returns the floating point category of the number. If only one property\n is going to be tested, it is generally faster to use the specific\n predicate instead.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":64865,"byte_end":64910,"line_start":263,"line_end":263,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":148},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":65754,"byte_end":65770,"line_start":290,"line_end":290,"column_start":12,"column_end":28},"name":"is_sign_positive","qualname":"<f64>::is_sign_positive","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n positive sign bit and positive infinity.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":65683,"byte_end":65728,"line_start":288,"line_end":288,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":65733,"byte_end":65742,"line_start":289,"line_end":289,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":149},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":66002,"byte_end":66013,"line_start":298,"line_end":298,"column_start":12,"column_end":23},"name":"is_positive","qualname":"<f64>::is_positive","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":65831,"byte_end":65876,"line_start":294,"line_end":294,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_positive\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":65881,"byte_end":65957,"line_start":295,"line_end":295,"column_start":5,"column_end":81}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":65962,"byte_end":65971,"line_start":296,"line_end":296,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":150},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":66447,"byte_end":66463,"line_start":314,"line_end":314,"column_start":12,"column_end":28},"name":"is_sign_negative","qualname":"<f64>::is_sign_negative","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `self` has a negative sign, including `-0.0`, `NaN`s with\n negative sign bit and negative infinity.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":66376,"byte_end":66421,"line_start":312,"line_end":312,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":66426,"byte_end":66435,"line_start":313,"line_end":313,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":151},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":66714,"byte_end":66725,"line_start":322,"line_end":322,"column_start":12,"column_end":23},"name":"is_negative","qualname":"<f64>::is_negative","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":66543,"byte_end":66588,"line_start":318,"line_end":318,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_negative\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":66593,"byte_end":66669,"line_start":319,"line_end":319,"column_start":5,"column_end":81}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":66674,"byte_end":66683,"line_start":320,"line_end":320,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":152},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":67079,"byte_end":67084,"line_start":336,"line_end":336,"column_start":12,"column_end":17},"name":"recip","qualname":"<f64>::recip","value":"fn (self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Takes the reciprocal (inverse) of a number, `1/x`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":67008,"byte_end":67053,"line_start":334,"line_end":334,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":67058,"byte_end":67067,"line_start":335,"line_end":335,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":153},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":67462,"byte_end":67472,"line_start":353,"line_end":353,"column_start":12,"column_end":22},"name":"to_degrees","qualname":"<f64>::to_degrees","value":"fn (self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Converts radians to degrees.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":67391,"byte_end":67436,"line_start":351,"line_end":351,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":67441,"byte_end":67450,"line_start":352,"line_end":352,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":154},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":68081,"byte_end":68091,"line_start":373,"line_end":373,"column_start":12,"column_end":22},"name":"to_radians","qualname":"<f64>::to_radians","value":"fn (self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Converts degrees to radians.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":68010,"byte_end":68055,"line_start":371,"line_end":371,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":68060,"byte_end":68069,"line_start":372,"line_end":372,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":155},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":68513,"byte_end":68516,"line_start":390,"line_end":390,"column_start":12,"column_end":15},"name":"max","qualname":"<f64>::max","value":"fn (self, other: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the maximum of the two numbers.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":68442,"byte_end":68487,"line_start":388,"line_end":388,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":68492,"byte_end":68501,"line_start":389,"line_end":389,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":156},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":68925,"byte_end":68928,"line_start":406,"line_end":406,"column_start":12,"column_end":15},"name":"min","qualname":"<f64>::min","value":"fn (self, other: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the minimum of the two numbers.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":68854,"byte_end":68899,"line_start":404,"line_end":404,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":68904,"byte_end":68913,"line_start":405,"line_end":405,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":157},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":69711,"byte_end":69718,"line_start":429,"line_end":429,"column_start":12,"column_end":19},"name":"to_bits","qualname":"<f64>::to_bits","value":"fn (self) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Raw transmutation to `u64`.","sig":null,"attributes":[{"value":"stable(feature = \"float_bits_conv\", since = \"1.20.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":69629,"byte_end":69685,"line_start":427,"line_end":427,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":69690,"byte_end":69699,"line_start":428,"line_end":428,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":158},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":71651,"byte_end":71660,"line_start":473,"line_end":473,"column_start":12,"column_end":21},"name":"from_bits","qualname":"<f64>::from_bits","value":"fn (v: u64) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Raw transmutation from `u64`.","sig":null,"attributes":[{"value":"stable(feature = \"float_bits_conv\", since = \"1.20.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":71569,"byte_end":71625,"line_start":471,"line_end":471,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":71630,"byte_end":71639,"line_start":472,"line_end":472,"column_start":5,"column_end":14}}]},{"kind":"Mod","id":{"krate":0,"index":159},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"num","qualname":"::num","value":"src/libcore/num/mod.rs","parent":null,"children":[{"krate":0,"index":160},{"krate":0,"index":163},{"krate":0,"index":164},{"krate":0,"index":165},{"krate":0,"index":166},{"krate":0,"index":167},{"krate":0,"index":168},{"krate":0,"index":169},{"krate":0,"index":170},{"krate":0,"index":9710},{"krate":0,"index":9731},{"krate":0,"index":9729},{"krate":0,"index":9727},{"krate":0,"index":9724},{"krate":0,"index":9722},{"krate":0,"index":9716},{"krate":0,"index":9713},{"krate":0,"index":9638},{"krate":0,"index":9642},{"krate":0,"index":9732},{"krate":0,"index":9734},{"krate":0,"index":9736},{"krate":0,"index":9738},{"krate":0,"index":9740},{"krate":0,"index":9742},{"krate":0,"index":9744},{"krate":0,"index":9765},{"krate":0,"index":9763},{"krate":0,"index":9761},{"krate":0,"index":9758},{"krate":0,"index":9756},{"krate":0,"index":9750},{"krate":0,"index":9747},{"krate":0,"index":9644},{"krate":0,"index":9648},{"krate":0,"index":9766},{"krate":0,"index":9768},{"krate":0,"index":9770},{"krate":0,"index":9772},{"krate":0,"index":9774},{"krate":0,"index":9776},{"krate":0,"index":9778},{"krate":0,"index":9799},{"krate":0,"index":9797},{"krate":0,"index":9795},{"krate":0,"index":9792},{"krate":0,"index":9790},{"krate":0,"index":9784},{"krate":0,"index":9781},{"krate":0,"index":9650},{"krate":0,"index":9654},{"krate":0,"index":9800},{"krate":0,"index":9802},{"krate":0,"index":9804},{"krate":0,"index":9806},{"krate":0,"index":9808},{"krate":0,"index":9810},{"krate":0,"index":9812},{"krate":0,"index":9833},{"krate":0,"index":9831},{"krate":0,"index":9829},{"krate":0,"index":9826},{"krate":0,"index":9824},{"krate":0,"index":9818},{"krate":0,"index":9815},{"krate":0,"index":9656},{"krate":0,"index":9660},{"krate":0,"index":9834},{"krate":0,"index":9836},{"krate":0,"index":9838},{"krate":0,"index":9840},{"krate":0,"index":9842},{"krate":0,"index":9844},{"krate":0,"index":9846},{"krate":0,"index":9867},{"krate":0,"index":9865},{"krate":0,"index":9863},{"krate":0,"index":9860},{"krate":0,"index":9858},{"krate":0,"index":9852},{"krate":0,"index":9849},{"krate":0,"index":9662},{"krate":0,"index":9666},{"krate":0,"index":9868},{"krate":0,"index":9870},{"krate":0,"index":9872},{"krate":0,"index":9874},{"krate":0,"index":9876},{"krate":0,"index":9878},{"krate":0,"index":9880},{"krate":0,"index":9901},{"krate":0,"index":9899},{"krate":0,"index":9897},{"krate":0,"index":9894},{"krate":0,"index":9892},{"krate":0,"index":9886},{"krate":0,"index":9883},{"krate":0,"index":9668},{"krate":0,"index":9672},{"krate":0,"index":9902},{"krate":0,"index":9904},{"krate":0,"index":9906},{"krate":0,"index":9908},{"krate":0,"index":9910},{"krate":0,"index":9912},{"krate":0,"index":9914},{"krate":0,"index":9935},{"krate":0,"index":9933},{"krate":0,"index":9931},{"krate":0,"index":9928},{"krate":0,"index":9926},{"krate":0,"index":9920},{"krate":0,"index":9917},{"krate":0,"index":9674},{"krate":0,"index":9678},{"krate":0,"index":9936},{"krate":0,"index":9938},{"krate":0,"index":9940},{"krate":0,"index":9942},{"krate":0,"index":9944},{"krate":0,"index":9946},{"krate":0,"index":9948},{"krate":0,"index":9969},{"krate":0,"index":9967},{"krate":0,"index":9965},{"krate":0,"index":9962},{"krate":0,"index":9960},{"krate":0,"index":9954},{"krate":0,"index":9951},{"krate":0,"index":9680},{"krate":0,"index":9684},{"krate":0,"index":9970},{"krate":0,"index":9972},{"krate":0,"index":9974},{"krate":0,"index":9976},{"krate":0,"index":9978},{"krate":0,"index":9980},{"krate":0,"index":9982},{"krate":0,"index":10003},{"krate":0,"index":10001},{"krate":0,"index":9999},{"krate":0,"index":9996},{"krate":0,"index":9994},{"krate":0,"index":9988},{"krate":0,"index":9985},{"krate":0,"index":9686},{"krate":0,"index":9690},{"krate":0,"index":10004},{"krate":0,"index":10006},{"krate":0,"index":10008},{"krate":0,"index":10010},{"krate":0,"index":10012},{"krate":0,"index":10014},{"krate":0,"index":10016},{"krate":0,"index":10037},{"krate":0,"index":10035},{"krate":0,"index":10033},{"krate":0,"index":10030},{"krate":0,"index":10028},{"krate":0,"index":10022},{"krate":0,"index":10019},{"krate":0,"index":9692},{"krate":0,"index":9696},{"krate":0,"index":10038},{"krate":0,"index":10040},{"krate":0,"index":10042},{"krate":0,"index":10044},{"krate":0,"index":10046},{"krate":0,"index":10048},{"krate":0,"index":10050},{"krate":0,"index":10071},{"krate":0,"index":10069},{"krate":0,"index":10067},{"krate":0,"index":10064},{"krate":0,"index":10062},{"krate":0,"index":10056},{"krate":0,"index":10053},{"krate":0,"index":9698},{"krate":0,"index":9702},{"krate":0,"index":10072},{"krate":0,"index":10074},{"krate":0,"index":10076},{"krate":0,"index":10078},{"krate":0,"index":10080},{"krate":0,"index":10082},{"krate":0,"index":10084},{"krate":0,"index":10105},{"krate":0,"index":10103},{"krate":0,"index":10101},{"krate":0,"index":10098},{"krate":0,"index":10096},{"krate":0,"index":10090},{"krate":0,"index":10087},{"krate":0,"index":9704},{"krate":0,"index":9708},{"krate":0,"index":10106},{"krate":0,"index":10108},{"krate":0,"index":10110},{"krate":0,"index":10112},{"krate":0,"index":10114},{"krate":0,"index":10116},{"krate":0,"index":171},{"krate":0,"index":10118},{"krate":0,"index":10121},{"krate":0,"index":10124},{"krate":0,"index":10127},{"krate":0,"index":10130},{"krate":0,"index":10133},{"krate":0,"index":10136},{"krate":0,"index":10139},{"krate":0,"index":10142},{"krate":0,"index":10145},{"krate":0,"index":10148},{"krate":0,"index":10151},{"krate":0,"index":10154},{"krate":0,"index":10183},{"krate":0,"index":10180},{"krate":0,"index":10173},{"krate":0,"index":10170},{"krate":0,"index":10167},{"krate":0,"index":10165},{"krate":0,"index":10162},{"krate":0,"index":10158},{"krate":0,"index":172},{"krate":0,"index":175},{"krate":0,"index":178},{"krate":0,"index":181},{"krate":0,"index":184},{"krate":0,"index":187},{"krate":0,"index":190},{"krate":0,"index":307},{"krate":0,"index":512},{"krate":0,"index":526},{"krate":0,"index":532},{"krate":0,"index":558},{"krate":0,"index":559},{"krate":0,"index":560},{"krate":0,"index":561},{"krate":0,"index":562},{"krate":0,"index":563},{"krate":0,"index":564},{"krate":0,"index":565},{"krate":0,"index":566},{"krate":0,"index":567},{"krate":0,"index":568},{"krate":0,"index":585},{"krate":0,"index":586},{"krate":0,"index":587},{"krate":0,"index":588},{"krate":0,"index":589},{"krate":0,"index":13574},{"krate":0,"index":13593},{"krate":0,"index":13591},{"krate":0,"index":13589},{"krate":0,"index":13587},{"krate":0,"index":13585},{"krate":0,"index":590},{"krate":0,"index":13594},{"krate":0,"index":13597},{"krate":0,"index":13600},{"krate":0,"index":13603},{"krate":0,"index":13606},{"krate":0,"index":13609},{"krate":0,"index":13612},{"krate":0,"index":13615},{"krate":0,"index":13618},{"krate":0,"index":13621},{"krate":0,"index":13624},{"krate":0,"index":13627},{"krate":0,"index":13630},{"krate":0,"index":13641},{"krate":0,"index":13640},{"krate":0,"index":13638},{"krate":0,"index":13635},{"krate":0,"index":13633},{"krate":0,"index":591},{"krate":0,"index":593},{"krate":0,"index":595},{"krate":0,"index":597},{"krate":0,"index":599},{"krate":0,"index":600},{"krate":0,"index":601},{"krate":0,"index":602},{"krate":0,"index":603},{"krate":0,"index":13643},{"krate":0,"index":13646},{"krate":0,"index":13649},{"krate":0,"index":13652},{"krate":0,"index":13655},{"krate":0,"index":13658},{"krate":0,"index":13661},{"krate":0,"index":13664},{"krate":0,"index":13667},{"krate":0,"index":13670},{"krate":0,"index":13673},{"krate":0,"index":13676},{"krate":0,"index":13679},{"krate":0,"index":13682},{"krate":0,"index":13685},{"krate":0,"index":13688},{"krate":0,"index":13691},{"krate":0,"index":13694},{"krate":0,"index":13697},{"krate":0,"index":13700},{"krate":0,"index":13703},{"krate":0,"index":13706},{"krate":0,"index":13709},{"krate":0,"index":13712},{"krate":0,"index":13715},{"krate":0,"index":13718},{"krate":0,"index":13721},{"krate":0,"index":13724},{"krate":0,"index":13727},{"krate":0,"index":13730},{"krate":0,"index":13733},{"krate":0,"index":13736},{"krate":0,"index":13739},{"krate":0,"index":13742},{"krate":0,"index":13745},{"krate":0,"index":13748},{"krate":0,"index":13751},{"krate":0,"index":13754},{"krate":0,"index":13757},{"krate":0,"index":13760},{"krate":0,"index":13763},{"krate":0,"index":13766},{"krate":0,"index":13769},{"krate":0,"index":13772},{"krate":0,"index":13775},{"krate":0,"index":13778},{"krate":0,"index":13781},{"krate":0,"index":13784},{"krate":0,"index":13787},{"krate":0,"index":13790},{"krate":0,"index":13793},{"krate":0,"index":13796},{"krate":0,"index":13799},{"krate":0,"index":13802},{"krate":0,"index":13805},{"krate":0,"index":13808},{"krate":0,"index":13811},{"krate":0,"index":13814},{"krate":0,"index":13817},{"krate":0,"index":13820},{"krate":0,"index":13823},{"krate":0,"index":13826},{"krate":0,"index":604},{"krate":0,"index":607},{"krate":0,"index":614},{"krate":0,"index":13934},{"krate":0,"index":13941},{"krate":0,"index":13948},{"krate":0,"index":13955},{"krate":0,"index":13962},{"krate":0,"index":13969},{"krate":0,"index":13976},{"krate":0,"index":13983},{"krate":0,"index":13990},{"krate":0,"index":13997},{"krate":0,"index":14004},{"krate":0,"index":14011},{"krate":0,"index":615},{"krate":0,"index":14018},{"krate":0,"index":14027},{"krate":0,"index":14025},{"krate":0,"index":14022},{"krate":0,"index":14020},{"krate":0,"index":14029},{"krate":0,"index":14046},{"krate":0,"index":14044},{"krate":0,"index":14042},{"krate":0,"index":14040},{"krate":0,"index":619},{"krate":0,"index":622},{"krate":0,"index":624},{"krate":0,"index":625},{"krate":0,"index":626},{"krate":0,"index":14048},{"krate":0,"index":14050},{"krate":0,"index":14052},{"krate":0,"index":14054},{"krate":0,"index":14056},{"krate":0,"index":14058},{"krate":0,"index":14060},{"krate":0,"index":14062},{"krate":0,"index":14064},{"krate":0,"index":14066},{"krate":0,"index":14068},{"krate":0,"index":14070},{"krate":0,"index":14072},{"krate":0,"index":14074},{"krate":0,"index":14076},{"krate":0,"index":14078},{"krate":0,"index":14080},{"krate":0,"index":14082},{"krate":0,"index":14084},{"krate":0,"index":14086},{"krate":0,"index":14088},{"krate":0,"index":14090},{"krate":0,"index":14092},{"krate":0,"index":14094},{"krate":0,"index":14096},{"krate":0,"index":14098},{"krate":0,"index":14100},{"krate":0,"index":14102},{"krate":0,"index":14104},{"krate":0,"index":14106},{"krate":0,"index":14108},{"krate":0,"index":14110},{"krate":0,"index":14112},{"krate":0,"index":14114},{"krate":0,"index":14116},{"krate":0,"index":14118},{"krate":0,"index":14120},{"krate":0,"index":14122},{"krate":0,"index":14124},{"krate":0,"index":14126},{"krate":0,"index":14128},{"krate":0,"index":14130},{"krate":0,"index":14132},{"krate":0,"index":14134},{"krate":0,"index":14136},{"krate":0,"index":14138},{"krate":0,"index":14140},{"krate":0,"index":14142},{"krate":0,"index":14144},{"krate":0,"index":14146},{"krate":0,"index":14148},{"krate":0,"index":14150},{"krate":0,"index":14152},{"krate":0,"index":14154},{"krate":0,"index":14156},{"krate":0,"index":14158},{"krate":0,"index":14160},{"krate":0,"index":14162}],"decl_id":null,"docs":" Numeric traits and functions for the built-in numeric types.\n","sig":null,"attributes":[{"value":"macro_use","span":{"file_name":"src/libcore/lib.rs","byte_start":5868,"byte_end":5880,"line_start":165,"line_end":165,"column_start":1,"column_end":13}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":71894,"byte_end":71940,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Struct","id":{"krate":0,"index":9710},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":74786,"byte_end":74795,"line_start":104,"line_end":104,"column_start":54,"column_end":63},"name":"NonZeroU8","qualname":"::num::NonZeroU8","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"nonzero\", since = \"1.28.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73055,"byte_end":73068,"line_start":49,"line_end":49,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73162,"byte_end":73182,"line_start":51,"line_end":51,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73199,"byte_end":73242,"line_start":52,"line_end":52,"column_start":17,"column_end":60}},{"value":"rustc_nonnull_optimization_guaranteed","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73286,"byte_end":73323,"line_start":53,"line_end":53,"column_start":44,"column_end":81}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":9744},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":74854,"byte_end":74864,"line_start":105,"line_end":105,"column_start":54,"column_end":64},"name":"NonZeroU16","qualname":"::num::NonZeroU16","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"nonzero\", since = \"1.28.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73055,"byte_end":73068,"line_start":49,"line_end":49,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73162,"byte_end":73182,"line_start":51,"line_end":51,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73199,"byte_end":73242,"line_start":52,"line_end":52,"column_start":17,"column_end":60}},{"value":"rustc_nonnull_optimization_guaranteed","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73286,"byte_end":73323,"line_start":53,"line_end":53,"column_start":44,"column_end":81}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":9778},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":74924,"byte_end":74934,"line_start":106,"line_end":106,"column_start":54,"column_end":64},"name":"NonZeroU32","qualname":"::num::NonZeroU32","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"nonzero\", since = \"1.28.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73055,"byte_end":73068,"line_start":49,"line_end":49,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73162,"byte_end":73182,"line_start":51,"line_end":51,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73199,"byte_end":73242,"line_start":52,"line_end":52,"column_start":17,"column_end":60}},{"value":"rustc_nonnull_optimization_guaranteed","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73286,"byte_end":73323,"line_start":53,"line_end":53,"column_start":44,"column_end":81}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":9812},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":74994,"byte_end":75004,"line_start":107,"line_end":107,"column_start":54,"column_end":64},"name":"NonZeroU64","qualname":"::num::NonZeroU64","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"nonzero\", since = \"1.28.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73055,"byte_end":73068,"line_start":49,"line_end":49,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73162,"byte_end":73182,"line_start":51,"line_end":51,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73199,"byte_end":73242,"line_start":52,"line_end":52,"column_start":17,"column_end":60}},{"value":"rustc_nonnull_optimization_guaranteed","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73286,"byte_end":73323,"line_start":53,"line_end":53,"column_start":44,"column_end":81}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":9846},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":75064,"byte_end":75075,"line_start":108,"line_end":108,"column_start":54,"column_end":65},"name":"NonZeroU128","qualname":"::num::NonZeroU128","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"nonzero\", since = \"1.28.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73055,"byte_end":73068,"line_start":49,"line_end":49,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73162,"byte_end":73182,"line_start":51,"line_end":51,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73199,"byte_end":73242,"line_start":52,"line_end":52,"column_start":17,"column_end":60}},{"value":"rustc_nonnull_optimization_guaranteed","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73286,"byte_end":73323,"line_start":53,"line_end":53,"column_start":44,"column_end":81}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":9880},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":75136,"byte_end":75148,"line_start":109,"line_end":109,"column_start":54,"column_end":66},"name":"NonZeroUsize","qualname":"::num::NonZeroUsize","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"nonzero\", since = \"1.28.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73055,"byte_end":73068,"line_start":49,"line_end":49,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73162,"byte_end":73182,"line_start":51,"line_end":51,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73199,"byte_end":73242,"line_start":52,"line_end":52,"column_start":17,"column_end":60}},{"value":"rustc_nonnull_optimization_guaranteed","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73286,"byte_end":73323,"line_start":53,"line_end":53,"column_start":44,"column_end":81}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":9914},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":75217,"byte_end":75226,"line_start":110,"line_end":110,"column_start":61,"column_end":70},"name":"NonZeroI8","qualname":"::num::NonZeroI8","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"signed_nonzero\", since = \"1.34.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73055,"byte_end":73068,"line_start":49,"line_end":49,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73162,"byte_end":73182,"line_start":51,"line_end":51,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73199,"byte_end":73242,"line_start":52,"line_end":52,"column_start":17,"column_end":60}},{"value":"rustc_nonnull_optimization_guaranteed","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73286,"byte_end":73323,"line_start":53,"line_end":53,"column_start":44,"column_end":81}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":9948},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":75292,"byte_end":75302,"line_start":111,"line_end":111,"column_start":61,"column_end":71},"name":"NonZeroI16","qualname":"::num::NonZeroI16","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"signed_nonzero\", since = \"1.34.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73055,"byte_end":73068,"line_start":49,"line_end":49,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73162,"byte_end":73182,"line_start":51,"line_end":51,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73199,"byte_end":73242,"line_start":52,"line_end":52,"column_start":17,"column_end":60}},{"value":"rustc_nonnull_optimization_guaranteed","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73286,"byte_end":73323,"line_start":53,"line_end":53,"column_start":44,"column_end":81}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":9982},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":75369,"byte_end":75379,"line_start":112,"line_end":112,"column_start":61,"column_end":71},"name":"NonZeroI32","qualname":"::num::NonZeroI32","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"signed_nonzero\", since = \"1.34.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73055,"byte_end":73068,"line_start":49,"line_end":49,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73162,"byte_end":73182,"line_start":51,"line_end":51,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73199,"byte_end":73242,"line_start":52,"line_end":52,"column_start":17,"column_end":60}},{"value":"rustc_nonnull_optimization_guaranteed","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73286,"byte_end":73323,"line_start":53,"line_end":53,"column_start":44,"column_end":81}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":10016},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":75446,"byte_end":75456,"line_start":113,"line_end":113,"column_start":61,"column_end":71},"name":"NonZeroI64","qualname":"::num::NonZeroI64","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"signed_nonzero\", since = \"1.34.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73055,"byte_end":73068,"line_start":49,"line_end":49,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73162,"byte_end":73182,"line_start":51,"line_end":51,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73199,"byte_end":73242,"line_start":52,"line_end":52,"column_start":17,"column_end":60}},{"value":"rustc_nonnull_optimization_guaranteed","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73286,"byte_end":73323,"line_start":53,"line_end":53,"column_start":44,"column_end":81}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":10050},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":75523,"byte_end":75534,"line_start":114,"line_end":114,"column_start":61,"column_end":72},"name":"NonZeroI128","qualname":"::num::NonZeroI128","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"signed_nonzero\", since = \"1.34.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73055,"byte_end":73068,"line_start":49,"line_end":49,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73162,"byte_end":73182,"line_start":51,"line_end":51,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73199,"byte_end":73242,"line_start":52,"line_end":52,"column_start":17,"column_end":60}},{"value":"rustc_nonnull_optimization_guaranteed","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73286,"byte_end":73323,"line_start":53,"line_end":53,"column_start":44,"column_end":81}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":10084},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":75602,"byte_end":75614,"line_start":115,"line_end":115,"column_start":61,"column_end":73},"name":"NonZeroIsize","qualname":"::num::NonZeroIsize","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"signed_nonzero\", since = \"1.34.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73055,"byte_end":73068,"line_start":49,"line_end":49,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73162,"byte_end":73182,"line_start":51,"line_end":51,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73199,"byte_end":73242,"line_start":52,"line_end":52,"column_start":17,"column_end":60}},{"value":"rustc_nonnull_optimization_guaranteed","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73286,"byte_end":73323,"line_start":53,"line_end":53,"column_start":44,"column_end":81}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":73342,"byte_end":73363,"line_start":54,"line_end":54,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":10154},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":77316,"byte_end":77324,"line_start":165,"line_end":165,"column_start":12,"column_end":20},"name":"Wrapping","qualname":"::num::Wrapping","value":"","parent":null,"children":[],"decl_id":null,"docs":" Provides intentionally-wrapped arithmetic on `T`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":77168,"byte_end":77213,"line_start":162,"line_end":162,"column_start":1,"column_end":46}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":77284,"byte_end":77304,"line_start":164,"line_end":164,"column_start":1,"column_end":21}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":77305,"byte_end":77404,"line_start":165,"line_end":166,"column_start":1,"column_end":31}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":77305,"byte_end":77404,"line_start":165,"line_end":166,"column_start":1,"column_end":31}}]},{"kind":"Mod","id":{"krate":0,"index":190},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"flt2dec","qualname":"::num::flt2dec","value":"src/libcore/num/flt2dec/mod.rs","parent":null,"children":[{"krate":0,"index":191},{"krate":0,"index":192},{"krate":0,"index":197},{"krate":0,"index":199},{"krate":0,"index":213},{"krate":0,"index":274},{"krate":0,"index":275},{"krate":0,"index":10223},{"krate":0,"index":10247},{"krate":0,"index":10244},{"krate":0,"index":10240},{"krate":0,"index":10237},{"krate":0,"index":10234},{"krate":0,"index":277},{"krate":0,"index":10249},{"krate":0,"index":10253},{"krate":0,"index":281},{"krate":0,"index":285},{"krate":0,"index":287},{"krate":0,"index":10256},{"krate":0,"index":10273},{"krate":0,"index":10271},{"krate":0,"index":10269},{"krate":0,"index":10267},{"krate":0,"index":10265},{"krate":0,"index":289},{"krate":0,"index":290},{"krate":0,"index":294},{"krate":0,"index":298},{"krate":0,"index":299},{"krate":0,"index":303}],"decl_id":null,"docs":"Floating-point number to decimal conversion routines.","sig":null,"attributes":[{"value":"unstable(feature = \"flt2dec\",\n           reason = \"internal routines only exposed for testing\",\n           issue = \"0\")","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":246048,"byte_end":246173,"line_start":119,"line_end":121,"column_start":1,"column_end":26}}]},{"kind":"Mod","id":{"krate":0,"index":197},"span":{"file_name":"src/libcore/num/flt2dec/estimator.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"estimator","qualname":"::num::flt2dec::estimator","value":"src/libcore/num/flt2dec/estimator.rs","parent":null,"children":[{"krate":0,"index":198}],"decl_id":null,"docs":" The exponent estimator.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":198},"span":{"file_name":"src/libcore/num/flt2dec/estimator.rs","byte_start":269104,"byte_end":269127,"line_start":8,"line_end":8,"column_start":8,"column_end":31},"name":"estimate_scaling_factor","qualname":"::num::flt2dec::estimator::estimate_scaling_factor","value":"fn (mant: u64, exp: i16) -> i16","parent":null,"children":[],"decl_id":null,"docs":" Finds `k_0` such that `10^(k_0-1) < mant * 2^exp <= 10^(k_0+1)`.","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":199},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"decoder","qualname":"::num::flt2dec::decoder","value":"src/libcore/num/flt2dec/decoder.rs","parent":null,"children":[{"krate":0,"index":200},{"krate":0,"index":203},{"krate":0,"index":204},{"krate":0,"index":10187},{"krate":0,"index":10202},{"krate":0,"index":10200},{"krate":0,"index":10198},{"krate":0,"index":10195},{"krate":0,"index":10193},{"krate":0,"index":10203},{"krate":0,"index":10222},{"krate":0,"index":10220},{"krate":0,"index":10218},{"krate":0,"index":10215},{"krate":0,"index":10213},{"krate":0,"index":205},{"krate":0,"index":207},{"krate":0,"index":209},{"krate":0,"index":211}],"decl_id":null,"docs":" Decodes a floating-point value into individual parts and error ranges.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":10187},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":269944,"byte_end":269951,"line_start":15,"line_end":15,"column_start":12,"column_end":19},"name":"Decoded","qualname":"::num::flt2dec::decoder::Decoded","value":"Decoded { mant, minus, plus, exp, inclusive }","parent":null,"children":[{"krate":0,"index":10188},{"krate":0,"index":10189},{"krate":0,"index":10190},{"krate":0,"index":10191},{"krate":0,"index":10192}],"decl_id":null,"docs":" Decoded unsigned finite value, such that:","sig":null,"attributes":[{"value":"structural_match","span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":269933,"byte_end":270313,"line_start":15,"line_end":28,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":269933,"byte_end":270313,"line_start":15,"line_end":28,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":10188},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":269991,"byte_end":269995,"line_start":17,"line_end":17,"column_start":9,"column_end":13},"name":"mant","qualname":"::num::flt2dec::decoder::Decoded::mant","value":"u64","parent":{"krate":0,"index":10187},"children":[],"decl_id":null,"docs":" The scaled mantissa.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":10189},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":270041,"byte_end":270046,"line_start":19,"line_end":19,"column_start":9,"column_end":14},"name":"minus","qualname":"::num::flt2dec::decoder::Decoded::minus","value":"u64","parent":{"krate":0,"index":10187},"children":[],"decl_id":null,"docs":" The lower error range.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":10190},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":270092,"byte_end":270096,"line_start":21,"line_end":21,"column_start":9,"column_end":13},"name":"plus","qualname":"::num::flt2dec::decoder::Decoded::plus","value":"u64","parent":{"krate":0,"index":10187},"children":[],"decl_id":null,"docs":" The upper error range.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":10191},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":270150,"byte_end":270153,"line_start":23,"line_end":23,"column_start":9,"column_end":12},"name":"exp","qualname":"::num::flt2dec::decoder::Decoded::exp","value":"i16","parent":{"krate":0,"index":10187},"children":[],"decl_id":null,"docs":" The shared exponent in base 2.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":10192},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":270295,"byte_end":270304,"line_start":27,"line_end":27,"column_start":9,"column_end":18},"name":"inclusive","qualname":"::num::flt2dec::decoder::Decoded::inclusive","value":"bool","parent":{"krate":0,"index":10187},"children":[],"decl_id":null,"docs":" True when the error range is inclusive.","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":10204},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":270437,"byte_end":270440,"line_start":34,"line_end":34,"column_start":5,"column_end":8},"name":"Nan","qualname":"::num::flt2dec::decoder::FullDecoded::Nan","value":"FullDecoded::Nan","parent":{"krate":0,"index":10203},"children":[],"decl_id":null,"docs":" Not-a-number.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":10206},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":270495,"byte_end":270503,"line_start":36,"line_end":36,"column_start":5,"column_end":13},"name":"Infinite","qualname":"::num::flt2dec::decoder::FullDecoded::Infinite","value":"FullDecoded::Infinite","parent":{"krate":0,"index":10203},"children":[],"decl_id":null,"docs":" Infinities, either positive or negative.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":10208},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":270552,"byte_end":270556,"line_start":38,"line_end":38,"column_start":5,"column_end":9},"name":"Zero","qualname":"::num::flt2dec::decoder::FullDecoded::Zero","value":"FullDecoded::Zero","parent":{"krate":0,"index":10203},"children":[],"decl_id":null,"docs":" Zero, either positive or negative.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":10210},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":270614,"byte_end":270620,"line_start":40,"line_end":40,"column_start":5,"column_end":11},"name":"Finite","qualname":"::num::flt2dec::decoder::FullDecoded::Finite","value":"FullDecoded::Finite(Decoded)","parent":{"krate":0,"index":10203},"children":[],"decl_id":null,"docs":" Finite numbers with further decoded fields.\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":10203},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":270397,"byte_end":270408,"line_start":32,"line_end":32,"column_start":10,"column_end":21},"name":"FullDecoded","qualname":"::num::flt2dec::decoder::FullDecoded","value":"FullDecoded::{Nan, Infinite, Zero, Finite}","parent":null,"children":[{"krate":0,"index":10204},{"krate":0,"index":10206},{"krate":0,"index":10208},{"krate":0,"index":10210}],"decl_id":null,"docs":" Decoded unsigned value.\n","sig":null,"attributes":[{"value":"structural_match","span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":270388,"byte_end":270632,"line_start":32,"line_end":41,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":270388,"byte_end":270632,"line_start":32,"line_end":41,"column_start":1,"column_end":2}}]},{"kind":"Trait","id":{"krate":0,"index":205},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":270694,"byte_end":270708,"line_start":44,"line_end":44,"column_start":11,"column_end":25},"name":"DecodableFloat","qualname":"::num::flt2dec::decoder::DecodableFloat","value":"DecodableFloat: RawFloat + Copy","parent":null,"children":[{"krate":0,"index":206}],"decl_id":null,"docs":" A floating point type which can be `decode`d.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":206},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":270782,"byte_end":270800,"line_start":46,"line_end":46,"column_start":8,"column_end":26},"name":"min_pos_norm_value","qualname":"::num::flt2dec::decoder::DecodableFloat::min_pos_norm_value","value":"fn () -> Self","parent":{"krate":0,"index":205},"children":[],"decl_id":null,"docs":" The minimum positive normalized value.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":211},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":271106,"byte_end":271112,"line_start":59,"line_end":59,"column_start":8,"column_end":14},"name":"decode","qualname":"::num::flt2dec::decoder::decode","value":"fn <T> (v: T) -> (bool, FullDecoded)","parent":null,"children":[],"decl_id":null,"docs":" Returns a sign (true when negative) and `FullDecoded` value\n from given floating point number.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":213},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":246341,"byte_end":246349,"line_start":130,"line_end":130,"column_start":9,"column_end":17},"name":"strategy","qualname":"::num::flt2dec::strategy","value":"src/libcore/num/flt2dec/mod.rs","parent":null,"children":[{"krate":0,"index":214},{"krate":0,"index":243}],"decl_id":null,"docs":" Digit-generation algorithms.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":214},"span":{"file_name":"src/libcore/num/flt2dec/strategy/dragon.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"dragon","qualname":"::num::flt2dec::strategy::dragon","value":"src/libcore/num/flt2dec/strategy/dragon.rs","parent":null,"children":[{"krate":0,"index":215},{"krate":0,"index":216},{"krate":0,"index":220},{"krate":0,"index":221},{"krate":0,"index":222},{"krate":0,"index":223},{"krate":0,"index":225},{"krate":0,"index":227},{"krate":0,"index":229},{"krate":0,"index":231},{"krate":0,"index":233},{"krate":0,"index":235},{"krate":0,"index":237},{"krate":0,"index":238},{"krate":0,"index":239},{"krate":0,"index":241},{"krate":0,"index":242}],"decl_id":null,"docs":" Almost direct (but slightly optimized) Rust translation of Figure 3 of \"Printing\n Floating-Point Numbers Quickly and Accurately\"[^1].","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":237},"span":{"file_name":"src/libcore/num/flt2dec/strategy/dragon.rs","byte_start":274174,"byte_end":274183,"line_start":32,"line_end":32,"column_start":8,"column_end":17},"name":"mul_pow10","qualname":"::num::flt2dec::strategy::dragon::mul_pow10","value":"fn (x: &mut Big, n: usize) -> &mut Big","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":241},"span":{"file_name":"src/libcore/num/flt2dec/strategy/dragon.rs","byte_start":275365,"byte_end":275380,"line_start":67,"line_end":67,"column_start":8,"column_end":23},"name":"format_shortest","qualname":"::num::flt2dec::strategy::dragon::format_shortest","value":"fn (d: &Decoded, buf: &mut [u8]) -> (usize, i16)","parent":null,"children":[],"decl_id":null,"docs":" The shortest mode implementation for Dragon.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":242},"span":{"file_name":"src/libcore/num/flt2dec/strategy/dragon.rs","byte_start":282289,"byte_end":282301,"line_start":217,"line_end":217,"column_start":8,"column_end":20},"name":"format_exact","qualname":"::num::flt2dec::strategy::dragon::format_exact","value":"fn (d: &Decoded, buf: &mut [u8], limit: i16) -> (usize, i16)","parent":null,"children":[],"decl_id":null,"docs":" The exact and fixed mode implementation for Dragon.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":243},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"grisu","qualname":"::num::flt2dec::strategy::grisu","value":"src/libcore/num/flt2dec/strategy/grisu.rs","parent":null,"children":[{"krate":0,"index":244},{"krate":0,"index":245},{"krate":0,"index":249},{"krate":0,"index":250},{"krate":0,"index":251},{"krate":0,"index":253},{"krate":0,"index":254},{"krate":0,"index":255},{"krate":0,"index":256},{"krate":0,"index":266},{"krate":0,"index":268},{"krate":0,"index":270},{"krate":0,"index":272}],"decl_id":null,"docs":" Rust adaptation of the Grisu3 algorithm described in \"Printing Floating-Point Numbers Quickly\n and Accurately with Integers\"[^1]. It uses about 1KB of precomputed table, and in turn, it's\n very quick for most inputs.","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":249},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":287070,"byte_end":287075,"line_start":13,"line_end":13,"column_start":26,"column_end":31},"name":"ALPHA","qualname":"::num::flt2dec::strategy::grisu::ALPHA","value":"i16","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":250},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":287113,"byte_end":287118,"line_start":14,"line_end":14,"column_start":26,"column_end":31},"name":"GAMMA","qualname":"::num::flt2dec::strategy::grisu::GAMMA","value":"i16","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":251},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":287452,"byte_end":287464,"line_start":27,"line_end":27,"column_start":12,"column_end":24},"name":"CACHED_POW10","qualname":"::num::flt2dec::strategy::grisu::CACHED_POW10","value":"[(u64, i16, i16); 81]","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":253},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":290693,"byte_end":290713,"line_start":111,"line_end":111,"column_start":26,"column_end":46},"name":"CACHED_POW10_FIRST_E","qualname":"::num::flt2dec::strategy::grisu::CACHED_POW10_FIRST_E","value":"i16","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":254},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":290753,"byte_end":290772,"line_start":112,"line_end":112,"column_start":26,"column_end":45},"name":"CACHED_POW10_LAST_E","qualname":"::num::flt2dec::strategy::grisu::CACHED_POW10_LAST_E","value":"i16","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":255},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":290809,"byte_end":290821,"line_start":115,"line_end":115,"column_start":8,"column_end":20},"name":"cached_power","qualname":"::num::flt2dec::strategy::grisu::cached_power","value":"fn (alpha: i16, gamma: i16) -> (i16, Fp)","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":256},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":291296,"byte_end":291318,"line_start":127,"line_end":127,"column_start":8,"column_end":30},"name":"max_pow10_no_more_than","qualname":"::num::flt2dec::strategy::grisu::max_pow10_no_more_than","value":"fn (x: u32) -> (u8, u32)","parent":null,"children":[],"decl_id":null,"docs":" Given `x > 0`, returns `(k, 10^k)` such that `10^k <= x < 10^(k+1)`.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":266},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":292153,"byte_end":292172,"line_start":153,"line_end":153,"column_start":8,"column_end":27},"name":"format_shortest_opt","qualname":"::num::flt2dec::strategy::grisu::format_shortest_opt","value":"fn (d: &Decoded, buf: &mut [u8]) -> Option<(usize, i16)>","parent":null,"children":[],"decl_id":null,"docs":" The shortest mode implementation for Grisu.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":268},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":306368,"byte_end":306383,"line_start":420,"line_end":420,"column_start":8,"column_end":23},"name":"format_shortest","qualname":"::num::flt2dec::strategy::grisu::format_shortest","value":"fn (d: &Decoded, buf: &mut [u8]) -> (usize, i16)","parent":null,"children":[],"decl_id":null,"docs":" The shortest mode implementation for Grisu with Dragon fallback.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":270},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":306782,"byte_end":306798,"line_start":431,"line_end":431,"column_start":8,"column_end":24},"name":"format_exact_opt","qualname":"::num::flt2dec::strategy::grisu::format_exact_opt","value":"fn (d: &Decoded, buf: &mut [u8], limit: i16) -> Option<(usize, i16)>","parent":null,"children":[],"decl_id":null,"docs":" The exact and fixed mode implementation for Grisu.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":272},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":318014,"byte_end":318026,"line_start":677,"line_end":677,"column_start":8,"column_end":20},"name":"format_exact","qualname":"::num::flt2dec::strategy::grisu::format_exact","value":"fn (d: &Decoded, buf: &mut [u8], limit: i16) -> (usize, i16)","parent":null,"children":[],"decl_id":null,"docs":" The exact and fixed mode implementation for Grisu with Dragon fallback.","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":274},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":246706,"byte_end":246720,"line_start":140,"line_end":140,"column_start":11,"column_end":25},"name":"MAX_SIG_DIGITS","qualname":"::num::flt2dec::MAX_SIG_DIGITS","value":"usize","parent":null,"children":[],"decl_id":null,"docs":" The minimum size of buffer necessary for the shortest mode.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":275},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":246904,"byte_end":246912,"line_start":145,"line_end":145,"column_start":8,"column_end":16},"name":"round_up","qualname":"::num::flt2dec::round_up","value":"fn (d: &mut [u8], n: usize) -> Option<u8>","parent":null,"children":[],"decl_id":null,"docs":" When `d[..n]` contains decimal digits, increase the last digit and propagate carry.\n Returns a next digit when it causes the length change.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":10225},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":247581,"byte_end":247585,"line_start":167,"line_end":167,"column_start":5,"column_end":9},"name":"Zero","qualname":"::num::flt2dec::Part::Zero","value":"Part::Zero(usize)","parent":{"krate":0,"index":10223},"children":[],"decl_id":null,"docs":" Given number of zero digits.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":10228},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":247639,"byte_end":247642,"line_start":169,"line_end":169,"column_start":5,"column_end":8},"name":"Num","qualname":"::num::flt2dec::Part::Num","value":"Part::Num(u16)","parent":{"krate":0,"index":10223},"children":[],"decl_id":null,"docs":" A literal number up to 5 digits.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":10231},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":247693,"byte_end":247697,"line_start":171,"line_end":171,"column_start":5,"column_end":9},"name":"Copy","qualname":"::num::flt2dec::Part::Copy","value":"Part::Copy(&'a [u8])","parent":{"krate":0,"index":10223},"children":[],"decl_id":null,"docs":" A verbatim copy of given bytes.\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":10223},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":247529,"byte_end":247533,"line_start":165,"line_end":165,"column_start":10,"column_end":14},"name":"Part","qualname":"::num::flt2dec::Part","value":"Part::{Zero, Num, Copy}","parent":null,"children":[{"krate":0,"index":10225},{"krate":0,"index":10228},{"krate":0,"index":10231}],"decl_id":null,"docs":" Formatted parts.\n","sig":null,"attributes":[{"value":"structural_match","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":247520,"byte_end":247710,"line_start":165,"line_end":172,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":247520,"byte_end":247710,"line_start":165,"line_end":172,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":279},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":247796,"byte_end":247799,"line_start":176,"line_end":176,"column_start":12,"column_end":15},"name":"len","qualname":"<Part>::len","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the exact byte length of given part.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":280},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":248338,"byte_end":248343,"line_start":188,"line_end":188,"column_start":12,"column_end":17},"name":"write","qualname":"<Part>::write","value":"fn (&self, out: &mut [u8]) -> Option<usize>","parent":null,"children":[],"decl_id":null,"docs":" Writes a part into the supplied buffer.\n Returns the number of written bytes, or `None` if the buffer is not enough.\n (It may still leave partially written bytes in the buffer; do not rely on that.)\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":10249},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":249220,"byte_end":249229,"line_start":216,"line_end":216,"column_start":12,"column_end":21},"name":"Formatted","qualname":"::num::flt2dec::Formatted","value":"Formatted { sign, parts }","parent":null,"children":[{"krate":0,"index":10251},{"krate":0,"index":10252}],"decl_id":null,"docs":" Formatted result containing one or more parts.\n This can be written to the byte buffer or converted to the allocated string.\n","sig":null,"attributes":[{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":249152,"byte_end":249191,"line_start":214,"line_end":214,"column_start":1,"column_end":40}}]},{"kind":"Field","id":{"krate":0,"index":10251},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":249315,"byte_end":249319,"line_start":218,"line_end":218,"column_start":9,"column_end":13},"name":"sign","qualname":"::num::flt2dec::Formatted::sign","value":"&'static [u8]","parent":{"krate":0,"index":10249},"children":[],"decl_id":null,"docs":" A byte slice representing a sign, either `\"\"`, `\"-\"` or `\"+\"`.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":10252},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":249423,"byte_end":249428,"line_start":220,"line_end":220,"column_start":9,"column_end":14},"name":"parts","qualname":"::num::flt2dec::Formatted::parts","value":"&'a [num::flt2dec::Part<'a>]","parent":{"krate":0,"index":10249},"children":[],"decl_id":null,"docs":" Formatted parts to be rendered after a sign and optional zero padding.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":283},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":249553,"byte_end":249556,"line_start":225,"line_end":225,"column_start":12,"column_end":15},"name":"len","qualname":"<Formatted>::len","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the exact byte length of combined formatted result.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":284},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":249952,"byte_end":249957,"line_start":236,"line_end":236,"column_start":12,"column_end":17},"name":"write","qualname":"<Formatted>::write","value":"fn (&self, out: &mut [u8]) -> Option<usize>","parent":null,"children":[],"decl_id":null,"docs":" Writes all formatted parts into the supplied buffer.\n Returns the number of written bytes, or `None` if the buffer is not enough.\n (It may still leave partially written bytes in the buffer; do not rely on that.)\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":10257},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":254978,"byte_end":254983,"line_start":362,"line_end":362,"column_start":5,"column_end":10},"name":"Minus","qualname":"::num::flt2dec::Sign::Minus","value":"Sign::Minus","parent":{"krate":0,"index":10256},"children":[],"decl_id":null,"docs":" Prints `-` only for the negative non-zero values.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":10259},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":255104,"byte_end":255112,"line_start":364,"line_end":364,"column_start":5,"column_end":13},"name":"MinusRaw","qualname":"::num::flt2dec::Sign::MinusRaw","value":"Sign::MinusRaw","parent":{"krate":0,"index":10256},"children":[],"decl_id":null,"docs":" Prints `-` only for any negative values (including the negative zero).\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":10261},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":255222,"byte_end":255231,"line_start":366,"line_end":366,"column_start":5,"column_end":14},"name":"MinusPlus","qualname":"::num::flt2dec::Sign::MinusPlus","value":"Sign::MinusPlus","parent":{"krate":0,"index":10256},"children":[],"decl_id":null,"docs":" Prints `-` for the negative non-zero values, or `+` otherwise.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":10263},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":255361,"byte_end":255373,"line_start":368,"line_end":368,"column_start":5,"column_end":17},"name":"MinusPlusRaw","qualname":"::num::flt2dec::Sign::MinusPlusRaw","value":"Sign::MinusPlusRaw","parent":{"krate":0,"index":10256},"children":[],"decl_id":null,"docs":" Prints `-` for any negative values (including the negative zero), or `+` otherwise.\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":10256},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":254909,"byte_end":254913,"line_start":360,"line_end":360,"column_start":10,"column_end":14},"name":"Sign","qualname":"::num::flt2dec::Sign","value":"Sign::{Minus, MinusRaw, MinusPlus, MinusPlusRaw}","parent":null,"children":[{"krate":0,"index":10257},{"krate":0,"index":10259},{"krate":0,"index":10261},{"krate":0,"index":10263}],"decl_id":null,"docs":" Sign formatting options.\n","sig":null,"attributes":[{"value":"structural_match","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":254900,"byte_end":255405,"line_start":360,"line_end":369,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":254900,"byte_end":255405,"line_start":360,"line_end":369,"column_start":1,"column_end":2}}]},{"kind":"Function","id":{"krate":0,"index":290},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":257273,"byte_end":257288,"line_start":403,"line_end":403,"column_start":8,"column_end":23},"name":"to_shortest_str","qualname":"::num::flt2dec::to_shortest_str","value":"fn <'a, T, F> (mut format_shortest: F, v: T, sign: Sign, frac_digits: usize, _upper: bool, buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>","parent":null,"children":[],"decl_id":null,"docs":" Formats the given floating point number into the decimal form with at least\n given number of fractional digits. The result is stored to the supplied parts\n array while utilizing given byte buffer as a scratch. `upper` is currently\n unused but left for the future decision to change the case of non-finite values,\n i.e., `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n (which can be an empty string if no sign is rendered).","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":294},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":259806,"byte_end":259825,"line_start":458,"line_end":458,"column_start":8,"column_end":27},"name":"to_shortest_exp_str","qualname":"::num::flt2dec::to_shortest_exp_str","value":"fn <'a, T, F> (mut format_shortest: F, v: T, sign: Sign, dec_bounds: (i16, i16), upper: bool, buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>","parent":null,"children":[],"decl_id":null,"docs":" Formats the given floating point number into the decimal form or\n the exponential form, depending on the resulting exponent. The result is\n stored to the supplied parts array while utilizing given byte buffer\n as a scratch. `upper` is used to determine the case of non-finite values\n (`inf` and `nan`) or the case of the exponent prefix (`e` or `E`).\n The first part to be rendered is always a `Part::Sign` (which can be\n an empty string if no sign is rendered).","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":299},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":263584,"byte_end":263600,"line_start":537,"line_end":537,"column_start":8,"column_end":24},"name":"to_exact_exp_str","qualname":"::num::flt2dec::to_exact_exp_str","value":"fn <'a, T, F> (mut format_exact: F, v: T, sign: Sign, ndigits: usize, upper: bool, buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>","parent":null,"children":[],"decl_id":null,"docs":" Formats given floating point number into the exponential form with\n exactly given number of significant digits. The result is stored to\n the supplied parts array while utilizing given byte buffer as a scratch.\n `upper` is used to determine the case of the exponent prefix (`e` or `E`).\n The first part to be rendered is always a `Part::Sign` (which can be\n an empty string if no sign is rendered).","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":303},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":266285,"byte_end":266303,"line_start":593,"line_end":593,"column_start":8,"column_end":26},"name":"to_exact_fixed_str","qualname":"::num::flt2dec::to_exact_fixed_str","value":"fn <'a, T, F> (mut format_exact: F, v: T, sign: Sign, frac_digits: usize, _upper: bool, buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>","parent":null,"children":[],"decl_id":null,"docs":" Formats given floating point number into the decimal form with exactly\n given number of fractional digits. The result is stored to the supplied parts\n array while utilizing given byte buffer as a scratch. `upper` is currently\n unused but left for the future decision to change the case of non-finite values,\n i.e., `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n (which can be an empty string if no sign is rendered).","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":307},"span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"dec2flt","qualname":"::num::dec2flt","value":"src/libcore/num/dec2flt/mod.rs","parent":null,"children":[{"krate":0,"index":308},{"krate":0,"index":309},{"krate":0,"index":310},{"krate":0,"index":315},{"krate":0,"index":316},{"krate":0,"index":317},{"krate":0,"index":355},{"krate":0,"index":365},{"krate":0,"index":379},{"krate":0,"index":481},{"krate":0,"index":495},{"krate":0,"index":10345},{"krate":0,"index":10348},{"krate":0,"index":10351},{"krate":0,"index":10360},{"krate":0,"index":10358},{"krate":0,"index":10355},{"krate":0,"index":10353},{"krate":0,"index":10362},{"krate":0,"index":10373},{"krate":0,"index":10371},{"krate":0,"index":10369},{"krate":0,"index":10367},{"krate":0,"index":496},{"krate":0,"index":498},{"krate":0,"index":500},{"krate":0,"index":501},{"krate":0,"index":502},{"krate":0,"index":503},{"krate":0,"index":505},{"krate":0,"index":507},{"krate":0,"index":509},{"krate":0,"index":510}],"decl_id":null,"docs":" Converting decimal strings into IEEE 754 binary floating point numbers.","sig":null,"attributes":[{"value":"unstable(feature = \"dec2flt\",\n           reason = \"internal routines only exposed for testing\",\n           issue = \"0\")","span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":323304,"byte_end":323429,"line_start":81,"line_end":83,"column_start":1,"column_end":26}}]},{"kind":"Function","id":{"krate":0,"index":338},"span":{"file_name":"src/libcore/num/dec2flt/algorithm.rs","byte_start":334663,"byte_end":334676,"line_start":28,"line_end":28,"column_start":12,"column_end":25},"name":"set_precision","qualname":"::num::dec2flt::algorithm::fpu_precision::set_precision","value":"fn <T> () -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":340},"span":{"file_name":"src/libcore/num/dec2flt/algorithm.rs","byte_start":337584,"byte_end":337593,"line_start":97,"line_end":97,"column_start":8,"column_end":17},"name":"fast_path","qualname":"::num::dec2flt::algorithm::fast_path","value":"fn <T> (integral: &[u8], fractional: &[u8], e: i64) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" The fast path of Bellerophon using machine-sized integers and floats.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":342},"span":{"file_name":"src/libcore/num/dec2flt/algorithm.rs","byte_start":340179,"byte_end":340190,"line_start":145,"line_end":145,"column_start":8,"column_end":19},"name":"bellerophon","qualname":"::num::dec2flt::algorithm::bellerophon","value":"fn <T> (f: &Big, e: i16) -> T","parent":null,"children":[],"decl_id":null,"docs":" Algorithm Bellerophon is trivial code justified by non-trivial numeric analysis.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":347},"span":{"file_name":"src/libcore/num/dec2flt/algorithm.rs","byte_start":345987,"byte_end":345998,"line_start":277,"line_end":277,"column_start":8,"column_end":19},"name":"algorithm_m","qualname":"::num::dec2flt::algorithm::algorithm_m","value":"fn <T> (f: &Big, e: i16) -> T","parent":null,"children":[],"decl_id":null,"docs":" Conceptually, Algorithm M is the simplest way to convert a decimal to a float.","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":356},"span":{"file_name":"src/libcore/num/dec2flt/table.rs","byte_start":351185,"byte_end":351190,"line_start":4,"line_end":4,"column_start":11,"column_end":16},"name":"MIN_E","qualname":"::num::dec2flt::table::MIN_E","value":"i16","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":357},"span":{"file_name":"src/libcore/num/dec2flt/table.rs","byte_start":351214,"byte_end":351219,"line_start":5,"line_end":5,"column_start":11,"column_end":16},"name":"MAX_E","qualname":"::num::dec2flt::table::MAX_E","value":"i16","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":358},"span":{"file_name":"src/libcore/num/dec2flt/table.rs","byte_start":351243,"byte_end":351249,"line_start":7,"line_end":7,"column_start":11,"column_end":17},"name":"POWERS","qualname":"::num::dec2flt::table::POWERS","value":"([u64; 611], [i16; 611])","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":361},"span":{"file_name":"src/libcore/num/dec2flt/table.rs","byte_start":371747,"byte_end":371763,"line_start":1233,"line_end":1233,"column_start":11,"column_end":27},"name":"F32_SHORT_POWERS","qualname":"::num::dec2flt::table::F32_SHORT_POWERS","value":"[f32; 11]","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":363},"span":{"file_name":"src/libcore/num/dec2flt/table.rs","byte_start":371893,"byte_end":371909,"line_start":1247,"line_end":1247,"column_start":11,"column_end":27},"name":"F64_SHORT_POWERS","qualname":"::num::dec2flt::table::F64_SHORT_POWERS","value":"[f64; 23]","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":372},"span":{"file_name":"src/libcore/num/dec2flt/num.rs","byte_start":372585,"byte_end":372606,"line_start":11,"line_end":11,"column_start":8,"column_end":29},"name":"compare_with_half_ulp","qualname":"::num::dec2flt::num::compare_with_half_ulp","value":"fn (f: &Big, ones_place: usize) -> Ordering","parent":null,"children":[],"decl_id":null,"docs":" Test whether truncating all bits less significant than `ones_place` introduces\n a relative error less, equal, or greater than 0.5 ULP.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":373},"span":{"file_name":"src/libcore/num/dec2flt/num.rs","byte_start":373650,"byte_end":373668,"line_start":39,"line_end":39,"column_start":8,"column_end":26},"name":"from_str_unchecked","qualname":"::num::dec2flt::num::from_str_unchecked","value":"fn <'a, T> (bytes: T) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Converts an ASCII string containing only decimal digits to a `u64`.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":376},"span":{"file_name":"src/libcore/num/dec2flt/num.rs","byte_start":374001,"byte_end":374014,"line_start":50,"line_end":50,"column_start":8,"column_end":21},"name":"digits_to_big","qualname":"::num::dec2flt::num::digits_to_big","value":"fn (integral: &[u8], fractional: &[u8]) -> Big","parent":null,"children":[],"decl_id":null,"docs":" Converts a string of ASCII digits into a bignum.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":377},"span":{"file_name":"src/libcore/num/dec2flt/num.rs","byte_start":374331,"byte_end":374337,"line_start":61,"line_end":61,"column_start":8,"column_end":14},"name":"to_u64","qualname":"::num::dec2flt::num::to_u64","value":"fn (x: &Big) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Unwraps a bignum into a 64 bit integer. Panics if the number is too large.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":378},"span":{"file_name":"src/libcore/num/dec2flt/num.rs","byte_start":374708,"byte_end":374716,"line_start":76,"line_end":76,"column_start":8,"column_end":16},"name":"get_bits","qualname":"::num::dec2flt::num::get_bits","value":"fn (x: &Big, start: usize, end: usize) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Extracts a range of bits.\n Index 0 is the least significant bit and the range is half-open as usual.\n Panics if asked to extract more bits than fit into the return type.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":379},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"rawfp","qualname":"::num::dec2flt::rawfp","value":"src/libcore/num/dec2flt/rawfp.rs","parent":null,"children":[{"krate":0,"index":380},{"krate":0,"index":384},{"krate":0,"index":387},{"krate":0,"index":392},{"krate":0,"index":395},{"krate":0,"index":396},{"krate":0,"index":402},{"krate":0,"index":403},{"krate":0,"index":406},{"krate":0,"index":10274},{"krate":0,"index":10279},{"krate":0,"index":10277},{"krate":0,"index":37144},{"krate":0,"index":407},{"krate":0,"index":409},{"krate":0,"index":435},{"krate":0,"index":436},{"krate":0,"index":451},{"krate":0,"index":466},{"krate":0,"index":468},{"krate":0,"index":470},{"krate":0,"index":473},{"krate":0,"index":476},{"krate":0,"index":477},{"krate":0,"index":479}],"decl_id":null,"docs":" Bit fiddling on positive IEEE 754 floats. Negative numbers aren't and needn't be handled.\n Normal floating point numbers have a canonical representation as (frac, exp) such that the\n value is 2<sup>exp</sup> * (1 + sum(frac[N-i] / 2<sup>i</sup>)) where N is the number of bits.\n Subnormals are slightly different and weird, but the same principle applies.","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":10274},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":376458,"byte_end":376466,"line_start":31,"line_end":31,"column_start":12,"column_end":20},"name":"Unpacked","qualname":"::num::dec2flt::rawfp::Unpacked","value":"Unpacked { sig, k }","parent":null,"children":[{"krate":0,"index":10275},{"krate":0,"index":10276}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":376447,"byte_end":376504,"line_start":31,"line_end":34,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":10275},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":376477,"byte_end":376480,"line_start":32,"line_end":32,"column_start":9,"column_end":12},"name":"sig","qualname":"::num::dec2flt::rawfp::Unpacked::sig","value":"u64","parent":{"krate":0,"index":10274},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":10276},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":376495,"byte_end":376496,"line_start":33,"line_end":33,"column_start":9,"column_end":10},"name":"k","qualname":"::num::dec2flt::rawfp::Unpacked::k","value":"i16","parent":{"krate":0,"index":10274},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":408},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":376533,"byte_end":376536,"line_start":37,"line_end":37,"column_start":12,"column_end":15},"name":"new","qualname":"<Unpacked>::new","value":"fn (sig: u64, k: i16) -> Self","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":409},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":376878,"byte_end":376886,"line_start":47,"line_end":47,"column_start":11,"column_end":19},"name":"RawFloat","qualname":"::num::dec2flt::rawfp::RawFloat","value":"RawFloat: Copy + Debug + LowerExp + Mul<Output = Self> + Div<Output = Self> + Neg<Output\n= Self>","parent":null,"children":[{"krate":0,"index":410},{"krate":0,"index":411},{"krate":0,"index":412},{"krate":0,"index":413},{"krate":0,"index":414},{"krate":0,"index":415},{"krate":0,"index":416},{"krate":0,"index":417},{"krate":0,"index":418},{"krate":0,"index":419},{"krate":0,"index":420},{"krate":0,"index":421},{"krate":0,"index":422},{"krate":0,"index":423},{"krate":0,"index":424},{"krate":0,"index":425},{"krate":0,"index":426},{"krate":0,"index":427},{"krate":0,"index":428},{"krate":0,"index":429},{"krate":0,"index":430},{"krate":0,"index":431},{"krate":0,"index":432},{"krate":0,"index":433},{"krate":0,"index":434}],"decl_id":null,"docs":" A helper trait to avoid duplicating basically all the conversion code for `f32` and `f64`.","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":410},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":377006,"byte_end":377014,"line_start":55,"line_end":55,"column_start":11,"column_end":19},"name":"INFINITY","qualname":"::num::dec2flt::rawfp::RawFloat::INFINITY","value":"Self","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":411},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":377032,"byte_end":377035,"line_start":56,"line_end":56,"column_start":11,"column_end":14},"name":"NAN","qualname":"::num::dec2flt::rawfp::RawFloat::NAN","value":"Self","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":412},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":377053,"byte_end":377057,"line_start":57,"line_end":57,"column_start":11,"column_end":15},"name":"ZERO","qualname":"::num::dec2flt::rawfp::RawFloat::ZERO","value":"Self","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":413},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":377123,"byte_end":377127,"line_start":60,"line_end":60,"column_start":10,"column_end":14},"name":"Bits","qualname":"::num::dec2flt::rawfp::RawFloat::Bits","value":"type Bits: Add<Output = Self::Bits> + From<u8> + TryFrom<u64>;","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" Type used by `to_bits` and `from_bits`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":414},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":377241,"byte_end":377248,"line_start":63,"line_end":63,"column_start":8,"column_end":15},"name":"to_bits","qualname":"::num::dec2flt::rawfp::RawFloat::to_bits","value":"fn (self) -> Self::Bits","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" Performs a raw transmutation to an integer.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":415},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":377332,"byte_end":377341,"line_start":66,"line_end":66,"column_start":8,"column_end":17},"name":"from_bits","qualname":"::num::dec2flt::rawfp::RawFloat::from_bits","value":"fn (v: Self::Bits) -> Self","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" Performs a raw transmutation from an integer.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":416},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":377432,"byte_end":377440,"line_start":69,"line_end":69,"column_start":8,"column_end":16},"name":"classify","qualname":"::num::dec2flt::rawfp::RawFloat::classify","value":"fn (self) -> FpCategory","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" Returns the category that this number falls into.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":417},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":377531,"byte_end":377545,"line_start":72,"line_end":72,"column_start":8,"column_end":22},"name":"integer_decode","qualname":"::num::dec2flt::rawfp::RawFloat::integer_decode","value":"fn (self) -> (u64, i16, i8)","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" Returns the mantissa, exponent and sign as integers.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":418},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":377606,"byte_end":377612,"line_start":75,"line_end":75,"column_start":8,"column_end":14},"name":"unpack","qualname":"::num::dec2flt::rawfp::RawFloat::unpack","value":"fn (self) -> Unpacked","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" Decodes the float.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":419},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":377826,"byte_end":377834,"line_start":79,"line_end":79,"column_start":8,"column_end":16},"name":"from_int","qualname":"::num::dec2flt::rawfp::RawFloat::from_int","value":"fn (x: u64) -> Self","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" Casts from a small integer that can be represented exactly. Panic if the integer can't be\n represented, the other code in this module makes sure to never let that happen.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":420},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":377973,"byte_end":377989,"line_start":83,"line_end":83,"column_start":8,"column_end":24},"name":"short_fast_pow10","qualname":"::num::dec2flt::rawfp::RawFloat::short_fast_pow10","value":"fn (e: usize) -> Self","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" Gets the value 10<sup>e</sup> from a pre-computed table.\n Panics for `e >= CEIL_LOG5_OF_MAX_SIG`.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":421},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":378141,"byte_end":378161,"line_start":87,"line_end":87,"column_start":11,"column_end":31},"name":"CEIL_LOG5_OF_MAX_SIG","qualname":"::num::dec2flt::rawfp::RawFloat::CEIL_LOG5_OF_MAX_SIG","value":"i16","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" What the name says. It's easier to hard code than juggling intrinsics and\n hoping LLVM constant folds it.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":422},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":378373,"byte_end":378390,"line_start":91,"line_end":91,"column_start":11,"column_end":28},"name":"MAX_NORMAL_DIGITS","qualname":"::num::dec2flt::rawfp::RawFloat::MAX_NORMAL_DIGITS","value":"usize","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" subnormals. Probably the decimal exponent of the maximum normal value, hence the name.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":423},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":378548,"byte_end":378558,"line_start":95,"line_end":95,"column_start":11,"column_end":21},"name":"INF_CUTOFF","qualname":"::num::dec2flt::rawfp::RawFloat::INF_CUTOFF","value":"i64","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" When the most significant decimal digit has a place value greater than this, the number\n is certainly rounded to infinity.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":424},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":378707,"byte_end":378718,"line_start":99,"line_end":99,"column_start":11,"column_end":22},"name":"ZERO_CUTOFF","qualname":"::num::dec2flt::rawfp::RawFloat::ZERO_CUTOFF","value":"i64","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" When the most significant decimal digit has a place value less than this, the number\n is certainly rounded to zero.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":425},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":378780,"byte_end":378788,"line_start":102,"line_end":102,"column_start":11,"column_end":19},"name":"EXP_BITS","qualname":"::num::dec2flt::rawfp::RawFloat::EXP_BITS","value":"u8","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" The number of bits in the exponent.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":426},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":378880,"byte_end":378888,"line_start":105,"line_end":105,"column_start":11,"column_end":19},"name":"SIG_BITS","qualname":"::num::dec2flt::rawfp::RawFloat::SIG_BITS","value":"u8","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" The number of bits in the significand, *including* the hidden bit.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":427},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":378980,"byte_end":378997,"line_start":108,"line_end":108,"column_start":11,"column_end":28},"name":"EXPLICIT_SIG_BITS","qualname":"::num::dec2flt::rawfp::RawFloat::EXPLICIT_SIG_BITS","value":"u8","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" The number of bits in the significand, *excluding* the hidden bit.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":428},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":379079,"byte_end":379086,"line_start":111,"line_end":111,"column_start":11,"column_end":18},"name":"MAX_EXP","qualname":"::num::dec2flt::rawfp::RawFloat::MAX_EXP","value":"i16","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" The maximum legal exponent in fractional representation.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":429},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":379191,"byte_end":379198,"line_start":114,"line_end":114,"column_start":11,"column_end":18},"name":"MIN_EXP","qualname":"::num::dec2flt::rawfp::RawFloat::MIN_EXP","value":"i16","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" The minimum legal exponent in fractional representation, excluding subnormals.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":430},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":379293,"byte_end":379304,"line_start":117,"line_end":117,"column_start":11,"column_end":22},"name":"MAX_EXP_INT","qualname":"::num::dec2flt::rawfp::RawFloat::MAX_EXP_INT","value":"i16","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" `MAX_EXP` for integral representation, i.e., with the shift applied.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":431},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":379373,"byte_end":379388,"line_start":120,"line_end":120,"column_start":11,"column_end":26},"name":"MAX_ENCODED_EXP","qualname":"::num::dec2flt::rawfp::RawFloat::MAX_ENCODED_EXP","value":"i16","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" `MAX_EXP` encoded (i.e., with offset bias)\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":432},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":379483,"byte_end":379494,"line_start":123,"line_end":123,"column_start":11,"column_end":22},"name":"MIN_EXP_INT","qualname":"::num::dec2flt::rawfp::RawFloat::MIN_EXP_INT","value":"i16","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" `MIN_EXP` for integral representation, i.e., with the shift applied.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":433},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":379583,"byte_end":379590,"line_start":126,"line_end":126,"column_start":11,"column_end":18},"name":"MAX_SIG","qualname":"::num::dec2flt::rawfp::RawFloat::MAX_SIG","value":"u64","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" The maximum normalized significand in integral representation.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":434},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":379679,"byte_end":379686,"line_start":129,"line_end":129,"column_start":11,"column_end":18},"name":"MIN_SIG","qualname":"::num::dec2flt::rawfp::RawFloat::MIN_SIG","value":"u64","parent":{"krate":0,"index":409},"children":[],"decl_id":null,"docs":" The minimal normalized significand in integral representation.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":466},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":383369,"byte_end":383380,"line_start":245,"line_end":245,"column_start":8,"column_end":19},"name":"fp_to_float","qualname":"::num::dec2flt::rawfp::fp_to_float","value":"fn <T> (x: Fp) -> T","parent":null,"children":[],"decl_id":null,"docs":" Converts an `Fp` to the closest machine float type.\n Does not handle subnormal results.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":468},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":383865,"byte_end":383877,"line_start":260,"line_end":260,"column_start":8,"column_end":20},"name":"round_normal","qualname":"::num::dec2flt::rawfp::round_normal","value":"fn <T> (x: Fp) -> Unpacked","parent":null,"children":[],"decl_id":null,"docs":" Round the 64-bit significand to T::SIG_BITS bits with half-to-even.\n Does not handle exponent overflow.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":470},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":384545,"byte_end":384558,"line_start":280,"line_end":280,"column_start":8,"column_end":21},"name":"encode_normal","qualname":"::num::dec2flt::rawfp::encode_normal","value":"fn <T> (x: Unpacked) -> T","parent":null,"children":[],"decl_id":null,"docs":" Inverse of `RawFloat::unpack()` for normalized numbers.\n Panics if the significand or exponent are not valid for normalized numbers.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":473},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":385312,"byte_end":385328,"line_start":295,"line_end":295,"column_start":8,"column_end":24},"name":"encode_subnormal","qualname":"::num::dec2flt::rawfp::encode_subnormal","value":"fn <T> (significand: u64) -> T","parent":null,"children":[],"decl_id":null,"docs":" Construct a subnormal. A mantissa of 0 is allowed and constructs zero.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":476},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":385704,"byte_end":385713,"line_start":302,"line_end":302,"column_start":8,"column_end":17},"name":"big_to_fp","qualname":"::num::dec2flt::rawfp::big_to_fp","value":"fn (f: &Big) -> Fp","parent":null,"children":[],"decl_id":null,"docs":" Approximate a bignum with an Fp. Rounds within 0.5 ULP with half-to-even.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":477},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":386668,"byte_end":386678,"line_start":324,"line_end":324,"column_start":8,"column_end":18},"name":"prev_float","qualname":"::num::dec2flt::rawfp::prev_float","value":"fn <T> (x: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Finds the largest floating point number strictly smaller than the argument.\n Does not handle subnormals, zero, or exponent underflow.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":479},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":387580,"byte_end":387590,"line_start":345,"line_end":345,"column_start":8,"column_end":18},"name":"next_float","qualname":"::num::dec2flt::rawfp::next_float","value":"fn <T> (x: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":481},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"parse","qualname":"::num::dec2flt::parse","value":"src/libcore/num/dec2flt/parse.rs","parent":null,"children":[{"krate":0,"index":482},{"krate":0,"index":483},{"krate":0,"index":10302},{"krate":0,"index":10307},{"krate":0,"index":10309},{"krate":0,"index":10321},{"krate":0,"index":10317},{"krate":0,"index":10314},{"krate":0,"index":488},{"krate":0,"index":10324},{"krate":0,"index":10342},{"krate":0,"index":10338},{"krate":0,"index":10335},{"krate":0,"index":491},{"krate":0,"index":492},{"krate":0,"index":493}],"decl_id":null,"docs":" Validating and decomposing a decimal string of the form:","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":10303},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":389343,"byte_end":389351,"line_start":18,"line_end":18,"column_start":5,"column_end":13},"name":"Positive","qualname":"::num::dec2flt::parse::Sign::Positive","value":"Sign::Positive","parent":{"krate":0,"index":10302},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":10305},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":389357,"byte_end":389365,"line_start":19,"line_end":19,"column_start":5,"column_end":13},"name":"Negative","qualname":"::num::dec2flt::parse::Sign::Negative","value":"Sign::Negative","parent":{"krate":0,"index":10302},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":10302},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":389332,"byte_end":389336,"line_start":17,"line_end":17,"column_start":10,"column_end":14},"name":"Sign","qualname":"::num::dec2flt::parse::Sign","value":"Sign::{Positive, Negative}","parent":null,"children":[{"krate":0,"index":10303},{"krate":0,"index":10305}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":10309},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":389460,"byte_end":389467,"line_start":24,"line_end":24,"column_start":12,"column_end":19},"name":"Decimal","qualname":"::num::dec2flt::parse::Decimal","value":"Decimal { integral, fractional, exp }","parent":null,"children":[{"krate":0,"index":10311},{"krate":0,"index":10312},{"krate":0,"index":10313}],"decl_id":null,"docs":" The interesting parts of a decimal string.\n","sig":null,"attributes":[{"value":"structural_match","span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":389449,"byte_end":389630,"line_start":24,"line_end":29,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":10311},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":389482,"byte_end":389490,"line_start":25,"line_end":25,"column_start":9,"column_end":17},"name":"integral","qualname":"::num::dec2flt::parse::Decimal::integral","value":"&'a [u8]","parent":{"krate":0,"index":10309},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":10312},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":389510,"byte_end":389520,"line_start":26,"line_end":26,"column_start":9,"column_end":19},"name":"fractional","qualname":"::num::dec2flt::parse::Decimal::fractional","value":"&'a [u8]","parent":{"krate":0,"index":10309},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":10313},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":389619,"byte_end":389622,"line_start":28,"line_end":28,"column_start":9,"column_end":12},"name":"exp","qualname":"::num::dec2flt::parse::Decimal::exp","value":"i64","parent":{"krate":0,"index":10309},"children":[],"decl_id":null,"docs":" The decimal exponent, guaranteed to have fewer than 18 decimal digits.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":490},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":389666,"byte_end":389669,"line_start":32,"line_end":32,"column_start":12,"column_end":15},"name":"new","qualname":"<Decimal>::new","value":"fn (integral: &'a [u8], fractional: &'a [u8], exp: i64) -> Decimal<'a>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":10326},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":389857,"byte_end":389862,"line_start":39,"line_end":39,"column_start":5,"column_end":10},"name":"Valid","qualname":"::num::dec2flt::parse::ParseResult::Valid","value":"ParseResult::Valid(Decimal<'a>)","parent":{"krate":0,"index":10324},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":10329},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":389881,"byte_end":389894,"line_start":40,"line_end":40,"column_start":5,"column_end":18},"name":"ShortcutToInf","qualname":"::num::dec2flt::parse::ParseResult::ShortcutToInf","value":"ParseResult::ShortcutToInf","parent":{"krate":0,"index":10324},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":10331},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":389900,"byte_end":389914,"line_start":41,"line_end":41,"column_start":5,"column_end":19},"name":"ShortcutToZero","qualname":"::num::dec2flt::parse::ParseResult::ShortcutToZero","value":"ParseResult::ShortcutToZero","parent":{"krate":0,"index":10324},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":10333},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":389920,"byte_end":389927,"line_start":42,"line_end":42,"column_start":5,"column_end":12},"name":"Invalid","qualname":"::num::dec2flt::parse::ParseResult::Invalid","value":"ParseResult::Invalid","parent":{"krate":0,"index":10324},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":10324},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":389835,"byte_end":389846,"line_start":38,"line_end":38,"column_start":10,"column_end":21},"name":"ParseResult","qualname":"::num::dec2flt::parse::ParseResult","value":"ParseResult::{Valid, ShortcutToInf, ShortcutToZero, Invalid}","parent":null,"children":[{"krate":0,"index":10326},{"krate":0,"index":10329},{"krate":0,"index":10331},{"krate":0,"index":10333}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"structural_match","span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":389826,"byte_end":389930,"line_start":38,"line_end":43,"column_start":1,"column_end":2}}]},{"kind":"Function","id":{"krate":0,"index":491},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":390112,"byte_end":390125,"line_start":47,"line_end":47,"column_start":8,"column_end":21},"name":"parse_decimal","qualname":"::num::dec2flt::parse::parse_decimal","value":"fn (s: &str) -> ParseResult<'_>","parent":null,"children":[],"decl_id":null,"docs":" Checks if the input string is a valid floating point number and if so, locate the integral\n part, the fractional part, and the exponent in it. Does not handle signs.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":10351},"span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":326303,"byte_end":326318,"line_start":173,"line_end":173,"column_start":12,"column_end":27},"name":"ParseFloatError","qualname":"::num::dec2flt::ParseFloatError","value":"ParseFloatError {  }","parent":null,"children":[{"krate":0,"index":10352}],"decl_id":null,"docs":" An error which can be returned when parsing a float.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":326246,"byte_end":326291,"line_start":172,"line_end":172,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":326292,"byte_end":326347,"line_start":173,"line_end":175,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":497},"span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":326698,"byte_end":326711,"line_start":189,"line_end":189,"column_start":12,"column_end":25},"name":"__description","qualname":"<ParseFloatError>::__description","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"int_error_internals\",\n           reason =\n               \"available through Error trait and this method should \\\n                         not be exposed publicly\",\n           issue = \"0\")","span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":326464,"byte_end":326667,"line_start":184,"line_end":187,"column_start":5,"column_end":29}}]},{"kind":"Mod","id":{"krate":0,"index":512},"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"bignum","qualname":"::num::bignum","value":"src/libcore/num/bignum.rs","parent":null,"children":[{"krate":0,"index":513},{"krate":0,"index":514},{"krate":0,"index":515},{"krate":0,"index":520},{"krate":0,"index":10375},{"krate":0,"index":10380},{"krate":0,"index":10385},{"krate":0,"index":521},{"krate":0,"index":523},{"krate":0,"index":524},{"krate":0,"index":10390},{"krate":0,"index":10394},{"krate":0,"index":10435},{"krate":0,"index":10437},{"krate":0,"index":10438},{"krate":0,"index":10440},{"krate":0,"index":10443},{"krate":0,"index":10445},{"krate":0,"index":525}],"decl_id":null,"docs":" Custom arbitrary-precision number (bignum) implementation.","sig":null,"attributes":[{"value":"unstable(feature = \"core_private_bignum\",\n           reason = \"internal routines only exposed for testing\",\n           issue = \"0\")","span":{"file_name":"src/libcore/num/bignum.rs","byte_start":393594,"byte_end":393731,"line_start":15,"line_end":17,"column_start":1,"column_end":26}},{"value":"macro_use","span":{"file_name":"src/libcore/num/bignum.rs","byte_start":393732,"byte_end":393745,"line_start":18,"line_end":18,"column_start":1,"column_end":14}}]},{"kind":"Trait","id":{"krate":0,"index":515},"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":393844,"byte_end":393851,"line_start":24,"line_end":24,"column_start":11,"column_end":18},"name":"FullOps","qualname":"::num::bignum::FullOps","value":"FullOps: Sized","parent":null,"children":[{"krate":0,"index":516},{"krate":0,"index":517},{"krate":0,"index":518},{"krate":0,"index":519}],"decl_id":null,"docs":" Arithmetic operations required by bignums.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":516},"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":394004,"byte_end":394012,"line_start":27,"line_end":27,"column_start":8,"column_end":16},"name":"full_add","qualname":"::num::bignum::FullOps::full_add","value":"fn (self, other: Self, carry: bool) -> (bool, Self)","parent":{"krate":0,"index":515},"children":[],"decl_id":null,"docs":" Returns `(carry', v')` such that `carry' * 2^W + v' = self + other + carry`,\n where `W` is the number of bits in `Self`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":517},"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":394218,"byte_end":394226,"line_start":31,"line_end":31,"column_start":8,"column_end":16},"name":"full_mul","qualname":"::num::bignum::FullOps::full_mul","value":"fn (self, other: Self, carry: Self) -> (Self, Self)","parent":{"krate":0,"index":515},"children":[],"decl_id":null,"docs":" Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + carry`,\n where `W` is the number of bits in `Self`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":518},"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":394441,"byte_end":394453,"line_start":35,"line_end":35,"column_start":8,"column_end":20},"name":"full_mul_add","qualname":"::num::bignum::FullOps::full_mul_add","value":"fn (self, other: Self, other2: Self, carry: Self) -> (Self, Self)","parent":{"krate":0,"index":515},"children":[],"decl_id":null,"docs":" Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + other2 + carry`,\n where `W` is the number of bits in `Self`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":519},"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":394693,"byte_end":394705,"line_start":39,"line_end":39,"column_start":8,"column_end":20},"name":"full_div_rem","qualname":"::num::bignum::FullOps::full_div_rem","value":"fn (self, other: Self, borrow: Self) -> (Self, Self)","parent":{"krate":0,"index":515},"children":[],"decl_id":null,"docs":" Returns `(quo, rem)` such that `borrow * 2^W + self = quo * other + rem`\n and `0 <= rem < other`, where `W` is the number of bits in `Self`.\n","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":524},"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":412258,"byte_end":412265,"line_start":479,"line_end":479,"column_start":10,"column_end":17},"name":"Digit32","qualname":"::num::bignum::Digit32","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" The digit type for `Big32x40`.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":10390},"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":412289,"byte_end":412297,"line_start":481,"line_end":481,"column_start":16,"column_end":24},"name":"Big32x40","qualname":"::num::bignum::Big32x40","value":"Big32x40 {  }","parent":null,"children":[{"krate":0,"index":10391},{"krate":0,"index":10392}],"decl_id":null,"docs":" Stack-allocated arbitrary-precision (up to certain limit) integer.","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":525},"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":412382,"byte_end":412387,"line_start":485,"line_end":485,"column_start":9,"column_end":14},"name":"tests","qualname":"::num::bignum::tests","value":"src/libcore/num/bignum.rs","parent":null,"children":[{"krate":0,"index":10451},{"krate":0,"index":10455},{"krate":0,"index":10496},{"krate":0,"index":10498},{"krate":0,"index":10499},{"krate":0,"index":10501},{"krate":0,"index":10504},{"krate":0,"index":10506}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":10451},"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":412409,"byte_end":412415,"line_start":486,"line_end":486,"column_start":20,"column_end":26},"name":"Big8x3","qualname":"::num::bignum::tests::Big8x3","value":"Big8x3 {  }","parent":null,"children":[{"krate":0,"index":10452},{"krate":0,"index":10453}],"decl_id":null,"docs":" Stack-allocated arbitrary-precision (up to certain limit) integer.","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":526},"span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"diy_float","qualname":"::num::diy_float","value":"src/libcore/num/diy_float.rs","parent":null,"children":[{"krate":0,"index":10512},{"krate":0,"index":10519},{"krate":0,"index":10517},{"krate":0,"index":10515},{"krate":0,"index":527}],"decl_id":null,"docs":" Extended precision \"soft float\", for internal use only.\n","sig":null,"attributes":[{"value":"unstable(feature = \"core_private_diy_float\",\n           reason = \"internal routines only exposed for testing\",\n           issue = \"0\")","span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":412643,"byte_end":412783,"line_start":6,"line_end":8,"column_start":1,"column_end":26}}]},{"kind":"Struct","id":{"krate":0,"index":10512},"span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":412906,"byte_end":412908,"line_start":13,"line_end":13,"column_start":12,"column_end":14},"name":"Fp","qualname":"::num::diy_float::Fp","value":"Fp { f, e }","parent":null,"children":[{"krate":0,"index":10513},{"krate":0,"index":10514}],"decl_id":null,"docs":" A custom 64-bit floating point type, representing `f * 2^e`.\n","sig":null,"attributes":[{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":412895,"byte_end":413006,"line_start":13,"line_end":18,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":10513},"span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":412949,"byte_end":412950,"line_start":15,"line_end":15,"column_start":9,"column_end":10},"name":"f","qualname":"::num::diy_float::Fp::f","value":"u64","parent":{"krate":0,"index":10512},"children":[],"decl_id":null,"docs":" The integer mantissa.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":10514},"span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":412997,"byte_end":412998,"line_start":17,"line_end":17,"column_start":9,"column_end":10},"name":"e","qualname":"::num::diy_float::Fp::e","value":"i16","parent":{"krate":0,"index":10512},"children":[],"decl_id":null,"docs":" The exponent in base 2.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":528},"span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":413096,"byte_end":413099,"line_start":22,"line_end":22,"column_start":12,"column_end":15},"name":"mul","qualname":"<Fp>::mul","value":"fn (&self, other: &Fp) -> Fp","parent":null,"children":[],"decl_id":null,"docs":" Returns a correctly rounded product of itself and `other`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":530},"span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":413681,"byte_end":413690,"line_start":39,"line_end":39,"column_start":12,"column_end":21},"name":"normalize","qualname":"<Fp>::normalize","value":"fn (&self) -> Fp","parent":null,"children":[],"decl_id":null,"docs":" Normalizes itself so that the resulting mantissa is at least `2^63`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":531},"span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":414474,"byte_end":414486,"line_start":72,"line_end":72,"column_start":12,"column_end":24},"name":"normalize_to","qualname":"<Fp>::normalize_to","value":"fn (&self, e: i16) -> Fp","parent":null,"children":[],"decl_id":null,"docs":" Normalizes itself to have the shared exponent.\n It can only decrease the exponent (and thus increase the mantissa).\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":544},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":442260,"byte_end":442265,"line_start":905,"line_end":905,"column_start":19,"column_end":24},"name":"usize","qualname":"::num::wrapping::shift_max::platform::usize","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":545},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":442303,"byte_end":442308,"line_start":906,"line_end":906,"column_start":19,"column_end":24},"name":"isize","qualname":"::num::wrapping::shift_max::platform::isize","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":546},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":442349,"byte_end":442351,"line_start":909,"line_end":909,"column_start":15,"column_end":17},"name":"i8","qualname":"::num::wrapping::shift_max::i8","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":547},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":442387,"byte_end":442390,"line_start":910,"line_end":910,"column_start":15,"column_end":18},"name":"i16","qualname":"::num::wrapping::shift_max::i16","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":548},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":442426,"byte_end":442429,"line_start":911,"line_end":911,"column_start":15,"column_end":18},"name":"i32","qualname":"::num::wrapping::shift_max::i32","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":549},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":442465,"byte_end":442468,"line_start":912,"line_end":912,"column_start":15,"column_end":18},"name":"i64","qualname":"::num::wrapping::shift_max::i64","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":550},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":442504,"byte_end":442508,"line_start":913,"line_end":913,"column_start":15,"column_end":19},"name":"i128","qualname":"::num::wrapping::shift_max::i128","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":552},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":442580,"byte_end":442582,"line_start":916,"line_end":916,"column_start":15,"column_end":17},"name":"u8","qualname":"::num::wrapping::shift_max::u8","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":553},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":442608,"byte_end":442611,"line_start":917,"line_end":917,"column_start":15,"column_end":18},"name":"u16","qualname":"::num::wrapping::shift_max::u16","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":554},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":442638,"byte_end":442641,"line_start":918,"line_end":918,"column_start":15,"column_end":18},"name":"u32","qualname":"::num::wrapping::shift_max::u32","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":555},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":442668,"byte_end":442671,"line_start":919,"line_end":919,"column_start":15,"column_end":18},"name":"u64","qualname":"::num::wrapping::shift_max::u64","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":556},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":442698,"byte_end":442702,"line_start":920,"line_end":920,"column_start":15,"column_end":19},"name":"u128","qualname":"::num::wrapping::shift_max::u128","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":569},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":199284,"byte_end":199292,"line_start":4049,"line_end":4049,"column_start":12,"column_end":20},"name":"is_ascii","qualname":"<u8>::is_ascii","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is within the ASCII range.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":199190,"byte_end":199258,"line_start":4047,"line_end":4047,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":199263,"byte_end":199272,"line_start":4048,"line_end":4048,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":570},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":199929,"byte_end":199947,"line_start":4071,"line_end":4071,"column_start":12,"column_end":30},"name":"to_ascii_uppercase","qualname":"<u8>::to_ascii_uppercase","value":"fn (&self) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Makes a copy of the value in its ASCII upper case equivalent.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":199835,"byte_end":199903,"line_start":4069,"line_end":4069,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":199908,"byte_end":199917,"line_start":4070,"line_end":4070,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":571},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":200675,"byte_end":200693,"line_start":4094,"line_end":4094,"column_start":12,"column_end":30},"name":"to_ascii_lowercase","qualname":"<u8>::to_ascii_lowercase","value":"fn (&self) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Makes a copy of the value in its ASCII lower case equivalent.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":200581,"byte_end":200649,"line_start":4092,"line_end":4092,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":200654,"byte_end":200663,"line_start":4093,"line_end":4093,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":572},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":201282,"byte_end":201302,"line_start":4113,"line_end":4113,"column_start":12,"column_end":32},"name":"eq_ignore_ascii_case","qualname":"<u8>::eq_ignore_ascii_case","value":"fn (&self, other: &u8) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks that two values are an ASCII case-insensitive match.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":201188,"byte_end":201256,"line_start":4111,"line_end":4111,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":201261,"byte_end":201270,"line_start":4112,"line_end":4112,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":573},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":202047,"byte_end":202067,"line_start":4138,"line_end":4138,"column_start":12,"column_end":32},"name":"make_ascii_uppercase","qualname":"<u8>::make_ascii_uppercase","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Converts this value to its ASCII upper case equivalent in-place.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":201953,"byte_end":202021,"line_start":4136,"line_end":4136,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":202026,"byte_end":202035,"line_start":4137,"line_end":4137,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":574},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":202775,"byte_end":202795,"line_start":4163,"line_end":4163,"column_start":12,"column_end":32},"name":"make_ascii_lowercase","qualname":"<u8>::make_ascii_lowercase","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Converts this value to its ASCII lower case equivalent in-place.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":202681,"byte_end":202749,"line_start":4161,"line_end":4161,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":202754,"byte_end":202763,"line_start":4162,"line_end":4162,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":575},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":203826,"byte_end":203845,"line_start":4197,"line_end":4197,"column_start":12,"column_end":31},"name":"is_ascii_alphabetic","qualname":"<u8>::is_ascii_alphabetic","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII alphabetic character:","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":203734,"byte_end":203800,"line_start":4195,"line_end":4195,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":203805,"byte_end":203814,"line_start":4196,"line_end":4196,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":576},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":204881,"byte_end":204899,"line_start":4232,"line_end":4232,"column_start":12,"column_end":30},"name":"is_ascii_uppercase","qualname":"<u8>::is_ascii_uppercase","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII uppercase character:\n U+0041 'A' ..= U+005A 'Z'.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":204789,"byte_end":204855,"line_start":4230,"line_end":4230,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":204860,"byte_end":204869,"line_start":4231,"line_end":4231,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":577},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":205921,"byte_end":205939,"line_start":4267,"line_end":4267,"column_start":12,"column_end":30},"name":"is_ascii_lowercase","qualname":"<u8>::is_ascii_lowercase","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII lowercase character:\n U+0061 'a' ..= U+007A 'z'.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":205829,"byte_end":205895,"line_start":4265,"line_end":4265,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":205900,"byte_end":205909,"line_start":4266,"line_end":4266,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":578},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":207078,"byte_end":207099,"line_start":4305,"line_end":4305,"column_start":12,"column_end":33},"name":"is_ascii_alphanumeric","qualname":"<u8>::is_ascii_alphanumeric","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII alphanumeric character:","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":206986,"byte_end":207052,"line_start":4303,"line_end":4303,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":207057,"byte_end":207066,"line_start":4304,"line_end":4304,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":579},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":208108,"byte_end":208122,"line_start":4340,"line_end":4340,"column_start":12,"column_end":26},"name":"is_ascii_digit","qualname":"<u8>::is_ascii_digit","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII decimal digit:\n U+0030 '0' ..= U+0039 '9'.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":208016,"byte_end":208082,"line_start":4338,"line_end":4338,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":208087,"byte_end":208096,"line_start":4339,"line_end":4339,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":580},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":209222,"byte_end":209239,"line_start":4378,"line_end":4378,"column_start":12,"column_end":29},"name":"is_ascii_hexdigit","qualname":"<u8>::is_ascii_hexdigit","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII hexadecimal digit:","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":209130,"byte_end":209196,"line_start":4376,"line_end":4376,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":209201,"byte_end":209210,"line_start":4377,"line_end":4377,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":581},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":210482,"byte_end":210502,"line_start":4417,"line_end":4417,"column_start":12,"column_end":32},"name":"is_ascii_punctuation","qualname":"<u8>::is_ascii_punctuation","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII punctuation character:","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":210390,"byte_end":210456,"line_start":4415,"line_end":4415,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":210461,"byte_end":210470,"line_start":4416,"line_end":4416,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":582},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":211542,"byte_end":211558,"line_start":4452,"line_end":4452,"column_start":12,"column_end":28},"name":"is_ascii_graphic","qualname":"<u8>::is_ascii_graphic","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII graphic character:\n U+0021 '!' ..= U+007E '~'.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":211450,"byte_end":211516,"line_start":4450,"line_end":4450,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":211521,"byte_end":211530,"line_start":4451,"line_end":4451,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":583},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":213608,"byte_end":213627,"line_start":4504,"line_end":4504,"column_start":12,"column_end":31},"name":"is_ascii_whitespace","qualname":"<u8>::is_ascii_whitespace","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII whitespace character:\n U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n U+000C FORM FEED, or U+000D CARRIAGE RETURN.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":213516,"byte_end":213582,"line_start":4502,"line_end":4502,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":213587,"byte_end":213596,"line_start":4503,"line_end":4503,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":584},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":214786,"byte_end":214802,"line_start":4541,"line_end":4541,"column_start":12,"column_end":28},"name":"is_ascii_control","qualname":"<u8>::is_ascii_control","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII control character:\n U+0000 NUL ..= U+001F UNIT SEPARATOR, or U+007F DELETE.\n Note that most ASCII whitespace characters are control\n characters, but SPACE is not.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":214694,"byte_end":214760,"line_start":4539,"line_end":4539,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":214765,"byte_end":214774,"line_start":4540,"line_end":4540,"column_start":5,"column_end":14}}]},{"kind":"TupleVariant","id":{"krate":0,"index":13575},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":218311,"byte_end":218314,"line_start":4638,"line_end":4638,"column_start":5,"column_end":8},"name":"Nan","qualname":"::num::FpCategory::Nan","value":"FpCategory::Nan","parent":{"krate":0,"index":13574},"children":[],"decl_id":null,"docs":" \"Not a Number\", often obtained by dividing by zero.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":218261,"byte_end":218306,"line_start":4637,"line_end":4637,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":13577},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":218410,"byte_end":218418,"line_start":4642,"line_end":4642,"column_start":5,"column_end":13},"name":"Infinite","qualname":"::num::FpCategory::Infinite","value":"FpCategory::Infinite","parent":{"krate":0,"index":13574},"children":[],"decl_id":null,"docs":" Positive or negative infinity.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":218360,"byte_end":218405,"line_start":4641,"line_end":4641,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":13579},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":218510,"byte_end":218514,"line_start":4646,"line_end":4646,"column_start":5,"column_end":9},"name":"Zero","qualname":"::num::FpCategory::Zero","value":"FpCategory::Zero","parent":{"krate":0,"index":13574},"children":[],"decl_id":null,"docs":" Positive or negative zero.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":218460,"byte_end":218505,"line_start":4645,"line_end":4645,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":13581},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":218653,"byte_end":218662,"line_start":4650,"line_end":4650,"column_start":5,"column_end":14},"name":"Subnormal","qualname":"::num::FpCategory::Subnormal","value":"FpCategory::Subnormal","parent":{"krate":0,"index":13574},"children":[],"decl_id":null,"docs":" De-normalized floating point representation (less precise than `Normal`).\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":218603,"byte_end":218648,"line_start":4649,"line_end":4649,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":13583},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":218760,"byte_end":218766,"line_start":4654,"line_end":4654,"column_start":5,"column_end":11},"name":"Normal","qualname":"::num::FpCategory::Normal","value":"FpCategory::Normal","parent":{"krate":0,"index":13574},"children":[],"decl_id":null,"docs":" A regular floating point number.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":218710,"byte_end":218755,"line_start":4653,"line_end":4653,"column_start":5,"column_end":50}}]},{"kind":"Enum","id":{"krate":0,"index":13574},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":218184,"byte_end":218194,"line_start":4635,"line_end":4635,"column_start":10,"column_end":20},"name":"FpCategory","qualname":"::num::FpCategory","value":"FpCategory::{Nan, Infinite, Zero, Subnormal, Normal}","parent":null,"children":[{"krate":0,"index":13575},{"krate":0,"index":13577},{"krate":0,"index":13579},{"krate":0,"index":13581},{"krate":0,"index":13583}],"decl_id":null,"docs":" A classification of floating point numbers.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":218129,"byte_end":218174,"line_start":4634,"line_end":4634,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":218175,"byte_end":218769,"line_start":4635,"line_end":4655,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":218175,"byte_end":218769,"line_start":4635,"line_end":4655,"column_start":1,"column_end":2}}]},{"kind":"Struct","id":{"krate":0,"index":13630},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":219360,"byte_end":219375,"line_start":4673,"line_end":4673,"column_start":12,"column_end":27},"name":"TryFromIntError","qualname":"::num::TryFromIntError","value":"","parent":null,"children":[],"decl_id":null,"docs":" The error type returned when a checked integral type conversion fails.\n","sig":null,"attributes":[{"value":"stable(feature = \"try_from\", since = \"1.34.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":219254,"byte_end":219303,"line_start":4671,"line_end":4671,"column_start":1,"column_end":50}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":219349,"byte_end":219380,"line_start":4673,"line_end":4673,"column_start":1,"column_end":32}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":219349,"byte_end":219380,"line_start":4673,"line_end":4673,"column_start":1,"column_end":32}}]},{"kind":"Method","id":{"krate":0,"index":592},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":219643,"byte_end":219656,"line_start":4681,"line_end":4681,"column_start":12,"column_end":25},"name":"__description","qualname":"<TryFromIntError>::__description","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"int_error_internals\",\n           reason =\n               \"available through Error trait and this method should \\\n                         not be exposed publicly\",\n           issue = \"0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":219409,"byte_end":219612,"line_start":4676,"line_end":4679,"column_start":5,"column_end":29}}]},{"kind":"Method","id":{"krate":0,"index":608},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":227335,"byte_end":227344,"line_start":4912,"line_end":4912,"column_start":8,"column_end":17},"name":"min_value","qualname":"::num::FromStrRadixHelper::min_value","value":"fn () -> Self","parent":{"krate":0,"index":607},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":609},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":227363,"byte_end":227372,"line_start":4913,"line_end":4913,"column_start":8,"column_end":17},"name":"max_value","qualname":"::num::FromStrRadixHelper::max_value","value":"fn () -> Self","parent":{"krate":0,"index":607},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":610},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":227391,"byte_end":227399,"line_start":4914,"line_end":4914,"column_start":8,"column_end":16},"name":"from_u32","qualname":"::num::FromStrRadixHelper::from_u32","value":"fn (u: u32) -> Self","parent":{"krate":0,"index":607},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":611},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":227424,"byte_end":227435,"line_start":4915,"line_end":4915,"column_start":8,"column_end":19},"name":"checked_mul","qualname":"::num::FromStrRadixHelper::checked_mul","value":"fn (&self, other: u32) -> Option<Self>","parent":{"krate":0,"index":607},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":612},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":227479,"byte_end":227490,"line_start":4916,"line_end":4916,"column_start":8,"column_end":19},"name":"checked_sub","qualname":"::num::FromStrRadixHelper::checked_sub","value":"fn (&self, other: u32) -> Option<Self>","parent":{"krate":0,"index":607},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":613},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":227534,"byte_end":227545,"line_start":4917,"line_end":4917,"column_start":8,"column_end":19},"name":"checked_add","qualname":"::num::FromStrRadixHelper::checked_add","value":"fn (&self, other: u32) -> Option<Self>","parent":{"krate":0,"index":607},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":14018},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":231312,"byte_end":231325,"line_start":5026,"line_end":5026,"column_start":12,"column_end":25},"name":"ParseIntError","qualname":"::num::ParseIntError","value":"ParseIntError {  }","parent":null,"children":[{"krate":0,"index":14019}],"decl_id":null,"docs":" An error which can be returned when parsing an integer.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":231255,"byte_end":231300,"line_start":5025,"line_end":5025,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":231301,"byte_end":231353,"line_start":5026,"line_end":5028,"column_start":1,"column_end":2}}]},{"kind":"TupleVariant","id":{"krate":0,"index":14030},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":231863,"byte_end":231868,"line_start":5041,"line_end":5041,"column_start":5,"column_end":10},"name":"Empty","qualname":"::num::IntErrorKind::Empty","value":"IntErrorKind::Empty","parent":{"krate":0,"index":14029},"children":[],"decl_id":null,"docs":" Value being parsed is empty.","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":14032},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":232032,"byte_end":232044,"line_start":5046,"line_end":5046,"column_start":5,"column_end":17},"name":"InvalidDigit","qualname":"::num::IntErrorKind::InvalidDigit","value":"IntErrorKind::InvalidDigit","parent":{"krate":0,"index":14029},"children":[],"decl_id":null,"docs":" Contains an invalid digit.","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":14034},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":232112,"byte_end":232120,"line_start":5048,"line_end":5048,"column_start":5,"column_end":13},"name":"Overflow","qualname":"::num::IntErrorKind::Overflow","value":"IntErrorKind::Overflow","parent":{"krate":0,"index":14029},"children":[],"decl_id":null,"docs":" Integer is too large to store in target integer type.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":14036},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":232188,"byte_end":232197,"line_start":5050,"line_end":5050,"column_start":5,"column_end":14},"name":"Underflow","qualname":"::num::IntErrorKind::Underflow","value":"IntErrorKind::Underflow","parent":{"krate":0,"index":14029},"children":[],"decl_id":null,"docs":" Integer is too small to store in target integer type.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":14038},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":232367,"byte_end":232371,"line_start":5055,"line_end":5055,"column_start":5,"column_end":9},"name":"Zero","qualname":"::num::IntErrorKind::Zero","value":"IntErrorKind::Zero","parent":{"krate":0,"index":14029},"children":[],"decl_id":null,"docs":" Value was Zero","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":14029},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":231708,"byte_end":231720,"line_start":5037,"line_end":5037,"column_start":10,"column_end":22},"name":"IntErrorKind","qualname":"::num::IntErrorKind","value":"IntErrorKind::{Empty, InvalidDigit, Overflow, Underflow, Zero}","parent":null,"children":[{"krate":0,"index":14030},{"krate":0,"index":14032},{"krate":0,"index":14034},{"krate":0,"index":14036},{"krate":0,"index":14038}],"decl_id":null,"docs":" Enum to store the various types of errors that can cause parsing an integer to fail.\n","sig":null,"attributes":[{"value":"unstable(feature = \"int_error_matching\",\n           reason =\n               \"it can be useful to match errors when making error messages \\\n                     for integer parsing\",\n           issue = \"22639\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":231444,"byte_end":231641,"line_start":5031,"line_end":5034,"column_start":1,"column_end":29}},{"value":"non_exhaustive","span":{"file_name":"src/libcore/num/mod.rs","byte_start":231681,"byte_end":231698,"line_start":5036,"line_end":5036,"column_start":1,"column_end":18}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":231699,"byte_end":232374,"line_start":5037,"line_end":5056,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":620},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":232688,"byte_end":232692,"line_start":5064,"line_end":5064,"column_start":12,"column_end":16},"name":"kind","qualname":"<ParseIntError>::kind","value":"fn (&self) -> &IntErrorKind","parent":null,"children":[],"decl_id":null,"docs":" Outputs the detailed cause of parsing an integer failing.\n","sig":null,"attributes":[{"value":"unstable(feature = \"int_error_matching\",\n           reason =\n               \"it can be useful to match errors when making error messages \\\n                         for integer parsing\",\n           issue = \"22639\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":232467,"byte_end":232676,"line_start":5060,"line_end":5063,"column_start":5,"column_end":33}}]},{"kind":"Method","id":{"krate":0,"index":621},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":232982,"byte_end":232995,"line_start":5072,"line_end":5072,"column_start":12,"column_end":25},"name":"__description","qualname":"<ParseIntError>::__description","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"int_error_internals\",\n           reason =\n               \"available through Error trait and this method should \\\n                         not be exposed publicly\",\n           issue = \"0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":232748,"byte_end":232951,"line_start":5067,"line_end":5070,"column_start":5,"column_end":29}}]},{"kind":"Mod","id":{"krate":0,"index":627},"span":{"file_name":"src/libcore/prelude/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"prelude","qualname":"::prelude","value":"src/libcore/prelude/mod.rs","parent":null,"children":[{"krate":0,"index":628}],"decl_id":null,"docs":" The libcore prelude\n","sig":null,"attributes":[{"value":"stable(feature = \"core_prelude\", since = \"1.4.0\")","span":{"file_name":"src/libcore/prelude/mod.rs","byte_start":442779,"byte_end":442832,"line_start":3,"line_end":3,"column_start":1,"column_end":54}}]},{"kind":"Mod","id":{"krate":0,"index":628},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"v1","qualname":"::prelude::v1","value":"src/libcore/prelude/v1.rs","parent":null,"children":[{"krate":0,"index":629},{"krate":0,"index":635},{"krate":0,"index":640},{"krate":0,"index":641},{"krate":0,"index":642},{"krate":0,"index":647},{"krate":0,"index":652},{"krate":0,"index":653},{"krate":0,"index":657},{"krate":0,"index":660},{"krate":0,"index":664}],"decl_id":null,"docs":" The core prelude","sig":null,"attributes":[{"value":"stable(feature = \"core_prelude\", since = \"1.4.0\")","span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":443082,"byte_end":443135,"line_start":7,"line_end":7,"column_start":1,"column_end":54}}]},{"kind":"Mod","id":{"krate":0,"index":668},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"intrinsics","qualname":"::intrinsics","value":"src/libcore/intrinsics.rs","parent":null,"children":[{"krate":0,"index":669},{"krate":0,"index":670},{"krate":0,"index":841},{"krate":0,"index":1012},{"krate":0,"index":1017},{"krate":0,"index":1022}],"decl_id":null,"docs":" Compiler intrinsics.","sig":null,"attributes":[{"value":"unstable(feature = \"core_intrinsics\",\n           reason =\n               \"intrinsics are unlikely to ever be stabilized, instead \\\n                      they should be used through stabilized interfaces \\\n                      in the rest of the standard library\",\n           issue = \"0\")","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":445727,"byte_end":446006,"line_start":32,"line_end":36,"column_start":1,"column_end":26}},{"value":"allow(missing_docs)","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":446007,"byte_end":446030,"line_start":37,"line_end":37,"column_start":1,"column_end":24}}]},{"kind":"ForeignFunction","id":{"krate":0,"index":671},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":446953,"byte_end":446965,"line_start":56,"line_end":56,"column_start":12,"column_end":24},"name":"atomic_cxchg","qualname":"::intrinsics::atomic_cxchg","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as both the `success` and `failure` parameters. For example,\n [`AtomicBool::compare_exchange`][compare_exchange].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":673},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":447553,"byte_end":447569,"line_start":65,"line_end":65,"column_start":12,"column_end":28},"name":"atomic_cxchg_acq","qualname":"::intrinsics::atomic_cxchg_acq","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as both the `success` and `failure` parameters. For example,\n [`AtomicBool::compare_exchange`][compare_exchange].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":675},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":448239,"byte_end":448255,"line_start":76,"line_end":76,"column_start":12,"column_end":28},"name":"atomic_cxchg_rel","qualname":"::intrinsics::atomic_cxchg_rel","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange` method by passing\n [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange`][compare_exchange].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":677},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":448924,"byte_end":448943,"line_start":87,"line_end":87,"column_start":12,"column_end":31},"name":"atomic_cxchg_acqrel","qualname":"::intrinsics::atomic_cxchg_acqrel","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange`][compare_exchange].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":679},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":449531,"byte_end":449551,"line_start":96,"line_end":96,"column_start":12,"column_end":32},"name":"atomic_cxchg_relaxed","qualname":"::intrinsics::atomic_cxchg_relaxed","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as both the `success` and `failure` parameters. For example,\n [`AtomicBool::compare_exchange`][compare_exchange].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":681},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":450220,"byte_end":450244,"line_start":107,"line_end":107,"column_start":12,"column_end":36},"name":"atomic_cxchg_failrelaxed","qualname":"::intrinsics::atomic_cxchg_failrelaxed","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange`][compare_exchange].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":683},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":450913,"byte_end":450933,"line_start":118,"line_end":118,"column_start":12,"column_end":32},"name":"atomic_cxchg_failacq","qualname":"::intrinsics::atomic_cxchg_failacq","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange`][compare_exchange].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":685},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":451603,"byte_end":451631,"line_start":129,"line_end":129,"column_start":12,"column_end":40},"name":"atomic_cxchg_acq_failrelaxed","qualname":"::intrinsics::atomic_cxchg_acq_failrelaxed","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange`][compare_exchange].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":687},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":452300,"byte_end":452331,"line_start":140,"line_end":140,"column_start":12,"column_end":43},"name":"atomic_cxchg_acqrel_failrelaxed","qualname":"::intrinsics::atomic_cxchg_acqrel_failrelaxed","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange`][compare_exchange].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":689},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":452908,"byte_end":452924,"line_start":150,"line_end":150,"column_start":12,"column_end":28},"name":"atomic_cxchgweak","qualname":"::intrinsics::atomic_cxchgweak","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as both the `success` and `failure` parameters. For example,\n [`AtomicBool::compare_exchange_weak`][cew].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":691},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":453501,"byte_end":453521,"line_start":159,"line_end":159,"column_start":12,"column_end":32},"name":"atomic_cxchgweak_acq","qualname":"::intrinsics::atomic_cxchgweak_acq","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as both the `success` and `failure` parameters. For example,\n [`AtomicBool::compare_exchange_weak`][cew].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":693},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":454180,"byte_end":454200,"line_start":170,"line_end":170,"column_start":12,"column_end":32},"name":"atomic_cxchgweak_rel","qualname":"::intrinsics::atomic_cxchgweak_rel","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange_weak`][cew].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":695},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":454858,"byte_end":454881,"line_start":181,"line_end":181,"column_start":12,"column_end":35},"name":"atomic_cxchgweak_acqrel","qualname":"::intrinsics::atomic_cxchgweak_acqrel","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange_weak`][cew].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":697},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":455458,"byte_end":455482,"line_start":190,"line_end":190,"column_start":12,"column_end":36},"name":"atomic_cxchgweak_relaxed","qualname":"::intrinsics::atomic_cxchgweak_relaxed","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as both the `success` and `failure` parameters. For example,\n [`AtomicBool::compare_exchange_weak`][cew].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":699},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":456140,"byte_end":456168,"line_start":201,"line_end":201,"column_start":12,"column_end":40},"name":"atomic_cxchgweak_failrelaxed","qualname":"::intrinsics::atomic_cxchgweak_failrelaxed","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange_weak`][cew].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":701},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":456826,"byte_end":456850,"line_start":212,"line_end":212,"column_start":12,"column_end":36},"name":"atomic_cxchgweak_failacq","qualname":"::intrinsics::atomic_cxchgweak_failacq","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange_weak`][cew].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":703},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":457509,"byte_end":457541,"line_start":223,"line_end":223,"column_start":12,"column_end":44},"name":"atomic_cxchgweak_acq_failrelaxed","qualname":"::intrinsics::atomic_cxchgweak_acq_failrelaxed","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange_weak`][cew].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":705},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":458199,"byte_end":458234,"line_start":234,"line_end":234,"column_start":12,"column_end":47},"name":"atomic_cxchgweak_acqrel_failrelaxed","qualname":"::intrinsics::atomic_cxchgweak_acqrel_failrelaxed","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange_weak`][cew].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":707},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":458673,"byte_end":458684,"line_start":242,"line_end":242,"column_start":12,"column_end":23},"name":"atomic_load","qualname":"::intrinsics::atomic_load","value":"fn <T> (src: *const T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Loads the current value of the pointer.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `load` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":709},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":459101,"byte_end":459116,"line_start":249,"line_end":249,"column_start":12,"column_end":27},"name":"atomic_load_acq","qualname":"::intrinsics::atomic_load_acq","value":"fn <T> (src: *const T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Loads the current value of the pointer.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `load` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":711},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":459533,"byte_end":459552,"line_start":256,"line_end":256,"column_start":12,"column_end":31},"name":"atomic_load_relaxed","qualname":"::intrinsics::atomic_load_relaxed","value":"fn <T> (src: *const T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Loads the current value of the pointer.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `load` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":713},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":459588,"byte_end":459609,"line_start":257,"line_end":257,"column_start":12,"column_end":33},"name":"atomic_load_unordered","qualname":"::intrinsics::atomic_load_unordered","value":"fn <T> (src: *const T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":715},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":460040,"byte_end":460052,"line_start":265,"line_end":265,"column_start":12,"column_end":24},"name":"atomic_store","qualname":"::intrinsics::atomic_store","value":"fn <T> (dst: *mut T, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the value at the specified memory location.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `store` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":717},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":460484,"byte_end":460500,"line_start":272,"line_end":272,"column_start":12,"column_end":28},"name":"atomic_store_rel","qualname":"::intrinsics::atomic_store_rel","value":"fn <T> (dst: *mut T, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the value at the specified memory location.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `store` method by passing\n [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":719},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":460932,"byte_end":460952,"line_start":279,"line_end":279,"column_start":12,"column_end":32},"name":"atomic_store_relaxed","qualname":"::intrinsics::atomic_store_relaxed","value":"fn <T> (dst: *mut T, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the value at the specified memory location.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `store` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":721},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":460989,"byte_end":461011,"line_start":280,"line_end":280,"column_start":12,"column_end":34},"name":"atomic_store_unordered","qualname":"::intrinsics::atomic_store_unordered","value":"fn <T> (dst: *mut T, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":723},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":461465,"byte_end":461476,"line_start":288,"line_end":288,"column_start":12,"column_end":23},"name":"atomic_xchg","qualname":"::intrinsics::atomic_xchg","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Stores the value at the specified memory location, returning the old value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `swap` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":725},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":461935,"byte_end":461950,"line_start":295,"line_end":295,"column_start":12,"column_end":27},"name":"atomic_xchg_acq","qualname":"::intrinsics::atomic_xchg_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Stores the value at the specified memory location, returning the old value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `swap` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":727},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":462409,"byte_end":462424,"line_start":302,"line_end":302,"column_start":12,"column_end":27},"name":"atomic_xchg_rel","qualname":"::intrinsics::atomic_xchg_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Stores the value at the specified memory location, returning the old value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `swap` method by passing\n [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":729},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":462882,"byte_end":462900,"line_start":309,"line_end":309,"column_start":12,"column_end":30},"name":"atomic_xchg_acqrel","qualname":"::intrinsics::atomic_xchg_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Stores the value at the specified memory location, returning the old value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `swap` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":731},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":463359,"byte_end":463378,"line_start":316,"line_end":316,"column_start":12,"column_end":31},"name":"atomic_xchg_relaxed","qualname":"::intrinsics::atomic_xchg_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Stores the value at the specified memory location, returning the old value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `swap` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":733},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":463835,"byte_end":463846,"line_start":324,"line_end":324,"column_start":12,"column_end":23},"name":"atomic_xadd","qualname":"::intrinsics::atomic_xadd","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Adds to the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_add` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":735},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":464303,"byte_end":464318,"line_start":331,"line_end":331,"column_start":12,"column_end":27},"name":"atomic_xadd_acq","qualname":"::intrinsics::atomic_xadd_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Adds to the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_add` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":737},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":464775,"byte_end":464790,"line_start":338,"line_end":338,"column_start":12,"column_end":27},"name":"atomic_xadd_rel","qualname":"::intrinsics::atomic_xadd_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Adds to the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_add` method by passing\n [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":739},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":465246,"byte_end":465264,"line_start":345,"line_end":345,"column_start":12,"column_end":30},"name":"atomic_xadd_acqrel","qualname":"::intrinsics::atomic_xadd_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Adds to the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_add` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":741},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":465721,"byte_end":465740,"line_start":352,"line_end":352,"column_start":12,"column_end":31},"name":"atomic_xadd_relaxed","qualname":"::intrinsics::atomic_xadd_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Adds to the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_add` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":743},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":466203,"byte_end":466214,"line_start":360,"line_end":360,"column_start":12,"column_end":23},"name":"atomic_xsub","qualname":"::intrinsics::atomic_xsub","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Subtract from the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_sub` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":745},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":466677,"byte_end":466692,"line_start":367,"line_end":367,"column_start":12,"column_end":27},"name":"atomic_xsub_acq","qualname":"::intrinsics::atomic_xsub_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Subtract from the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_sub` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":747},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":467155,"byte_end":467170,"line_start":374,"line_end":374,"column_start":12,"column_end":27},"name":"atomic_xsub_rel","qualname":"::intrinsics::atomic_xsub_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Subtract from the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_sub` method by passing\n [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":749},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":467632,"byte_end":467650,"line_start":381,"line_end":381,"column_start":12,"column_end":30},"name":"atomic_xsub_acqrel","qualname":"::intrinsics::atomic_xsub_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Subtract from the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_sub` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":751},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":468113,"byte_end":468132,"line_start":388,"line_end":388,"column_start":12,"column_end":31},"name":"atomic_xsub_relaxed","qualname":"::intrinsics::atomic_xsub_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Subtract from the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_sub` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":753},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":468596,"byte_end":468606,"line_start":396,"line_end":396,"column_start":12,"column_end":22},"name":"atomic_and","qualname":"::intrinsics::atomic_and","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise and with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_and` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":755},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":469070,"byte_end":469084,"line_start":403,"line_end":403,"column_start":12,"column_end":26},"name":"atomic_and_acq","qualname":"::intrinsics::atomic_and_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise and with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_and` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":757},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":469548,"byte_end":469562,"line_start":410,"line_end":410,"column_start":12,"column_end":26},"name":"atomic_and_rel","qualname":"::intrinsics::atomic_and_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise and with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_and` method by passing\n [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":759},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":470025,"byte_end":470042,"line_start":417,"line_end":417,"column_start":12,"column_end":29},"name":"atomic_and_acqrel","qualname":"::intrinsics::atomic_and_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise and with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_and` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":761},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":470506,"byte_end":470524,"line_start":424,"line_end":424,"column_start":12,"column_end":30},"name":"atomic_and_relaxed","qualname":"::intrinsics::atomic_and_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise and with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_and` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":763},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":471003,"byte_end":471014,"line_start":432,"line_end":432,"column_start":12,"column_end":23},"name":"atomic_nand","qualname":"::intrinsics::atomic_nand","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise nand with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":765},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":471493,"byte_end":471508,"line_start":439,"line_end":439,"column_start":12,"column_end":27},"name":"atomic_nand_acq","qualname":"::intrinsics::atomic_nand_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise nand with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":767},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":471987,"byte_end":472002,"line_start":446,"line_end":446,"column_start":12,"column_end":27},"name":"atomic_nand_rel","qualname":"::intrinsics::atomic_nand_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise nand with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":769},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":472480,"byte_end":472498,"line_start":453,"line_end":453,"column_start":12,"column_end":30},"name":"atomic_nand_acqrel","qualname":"::intrinsics::atomic_nand_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise nand with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":771},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":472977,"byte_end":472996,"line_start":460,"line_end":460,"column_start":12,"column_end":31},"name":"atomic_nand_relaxed","qualname":"::intrinsics::atomic_nand_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise nand with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":773},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":473456,"byte_end":473465,"line_start":468,"line_end":468,"column_start":12,"column_end":21},"name":"atomic_or","qualname":"::intrinsics::atomic_or","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise or with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_or` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":775},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":473925,"byte_end":473938,"line_start":475,"line_end":475,"column_start":12,"column_end":25},"name":"atomic_or_acq","qualname":"::intrinsics::atomic_or_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise or with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_or` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":777},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":474398,"byte_end":474411,"line_start":482,"line_end":482,"column_start":12,"column_end":25},"name":"atomic_or_rel","qualname":"::intrinsics::atomic_or_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise or with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_or` method by passing\n [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":779},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":474870,"byte_end":474886,"line_start":489,"line_end":489,"column_start":12,"column_end":28},"name":"atomic_or_acqrel","qualname":"::intrinsics::atomic_or_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise or with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_or` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":781},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":475346,"byte_end":475363,"line_start":496,"line_end":496,"column_start":12,"column_end":29},"name":"atomic_or_relaxed","qualname":"::intrinsics::atomic_or_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise or with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_or` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":783},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":475827,"byte_end":475837,"line_start":504,"line_end":504,"column_start":12,"column_end":22},"name":"atomic_xor","qualname":"::intrinsics::atomic_xor","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise xor with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_xor` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":785},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":476301,"byte_end":476315,"line_start":511,"line_end":511,"column_start":12,"column_end":26},"name":"atomic_xor_acq","qualname":"::intrinsics::atomic_xor_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise xor with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_xor` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":787},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":476779,"byte_end":476793,"line_start":518,"line_end":518,"column_start":12,"column_end":26},"name":"atomic_xor_rel","qualname":"::intrinsics::atomic_xor_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise xor with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_xor` method by passing\n [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":789},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":477256,"byte_end":477273,"line_start":525,"line_end":525,"column_start":12,"column_end":29},"name":"atomic_xor_acqrel","qualname":"::intrinsics::atomic_xor_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise xor with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_xor` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":791},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":477737,"byte_end":477755,"line_start":532,"line_end":532,"column_start":12,"column_end":30},"name":"atomic_xor_relaxed","qualname":"::intrinsics::atomic_xor_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise xor with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_xor` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":793},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":477798,"byte_end":477808,"line_start":534,"line_end":534,"column_start":12,"column_end":22},"name":"atomic_max","qualname":"::intrinsics::atomic_max","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":795},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":477850,"byte_end":477864,"line_start":535,"line_end":535,"column_start":12,"column_end":26},"name":"atomic_max_acq","qualname":"::intrinsics::atomic_max_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":797},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":477906,"byte_end":477920,"line_start":536,"line_end":536,"column_start":12,"column_end":26},"name":"atomic_max_rel","qualname":"::intrinsics::atomic_max_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":799},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":477962,"byte_end":477979,"line_start":537,"line_end":537,"column_start":12,"column_end":29},"name":"atomic_max_acqrel","qualname":"::intrinsics::atomic_max_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":801},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":478021,"byte_end":478039,"line_start":538,"line_end":538,"column_start":12,"column_end":30},"name":"atomic_max_relaxed","qualname":"::intrinsics::atomic_max_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":803},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":478082,"byte_end":478092,"line_start":540,"line_end":540,"column_start":12,"column_end":22},"name":"atomic_min","qualname":"::intrinsics::atomic_min","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":805},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":478134,"byte_end":478148,"line_start":541,"line_end":541,"column_start":12,"column_end":26},"name":"atomic_min_acq","qualname":"::intrinsics::atomic_min_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":807},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":478190,"byte_end":478204,"line_start":542,"line_end":542,"column_start":12,"column_end":26},"name":"atomic_min_rel","qualname":"::intrinsics::atomic_min_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":809},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":478246,"byte_end":478263,"line_start":543,"line_end":543,"column_start":12,"column_end":29},"name":"atomic_min_acqrel","qualname":"::intrinsics::atomic_min_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":811},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":478305,"byte_end":478323,"line_start":544,"line_end":544,"column_start":12,"column_end":30},"name":"atomic_min_relaxed","qualname":"::intrinsics::atomic_min_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":813},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":478366,"byte_end":478377,"line_start":546,"line_end":546,"column_start":12,"column_end":23},"name":"atomic_umin","qualname":"::intrinsics::atomic_umin","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":815},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":478419,"byte_end":478434,"line_start":547,"line_end":547,"column_start":12,"column_end":27},"name":"atomic_umin_acq","qualname":"::intrinsics::atomic_umin_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":817},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":478476,"byte_end":478491,"line_start":548,"line_end":548,"column_start":12,"column_end":27},"name":"atomic_umin_rel","qualname":"::intrinsics::atomic_umin_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":819},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":478533,"byte_end":478551,"line_start":549,"line_end":549,"column_start":12,"column_end":30},"name":"atomic_umin_acqrel","qualname":"::intrinsics::atomic_umin_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":821},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":478593,"byte_end":478612,"line_start":550,"line_end":550,"column_start":12,"column_end":31},"name":"atomic_umin_relaxed","qualname":"::intrinsics::atomic_umin_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":823},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":478655,"byte_end":478666,"line_start":552,"line_end":552,"column_start":12,"column_end":23},"name":"atomic_umax","qualname":"::intrinsics::atomic_umax","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":825},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":478708,"byte_end":478723,"line_start":553,"line_end":553,"column_start":12,"column_end":27},"name":"atomic_umax_acq","qualname":"::intrinsics::atomic_umax_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":827},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":478765,"byte_end":478780,"line_start":554,"line_end":554,"column_start":12,"column_end":27},"name":"atomic_umax_rel","qualname":"::intrinsics::atomic_umax_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":829},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":478822,"byte_end":478840,"line_start":555,"line_end":555,"column_start":12,"column_end":30},"name":"atomic_umax_acqrel","qualname":"::intrinsics::atomic_umax_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":831},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":478882,"byte_end":478901,"line_start":556,"line_end":556,"column_start":12,"column_end":31},"name":"atomic_umax_relaxed","qualname":"::intrinsics::atomic_umax_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":833},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":479394,"byte_end":479412,"line_start":565,"line_end":565,"column_start":12,"column_end":30},"name":"prefetch_read_data","qualname":"::intrinsics::prefetch_read_data","value":"fn <T> (data: *const T, locality: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n if supported; otherwise, it is a no-op.\n Prefetches have no effect on the behavior of the program but can change its performance\n characteristics.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":835},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":479909,"byte_end":479928,"line_start":573,"line_end":573,"column_start":12,"column_end":31},"name":"prefetch_write_data","qualname":"::intrinsics::prefetch_write_data","value":"fn <T> (data: *const T, locality: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n if supported; otherwise, it is a no-op.\n Prefetches have no effect on the behavior of the program but can change its performance\n characteristics.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":837},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":480425,"byte_end":480450,"line_start":581,"line_end":581,"column_start":12,"column_end":37},"name":"prefetch_read_instruction","qualname":"::intrinsics::prefetch_read_instruction","value":"fn <T> (data: *const T, locality: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n if supported; otherwise, it is a no-op.\n Prefetches have no effect on the behavior of the program but can change its performance\n characteristics.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":839},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":480947,"byte_end":480973,"line_start":589,"line_end":589,"column_start":12,"column_end":38},"name":"prefetch_write_instruction","qualname":"::intrinsics::prefetch_write_instruction","value":"fn <T> (data: *const T, locality: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n if supported; otherwise, it is a no-op.\n Prefetches have no effect on the behavior of the program but can change its performance\n characteristics.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":842},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":481050,"byte_end":481062,"line_start":594,"line_end":594,"column_start":12,"column_end":24},"name":"atomic_fence","qualname":"::intrinsics::atomic_fence","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":843},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":481077,"byte_end":481093,"line_start":595,"line_end":595,"column_start":12,"column_end":28},"name":"atomic_fence_acq","qualname":"::intrinsics::atomic_fence_acq","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":844},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":481108,"byte_end":481124,"line_start":596,"line_end":596,"column_start":12,"column_end":28},"name":"atomic_fence_rel","qualname":"::intrinsics::atomic_fence_rel","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":845},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":481139,"byte_end":481158,"line_start":597,"line_end":597,"column_start":12,"column_end":31},"name":"atomic_fence_acqrel","qualname":"::intrinsics::atomic_fence_acqrel","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":846},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":481499,"byte_end":481523,"line_start":605,"line_end":605,"column_start":12,"column_end":36},"name":"atomic_singlethreadfence","qualname":"::intrinsics::atomic_singlethreadfence","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" A compiler-only memory barrier.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":847},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":481538,"byte_end":481566,"line_start":606,"line_end":606,"column_start":12,"column_end":40},"name":"atomic_singlethreadfence_acq","qualname":"::intrinsics::atomic_singlethreadfence_acq","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":848},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":481581,"byte_end":481609,"line_start":607,"line_end":607,"column_start":12,"column_end":40},"name":"atomic_singlethreadfence_rel","qualname":"::intrinsics::atomic_singlethreadfence_rel","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":849},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":481624,"byte_end":481655,"line_start":608,"line_end":608,"column_start":12,"column_end":43},"name":"atomic_singlethreadfence_acqrel","qualname":"::intrinsics::atomic_singlethreadfence_acqrel","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":850},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":482039,"byte_end":482049,"line_start":617,"line_end":617,"column_start":12,"column_end":22},"name":"rustc_peek","qualname":"::intrinsics::rustc_peek","value":"fn <T> (_: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Magic intrinsic that derives its meaning from attributes\n attached to the function.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":852},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":482247,"byte_end":482252,"line_start":623,"line_end":623,"column_start":12,"column_end":17},"name":"abort","qualname":"::intrinsics::abort","value":"fn () -> !","parent":null,"children":[],"decl_id":null,"docs":" Aborts the execution of the process.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":853},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":482744,"byte_end":482755,"line_start":634,"line_end":634,"column_start":12,"column_end":23},"name":"unreachable","qualname":"::intrinsics::unreachable","value":"fn () -> !","parent":null,"children":[],"decl_id":null,"docs":" Tells LLVM that this point in the code is not reachable, enabling\n further optimizations.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":854},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":483292,"byte_end":483298,"line_start":644,"line_end":644,"column_start":12,"column_end":18},"name":"assume","qualname":"::intrinsics::assume","value":"fn (b: bool) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Informs the optimizer that a condition is always true.\n If the condition is false, the behavior is undefined.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":855},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":483525,"byte_end":483531,"line_start":650,"line_end":650,"column_start":12,"column_end":18},"name":"likely","qualname":"::intrinsics::likely","value":"fn (b: bool) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Hints to the compiler that branch condition is likely to be true.\n Returns the value passed to it.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":856},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":483767,"byte_end":483775,"line_start":656,"line_end":656,"column_start":12,"column_end":20},"name":"unlikely","qualname":"::intrinsics::unlikely","value":"fn (b: bool) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Hints to the compiler that branch condition is likely to be false.\n Returns the value passed to it.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":857},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":483872,"byte_end":483882,"line_start":659,"line_end":659,"column_start":12,"column_end":22},"name":"breakpoint","qualname":"::intrinsics::breakpoint","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Executes a breakpoint trap, for inspection by a debugger.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":858},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":484200,"byte_end":484207,"line_start":668,"line_end":668,"column_start":12,"column_end":19},"name":"size_of","qualname":"::intrinsics::size_of","value":"fn <T> () -> usize","parent":null,"children":[],"decl_id":null,"docs":" The size of a type in bytes.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":860},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":484351,"byte_end":484364,"line_start":673,"line_end":673,"column_start":12,"column_end":25},"name":"move_val_init","qualname":"::intrinsics::move_val_init","value":"fn <T> (dst: *mut T, src: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Moves a value to an uninitialized memory location.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":862},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":484402,"byte_end":484414,"line_start":675,"line_end":675,"column_start":12,"column_end":24},"name":"min_align_of","qualname":"::intrinsics::min_align_of","value":"fn <T> () -> usize","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":864},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":484441,"byte_end":484454,"line_start":676,"line_end":676,"column_start":12,"column_end":25},"name":"pref_align_of","qualname":"::intrinsics::pref_align_of","value":"fn <T> () -> usize","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":866},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":484663,"byte_end":484674,"line_start":682,"line_end":682,"column_start":12,"column_end":23},"name":"size_of_val","qualname":"::intrinsics::size_of_val","value":"fn <T> (_: &T) -> usize","parent":null,"children":[],"decl_id":null,"docs":" The size of the referenced value in bytes.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":868},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":484714,"byte_end":484730,"line_start":683,"line_end":683,"column_start":12,"column_end":28},"name":"min_align_of_val","qualname":"::intrinsics::min_align_of_val","value":"fn <T> (_: &T) -> usize","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":870},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":484837,"byte_end":484846,"line_start":686,"line_end":686,"column_start":12,"column_end":21},"name":"type_name","qualname":"::intrinsics::type_name","value":"fn <T> () -> &'static str","parent":null,"children":[],"decl_id":null,"docs":" Gets a static string slice containing the name of a type.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":872},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":485080,"byte_end":485087,"line_start":691,"line_end":691,"column_start":12,"column_end":19},"name":"type_id","qualname":"::intrinsics::type_id","value":"fn <T> () -> u64","parent":null,"children":[],"decl_id":null,"docs":" Gets an identifier which is globally unique to the specified type. This\n function will return the same value for a type regardless of whichever\n crate it is invoked in.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":874},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":485278,"byte_end":485298,"line_start":695,"line_end":695,"column_start":12,"column_end":32},"name":"panic_if_uninhabited","qualname":"::intrinsics::panic_if_uninhabited","value":"fn <T> () -> ()","parent":null,"children":[],"decl_id":null,"docs":" A guard for unsafe functions that cannot ever be executed if `T` is uninhabited:\n This will statically either panic, or do nothing.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":876},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":485610,"byte_end":485614,"line_start":703,"line_end":703,"column_start":12,"column_end":16},"name":"init","qualname":"::intrinsics::init","value":"fn <T> () -> T","parent":null,"children":[],"decl_id":null,"docs":" Creates a value initialized to zero.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":878},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":486015,"byte_end":486021,"line_start":712,"line_end":712,"column_start":12,"column_end":18},"name":"uninit","qualname":"::intrinsics::uninit","value":"fn <T> () -> T","parent":null,"children":[],"decl_id":null,"docs":" Creates an uninitialized value.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":880},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":486107,"byte_end":486113,"line_start":715,"line_end":715,"column_start":12,"column_end":18},"name":"forget","qualname":"::intrinsics::forget","value":"fn <T> (_: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Moves a value out of scope without running drop glue.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":882},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":493850,"byte_end":493859,"line_start":916,"line_end":916,"column_start":12,"column_end":21},"name":"transmute","qualname":"::intrinsics::transmute","value":"fn <T, U> (e: T) -> U","parent":null,"children":[],"decl_id":null,"docs":" Reinterprets the bits of a value of one type as another type.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":493793,"byte_end":493838,"line_start":915,"line_end":915,"column_start":5,"column_end":50}}]},{"kind":"ForeignFunction","id":{"krate":0,"index":885},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":494308,"byte_end":494318,"line_start":927,"line_end":927,"column_start":12,"column_end":22},"name":"needs_drop","qualname":"::intrinsics::needs_drop","value":"fn <T> () -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the actual type given as `T` requires drop\n glue; returns `false` if the actual type provided for `T`\n implements `Copy`.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":887},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":494877,"byte_end":494883,"line_start":940,"line_end":940,"column_start":12,"column_end":18},"name":"offset","qualname":"::intrinsics::offset","value":"fn <T> (dst: *const T, offset: isize) -> *const T","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":889},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":495511,"byte_end":495523,"line_start":953,"line_end":953,"column_start":12,"column_end":24},"name":"arith_offset","qualname":"::intrinsics::arith_offset","value":"fn <T> (dst: *const T, offset: isize) -> *const T","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer, potentially wrapping.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":891},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":495883,"byte_end":495918,"line_start":961,"line_end":961,"column_start":12,"column_end":47},"name":"volatile_copy_nonoverlapping_memory","qualname":"::intrinsics::volatile_copy_nonoverlapping_memory","value":"fn <T> (dst: *mut T, src: *const T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with\n a size of `count` * `size_of::<T>()` and an alignment of\n `min_align_of::<T>()`","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":893},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":496328,"byte_end":496348,"line_start":969,"line_end":969,"column_start":12,"column_end":32},"name":"volatile_copy_memory","qualname":"::intrinsics::volatile_copy_memory","value":"fn <T> (dst: *mut T, src: *const T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with\n a size of `count` * `size_of::<T>()` and an alignment of\n `min_align_of::<T>()`","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":895},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":496704,"byte_end":496723,"line_start":976,"line_end":976,"column_start":12,"column_end":31},"name":"volatile_set_memory","qualname":"::intrinsics::volatile_set_memory","value":"fn <T> (dst: *mut T, val: u8, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\n size of `count` * `size_of::<T>()` and an alignment of\n `min_align_of::<T>()`.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":897},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":496959,"byte_end":496972,"line_start":981,"line_end":981,"column_start":12,"column_end":25},"name":"volatile_load","qualname":"::intrinsics::volatile_load","value":"fn <T> (src: *const T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs a volatile load from the `src` pointer.\n The stabilized version of this intrinsic is\n [`std::ptr::read_volatile`](../../std/ptr/fn.read_volatile.html).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":899},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":497192,"byte_end":497206,"line_start":985,"line_end":985,"column_start":12,"column_end":26},"name":"volatile_store","qualname":"::intrinsics::volatile_store","value":"fn <T> (dst: *mut T, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a volatile store to the `dst` pointer.\n The stabilized version of this intrinsic is\n [`std::ptr::write_volatile`](../../std/ptr/fn.write_volatile.html).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":901},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":497351,"byte_end":497374,"line_start":989,"line_end":989,"column_start":12,"column_end":35},"name":"unaligned_volatile_load","qualname":"::intrinsics::unaligned_volatile_load","value":"fn <T> (src: *const T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs a volatile load from the `src` pointer\n The pointer is not required to be aligned.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":903},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":497517,"byte_end":497541,"line_start":992,"line_end":992,"column_start":12,"column_end":36},"name":"unaligned_volatile_store","qualname":"::intrinsics::unaligned_volatile_store","value":"fn <T> (dst: *mut T, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a volatile store to the `dst` pointer.\n The pointer is not required to be aligned.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":905},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":497623,"byte_end":497630,"line_start":995,"line_end":995,"column_start":12,"column_end":19},"name":"sqrtf32","qualname":"::intrinsics::sqrtf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the square root of an `f32`\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":906},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":497702,"byte_end":497709,"line_start":997,"line_end":997,"column_start":12,"column_end":19},"name":"sqrtf64","qualname":"::intrinsics::sqrtf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the square root of an `f64`\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":907},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":497783,"byte_end":497790,"line_start":1000,"line_end":1000,"column_start":12,"column_end":19},"name":"powif32","qualname":"::intrinsics::powif32","value":"fn (a: f32, x: i32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Raises an `f32` to an integer power.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":908},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":497871,"byte_end":497878,"line_start":1002,"line_end":1002,"column_start":12,"column_end":19},"name":"powif64","qualname":"::intrinsics::powif64","value":"fn (a: f64, x: i32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Raises an `f64` to an integer power.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":909},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":497953,"byte_end":497959,"line_start":1005,"line_end":1005,"column_start":12,"column_end":18},"name":"sinf32","qualname":"::intrinsics::sinf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the sine of an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":910},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":498025,"byte_end":498031,"line_start":1007,"line_end":1007,"column_start":12,"column_end":18},"name":"sinf64","qualname":"::intrinsics::sinf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the sine of an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":911},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":498100,"byte_end":498106,"line_start":1010,"line_end":1010,"column_start":12,"column_end":18},"name":"cosf32","qualname":"::intrinsics::cosf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the cosine of an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":912},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":498174,"byte_end":498180,"line_start":1012,"line_end":1012,"column_start":12,"column_end":18},"name":"cosf64","qualname":"::intrinsics::cosf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the cosine of an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":913},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":498252,"byte_end":498258,"line_start":1015,"line_end":1015,"column_start":12,"column_end":18},"name":"powf32","qualname":"::intrinsics::powf32","value":"fn (a: f32, x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Raises an `f32` to an `f32` power.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":914},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":498337,"byte_end":498343,"line_start":1017,"line_end":1017,"column_start":12,"column_end":18},"name":"powf64","qualname":"::intrinsics::powf64","value":"fn (a: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Raises an `f64` to an `f64` power.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":915},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":498425,"byte_end":498431,"line_start":1020,"line_end":1020,"column_start":12,"column_end":18},"name":"expf32","qualname":"::intrinsics::expf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the exponential of an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":916},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":498504,"byte_end":498510,"line_start":1022,"line_end":1022,"column_start":12,"column_end":18},"name":"expf64","qualname":"::intrinsics::expf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the exponential of an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":917},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":498590,"byte_end":498597,"line_start":1025,"line_end":1025,"column_start":12,"column_end":19},"name":"exp2f32","qualname":"::intrinsics::exp2f32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns 2 raised to the power of an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":918},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":498676,"byte_end":498683,"line_start":1027,"line_end":1027,"column_start":12,"column_end":19},"name":"exp2f64","qualname":"::intrinsics::exp2f64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns 2 raised to the power of an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":919},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":498763,"byte_end":498769,"line_start":1030,"line_end":1030,"column_start":12,"column_end":18},"name":"logf32","qualname":"::intrinsics::logf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the natural logarithm of an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":920},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":498848,"byte_end":498854,"line_start":1032,"line_end":1032,"column_start":12,"column_end":18},"name":"logf64","qualname":"::intrinsics::logf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the natural logarithm of an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":921},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":498934,"byte_end":498942,"line_start":1035,"line_end":1035,"column_start":12,"column_end":20},"name":"log10f32","qualname":"::intrinsics::log10f32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the base 10 logarithm of an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":922},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":499021,"byte_end":499029,"line_start":1037,"line_end":1037,"column_start":12,"column_end":20},"name":"log10f64","qualname":"::intrinsics::log10f64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the base 10 logarithm of an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":923},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":499108,"byte_end":499115,"line_start":1040,"line_end":1040,"column_start":12,"column_end":19},"name":"log2f32","qualname":"::intrinsics::log2f32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the base 2 logarithm of an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":924},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":499193,"byte_end":499200,"line_start":1042,"line_end":1042,"column_start":12,"column_end":19},"name":"log2f64","qualname":"::intrinsics::log2f64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the base 2 logarithm of an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":925},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":499275,"byte_end":499281,"line_start":1045,"line_end":1045,"column_start":12,"column_end":18},"name":"fmaf32","qualname":"::intrinsics::fmaf32","value":"fn (a: f32, b: f32, c: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns `a * b + c` for `f32` values.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":926},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":499371,"byte_end":499377,"line_start":1047,"line_end":1047,"column_start":12,"column_end":18},"name":"fmaf64","qualname":"::intrinsics::fmaf64","value":"fn (a: f64, b: f64, c: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns `a * b + c` for `f64` values.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":927},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":499470,"byte_end":499477,"line_start":1050,"line_end":1050,"column_start":12,"column_end":19},"name":"fabsf32","qualname":"::intrinsics::fabsf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the absolute value of an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":928},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":499553,"byte_end":499560,"line_start":1052,"line_end":1052,"column_start":12,"column_end":19},"name":"fabsf64","qualname":"::intrinsics::fabsf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the absolute value of an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":929},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":499665,"byte_end":499674,"line_start":1056,"line_end":1056,"column_start":12,"column_end":21},"name":"minnumf32","qualname":"::intrinsics::minnumf32","value":"fn (x: f32, y: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the minimum of two `f32` values.\n","sig":null,"attributes":[{"value":"cfg(not(bootstrap))","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":499631,"byte_end":499653,"line_start":1055,"line_end":1055,"column_start":5,"column_end":27}}]},{"kind":"ForeignFunction","id":{"krate":0,"index":930},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":499786,"byte_end":499795,"line_start":1059,"line_end":1059,"column_start":12,"column_end":21},"name":"minnumf64","qualname":"::intrinsics::minnumf64","value":"fn (x: f64, y: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the minimum of two `f64` values.\n","sig":null,"attributes":[{"value":"cfg(not(bootstrap))","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":499752,"byte_end":499774,"line_start":1058,"line_end":1058,"column_start":5,"column_end":27}}]},{"kind":"ForeignFunction","id":{"krate":0,"index":931},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":499907,"byte_end":499916,"line_start":1062,"line_end":1062,"column_start":12,"column_end":21},"name":"maxnumf32","qualname":"::intrinsics::maxnumf32","value":"fn (x: f32, y: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the maximum of two `f32` values.\n","sig":null,"attributes":[{"value":"cfg(not(bootstrap))","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":499873,"byte_end":499895,"line_start":1061,"line_end":1061,"column_start":5,"column_end":27}}]},{"kind":"ForeignFunction","id":{"krate":0,"index":932},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":500028,"byte_end":500037,"line_start":1065,"line_end":1065,"column_start":12,"column_end":21},"name":"maxnumf64","qualname":"::intrinsics::maxnumf64","value":"fn (x: f64, y: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the maximum of two `f64` values.\n","sig":null,"attributes":[{"value":"cfg(not(bootstrap))","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":499994,"byte_end":500016,"line_start":1064,"line_end":1064,"column_start":5,"column_end":27}}]},{"kind":"ForeignFunction","id":{"krate":0,"index":933},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":500132,"byte_end":500143,"line_start":1068,"line_end":1068,"column_start":12,"column_end":23},"name":"copysignf32","qualname":"::intrinsics::copysignf32","value":"fn (x: f32, y: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Copies the sign from `y` to `x` for `f32` values.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":934},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":500237,"byte_end":500248,"line_start":1070,"line_end":1070,"column_start":12,"column_end":23},"name":"copysignf64","qualname":"::intrinsics::copysignf64","value":"fn (x: f64, y: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Copies the sign from `y` to `x` for `f64` values.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":935},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":500353,"byte_end":500361,"line_start":1073,"line_end":1073,"column_start":12,"column_end":20},"name":"floorf32","qualname":"::intrinsics::floorf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the largest integer less than or equal to an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":936},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":500457,"byte_end":500465,"line_start":1075,"line_end":1075,"column_start":12,"column_end":20},"name":"floorf64","qualname":"::intrinsics::floorf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the largest integer less than or equal to an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":937},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":500566,"byte_end":500573,"line_start":1078,"line_end":1078,"column_start":12,"column_end":19},"name":"ceilf32","qualname":"::intrinsics::ceilf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the smallest integer greater than or equal to an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":938},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":500673,"byte_end":500680,"line_start":1080,"line_end":1080,"column_start":12,"column_end":19},"name":"ceilf64","qualname":"::intrinsics::ceilf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the smallest integer greater than or equal to an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":939},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":500755,"byte_end":500763,"line_start":1083,"line_end":1083,"column_start":12,"column_end":20},"name":"truncf32","qualname":"::intrinsics::truncf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the integer part of an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":940},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":500837,"byte_end":500845,"line_start":1085,"line_end":1085,"column_start":12,"column_end":20},"name":"truncf64","qualname":"::intrinsics::truncf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the integer part of an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":941},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":501012,"byte_end":501019,"line_start":1089,"line_end":1089,"column_start":12,"column_end":19},"name":"rintf32","qualname":"::intrinsics::rintf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the nearest integer to an `f32`. May raise an inexact floating-point exception\n if the argument is not an integer.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":942},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":501185,"byte_end":501192,"line_start":1092,"line_end":1092,"column_start":12,"column_end":19},"name":"rintf64","qualname":"::intrinsics::rintf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the nearest integer to an `f64`. May raise an inexact floating-point exception\n if the argument is not an integer.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":943},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":501270,"byte_end":501282,"line_start":1095,"line_end":1095,"column_start":12,"column_end":24},"name":"nearbyintf32","qualname":"::intrinsics::nearbyintf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the nearest integer to an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":944},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":501359,"byte_end":501371,"line_start":1097,"line_end":1097,"column_start":12,"column_end":24},"name":"nearbyintf64","qualname":"::intrinsics::nearbyintf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the nearest integer to an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":945},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":501487,"byte_end":501495,"line_start":1100,"line_end":1100,"column_start":12,"column_end":20},"name":"roundf32","qualname":"::intrinsics::roundf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the nearest integer to an `f32`. Rounds half-way cases away from zero.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":946},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":501610,"byte_end":501618,"line_start":1102,"line_end":1102,"column_start":12,"column_end":20},"name":"roundf64","qualname":"::intrinsics::roundf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the nearest integer to an `f64`. Rounds half-way cases away from zero.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":947},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":501760,"byte_end":501769,"line_start":1106,"line_end":1106,"column_start":12,"column_end":21},"name":"fadd_fast","qualname":"::intrinsics::fadd_fast","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Float addition that allows optimizations based on algebraic rules.\n May assume inputs are finite.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":949},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":501919,"byte_end":501928,"line_start":1110,"line_end":1110,"column_start":12,"column_end":21},"name":"fsub_fast","qualname":"::intrinsics::fsub_fast","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Float subtraction that allows optimizations based on algebraic rules.\n May assume inputs are finite.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":951},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":502081,"byte_end":502090,"line_start":1114,"line_end":1114,"column_start":12,"column_end":21},"name":"fmul_fast","qualname":"::intrinsics::fmul_fast","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Float multiplication that allows optimizations based on algebraic rules.\n May assume inputs are finite.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":953},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":502237,"byte_end":502246,"line_start":1118,"line_end":1118,"column_start":12,"column_end":21},"name":"fdiv_fast","qualname":"::intrinsics::fdiv_fast","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Float division that allows optimizations based on algebraic rules.\n May assume inputs are finite.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":955},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":502394,"byte_end":502403,"line_start":1122,"line_end":1122,"column_start":12,"column_end":21},"name":"frem_fast","qualname":"::intrinsics::frem_fast","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Float remainder that allows optimizations based on algebraic rules.\n May assume inputs are finite.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":957},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":502500,"byte_end":502505,"line_start":1126,"line_end":1126,"column_start":12,"column_end":17},"name":"ctpop","qualname":"::intrinsics::ctpop","value":"fn <T> (x: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the number of bits set in an integer type `T`\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":959},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":503151,"byte_end":503155,"line_start":1153,"line_end":1153,"column_start":12,"column_end":16},"name":"ctlz","qualname":"::intrinsics::ctlz","value":"fn <T> (x: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the number of leading unset bits (zeroes) in an integer type `T`.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":961},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":503562,"byte_end":503574,"line_start":1169,"line_end":1169,"column_start":12,"column_end":24},"name":"ctlz_nonzero","qualname":"::intrinsics::ctlz_nonzero","value":"fn <T> (x: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Like `ctlz`, but extra-unsafe as it returns `undef` when\n given an `x` with value `0`.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":963},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":504225,"byte_end":504229,"line_start":1196,"line_end":1196,"column_start":12,"column_end":16},"name":"cttz","qualname":"::intrinsics::cttz","value":"fn <T> (x: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the number of trailing unset bits (zeroes) in an integer type `T`.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":965},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":504638,"byte_end":504650,"line_start":1212,"line_end":1212,"column_start":12,"column_end":24},"name":"cttz_nonzero","qualname":"::intrinsics::cttz_nonzero","value":"fn <T> (x: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Like `cttz`, but extra-unsafe as it returns `undef` when\n given an `x` with value `0`.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":967},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":504729,"byte_end":504734,"line_start":1215,"line_end":1215,"column_start":12,"column_end":17},"name":"bswap","qualname":"::intrinsics::bswap","value":"fn <T> (x: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Reverses the bytes in an integer type `T`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":969},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":504812,"byte_end":504822,"line_start":1218,"line_end":1218,"column_start":12,"column_end":22},"name":"bitreverse","qualname":"::intrinsics::bitreverse","value":"fn <T> (x: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Reverses the bits in an integer type `T`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":971},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":505129,"byte_end":505146,"line_start":1224,"line_end":1224,"column_start":12,"column_end":29},"name":"add_with_overflow","qualname":"::intrinsics::add_with_overflow","value":"fn <T> (x: T, y: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Performs checked integer addition.\n The stabilized versions of this intrinsic are available on the integer\n primitives via the `overflowing_add` method. For example,\n [`std::u32::overflowing_add`](../../std/primitive.u32.html#method.overflowing_add)\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":973},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":505469,"byte_end":505486,"line_start":1230,"line_end":1230,"column_start":12,"column_end":29},"name":"sub_with_overflow","qualname":"::intrinsics::sub_with_overflow","value":"fn <T> (x: T, y: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Performs checked integer subtraction\n The stabilized versions of this intrinsic are available on the integer\n primitives via the `overflowing_sub` method. For example,\n [`std::u32::overflowing_sub`](../../std/primitive.u32.html#method.overflowing_sub)\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":975},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":505812,"byte_end":505829,"line_start":1236,"line_end":1236,"column_start":12,"column_end":29},"name":"mul_with_overflow","qualname":"::intrinsics::mul_with_overflow","value":"fn <T> (x: T, y: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Performs checked integer multiplication\n The stabilized versions of this intrinsic are available on the integer\n primitives via the `overflowing_mul` method. For example,\n [`std::u32::overflowing_mul`](../../std/primitive.u32.html#method.overflowing_mul)\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":977},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":506014,"byte_end":506023,"line_start":1240,"line_end":1240,"column_start":12,"column_end":21},"name":"exact_div","qualname":"::intrinsics::exact_div","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs an exact division, resulting in undefined behavior where\n `x % y != 0` or `y == 0` or `x == T::min_value() && y == -1`\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":979},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":506184,"byte_end":506197,"line_start":1244,"line_end":1244,"column_start":12,"column_end":25},"name":"unchecked_div","qualname":"::intrinsics::unchecked_div","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs an unchecked division, resulting in undefined behavior\n where y = 0 or x = `T::min_value()` and y = -1\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":981},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":506373,"byte_end":506386,"line_start":1247,"line_end":1247,"column_start":12,"column_end":25},"name":"unchecked_rem","qualname":"::intrinsics::unchecked_rem","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the remainder of an unchecked division, resulting in\n undefined behavior where y = 0 or x = `T::min_value()` and y = -1\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":983},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":506559,"byte_end":506572,"line_start":1251,"line_end":1251,"column_start":12,"column_end":25},"name":"unchecked_shl","qualname":"::intrinsics::unchecked_shl","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs an unchecked left shift, resulting in undefined behavior when\n y < 0 or y >= N, where N is the width of T in bits.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":985},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":506745,"byte_end":506758,"line_start":1254,"line_end":1254,"column_start":12,"column_end":25},"name":"unchecked_shr","qualname":"::intrinsics::unchecked_shr","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs an unchecked right shift, resulting in undefined behavior when\n y < 0 or y >= N, where N is the width of T in bits.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":987},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":506971,"byte_end":506984,"line_start":1259,"line_end":1259,"column_start":12,"column_end":25},"name":"unchecked_add","qualname":"::intrinsics::unchecked_add","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the result of an unchecked addition, resulting in\n undefined behavior when `x + y > T::max_value()` or `x + y < T::min_value()`.\n","sig":null,"attributes":[{"value":"cfg(not(bootstrap))","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":506937,"byte_end":506959,"line_start":1258,"line_end":1258,"column_start":5,"column_end":27}}]},{"kind":"ForeignFunction","id":{"krate":0,"index":989},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":507201,"byte_end":507214,"line_start":1264,"line_end":1264,"column_start":12,"column_end":25},"name":"unchecked_sub","qualname":"::intrinsics::unchecked_sub","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the result of an unchecked substraction, resulting in\n undefined behavior when `x - y > T::max_value()` or `x - y < T::min_value()`.\n","sig":null,"attributes":[{"value":"cfg(not(bootstrap))","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":507167,"byte_end":507189,"line_start":1263,"line_end":1263,"column_start":5,"column_end":27}}]},{"kind":"ForeignFunction","id":{"krate":0,"index":991},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":507433,"byte_end":507446,"line_start":1269,"line_end":1269,"column_start":12,"column_end":25},"name":"unchecked_mul","qualname":"::intrinsics::unchecked_mul","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the result of an unchecked multiplication, resulting in\n undefined behavior when `x * y > T::max_value()` or `x * y < T::min_value()`.\n","sig":null,"attributes":[{"value":"cfg(not(bootstrap))","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":507399,"byte_end":507421,"line_start":1268,"line_end":1268,"column_start":5,"column_end":27}}]},{"kind":"ForeignFunction","id":{"krate":0,"index":993},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":507734,"byte_end":507745,"line_start":1275,"line_end":1275,"column_start":12,"column_end":23},"name":"rotate_left","qualname":"::intrinsics::rotate_left","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs rotate left.\n The stabilized versions of this intrinsic are available on the integer\n primitives via the `rotate_left` method. For example,\n [`std::u32::rotate_left`](../../std/primitive.u32.html#method.rotate_left)\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":995},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":508037,"byte_end":508049,"line_start":1281,"line_end":1281,"column_start":12,"column_end":24},"name":"rotate_right","qualname":"::intrinsics::rotate_right","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs rotate right.\n The stabilized versions of this intrinsic are available on the integer\n primitives via the `rotate_right` method. For example,\n [`std::u32::rotate_right`](../../std/primitive.u32.html#method.rotate_right)\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":997},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":508388,"byte_end":508403,"line_start":1287,"line_end":1287,"column_start":12,"column_end":27},"name":"overflowing_add","qualname":"::intrinsics::overflowing_add","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n The stabilized versions of this intrinsic are available on the integer\n primitives via the `wrapping_add` method. For example,\n [`std::u32::wrapping_add`](../../std/primitive.u32.html#method.wrapping_add)\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":999},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":508741,"byte_end":508756,"line_start":1292,"line_end":1292,"column_start":12,"column_end":27},"name":"overflowing_sub","qualname":"::intrinsics::overflowing_sub","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n The stabilized versions of this intrinsic are available on the integer\n primitives via the `wrapping_sub` method. For example,\n [`std::u32::wrapping_sub`](../../std/primitive.u32.html#method.wrapping_sub)\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":1001},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":509094,"byte_end":509109,"line_start":1297,"line_end":1297,"column_start":12,"column_end":27},"name":"overflowing_mul","qualname":"::intrinsics::overflowing_mul","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n The stabilized versions of this intrinsic are available on the integer\n primitives via the `wrapping_mul` method. For example,\n [`std::u32::wrapping_mul`](../../std/primitive.u32.html#method.wrapping_mul)\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":1003},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":509438,"byte_end":509452,"line_start":1303,"line_end":1303,"column_start":12,"column_end":26},"name":"saturating_add","qualname":"::intrinsics::saturating_add","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Computes `a + b`, while saturating at numeric bounds.\n The stabilized versions of this intrinsic are available on the integer\n primitives via the `saturating_add` method. For example,\n [`std::u32::saturating_add`](../../std/primitive.u32.html#method.saturating_add)\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":1005},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":509780,"byte_end":509794,"line_start":1308,"line_end":1308,"column_start":12,"column_end":26},"name":"saturating_sub","qualname":"::intrinsics::saturating_sub","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Computes `a - b`, while saturating at numeric bounds.\n The stabilized versions of this intrinsic are available on the integer\n primitives via the `saturating_sub` method. For example,\n [`std::u32::saturating_sub`](../../std/primitive.u32.html#method.saturating_sub)\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":1007},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":509962,"byte_end":509980,"line_start":1312,"line_end":1312,"column_start":12,"column_end":30},"name":"discriminant_value","qualname":"::intrinsics::discriminant_value","value":"fn <T> (v: &T) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Returns the value of the discriminant for the variant in 'v',\n cast to a `u64`; if `T` has no discriminant, returns 0.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":1009},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":510507,"byte_end":510512,"line_start":1322,"line_end":1322,"column_start":12,"column_end":17},"name":"try","qualname":"::intrinsics::try","value":"fn (f: fn(*mut u8), data: *mut u8, local_ptr: *mut u8) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Rust's \"try catch\" construct which invokes the function pointer `f` with\n the data pointer `data`.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":1010},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":510700,"byte_end":510717,"line_start":1326,"line_end":1326,"column_start":12,"column_end":29},"name":"nontemporal_store","qualname":"::intrinsics::nontemporal_store","value":"fn <T> (ptr: *mut T, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Emits a `!nontemporal` store according to LLVM (see their docs).\n Probably will never become stable.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":1012},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":514098,"byte_end":514117,"line_start":1419,"line_end":1419,"column_start":15,"column_end":34},"name":"copy_nonoverlapping","qualname":"::intrinsics::copy_nonoverlapping","value":"fn <T> (src: *const T, dst: *mut T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":514028,"byte_end":514073,"line_start":1417,"line_end":1417,"column_start":1,"column_end":46}},{"value":"inline","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":514074,"byte_end":514083,"line_start":1418,"line_end":1418,"column_start":1,"column_end":10}}]},{"kind":"Function","id":{"krate":0,"index":1017},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":516246,"byte_end":516250,"line_start":1479,"line_end":1479,"column_start":15,"column_end":19},"name":"copy","qualname":"::intrinsics::copy","value":"fn <T> (src: *const T, dst: *mut T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination may overlap.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":516176,"byte_end":516221,"line_start":1477,"line_end":1477,"column_start":1,"column_end":46}},{"value":"inline","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":516222,"byte_end":516231,"line_start":1478,"line_end":1478,"column_start":1,"column_end":10}}]},{"kind":"Function","id":{"krate":0,"index":1022},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":518546,"byte_end":518557,"line_start":1560,"line_end":1560,"column_start":15,"column_end":26},"name":"write_bytes","qualname":"::intrinsics::write_bytes","value":"fn <T> (dst: *mut T, val: u8, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n `val`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":518476,"byte_end":518521,"line_start":1558,"line_end":1558,"column_start":1,"column_end":46}},{"value":"inline","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":518522,"byte_end":518531,"line_start":1559,"line_end":1559,"column_start":1,"column_end":10}}]},{"kind":"Mod","id":{"krate":0,"index":1027},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"mem","qualname":"::mem","value":"src/libcore/mem/mod.rs","parent":null,"children":[{"krate":0,"index":1028},{"krate":0,"index":1029},{"krate":0,"index":1030},{"krate":0,"index":1031},{"krate":0,"index":1032},{"krate":0,"index":1033},{"krate":0,"index":1037},{"krate":0,"index":1038},{"krate":0,"index":1058},{"krate":0,"index":1059},{"krate":0,"index":1079},{"krate":0,"index":1080},{"krate":0,"index":1081},{"krate":0,"index":1083},{"krate":0,"index":37159},{"krate":0,"index":1085},{"krate":0,"index":1087},{"krate":0,"index":1089},{"krate":0,"index":37157},{"krate":0,"index":1091},{"krate":0,"index":1093},{"krate":0,"index":1095},{"krate":0,"index":1097},{"krate":0,"index":1099},{"krate":0,"index":1101},{"krate":0,"index":1103},{"krate":0,"index":1105},{"krate":0,"index":1107},{"krate":0,"index":1110},{"krate":0,"index":1115},{"krate":0,"index":1117},{"krate":0,"index":1120},{"krate":0,"index":1123},{"krate":0,"index":1125},{"krate":0,"index":1129},{"krate":0,"index":1132}],"decl_id":null,"docs":" Basic functions for dealing with memory.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":521093,"byte_end":521139,"line_start":6,"line_end":6,"column_start":1,"column_end":47}}]},{"kind":"Struct","id":{"krate":0,"index":14164},"span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":547723,"byte_end":547735,"line_start":52,"line_end":52,"column_start":12,"column_end":24},"name":"ManuallyDrop","qualname":"::mem::manually_drop::ManuallyDrop","value":"ManuallyDrop {  }","parent":null,"children":[{"krate":0,"index":14166}],"decl_id":null,"docs":" A wrapper to inhibit compiler from automatically calling `T`’s destructor.","sig":null,"attributes":[{"value":"stable(feature = \"manually_drop\", since = \"1.20.0\")","span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":547533,"byte_end":547587,"line_start":48,"line_end":48,"column_start":1,"column_end":55}},{"value":"lang = \"manually_drop\"","span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":547588,"byte_end":547613,"line_start":49,"line_end":49,"column_start":1,"column_end":26}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":547691,"byte_end":547711,"line_start":51,"line_end":51,"column_start":1,"column_end":21}},{"value":"structural_match","span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":547712,"byte_end":547764,"line_start":52,"line_end":54,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":547712,"byte_end":547764,"line_start":52,"line_end":54,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":1045},"span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":548075,"byte_end":548078,"line_start":67,"line_end":67,"column_start":18,"column_end":21},"name":"new","qualname":"<ManuallyDrop<T>>::new","value":"fn (value: T) -> ManuallyDrop<T>","parent":null,"children":[],"decl_id":null,"docs":" Wrap a value to be manually dropped.","sig":null,"attributes":[{"value":"stable(feature = \"manually_drop\", since = \"1.20.0\")","span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":547981,"byte_end":548035,"line_start":65,"line_end":65,"column_start":5,"column_end":59}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":548040,"byte_end":548057,"line_start":66,"line_end":66,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1046},"span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":548594,"byte_end":548604,"line_start":84,"line_end":84,"column_start":18,"column_end":28},"name":"into_inner","qualname":"<ManuallyDrop<T>>::into_inner","value":"fn (slot: ManuallyDrop<T>) -> T","parent":null,"children":[],"decl_id":null,"docs":" Extracts the value from the `ManuallyDrop` container.","sig":null,"attributes":[{"value":"stable(feature = \"manually_drop\", since = \"1.20.0\")","span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":548500,"byte_end":548554,"line_start":82,"line_end":82,"column_start":5,"column_end":59}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":548559,"byte_end":548576,"line_start":83,"line_end":83,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1047},"span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":549653,"byte_end":549657,"line_start":107,"line_end":107,"column_start":19,"column_end":23},"name":"take","qualname":"<ManuallyDrop<T>>::take","value":"fn (slot: &mut ManuallyDrop<T>) -> T","parent":null,"children":[],"decl_id":null,"docs":" Takes the contained value out.","sig":null,"attributes":[{"value":"must_use =\n      \"if you don't need the value, you can use `ManuallyDrop::drop` instead\"","span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":549470,"byte_end":549555,"line_start":104,"line_end":104,"column_start":5,"column_end":90}},{"value":"unstable(feature = \"manually_drop_take\", issue = \"55422\")","span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":549560,"byte_end":549620,"line_start":105,"line_end":105,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":549625,"byte_end":549634,"line_start":106,"line_end":106,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1050},"span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":550355,"byte_end":550359,"line_start":126,"line_end":126,"column_start":19,"column_end":23},"name":"drop","qualname":"<ManuallyDrop<T>>::drop","value":"fn (slot: &mut ManuallyDrop<T>) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Manually drops the contained value.","sig":null,"attributes":[{"value":"stable(feature = \"manually_drop\", since = \"1.20.0\")","span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":550268,"byte_end":550322,"line_start":124,"line_end":124,"column_start":5,"column_end":59}},{"value":"inline","span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":550327,"byte_end":550336,"line_start":125,"line_end":125,"column_start":5,"column_end":14}}]},{"kind":"Union","id":{"krate":0,"index":14199},"span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":559776,"byte_end":559787,"line_start":211,"line_end":211,"column_start":11,"column_end":22},"name":"MaybeUninit","qualname":"::mem::maybe_uninit::MaybeUninit","value":"MaybeUninit {  }","parent":null,"children":[{"krate":0,"index":14201},{"krate":0,"index":14202}],"decl_id":null,"docs":" A wrapper type to construct uninitialized instances of `T`.","sig":null,"attributes":[{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":559609,"byte_end":559648,"line_start":207,"line_end":207,"column_start":1,"column_end":40}},{"value":"stable(feature = \"maybe_uninit\", since = \"1.36.0\")","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":559649,"byte_end":559702,"line_start":208,"line_end":208,"column_start":1,"column_end":54}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":559746,"byte_end":559763,"line_start":210,"line_end":210,"column_start":28,"column_end":45}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":559766,"byte_end":559838,"line_start":211,"line_end":214,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":1067},"span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":560604,"byte_end":560607,"line_start":235,"line_end":235,"column_start":18,"column_end":21},"name":"new","qualname":"<MaybeUninit<T>>::new","value":"fn (val: T) -> MaybeUninit<T>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `MaybeUninit<T>` initialized with the given value.\n It is safe to call [`assume_init`] on the return value of this function.","sig":null,"attributes":[{"value":"stable(feature = \"maybe_uninit\", since = \"1.36.0\")","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":560511,"byte_end":560564,"line_start":233,"line_end":233,"column_start":5,"column_end":58}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":560569,"byte_end":560586,"line_start":234,"line_end":234,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1068},"span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":561157,"byte_end":561163,"line_start":249,"line_end":249,"column_start":18,"column_end":24},"name":"uninit","qualname":"<MaybeUninit<T>>::uninit","value":"fn () -> MaybeUninit<T>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `MaybeUninit<T>` in an uninitialized state.","sig":null,"attributes":[{"value":"stable(feature = \"maybe_uninit\", since = \"1.36.0\")","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":561064,"byte_end":561117,"line_start":247,"line_end":247,"column_start":5,"column_end":58}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":561122,"byte_end":561139,"line_start":248,"line_end":248,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1069},"span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":562756,"byte_end":562762,"line_start":290,"line_end":290,"column_start":12,"column_end":18},"name":"zeroed","qualname":"<MaybeUninit<T>>::zeroed","value":"fn () -> MaybeUninit<T>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `MaybeUninit<T>` in an uninitialized state, with the memory being\n filled with `0` bytes. It depends on `T` whether that already makes for\n proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n but `MaybeUninit<&'static i32>::zeroed()` is not because references must not\n be null.","sig":null,"attributes":[{"value":"stable(feature = \"maybe_uninit\", since = \"1.36.0\")","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":562677,"byte_end":562730,"line_start":288,"line_end":288,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":562735,"byte_end":562744,"line_start":289,"line_end":289,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1070},"span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":563347,"byte_end":563352,"line_start":304,"line_end":304,"column_start":12,"column_end":17},"name":"write","qualname":"<MaybeUninit<T>>::write","value":"fn (&mut self, val: T) -> &mut T","parent":null,"children":[],"decl_id":null,"docs":" Sets the value of the `MaybeUninit<T>`. This overwrites any previous value\n without dropping it, so be careful not to use this twice unless you want to\n skip running the destructor. For your convenience, this also returns a mutable\n reference to the (now safely initialized) contents of `self`.\n","sig":null,"attributes":[{"value":"unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":563253,"byte_end":563313,"line_start":302,"line_end":302,"column_start":5,"column_end":65}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":563318,"byte_end":563335,"line_start":303,"line_end":303,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1071},"span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":564830,"byte_end":564836,"line_start":344,"line_end":344,"column_start":12,"column_end":18},"name":"as_ptr","qualname":"<MaybeUninit<T>>::as_ptr","value":"fn (&self) -> *const T","parent":null,"children":[],"decl_id":null,"docs":" Gets a pointer to the contained value. Reading from this pointer or turning it\n into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n Writing to memory that this pointer (non-transitively) points to is undefined behavior\n (except inside an `UnsafeCell<T>`).","sig":null,"attributes":[{"value":"stable(feature = \"maybe_uninit\", since = \"1.36.0\")","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":564743,"byte_end":564796,"line_start":342,"line_end":342,"column_start":5,"column_end":58}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":564801,"byte_end":564818,"line_start":343,"line_end":343,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1072},"span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":566175,"byte_end":566185,"line_start":381,"line_end":381,"column_start":12,"column_end":22},"name":"as_mut_ptr","qualname":"<MaybeUninit<T>>::as_mut_ptr","value":"fn (&mut self) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.","sig":null,"attributes":[{"value":"stable(feature = \"maybe_uninit\", since = \"1.36.0\")","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":566088,"byte_end":566141,"line_start":379,"line_end":379,"column_start":5,"column_end":58}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":566146,"byte_end":566163,"line_start":380,"line_end":380,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1073},"span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":567632,"byte_end":567643,"line_start":422,"line_end":422,"column_start":19,"column_end":30},"name":"assume_init","qualname":"<MaybeUninit<T>>::assume_init","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Extracts the value from the `MaybeUninit<T>` container. This is a great way\n to ensure that the data will get dropped, because the resulting `T` is\n subject to the usual drop handling.","sig":null,"attributes":[{"value":"stable(feature = \"maybe_uninit\", since = \"1.36.0\")","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":567538,"byte_end":567591,"line_start":420,"line_end":420,"column_start":5,"column_end":58}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":567596,"byte_end":567613,"line_start":421,"line_end":421,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1074},"span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":570081,"byte_end":570085,"line_start":486,"line_end":486,"column_start":19,"column_end":23},"name":"read","qualname":"<MaybeUninit<T>>::read","value":"fn (&self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n to the usual drop handling.","sig":null,"attributes":[{"value":"unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":569980,"byte_end":570040,"line_start":484,"line_end":484,"column_start":5,"column_end":65}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":570045,"byte_end":570062,"line_start":485,"line_end":485,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1075},"span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":570577,"byte_end":570584,"line_start":500,"line_end":500,"column_start":19,"column_end":26},"name":"get_ref","qualname":"<MaybeUninit<T>>::get_ref","value":"fn (&self) -> &T","parent":null,"children":[],"decl_id":null,"docs":" Gets a reference to the contained value.","sig":null,"attributes":[{"value":"unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":570478,"byte_end":570536,"line_start":498,"line_end":498,"column_start":5,"column_end":63}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":570541,"byte_end":570558,"line_start":499,"line_end":499,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1076},"span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":571265,"byte_end":571272,"line_start":516,"line_end":516,"column_start":19,"column_end":26},"name":"get_mut","qualname":"<MaybeUninit<T>>::get_mut","value":"fn (&mut self) -> &mut T","parent":null,"children":[],"decl_id":null,"docs":" Gets a mutable reference to the contained value.","sig":null,"attributes":[{"value":"unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":571166,"byte_end":571224,"line_start":514,"line_end":514,"column_start":5,"column_end":63}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":571229,"byte_end":571246,"line_start":515,"line_end":515,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1077},"span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":571484,"byte_end":571493,"line_start":523,"line_end":523,"column_start":12,"column_end":21},"name":"first_ptr","qualname":"<MaybeUninit<T>>::first_ptr","value":"fn (this: &[MaybeUninit<T>]) -> *const T","parent":null,"children":[],"decl_id":null,"docs":" Gets a pointer to the first element of the array.\n","sig":null,"attributes":[{"value":"unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":571390,"byte_end":571450,"line_start":521,"line_end":521,"column_start":5,"column_end":65}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":571455,"byte_end":571472,"line_start":522,"line_end":522,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1078},"span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":571756,"byte_end":571769,"line_start":530,"line_end":530,"column_start":12,"column_end":25},"name":"first_ptr_mut","qualname":"<MaybeUninit<T>>::first_ptr_mut","value":"fn (this: &mut [MaybeUninit<T>]) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Gets a mutable pointer to the first element of the array.\n","sig":null,"attributes":[{"value":"unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":571662,"byte_end":571722,"line_start":528,"line_end":528,"column_start":5,"column_end":65}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":571727,"byte_end":571744,"line_start":529,"line_end":529,"column_start":5,"column_end":22}}]},{"kind":"Function","id":{"krate":0,"index":1081},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":523800,"byte_end":523806,"line_start":83,"line_end":83,"column_start":8,"column_end":14},"name":"forget","qualname":"::mem::forget","value":"fn <T> (t: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Takes ownership and \"forgets\" about the value **without running its destructor**.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":523737,"byte_end":523746,"line_start":81,"line_end":81,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":523747,"byte_end":523792,"line_start":82,"line_end":82,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1083},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":524121,"byte_end":524135,"line_start":95,"line_end":95,"column_start":8,"column_end":22},"name":"forget_unsized","qualname":"::mem::forget_unsized","value":"fn <T> (t: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Like [`forget`], but also accepts unsized values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":524051,"byte_end":524060,"line_start":93,"line_end":93,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"forget_unsized\", issue = \"0\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":524061,"byte_end":524113,"line_start":94,"line_end":94,"column_start":1,"column_end":53}}]},{"kind":"Function","id":{"krate":0,"index":37159},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":528702,"byte_end":528709,"line_start":242,"line_end":242,"column_start":14,"column_end":21},"name":"size_of","qualname":"::mem::size_of","value":"fn <T> () -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the size of a type in bytes.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":528613,"byte_end":528622,"line_start":239,"line_end":239,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":528623,"byte_end":528668,"line_start":240,"line_end":240,"column_start":1,"column_end":46}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":528669,"byte_end":528688,"line_start":241,"line_end":241,"column_start":1,"column_end":20}}]},{"kind":"Function","id":{"krate":0,"index":1085},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":529416,"byte_end":529427,"line_start":268,"line_end":268,"column_start":8,"column_end":19},"name":"size_of_val","qualname":"::mem::size_of_val","value":"fn <T> (val: &T) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the size of the pointed-to value in bytes.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":529353,"byte_end":529362,"line_start":266,"line_end":266,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":529363,"byte_end":529408,"line_start":267,"line_end":267,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1087},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":530099,"byte_end":530111,"line_start":291,"line_end":291,"column_start":8,"column_end":20},"name":"min_align_of","qualname":"::mem::min_align_of","value":"fn <T> () -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the [ABI]-required minimum alignment of a type.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":529964,"byte_end":529973,"line_start":288,"line_end":288,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":529974,"byte_end":530019,"line_start":289,"line_end":289,"column_start":1,"column_end":46}},{"value":"rustc_deprecated(reason = \"use `align_of` instead\", since = \"1.2.0\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":530020,"byte_end":530091,"line_start":290,"line_end":290,"column_start":1,"column_end":72}}]},{"kind":"Function","id":{"krate":0,"index":1089},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":530700,"byte_end":530716,"line_start":312,"line_end":312,"column_start":8,"column_end":24},"name":"min_align_of_val","qualname":"::mem::min_align_of_val","value":"fn <T> (val: &T) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":530561,"byte_end":530570,"line_start":309,"line_end":309,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":530571,"byte_end":530616,"line_start":310,"line_end":310,"column_start":1,"column_end":46}},{"value":"rustc_deprecated(reason = \"use `align_of_val` instead\", since = \"1.2.0\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":530617,"byte_end":530692,"line_start":311,"line_end":311,"column_start":1,"column_end":76}}]},{"kind":"Function","id":{"krate":0,"index":37157},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":531315,"byte_end":531323,"line_start":334,"line_end":334,"column_start":14,"column_end":22},"name":"align_of","qualname":"::mem::align_of","value":"fn <T> () -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the [ABI]-required minimum alignment of a type.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":531226,"byte_end":531235,"line_start":331,"line_end":331,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":531236,"byte_end":531281,"line_start":332,"line_end":332,"column_start":1,"column_end":46}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":531282,"byte_end":531301,"line_start":333,"line_end":333,"column_start":1,"column_end":20}}]},{"kind":"Function","id":{"krate":0,"index":1091},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":531804,"byte_end":531816,"line_start":353,"line_end":353,"column_start":8,"column_end":20},"name":"align_of_val","qualname":"::mem::align_of_val","value":"fn <T> (val: &T) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":531741,"byte_end":531750,"line_start":351,"line_end":351,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":531751,"byte_end":531796,"line_start":352,"line_end":352,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1093},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":534044,"byte_end":534054,"line_start":413,"line_end":413,"column_start":14,"column_end":24},"name":"needs_drop","qualname":"::mem::needs_drop","value":"fn <T> () -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if dropping values of type `T` matters.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":533969,"byte_end":533978,"line_start":411,"line_end":411,"column_start":1,"column_end":10}},{"value":"stable(feature = \"needs_drop\", since = \"1.21.0\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":533979,"byte_end":534030,"line_start":412,"line_end":412,"column_start":1,"column_end":52}}]},{"kind":"Function","id":{"krate":0,"index":1095},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":535356,"byte_end":535362,"line_start":452,"line_end":452,"column_start":15,"column_end":21},"name":"zeroed","qualname":"::mem::zeroed","value":"fn <T> () -> T","parent":null,"children":[],"decl_id":null,"docs":" Creates a value whose bytes are all zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":535286,"byte_end":535295,"line_start":450,"line_end":450,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":535296,"byte_end":535341,"line_start":451,"line_end":451,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1097},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":536665,"byte_end":536678,"line_start":478,"line_end":478,"column_start":15,"column_end":28},"name":"uninitialized","qualname":"::mem::uninitialized","value":"fn <T> () -> T","parent":null,"children":[],"decl_id":null,"docs":" Bypasses Rust's normal memory-initialization checks by pretending to\n produce a value of type `T`, while doing nothing at all.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":536514,"byte_end":536523,"line_start":475,"line_end":475,"column_start":1,"column_end":10}},{"value":"rustc_deprecated(since = \"1.38.0\",\n                   reason = \"use `mem::MaybeUninit` instead\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":536524,"byte_end":536604,"line_start":476,"line_end":476,"column_start":1,"column_end":81}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":536605,"byte_end":536650,"line_start":477,"line_end":477,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1099},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":537093,"byte_end":537097,"line_start":500,"line_end":500,"column_start":8,"column_end":12},"name":"swap","qualname":"::mem::swap","value":"fn <T> (x: &mut T, y: &mut T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Swaps the values at two mutable locations, without deinitializing either one.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":537030,"byte_end":537039,"line_start":498,"line_end":498,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":537040,"byte_end":537085,"line_start":499,"line_end":499,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1101},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":538593,"byte_end":538597,"line_start":560,"line_end":560,"column_start":8,"column_end":12},"name":"take","qualname":"::mem::take","value":"fn <T> (dest: &mut T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Replace `dest` with the default value of `T`, and return the previous `dest` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":538525,"byte_end":538534,"line_start":558,"line_end":558,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"mem_take\", issue = \"61129\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":538535,"byte_end":538585,"line_start":559,"line_end":559,"column_start":1,"column_end":51}}]},{"kind":"Function","id":{"krate":0,"index":1103},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":540098,"byte_end":540105,"line_start":617,"line_end":617,"column_start":8,"column_end":15},"name":"replace","qualname":"::mem::replace","value":"fn <T> (dest: &mut T, mut src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Moves `src` into the referenced `dest`, returning the previous `dest` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":540035,"byte_end":540044,"line_start":615,"line_end":615,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":540045,"byte_end":540090,"line_start":616,"line_end":616,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1105},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":541792,"byte_end":541796,"line_start":686,"line_end":686,"column_start":8,"column_end":12},"name":"drop","qualname":"::mem::drop","value":"fn <T> (_x: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Disposes of a value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":541729,"byte_end":541738,"line_start":684,"line_end":684,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":541739,"byte_end":541784,"line_start":685,"line_end":685,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1107},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":543155,"byte_end":543169,"line_start":731,"line_end":731,"column_start":15,"column_end":29},"name":"transmute_copy","qualname":"::mem::transmute_copy","value":"fn <T, U> (src: &T) -> U","parent":null,"children":[],"decl_id":null,"docs":" Interprets `src` as having type `&U`, and then reads `src` without moving\n the contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":543085,"byte_end":543094,"line_start":729,"line_end":729,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":543095,"byte_end":543140,"line_start":730,"line_end":730,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":1110},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":543503,"byte_end":543515,"line_start":741,"line_end":741,"column_start":12,"column_end":24},"name":"Discriminant","qualname":"::mem::Discriminant","value":"","parent":null,"children":[],"decl_id":null,"docs":" Opaque type representing the discriminant of an enum.","sig":null,"attributes":[{"value":"stable(feature = \"discriminant_value\", since = \"1.21.0\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":543432,"byte_end":543491,"line_start":740,"line_end":740,"column_start":1,"column_end":60}}]},{"kind":"Function","id":{"krate":0,"index":1132},"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":545557,"byte_end":545569,"line_start":806,"line_end":806,"column_start":8,"column_end":20},"name":"discriminant","qualname":"::mem::discriminant","value":"fn <T> (v: &T) -> Discriminant<T>","parent":null,"children":[],"decl_id":null,"docs":" Returns a value uniquely identifying the enum variant in `v`.","sig":null,"attributes":[{"value":"stable(feature = \"discriminant_value\", since = \"1.21.0\")","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":545490,"byte_end":545549,"line_start":805,"line_end":805,"column_start":1,"column_end":60}}]},{"kind":"Mod","id":{"krate":0,"index":1134},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"ptr","qualname":"::ptr","value":"src/libcore/ptr/mod.rs","parent":null,"children":[{"krate":0,"index":1135},{"krate":0,"index":1136},{"krate":0,"index":1137},{"krate":0,"index":1138},{"krate":0,"index":1141},{"krate":0,"index":1146},{"krate":0,"index":1147},{"krate":0,"index":1148},{"krate":0,"index":1149},{"krate":0,"index":1220},{"krate":0,"index":1221},{"krate":0,"index":1277},{"krate":0,"index":1278},{"krate":0,"index":1280},{"krate":0,"index":37155},{"krate":0,"index":37153},{"krate":0,"index":1282},{"krate":0,"index":1287},{"krate":0,"index":1291},{"krate":0,"index":1293},{"krate":0,"index":1295},{"krate":0,"index":1297},{"krate":0,"index":1299},{"krate":0,"index":1301},{"krate":0,"index":1314},{"krate":0,"index":1316},{"krate":0,"index":1318},{"krate":0,"index":1320},{"krate":0,"index":1322},{"krate":0,"index":1324},{"krate":0,"index":1326},{"krate":0,"index":1328},{"krate":0,"index":1349},{"krate":0,"index":1381},{"krate":0,"index":1388},{"krate":0,"index":1391},{"krate":0,"index":1393},{"krate":0,"index":1396},{"krate":0,"index":1398},{"krate":0,"index":1400},{"krate":0,"index":1404},{"krate":0,"index":1405},{"krate":0,"index":14205},{"krate":0,"index":14208},{"krate":0,"index":14210},{"krate":0,"index":14213},{"krate":0,"index":14216},{"krate":0,"index":14220},{"krate":0,"index":14223},{"krate":0,"index":14226},{"krate":0,"index":14229},{"krate":0,"index":14231},{"krate":0,"index":14234},{"krate":0,"index":14237},{"krate":0,"index":14241},{"krate":0,"index":14244},{"krate":0,"index":14247},{"krate":0,"index":14250},{"krate":0,"index":14252},{"krate":0,"index":14255},{"krate":0,"index":14258},{"krate":0,"index":14262},{"krate":0,"index":14265},{"krate":0,"index":14268},{"krate":0,"index":14271},{"krate":0,"index":14273},{"krate":0,"index":14276},{"krate":0,"index":14279},{"krate":0,"index":14283},{"krate":0,"index":14286},{"krate":0,"index":14289},{"krate":0,"index":14293},{"krate":0,"index":14296},{"krate":0,"index":14300},{"krate":0,"index":14304},{"krate":0,"index":14309},{"krate":0,"index":14313},{"krate":0,"index":14317},{"krate":0,"index":14321},{"krate":0,"index":14324},{"krate":0,"index":14328},{"krate":0,"index":14332},{"krate":0,"index":14337},{"krate":0,"index":14341},{"krate":0,"index":14345},{"krate":0,"index":14349},{"krate":0,"index":14352},{"krate":0,"index":14356},{"krate":0,"index":14360},{"krate":0,"index":14365},{"krate":0,"index":14369},{"krate":0,"index":14373},{"krate":0,"index":14377},{"krate":0,"index":14380},{"krate":0,"index":14384},{"krate":0,"index":14388},{"krate":0,"index":14393},{"krate":0,"index":14397},{"krate":0,"index":14401},{"krate":0,"index":14405},{"krate":0,"index":14408},{"krate":0,"index":14412},{"krate":0,"index":14416},{"krate":0,"index":14421},{"krate":0,"index":14425},{"krate":0,"index":14429},{"krate":0,"index":14433},{"krate":0,"index":14436},{"krate":0,"index":14440},{"krate":0,"index":14444},{"krate":0,"index":14449},{"krate":0,"index":14453},{"krate":0,"index":14457},{"krate":0,"index":14462},{"krate":0,"index":14466},{"krate":0,"index":14471},{"krate":0,"index":14476},{"krate":0,"index":14482},{"krate":0,"index":14487},{"krate":0,"index":14492},{"krate":0,"index":14497},{"krate":0,"index":14501},{"krate":0,"index":14506},{"krate":0,"index":14511},{"krate":0,"index":14517},{"krate":0,"index":14522},{"krate":0,"index":14527},{"krate":0,"index":14532},{"krate":0,"index":14536},{"krate":0,"index":14541},{"krate":0,"index":14546},{"krate":0,"index":14552},{"krate":0,"index":14557},{"krate":0,"index":14562},{"krate":0,"index":14567},{"krate":0,"index":14571},{"krate":0,"index":14576},{"krate":0,"index":14581},{"krate":0,"index":14587},{"krate":0,"index":14592},{"krate":0,"index":14597},{"krate":0,"index":14602},{"krate":0,"index":14606},{"krate":0,"index":14611},{"krate":0,"index":14616},{"krate":0,"index":14622},{"krate":0,"index":14627},{"krate":0,"index":14632},{"krate":0,"index":14637},{"krate":0,"index":14641},{"krate":0,"index":14646},{"krate":0,"index":14651},{"krate":0,"index":14657},{"krate":0,"index":14662},{"krate":0,"index":14667},{"krate":0,"index":14673},{"krate":0,"index":14678},{"krate":0,"index":14684},{"krate":0,"index":14690},{"krate":0,"index":14697},{"krate":0,"index":14703},{"krate":0,"index":14709},{"krate":0,"index":14715},{"krate":0,"index":14720},{"krate":0,"index":14726},{"krate":0,"index":14732},{"krate":0,"index":14739},{"krate":0,"index":14745},{"krate":0,"index":14751},{"krate":0,"index":14757},{"krate":0,"index":14762},{"krate":0,"index":14768},{"krate":0,"index":14774},{"krate":0,"index":14781},{"krate":0,"index":14787},{"krate":0,"index":14793},{"krate":0,"index":14799},{"krate":0,"index":14804},{"krate":0,"index":14810},{"krate":0,"index":14816},{"krate":0,"index":14823},{"krate":0,"index":14829},{"krate":0,"index":14835},{"krate":0,"index":14841},{"krate":0,"index":14846},{"krate":0,"index":14852},{"krate":0,"index":14858},{"krate":0,"index":14865},{"krate":0,"index":14871},{"krate":0,"index":14877},{"krate":0,"index":14883},{"krate":0,"index":14888},{"krate":0,"index":14894},{"krate":0,"index":14900},{"krate":0,"index":14907},{"krate":0,"index":14913},{"krate":0,"index":14919},{"krate":0,"index":14926},{"krate":0,"index":14932},{"krate":0,"index":14939},{"krate":0,"index":14946},{"krate":0,"index":14954},{"krate":0,"index":14961},{"krate":0,"index":14968},{"krate":0,"index":14975},{"krate":0,"index":14981},{"krate":0,"index":14988},{"krate":0,"index":14995},{"krate":0,"index":15003},{"krate":0,"index":15010},{"krate":0,"index":15017},{"krate":0,"index":15024},{"krate":0,"index":15030},{"krate":0,"index":15037},{"krate":0,"index":15044},{"krate":0,"index":15052},{"krate":0,"index":15059},{"krate":0,"index":15066},{"krate":0,"index":15073},{"krate":0,"index":15079},{"krate":0,"index":15086},{"krate":0,"index":15093},{"krate":0,"index":15101},{"krate":0,"index":15108},{"krate":0,"index":15115},{"krate":0,"index":15122},{"krate":0,"index":15128},{"krate":0,"index":15135},{"krate":0,"index":15142},{"krate":0,"index":15150},{"krate":0,"index":15157},{"krate":0,"index":15164},{"krate":0,"index":15171},{"krate":0,"index":15177},{"krate":0,"index":15184},{"krate":0,"index":15191},{"krate":0,"index":15199},{"krate":0,"index":15206},{"krate":0,"index":15213},{"krate":0,"index":15221},{"krate":0,"index":15228},{"krate":0,"index":15236},{"krate":0,"index":15244},{"krate":0,"index":15253},{"krate":0,"index":15261},{"krate":0,"index":15269},{"krate":0,"index":15277},{"krate":0,"index":15284},{"krate":0,"index":15292},{"krate":0,"index":15300},{"krate":0,"index":15309},{"krate":0,"index":15317},{"krate":0,"index":15325},{"krate":0,"index":15333},{"krate":0,"index":15340},{"krate":0,"index":15348},{"krate":0,"index":15356},{"krate":0,"index":15365},{"krate":0,"index":15373},{"krate":0,"index":15381},{"krate":0,"index":15389},{"krate":0,"index":15396},{"krate":0,"index":15404},{"krate":0,"index":15412},{"krate":0,"index":15421},{"krate":0,"index":15429},{"krate":0,"index":15437},{"krate":0,"index":15445},{"krate":0,"index":15452},{"krate":0,"index":15460},{"krate":0,"index":15468},{"krate":0,"index":15477},{"krate":0,"index":15485},{"krate":0,"index":15493},{"krate":0,"index":15501},{"krate":0,"index":15508},{"krate":0,"index":15516},{"krate":0,"index":15524},{"krate":0,"index":15533},{"krate":0,"index":15541},{"krate":0,"index":15549},{"krate":0,"index":15558},{"krate":0,"index":15566},{"krate":0,"index":15575},{"krate":0,"index":15584},{"krate":0,"index":15594},{"krate":0,"index":15603},{"krate":0,"index":15612},{"krate":0,"index":15621},{"krate":0,"index":15629},{"krate":0,"index":15638},{"krate":0,"index":15647},{"krate":0,"index":15657},{"krate":0,"index":15666},{"krate":0,"index":15675},{"krate":0,"index":15684},{"krate":0,"index":15692},{"krate":0,"index":15701},{"krate":0,"index":15710},{"krate":0,"index":15720},{"krate":0,"index":15729},{"krate":0,"index":15738},{"krate":0,"index":15747},{"krate":0,"index":15755},{"krate":0,"index":15764},{"krate":0,"index":15773},{"krate":0,"index":15783},{"krate":0,"index":15792},{"krate":0,"index":15801},{"krate":0,"index":15810},{"krate":0,"index":15818},{"krate":0,"index":15827},{"krate":0,"index":15836},{"krate":0,"index":15846},{"krate":0,"index":15855},{"krate":0,"index":15864},{"krate":0,"index":15873},{"krate":0,"index":15881},{"krate":0,"index":15890},{"krate":0,"index":15899},{"krate":0,"index":15909},{"krate":0,"index":15918},{"krate":0,"index":15927},{"krate":0,"index":15937},{"krate":0,"index":15946},{"krate":0,"index":15956},{"krate":0,"index":15966},{"krate":0,"index":15977},{"krate":0,"index":15987},{"krate":0,"index":15997},{"krate":0,"index":16007},{"krate":0,"index":16016},{"krate":0,"index":16026},{"krate":0,"index":16036},{"krate":0,"index":16047},{"krate":0,"index":16057},{"krate":0,"index":16067},{"krate":0,"index":16077},{"krate":0,"index":16086},{"krate":0,"index":16096},{"krate":0,"index":16106},{"krate":0,"index":16117},{"krate":0,"index":16127},{"krate":0,"index":16137},{"krate":0,"index":16147},{"krate":0,"index":16156},{"krate":0,"index":16166},{"krate":0,"index":16176},{"krate":0,"index":16187},{"krate":0,"index":16197},{"krate":0,"index":16207},{"krate":0,"index":16217},{"krate":0,"index":16226},{"krate":0,"index":16236},{"krate":0,"index":16246},{"krate":0,"index":16257},{"krate":0,"index":16267},{"krate":0,"index":16277},{"krate":0,"index":16287},{"krate":0,"index":16296},{"krate":0,"index":16306},{"krate":0,"index":16316},{"krate":0,"index":16327},{"krate":0,"index":16337},{"krate":0,"index":16347},{"krate":0,"index":16358},{"krate":0,"index":16368},{"krate":0,"index":16379},{"krate":0,"index":16390},{"krate":0,"index":16402},{"krate":0,"index":16413},{"krate":0,"index":16424},{"krate":0,"index":16435},{"krate":0,"index":16445},{"krate":0,"index":16456},{"krate":0,"index":16467},{"krate":0,"index":16479},{"krate":0,"index":16490},{"krate":0,"index":16501},{"krate":0,"index":16512},{"krate":0,"index":16522},{"krate":0,"index":16533},{"krate":0,"index":16544},{"krate":0,"index":16556},{"krate":0,"index":16567},{"krate":0,"index":16578},{"krate":0,"index":16589},{"krate":0,"index":16599},{"krate":0,"index":16610},{"krate":0,"index":16621},{"krate":0,"index":16633},{"krate":0,"index":16644},{"krate":0,"index":16655},{"krate":0,"index":16666},{"krate":0,"index":16676},{"krate":0,"index":16687},{"krate":0,"index":16698},{"krate":0,"index":16710},{"krate":0,"index":16721},{"krate":0,"index":16732},{"krate":0,"index":16743},{"krate":0,"index":16753},{"krate":0,"index":16764},{"krate":0,"index":16775},{"krate":0,"index":16787},{"krate":0,"index":16798},{"krate":0,"index":16809},{"krate":0,"index":16821},{"krate":0,"index":16832},{"krate":0,"index":16844},{"krate":0,"index":16856},{"krate":0,"index":16869},{"krate":0,"index":16881},{"krate":0,"index":16893},{"krate":0,"index":16905},{"krate":0,"index":16916},{"krate":0,"index":16928},{"krate":0,"index":16940},{"krate":0,"index":16953},{"krate":0,"index":16965},{"krate":0,"index":16977},{"krate":0,"index":16989},{"krate":0,"index":17000},{"krate":0,"index":17012},{"krate":0,"index":17024},{"krate":0,"index":17037},{"krate":0,"index":17049},{"krate":0,"index":17061},{"krate":0,"index":17073},{"krate":0,"index":17084},{"krate":0,"index":17096},{"krate":0,"index":17108},{"krate":0,"index":17121},{"krate":0,"index":17133},{"krate":0,"index":17145},{"krate":0,"index":17157},{"krate":0,"index":17168},{"krate":0,"index":17180},{"krate":0,"index":17192},{"krate":0,"index":17205},{"krate":0,"index":17217},{"krate":0,"index":17229},{"krate":0,"index":17241},{"krate":0,"index":17252},{"krate":0,"index":17264},{"krate":0,"index":17276},{"krate":0,"index":17289},{"krate":0,"index":17301},{"krate":0,"index":17313},{"krate":0,"index":17326},{"krate":0,"index":17338},{"krate":0,"index":17351},{"krate":0,"index":17364},{"krate":0,"index":17378},{"krate":0,"index":17391},{"krate":0,"index":17404},{"krate":0,"index":17417},{"krate":0,"index":17429},{"krate":0,"index":17442},{"krate":0,"index":17455},{"krate":0,"index":17469},{"krate":0,"index":17482},{"krate":0,"index":17495},{"krate":0,"index":17508},{"krate":0,"index":17520},{"krate":0,"index":17533},{"krate":0,"index":17546},{"krate":0,"index":17560},{"krate":0,"index":17573},{"krate":0,"index":17586},{"krate":0,"index":17599},{"krate":0,"index":17611},{"krate":0,"index":17624},{"krate":0,"index":17637},{"krate":0,"index":17651},{"krate":0,"index":17664},{"krate":0,"index":17677},{"krate":0,"index":17690},{"krate":0,"index":17702},{"krate":0,"index":17715},{"krate":0,"index":17728},{"krate":0,"index":17742},{"krate":0,"index":17755},{"krate":0,"index":17768},{"krate":0,"index":17781},{"krate":0,"index":17793},{"krate":0,"index":17806},{"krate":0,"index":17819},{"krate":0,"index":17833},{"krate":0,"index":17846},{"krate":0,"index":17859},{"krate":0,"index":17873},{"krate":0,"index":17886},{"krate":0,"index":17900},{"krate":0,"index":17914},{"krate":0,"index":17929},{"krate":0,"index":17943},{"krate":0,"index":17957},{"krate":0,"index":17971},{"krate":0,"index":17984},{"krate":0,"index":17998},{"krate":0,"index":18012},{"krate":0,"index":18027},{"krate":0,"index":18041},{"krate":0,"index":18055},{"krate":0,"index":18069},{"krate":0,"index":18082},{"krate":0,"index":18096},{"krate":0,"index":18110},{"krate":0,"index":18125},{"krate":0,"index":18139},{"krate":0,"index":18153},{"krate":0,"index":18167},{"krate":0,"index":18180},{"krate":0,"index":18194},{"krate":0,"index":18208},{"krate":0,"index":18223},{"krate":0,"index":18237},{"krate":0,"index":18251},{"krate":0,"index":18265},{"krate":0,"index":18278},{"krate":0,"index":18292},{"krate":0,"index":18306},{"krate":0,"index":18321},{"krate":0,"index":18335},{"krate":0,"index":18349},{"krate":0,"index":18363},{"krate":0,"index":18376},{"krate":0,"index":18390},{"krate":0,"index":18404},{"krate":0,"index":18419},{"krate":0,"index":18433},{"krate":0,"index":18447},{"krate":0,"index":18462},{"krate":0,"index":18476},{"krate":0,"index":18491},{"krate":0,"index":18506},{"krate":0,"index":18522},{"krate":0,"index":18537},{"krate":0,"index":18552},{"krate":0,"index":18567},{"krate":0,"index":18581},{"krate":0,"index":18596},{"krate":0,"index":18611},{"krate":0,"index":18627},{"krate":0,"index":18642},{"krate":0,"index":18657},{"krate":0,"index":18672},{"krate":0,"index":18686},{"krate":0,"index":18701},{"krate":0,"index":18716},{"krate":0,"index":18732},{"krate":0,"index":18747},{"krate":0,"index":18762},{"krate":0,"index":18777},{"krate":0,"index":18791},{"krate":0,"index":18806},{"krate":0,"index":18821},{"krate":0,"index":18837},{"krate":0,"index":18852},{"krate":0,"index":18867},{"krate":0,"index":18882},{"krate":0,"index":18896},{"krate":0,"index":18911},{"krate":0,"index":18926},{"krate":0,"index":18942},{"krate":0,"index":18957},{"krate":0,"index":18972},{"krate":0,"index":18987},{"krate":0,"index":19001},{"krate":0,"index":19016},{"krate":0,"index":19031},{"krate":0,"index":19047},{"krate":0,"index":19062},{"krate":0,"index":1406},{"krate":0,"index":1409},{"krate":0,"index":1416},{"krate":0,"index":1419}],"decl_id":null,"docs":" Manually manage memory through raw pointers.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":575274,"byte_end":575320,"line_start":64,"line_end":64,"column_start":1,"column_end":47}}]},{"kind":"Struct","id":{"krate":0,"index":1160},"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":673247,"byte_end":673254,"line_start":42,"line_end":42,"column_start":12,"column_end":19},"name":"NonNull","qualname":"::ptr::non_null::NonNull","value":"NonNull {  }","parent":null,"children":[{"krate":0,"index":1162}],"decl_id":null,"docs":" `*mut T` but non-zero and covariant.","sig":null,"attributes":[{"value":"stable(feature = \"nonnull\", since = \"1.25.0\")","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":673055,"byte_end":673103,"line_start":38,"line_end":38,"column_start":1,"column_end":49}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":673104,"byte_end":673124,"line_start":39,"line_end":39,"column_start":1,"column_end":21}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":673125,"byte_end":673168,"line_start":40,"line_end":40,"column_start":1,"column_end":44}},{"value":"rustc_nonnull_optimization_guaranteed","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":673196,"byte_end":673233,"line_start":41,"line_end":41,"column_start":28,"column_end":65}}]},{"kind":"Method","id":{"krate":0,"index":1169},"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":674360,"byte_end":674368,"line_start":68,"line_end":68,"column_start":18,"column_end":26},"name":"dangling","qualname":"<NonNull<T>>::dangling","value":"fn () -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `NonNull` that is dangling, but well-aligned.","sig":null,"attributes":[{"value":"stable(feature = \"nonnull\", since = \"1.25.0\")","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":674280,"byte_end":674328,"line_start":66,"line_end":66,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":674333,"byte_end":674342,"line_start":67,"line_end":67,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1172},"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":674729,"byte_end":674742,"line_start":84,"line_end":84,"column_start":25,"column_end":38},"name":"new_unchecked","qualname":"<NonNull<T>>::new_unchecked","value":"fn (ptr: *mut T) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `NonNull`.","sig":null,"attributes":[{"value":"stable(feature = \"nonnull\", since = \"1.25.0\")","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":674642,"byte_end":674690,"line_start":82,"line_end":82,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":674695,"byte_end":674704,"line_start":83,"line_end":83,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1173},"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":674943,"byte_end":674946,"line_start":91,"line_end":91,"column_start":12,"column_end":15},"name":"new","qualname":"<NonNull<T>>::new","value":"fn (ptr: *mut T) -> Option<Self>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `NonNull` if `ptr` is non-null.\n","sig":null,"attributes":[{"value":"stable(feature = \"nonnull\", since = \"1.25.0\")","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":674869,"byte_end":674917,"line_start":89,"line_end":89,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":674922,"byte_end":674931,"line_start":90,"line_end":90,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1174},"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":675243,"byte_end":675249,"line_start":102,"line_end":102,"column_start":18,"column_end":24},"name":"as_ptr","qualname":"<NonNull<T>>::as_ptr","value":"fn (self) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Acquires the underlying `*mut` pointer.\n","sig":null,"attributes":[{"value":"stable(feature = \"nonnull\", since = \"1.25.0\")","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":675163,"byte_end":675211,"line_start":100,"line_end":100,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":675216,"byte_end":675225,"line_start":101,"line_end":101,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1175},"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":675648,"byte_end":675654,"line_start":113,"line_end":113,"column_start":19,"column_end":25},"name":"as_ref","qualname":"<NonNull<T>>::as_ref","value":"fn (&self) -> &T","parent":null,"children":[],"decl_id":null,"docs":" Dereferences the content.","sig":null,"attributes":[{"value":"stable(feature = \"nonnull\", since = \"1.25.0\")","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":675567,"byte_end":675615,"line_start":111,"line_end":111,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":675620,"byte_end":675629,"line_start":112,"line_end":112,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1176},"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":676055,"byte_end":676061,"line_start":124,"line_end":124,"column_start":19,"column_end":25},"name":"as_mut","qualname":"<NonNull<T>>::as_mut","value":"fn (&mut self) -> &mut T","parent":null,"children":[],"decl_id":null,"docs":" Mutably dereferences the content.","sig":null,"attributes":[{"value":"stable(feature = \"nonnull\", since = \"1.25.0\")","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":675974,"byte_end":676022,"line_start":122,"line_end":122,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":676027,"byte_end":676036,"line_start":123,"line_end":123,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1177},"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":676251,"byte_end":676255,"line_start":131,"line_end":131,"column_start":18,"column_end":22},"name":"cast","qualname":"<NonNull<T>>::cast","value":"fn <U> (self) -> NonNull<U>","parent":null,"children":[],"decl_id":null,"docs":" Cast to a pointer of another type\n","sig":null,"attributes":[{"value":"stable(feature = \"nonnull_cast\", since = \"1.27.0\")","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":676166,"byte_end":676219,"line_start":129,"line_end":129,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":676224,"byte_end":676233,"line_start":130,"line_end":130,"column_start":5,"column_end":14}}]},{"kind":"Struct","id":{"krate":0,"index":1232},"span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":680522,"byte_end":680528,"line_start":34,"line_end":34,"column_start":12,"column_end":18},"name":"Unique","qualname":"::ptr::unique::Unique","value":"Unique {  }","parent":null,"children":[{"krate":0,"index":1234},{"krate":0,"index":1235}],"decl_id":null,"docs":" A wrapper around a raw non-null `*mut T` that indicates that the possessor\n of this wrapper owns the referent. Useful for building abstractions like\n `Box<T>`, `Vec<T>`, `String`, and `HashMap<K, V>`.","sig":null,"attributes":[{"value":"unstable(feature = \"ptr_internals\",\n           issue = \"0\",\n           reason =\n               \"use NonNull instead and consider PhantomData<T> \\\n                     (if you also use #[may_dangle]), Send, and/or Sync\")","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":680234,"byte_end":680430,"line_start":28,"line_end":30,"column_start":1,"column_end":75}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":680446,"byte_end":680466,"line_start":32,"line_end":32,"column_start":1,"column_end":21}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":680467,"byte_end":680510,"line_start":33,"line_end":33,"column_start":1,"column_end":44}}]},{"kind":"Method","id":{"krate":0,"index":1242},"span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":682140,"byte_end":682145,"line_start":71,"line_end":71,"column_start":18,"column_end":23},"name":"empty","qualname":"<Unique<T>>::empty","value":"fn () -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Unique` that is dangling, but well-aligned.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":682113,"byte_end":682122,"line_start":70,"line_end":70,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1245},"span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":682475,"byte_end":682488,"line_start":86,"line_end":86,"column_start":25,"column_end":38},"name":"new_unchecked","qualname":"<Unique<T>>::new_unchecked","value":"fn (ptr: *mut T) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Unique`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":682441,"byte_end":682450,"line_start":85,"line_end":85,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1246},"span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":682656,"byte_end":682659,"line_start":92,"line_end":92,"column_start":12,"column_end":15},"name":"new","qualname":"<Unique<T>>::new","value":"fn (ptr: *mut T) -> Option<Self>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Unique` if `ptr` is non-null.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":682635,"byte_end":682644,"line_start":91,"line_end":91,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1247},"span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":682929,"byte_end":682935,"line_start":102,"line_end":102,"column_start":18,"column_end":24},"name":"as_ptr","qualname":"<Unique<T>>::as_ptr","value":"fn (self) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Acquires the underlying `*mut` pointer.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":682902,"byte_end":682911,"line_start":101,"line_end":101,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1248},"span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":683281,"byte_end":683287,"line_start":112,"line_end":112,"column_start":19,"column_end":25},"name":"as_ref","qualname":"<Unique<T>>::as_ref","value":"fn (&self) -> &T","parent":null,"children":[],"decl_id":null,"docs":" Dereferences the content.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":683253,"byte_end":683262,"line_start":111,"line_end":111,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1249},"span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":683635,"byte_end":683641,"line_start":122,"line_end":122,"column_start":19,"column_end":25},"name":"as_mut","qualname":"<Unique<T>>::as_mut","value":"fn (&mut self) -> &mut T","parent":null,"children":[],"decl_id":null,"docs":" Mutably dereferences the content.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":683607,"byte_end":683616,"line_start":121,"line_end":121,"column_start":5,"column_end":14}}]},{"kind":"Function","id":{"krate":0,"index":1278},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":579117,"byte_end":579130,"line_start":186,"line_end":186,"column_start":15,"column_end":28},"name":"drop_in_place","qualname":"::ptr::drop_in_place","value":"fn <T> (to_drop: *mut T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Executes the destructor (if any) of the pointed-to value.","sig":null,"attributes":[{"value":"stable(feature = \"drop_in_place\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":579031,"byte_end":579084,"line_start":184,"line_end":184,"column_start":1,"column_end":54}},{"value":"inline(always)","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":579085,"byte_end":579102,"line_start":185,"line_end":185,"column_start":1,"column_end":18}}]},{"kind":"Function","id":{"krate":0,"index":37155},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":580070,"byte_end":580074,"line_start":216,"line_end":216,"column_start":14,"column_end":18},"name":"null","qualname":"::ptr::null","value":"fn <T> () -> *const T","parent":null,"children":[],"decl_id":null,"docs":" Creates a null raw pointer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":579981,"byte_end":579990,"line_start":213,"line_end":213,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":579991,"byte_end":580036,"line_start":214,"line_end":214,"column_start":1,"column_end":46}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":580037,"byte_end":580056,"line_start":215,"line_end":215,"column_start":1,"column_end":20}}]},{"kind":"Function","id":{"krate":0,"index":37153},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":580366,"byte_end":580374,"line_start":231,"line_end":231,"column_start":14,"column_end":22},"name":"null_mut","qualname":"::ptr::null_mut","value":"fn <T> () -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Creates a null mutable raw pointer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":580277,"byte_end":580286,"line_start":228,"line_end":228,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":580287,"byte_end":580332,"line_start":229,"line_end":229,"column_start":1,"column_end":46}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":580333,"byte_end":580352,"line_start":230,"line_end":230,"column_start":1,"column_end":20}}]},{"kind":"Function","id":{"krate":0,"index":1291},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":581210,"byte_end":581230,"line_start":264,"line_end":264,"column_start":8,"column_end":28},"name":"slice_from_raw_parts","qualname":"::ptr::slice_from_raw_parts","value":"fn <T> (data: *const T, len: usize) -> *const [T]","parent":null,"children":[],"decl_id":null,"docs":" Forms a slice from a pointer and a length.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":581103,"byte_end":581112,"line_start":262,"line_end":262,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"slice_from_raw_parts\",\n           reason = \"recently added\",\n           issue = \"36925\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":581113,"byte_end":581202,"line_start":263,"line_end":263,"column_start":1,"column_end":90}}]},{"kind":"Function","id":{"krate":0,"index":1293},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":581684,"byte_end":581708,"line_start":276,"line_end":276,"column_start":8,"column_end":32},"name":"slice_from_raw_parts_mut","qualname":"::ptr::slice_from_raw_parts_mut","value":"fn <T> (data: *mut T, len: usize) -> *mut [T]","parent":null,"children":[],"decl_id":null,"docs":" Performs the same functionality as [`from_raw_parts`], except that a\n mutable slice is returned.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":581577,"byte_end":581586,"line_start":274,"line_end":274,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"slice_from_raw_parts\",\n           reason = \"recently added\",\n           issue = \"36925\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":581587,"byte_end":581676,"line_start":275,"line_end":275,"column_start":1,"column_end":90}}]},{"kind":"Function","id":{"krate":0,"index":1295},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":583979,"byte_end":583983,"line_start":347,"line_end":347,"column_start":15,"column_end":19},"name":"swap","qualname":"::ptr::swap","value":"fn <T> (x: *mut T, y: *mut T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Swaps the values at two mutable locations of the same type, without\n deinitializing either.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":583909,"byte_end":583918,"line_start":345,"line_end":345,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":583919,"byte_end":583964,"line_start":346,"line_end":346,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1297},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":585518,"byte_end":585537,"line_start":398,"line_end":398,"column_start":15,"column_end":34},"name":"swap_nonoverlapping","qualname":"::ptr::swap_nonoverlapping","value":"fn <T> (x: *mut T, y: *mut T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Swaps `count * size_of::<T>()` bytes between the two regions of memory\n beginning at `x` and `y`. The two regions must *not* overlap.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":585433,"byte_end":585442,"line_start":396,"line_end":396,"column_start":1,"column_end":10}},{"value":"stable(feature = \"swap_nonoverlapping\", since = \"1.27.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":585443,"byte_end":585503,"line_start":397,"line_end":397,"column_start":1,"column_end":61}}]},{"kind":"Function","id":{"krate":0,"index":1314},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":589145,"byte_end":589152,"line_start":507,"line_end":507,"column_start":15,"column_end":22},"name":"replace","qualname":"::ptr::replace","value":"fn <T> (dst: *mut T, mut src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Moves `src` into the pointed `dst`, returning the previous `dst` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":589075,"byte_end":589084,"line_start":505,"line_end":505,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":589085,"byte_end":589130,"line_start":506,"line_end":506,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1316},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":592648,"byte_end":592652,"line_start":621,"line_end":621,"column_start":15,"column_end":19},"name":"read","qualname":"::ptr::read","value":"fn <T> (src: *const T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Reads the value from `src` without moving it. This leaves the\n memory in `src` unchanged.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":592578,"byte_end":592587,"line_start":619,"line_end":619,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":592588,"byte_end":592633,"line_start":620,"line_end":620,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1318},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":594653,"byte_end":594667,"line_start":688,"line_end":688,"column_start":15,"column_end":29},"name":"read_unaligned","qualname":"::ptr::read_unaligned","value":"fn <T> (src: *const T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Reads the value from `src` without moving it. This leaves the\n memory in `src` unchanged.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":594574,"byte_end":594583,"line_start":686,"line_end":686,"column_start":1,"column_end":10}},{"value":"stable(feature = \"ptr_unaligned\", since = \"1.17.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":594584,"byte_end":594638,"line_start":687,"line_end":687,"column_start":1,"column_end":55}}]},{"kind":"Function","id":{"krate":0,"index":1320},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":597530,"byte_end":597535,"line_start":782,"line_end":782,"column_start":15,"column_end":20},"name":"write","qualname":"::ptr::write","value":"fn <T> (dst: *mut T, src: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Overwrites a memory location with the given value without reading or\n dropping the old value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":597460,"byte_end":597469,"line_start":780,"line_end":780,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":597470,"byte_end":597515,"line_start":781,"line_end":781,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1322},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":599511,"byte_end":599526,"line_start":848,"line_end":848,"column_start":15,"column_end":30},"name":"write_unaligned","qualname":"::ptr::write_unaligned","value":"fn <T> (dst: *mut T, src: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Overwrites a memory location with the given value without reading or\n dropping the old value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":599432,"byte_end":599441,"line_start":846,"line_end":846,"column_start":1,"column_end":10}},{"value":"stable(feature = \"ptr_unaligned\", since = \"1.17.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":599442,"byte_end":599496,"line_start":847,"line_end":847,"column_start":1,"column_end":55}}]},{"kind":"Function","id":{"krate":0,"index":1324},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":602097,"byte_end":602110,"line_start":919,"line_end":919,"column_start":15,"column_end":28},"name":"read_volatile","qualname":"::ptr::read_volatile","value":"fn <T> (src: *const T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs a volatile read of the value from `src` without moving it. This\n leaves the memory in `src` unchanged.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":602024,"byte_end":602033,"line_start":917,"line_end":917,"column_start":1,"column_end":10}},{"value":"stable(feature = \"volatile\", since = \"1.9.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":602034,"byte_end":602082,"line_start":918,"line_end":918,"column_start":1,"column_end":49}}]},{"kind":"Function","id":{"krate":0,"index":1326},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":604484,"byte_end":604498,"line_start":987,"line_end":987,"column_start":15,"column_end":29},"name":"write_volatile","qualname":"::ptr::write_volatile","value":"fn <T> (dst: *mut T, src: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a volatile write of a memory location with the given value without\n reading or dropping the old value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":604411,"byte_end":604420,"line_start":985,"line_end":985,"column_start":1,"column_end":10}},{"value":"stable(feature = \"volatile\", since = \"1.9.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":604421,"byte_end":604469,"line_start":986,"line_end":986,"column_start":1,"column_end":49}}]},{"kind":"Method","id":{"krate":0,"index":1330},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":605200,"byte_end":605207,"line_start":1011,"line_end":1011,"column_start":12,"column_end":19},"name":"is_null","qualname":"<*const T>::is_null","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the pointer is null.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":605129,"byte_end":605174,"line_start":1009,"line_end":1009,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":605179,"byte_end":605188,"line_start":1010,"line_end":1010,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1331},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":605531,"byte_end":605535,"line_start":1020,"line_end":1020,"column_start":18,"column_end":22},"name":"cast","qualname":"<*const T>::cast","value":"fn <U> (self) -> *const U","parent":null,"children":[],"decl_id":null,"docs":" Cast to a pointer to a different type\n","sig":null,"attributes":[{"value":"unstable(feature = \"ptr_cast\", issue = \"60602\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":605449,"byte_end":605499,"line_start":1018,"line_end":1018,"column_start":5,"column_end":55}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":605504,"byte_end":605513,"line_start":1019,"line_end":1019,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1333},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":607623,"byte_end":607629,"line_start":1076,"line_end":1076,"column_start":19,"column_end":25},"name":"as_ref","qualname":"<*const T>::as_ref","value":"fn <'a> (self) -> Option<&'a T>","parent":null,"children":[],"decl_id":null,"docs":" Returns `None` if the pointer is null, or else returns a reference to\n the value wrapped in `Some`.","sig":null,"attributes":[{"value":"stable(feature = \"ptr_as_ref\", since = \"1.9.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":607540,"byte_end":607590,"line_start":1074,"line_end":1074,"column_start":5,"column_end":55}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":607595,"byte_end":607604,"line_start":1075,"line_end":1075,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1335},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":609927,"byte_end":609933,"line_start":1134,"line_end":1134,"column_start":19,"column_end":25},"name":"offset","qualname":"<*const T>::offset","value":"fn (self, count: isize) -> *const T","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":609849,"byte_end":609894,"line_start":1132,"line_end":1132,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":609899,"byte_end":609908,"line_start":1133,"line_end":1133,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1336},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":611624,"byte_end":611639,"line_start":1178,"line_end":1178,"column_start":12,"column_end":27},"name":"wrapping_offset","qualname":"<*const T>::wrapping_offset","value":"fn (self, count: isize) -> *const T","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer using wrapping arithmetic.","sig":null,"attributes":[{"value":"stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":611538,"byte_end":611598,"line_start":1176,"line_end":1176,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":611603,"byte_end":611612,"line_start":1177,"line_end":1177,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1337},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":614421,"byte_end":614432,"line_start":1247,"line_end":1247,"column_start":19,"column_end":30},"name":"offset_from","qualname":"<*const T>::offset_from","value":"fn (self, origin: *const T) -> isize","parent":null,"children":[],"decl_id":null,"docs":" Calculates the distance between two pointers. The returned value is in\n units of T: the distance in bytes is divided by `mem::size_of::<T>()`.","sig":null,"attributes":[{"value":"unstable(feature = \"ptr_offset_from\", issue = \"41079\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":614331,"byte_end":614388,"line_start":1245,"line_end":1245,"column_start":5,"column_end":62}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":614393,"byte_end":614402,"line_start":1246,"line_end":1246,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1338},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":616342,"byte_end":616362,"line_start":1294,"line_end":1294,"column_start":12,"column_end":32},"name":"wrapping_offset_from","qualname":"<*const T>::wrapping_offset_from","value":"fn (self, origin: *const T) -> isize","parent":null,"children":[],"decl_id":null,"docs":" Calculates the distance between two pointers. The returned value is in\n units of T: the distance in bytes is divided by `mem::size_of::<T>()`.","sig":null,"attributes":[{"value":"unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":616250,"byte_end":616316,"line_start":1292,"line_end":1292,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":616321,"byte_end":616330,"line_start":1293,"line_end":1293,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1339},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":618855,"byte_end":618858,"line_start":1352,"line_end":1352,"column_start":19,"column_end":22},"name":"add","qualname":"<*const T>::add","value":"fn (self, count: usize) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer (convenience for `.offset(count as isize)`).","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":618766,"byte_end":618822,"line_start":1350,"line_end":1350,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":618827,"byte_end":618836,"line_start":1351,"line_end":1351,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1340},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":621205,"byte_end":621208,"line_start":1409,"line_end":1409,"column_start":19,"column_end":22},"name":"sub","qualname":"<*const T>::sub","value":"fn (self, count: usize) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer (convenience for\n `.offset((count as isize).wrapping_neg())`).","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":621116,"byte_end":621172,"line_start":1407,"line_end":1407,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":621177,"byte_end":621186,"line_start":1408,"line_end":1408,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1341},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":622504,"byte_end":622516,"line_start":1450,"line_end":1450,"column_start":12,"column_end":24},"name":"wrapping_add","qualname":"<*const T>::wrapping_add","value":"fn (self, count: usize) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer using wrapping arithmetic.\n (convenience for `.wrapping_offset(count as isize)`)","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":622422,"byte_end":622478,"line_start":1448,"line_end":1448,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":622483,"byte_end":622492,"line_start":1449,"line_end":1449,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1342},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":623868,"byte_end":623880,"line_start":1491,"line_end":1491,"column_start":12,"column_end":24},"name":"wrapping_sub","qualname":"<*const T>::wrapping_sub","value":"fn (self, count: usize) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer using wrapping arithmetic.\n (convenience for `.wrapping_offset((count as isize).wrapping_sub())`)","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":623786,"byte_end":623842,"line_start":1489,"line_end":1489,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":623847,"byte_end":623856,"line_start":1490,"line_end":1490,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1343},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":624326,"byte_end":624330,"line_start":1505,"line_end":1505,"column_start":19,"column_end":23},"name":"read","qualname":"<*const T>::read","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Reads the value from `self` without moving it. This leaves the\n memory in `self` unchanged.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":624237,"byte_end":624293,"line_start":1503,"line_end":1503,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":624298,"byte_end":624307,"line_start":1504,"line_end":1504,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1344},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":624951,"byte_end":624964,"line_start":1523,"line_end":1523,"column_start":19,"column_end":32},"name":"read_volatile","qualname":"<*const T>::read_volatile","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs a volatile read of the value from `self` without moving it. This\n leaves the memory in `self` unchanged.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":624862,"byte_end":624918,"line_start":1521,"line_end":1521,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":624923,"byte_end":624932,"line_start":1522,"line_end":1522,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1345},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":625450,"byte_end":625464,"line_start":1539,"line_end":1539,"column_start":19,"column_end":33},"name":"read_unaligned","qualname":"<*const T>::read_unaligned","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Reads the value from `self` without moving it. This leaves the\n memory in `self` unchanged.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":625361,"byte_end":625417,"line_start":1537,"line_end":1537,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":625422,"byte_end":625431,"line_start":1538,"line_end":1538,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1346},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":625941,"byte_end":625948,"line_start":1555,"line_end":1555,"column_start":19,"column_end":26},"name":"copy_to","qualname":"<*const T>::copy_to","value":"fn (self, dest: *mut T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n and destination may overlap.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":625852,"byte_end":625908,"line_start":1553,"line_end":1553,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":625913,"byte_end":625922,"line_start":1554,"line_end":1554,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1347},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":626517,"byte_end":626539,"line_start":1571,"line_end":1571,"column_start":19,"column_end":41},"name":"copy_to_nonoverlapping","qualname":"<*const T>::copy_to_nonoverlapping","value":"fn (self, dest: *mut T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n and destination may *not* overlap.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":626428,"byte_end":626484,"line_start":1569,"line_end":1569,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":626489,"byte_end":626498,"line_start":1570,"line_end":1570,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1348},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":628111,"byte_end":628123,"line_start":1615,"line_end":1615,"column_start":12,"column_end":24},"name":"align_offset","qualname":"<*const T>::align_offset","value":"fn (self, align: usize) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Computes the offset that needs to be applied to the pointer in order to make it aligned to\n `align`.","sig":null,"attributes":[{"value":"stable(feature = \"align_offset\", since = \"1.36.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":628046,"byte_end":628099,"line_start":1614,"line_end":1614,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":1351},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":628975,"byte_end":628982,"line_start":1646,"line_end":1646,"column_start":12,"column_end":19},"name":"is_null","qualname":"<*mut T>::is_null","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the pointer is null.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":628904,"byte_end":628949,"line_start":1644,"line_end":1644,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":628954,"byte_end":628963,"line_start":1645,"line_end":1645,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1352},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":629308,"byte_end":629312,"line_start":1655,"line_end":1655,"column_start":18,"column_end":22},"name":"cast","qualname":"<*mut T>::cast","value":"fn <U> (self) -> *mut U","parent":null,"children":[],"decl_id":null,"docs":" Cast to a pointer to a different type\n","sig":null,"attributes":[{"value":"unstable(feature = \"ptr_cast\", issue = \"60602\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":629226,"byte_end":629276,"line_start":1653,"line_end":1653,"column_start":5,"column_end":55}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":629281,"byte_end":629290,"line_start":1654,"line_end":1654,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1354},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":631398,"byte_end":631404,"line_start":1711,"line_end":1711,"column_start":19,"column_end":25},"name":"as_ref","qualname":"<*mut T>::as_ref","value":"fn <'a> (self) -> Option<&'a T>","parent":null,"children":[],"decl_id":null,"docs":" Returns `None` if the pointer is null, or else returns a reference to\n the value wrapped in `Some`.","sig":null,"attributes":[{"value":"stable(feature = \"ptr_as_ref\", since = \"1.9.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":631315,"byte_end":631365,"line_start":1709,"line_end":1709,"column_start":5,"column_end":55}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":631370,"byte_end":631379,"line_start":1710,"line_end":1710,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1356},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":633691,"byte_end":633697,"line_start":1769,"line_end":1769,"column_start":19,"column_end":25},"name":"offset","qualname":"<*mut T>::offset","value":"fn (self, count: isize) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":633613,"byte_end":633658,"line_start":1767,"line_end":1767,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":633663,"byte_end":633672,"line_start":1768,"line_end":1768,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1357},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":635387,"byte_end":635402,"line_start":1812,"line_end":1812,"column_start":12,"column_end":27},"name":"wrapping_offset","qualname":"<*mut T>::wrapping_offset","value":"fn (self, count: isize) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer using wrapping arithmetic.\n `count` is in units of T; e.g., a `count` of 3 represents a pointer\n offset of `3 * size_of::<T>()` bytes.","sig":null,"attributes":[{"value":"stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":635301,"byte_end":635361,"line_start":1810,"line_end":1810,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":635366,"byte_end":635375,"line_start":1811,"line_end":1811,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1358},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":637142,"byte_end":637148,"line_start":1854,"line_end":1854,"column_start":19,"column_end":25},"name":"as_mut","qualname":"<*mut T>::as_mut","value":"fn <'a> (self) -> Option<&'a mut T>","parent":null,"children":[],"decl_id":null,"docs":" Returns `None` if the pointer is null, or else returns a mutable\n reference to the value wrapped in `Some`.","sig":null,"attributes":[{"value":"stable(feature = \"ptr_as_ref\", since = \"1.9.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":637059,"byte_end":637109,"line_start":1852,"line_end":1852,"column_start":5,"column_end":55}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":637114,"byte_end":637123,"line_start":1853,"line_end":1853,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1360},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":639950,"byte_end":639961,"line_start":1925,"line_end":1925,"column_start":19,"column_end":30},"name":"offset_from","qualname":"<*mut T>::offset_from","value":"fn (self, origin: *const T) -> isize","parent":null,"children":[],"decl_id":null,"docs":" Calculates the distance between two pointers. The returned value is in\n units of T: the distance in bytes is divided by `mem::size_of::<T>()`.","sig":null,"attributes":[{"value":"unstable(feature = \"ptr_offset_from\", issue = \"41079\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":639860,"byte_end":639917,"line_start":1923,"line_end":1923,"column_start":5,"column_end":62}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":639922,"byte_end":639931,"line_start":1924,"line_end":1924,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1361},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":641442,"byte_end":641462,"line_start":1965,"line_end":1965,"column_start":12,"column_end":32},"name":"wrapping_offset_from","qualname":"<*mut T>::wrapping_offset_from","value":"fn (self, origin: *const T) -> isize","parent":null,"children":[],"decl_id":null,"docs":" Calculates the distance between two pointers. The returned value is in\n units of T: the distance in bytes is divided by `mem::size_of::<T>()`.","sig":null,"attributes":[{"value":"unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":641350,"byte_end":641416,"line_start":1963,"line_end":1963,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":641421,"byte_end":641430,"line_start":1964,"line_end":1964,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1362},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":643777,"byte_end":643780,"line_start":2019,"line_end":2019,"column_start":19,"column_end":22},"name":"add","qualname":"<*mut T>::add","value":"fn (self, count: usize) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer (convenience for `.offset(count as isize)`).","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":643688,"byte_end":643744,"line_start":2017,"line_end":2017,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":643749,"byte_end":643758,"line_start":2018,"line_end":2018,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1363},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":646127,"byte_end":646130,"line_start":2076,"line_end":2076,"column_start":19,"column_end":22},"name":"sub","qualname":"<*mut T>::sub","value":"fn (self, count: usize) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer (convenience for\n `.offset((count as isize).wrapping_neg())`).","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":646038,"byte_end":646094,"line_start":2074,"line_end":2074,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":646099,"byte_end":646108,"line_start":2075,"line_end":2075,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1364},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":647426,"byte_end":647438,"line_start":2117,"line_end":2117,"column_start":12,"column_end":24},"name":"wrapping_add","qualname":"<*mut T>::wrapping_add","value":"fn (self, count: usize) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer using wrapping arithmetic.\n (convenience for `.wrapping_offset(count as isize)`)","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":647344,"byte_end":647400,"line_start":2115,"line_end":2115,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":647405,"byte_end":647414,"line_start":2116,"line_end":2116,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1365},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":648790,"byte_end":648802,"line_start":2158,"line_end":2158,"column_start":12,"column_end":24},"name":"wrapping_sub","qualname":"<*mut T>::wrapping_sub","value":"fn (self, count: usize) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer using wrapping arithmetic.\n (convenience for `.wrapping_offset((count as isize).wrapping_sub())`)","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":648708,"byte_end":648764,"line_start":2156,"line_end":2156,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":648769,"byte_end":648778,"line_start":2157,"line_end":2157,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1366},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":649248,"byte_end":649252,"line_start":2172,"line_end":2172,"column_start":19,"column_end":23},"name":"read","qualname":"<*mut T>::read","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Reads the value from `self` without moving it. This leaves the\n memory in `self` unchanged.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":649159,"byte_end":649215,"line_start":2170,"line_end":2170,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":649220,"byte_end":649229,"line_start":2171,"line_end":2171,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1367},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":649873,"byte_end":649886,"line_start":2190,"line_end":2190,"column_start":19,"column_end":32},"name":"read_volatile","qualname":"<*mut T>::read_volatile","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs a volatile read of the value from `self` without moving it. This\n leaves the memory in `self` unchanged.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":649784,"byte_end":649840,"line_start":2188,"line_end":2188,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":649845,"byte_end":649854,"line_start":2189,"line_end":2189,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1368},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":650372,"byte_end":650386,"line_start":2206,"line_end":2206,"column_start":19,"column_end":33},"name":"read_unaligned","qualname":"<*mut T>::read_unaligned","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Reads the value from `self` without moving it. This leaves the\n memory in `self` unchanged.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":650283,"byte_end":650339,"line_start":2204,"line_end":2204,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":650344,"byte_end":650353,"line_start":2205,"line_end":2205,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1369},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":650863,"byte_end":650870,"line_start":2222,"line_end":2222,"column_start":19,"column_end":26},"name":"copy_to","qualname":"<*mut T>::copy_to","value":"fn (self, dest: *mut T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n and destination may overlap.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":650774,"byte_end":650830,"line_start":2220,"line_end":2220,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":650835,"byte_end":650844,"line_start":2221,"line_end":2221,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1370},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":651439,"byte_end":651461,"line_start":2238,"line_end":2238,"column_start":19,"column_end":41},"name":"copy_to_nonoverlapping","qualname":"<*mut T>::copy_to_nonoverlapping","value":"fn (self, dest: *mut T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n and destination may *not* overlap.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":651350,"byte_end":651406,"line_start":2236,"line_end":2236,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":651411,"byte_end":651420,"line_start":2237,"line_end":2237,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1371},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":651982,"byte_end":651991,"line_start":2254,"line_end":2254,"column_start":19,"column_end":28},"name":"copy_from","qualname":"<*mut T>::copy_from","value":"fn (self, src: *const T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies `count * size_of<T>` bytes from `src` to `self`. The source\n and destination may overlap.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":651893,"byte_end":651949,"line_start":2252,"line_end":2252,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":651954,"byte_end":651963,"line_start":2253,"line_end":2253,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1372},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":652563,"byte_end":652587,"line_start":2270,"line_end":2270,"column_start":19,"column_end":43},"name":"copy_from_nonoverlapping","qualname":"<*mut T>::copy_from_nonoverlapping","value":"fn (self, src: *const T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies `count * size_of<T>` bytes from `src` to `self`. The source\n and destination may *not* overlap.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":652474,"byte_end":652530,"line_start":2268,"line_end":2268,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":652535,"byte_end":652544,"line_start":2269,"line_end":2269,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1373},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":653010,"byte_end":653023,"line_start":2283,"line_end":2283,"column_start":19,"column_end":32},"name":"drop_in_place","qualname":"<*mut T>::drop_in_place","value":"fn (self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Executes the destructor (if any) of the pointed-to value.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":652921,"byte_end":652977,"line_start":2281,"line_end":2281,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":652982,"byte_end":652991,"line_start":2282,"line_end":2282,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1374},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":653390,"byte_end":653395,"line_start":2295,"line_end":2295,"column_start":19,"column_end":24},"name":"write","qualname":"<*mut T>::write","value":"fn (self, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Overwrites a memory location with the given value without reading or\n dropping the old value.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":653301,"byte_end":653357,"line_start":2293,"line_end":2293,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":653362,"byte_end":653371,"line_start":2294,"line_end":2294,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1375},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":653839,"byte_end":653850,"line_start":2309,"line_end":2309,"column_start":19,"column_end":30},"name":"write_bytes","qualname":"<*mut T>::write_bytes","value":"fn (self, val: u8, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n bytes of memory starting at `self` to `val`.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":653750,"byte_end":653806,"line_start":2307,"line_end":2307,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":653811,"byte_end":653820,"line_start":2308,"line_end":2308,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1376},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":654509,"byte_end":654523,"line_start":2327,"line_end":2327,"column_start":19,"column_end":33},"name":"write_volatile","qualname":"<*mut T>::write_volatile","value":"fn (self, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a volatile write of a memory location with the given value without\n reading or dropping the old value.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":654420,"byte_end":654476,"line_start":2325,"line_end":2325,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":654481,"byte_end":654490,"line_start":2326,"line_end":2326,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1377},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":655024,"byte_end":655039,"line_start":2343,"line_end":2343,"column_start":19,"column_end":34},"name":"write_unaligned","qualname":"<*mut T>::write_unaligned","value":"fn (self, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Overwrites a memory location with the given value without reading or\n dropping the old value.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":654935,"byte_end":654991,"line_start":2341,"line_end":2341,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":654996,"byte_end":655005,"line_start":2342,"line_end":2342,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1378},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":655453,"byte_end":655460,"line_start":2357,"line_end":2357,"column_start":19,"column_end":26},"name":"replace","qualname":"<*mut T>::replace","value":"fn (self, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Replaces the value at `self` with `src`, returning the old\n value, without dropping either.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":655364,"byte_end":655420,"line_start":2355,"line_end":2355,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":655425,"byte_end":655434,"line_start":2356,"line_end":2356,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1379},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":655938,"byte_end":655942,"line_start":2372,"line_end":2372,"column_start":19,"column_end":23},"name":"swap","qualname":"<*mut T>::swap","value":"fn (self, with: *mut T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Swaps the values at two mutable locations of the same type, without\n deinitializing either. They may overlap, unlike `mem::swap` which is\n otherwise equivalent.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":655849,"byte_end":655905,"line_start":2370,"line_end":2370,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":655910,"byte_end":655919,"line_start":2371,"line_end":2371,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1380},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":657478,"byte_end":657490,"line_start":2416,"line_end":2416,"column_start":12,"column_end":24},"name":"align_offset","qualname":"<*mut T>::align_offset","value":"fn (self, align: usize) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Computes the offset that needs to be applied to the pointer in order to make it aligned to\n `align`.","sig":null,"attributes":[{"value":"stable(feature = \"align_offset\", since = \"1.36.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":657413,"byte_end":657466,"line_start":2415,"line_end":2415,"column_start":5,"column_end":58}}]},{"kind":"Function","id":{"krate":0,"index":1398},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":665295,"byte_end":665297,"line_start":2637,"line_end":2637,"column_start":8,"column_end":10},"name":"eq","qualname":"::ptr::eq","value":"fn <T> (a: *const T, b: *const T) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Compares raw pointers for equality.","sig":null,"attributes":[{"value":"stable(feature = \"ptr_eq\", since = \"1.17.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":665230,"byte_end":665277,"line_start":2635,"line_end":2635,"column_start":1,"column_end":48}},{"value":"inline","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":665278,"byte_end":665287,"line_start":2636,"line_end":2636,"column_start":1,"column_end":10}}]},{"kind":"Function","id":{"krate":0,"index":1400},"span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":666123,"byte_end":666127,"line_start":2668,"line_end":2668,"column_start":8,"column_end":12},"name":"hash","qualname":"::ptr::hash","value":"fn <T, S> (hashee: *const T, into: &mut S) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Hash a raw pointer.","sig":null,"attributes":[{"value":"stable(feature = \"ptr_hash\", since = \"1.35.0\")","span":{"file_name":"src/libcore/ptr/mod.rs","byte_start":666066,"byte_end":666115,"line_start":2667,"line_end":2667,"column_start":1,"column_end":50}}]},{"kind":"Mod","id":{"krate":0,"index":1426},"span":{"file_name":"src/libcore/hint.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"hint","qualname":"::hint","value":"src/libcore/hint.rs","parent":null,"children":[{"krate":0,"index":1427},{"krate":0,"index":1428},{"krate":0,"index":1429},{"krate":0,"index":1430}],"decl_id":null,"docs":" Hints to compiler that affects how code should be emitted or optimized.\n","sig":null,"attributes":[{"value":"stable(feature = \"core_hint\", since = \"1.27.0\")","span":{"file_name":"src/libcore/hint.rs","byte_start":685359,"byte_end":685410,"line_start":1,"line_end":1,"column_start":1,"column_end":52}}]},{"kind":"Function","id":{"krate":0,"index":1428},"span":{"file_name":"src/libcore/hint.rs","byte_start":687090,"byte_end":687111,"line_start":48,"line_end":48,"column_start":15,"column_end":36},"name":"unreachable_unchecked","qualname":"::hint::unreachable_unchecked","value":"fn () -> !","parent":null,"children":[],"decl_id":null,"docs":" Informs the compiler that this point in the code is not reachable, enabling\n further optimizations.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hint.rs","byte_start":687013,"byte_end":687022,"line_start":46,"line_end":46,"column_start":1,"column_end":10}},{"value":"stable(feature = \"unreachable\", since = \"1.27.0\")","span":{"file_name":"src/libcore/hint.rs","byte_start":687023,"byte_end":687075,"line_start":47,"line_end":47,"column_start":1,"column_end":53}}]},{"kind":"Function","id":{"krate":0,"index":1429},"span":{"file_name":"src/libcore/hint.rs","byte_start":688616,"byte_end":688625,"line_start":76,"line_end":76,"column_start":8,"column_end":17},"name":"spin_loop","qualname":"::hint::spin_loop","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Signals the processor that it is entering a busy-wait spin-loop.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hint.rs","byte_start":688539,"byte_end":688548,"line_start":74,"line_end":74,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"renamed_spin_loop\", issue = \"55002\")","span":{"file_name":"src/libcore/hint.rs","byte_start":688549,"byte_end":688608,"line_start":75,"line_end":75,"column_start":1,"column_end":60}}]},{"kind":"Function","id":{"krate":0,"index":1430},"span":{"file_name":"src/libcore/hint.rs","byte_start":689696,"byte_end":689705,"line_start":115,"line_end":115,"column_start":8,"column_end":17},"name":"black_box","qualname":"::hint::black_box","value":"fn <T> (dummy: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" A function that is opaque to the optimizer, to allow benchmarks to\n pretend to use outputs to assist in avoiding dead-code\n elimination.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hint.rs","byte_start":689564,"byte_end":689573,"line_start":112,"line_end":112,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"test\", issue = \"27812\")","span":{"file_name":"src/libcore/hint.rs","byte_start":689574,"byte_end":689620,"line_start":113,"line_end":113,"column_start":1,"column_end":47}},{"value":"allow(unreachable_code)","span":{"file_name":"src/libcore/hint.rs","byte_start":689621,"byte_end":689647,"line_start":114,"line_end":114,"column_start":1,"column_end":27}}]},{"kind":"Mod","id":{"krate":0,"index":1432},"span":{"file_name":"src/libcore/marker.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"marker","qualname":"::marker","value":"src/libcore/marker.rs","parent":null,"children":[{"krate":0,"index":1433},{"krate":0,"index":1434},{"krate":0,"index":1435},{"krate":0,"index":1436},{"krate":0,"index":1437},{"krate":0,"index":1438},{"krate":0,"index":1440},{"krate":0,"index":1442},{"krate":0,"index":1443},{"krate":0,"index":1445},{"krate":0,"index":1446},{"krate":0,"index":1447},{"krate":0,"index":1449},{"krate":0,"index":1451},{"krate":0,"index":1452},{"krate":0,"index":19077},{"krate":0,"index":19081},{"krate":0,"index":19084},{"krate":0,"index":19086},{"krate":0,"index":19089},{"krate":0,"index":19092},{"krate":0,"index":19094},{"krate":0,"index":19097},{"krate":0,"index":1455},{"krate":0,"index":1460},{"krate":0,"index":1461},{"krate":0,"index":1463},{"krate":0,"index":1465},{"krate":0,"index":1467},{"krate":0,"index":1469},{"krate":0,"index":1471},{"krate":0,"index":1473},{"krate":0,"index":19100},{"krate":0,"index":19116},{"krate":0,"index":19115},{"krate":0,"index":19113},{"krate":0,"index":19111},{"krate":0,"index":19109},{"krate":0,"index":19107},{"krate":0,"index":19105},{"krate":0,"index":19102},{"krate":0,"index":1474},{"krate":0,"index":1475},{"krate":0,"index":1478},{"krate":0,"index":1481}],"decl_id":null,"docs":" Primitive traits and types representing basic properties of types.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/marker.rs","byte_start":690906,"byte_end":690952,"line_start":7,"line_end":7,"column_start":1,"column_end":47}}]},{"kind":"Trait","id":{"krate":0,"index":1437},"span":{"file_name":"src/libcore/marker.rs","byte_start":692096,"byte_end":692100,"line_start":36,"line_end":36,"column_start":23,"column_end":27},"name":"Send","qualname":"::marker::Send","value":"Send","parent":null,"children":[],"decl_id":null,"docs":" Types that can be transferred across thread boundaries.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/marker.rs","byte_start":691878,"byte_end":691923,"line_start":31,"line_end":31,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message =\n                             \"`{Self}` cannot be sent between threads safely\",\n                         label =\n                             \"`{Self}` cannot be sent between threads safely\")","span":{"file_name":"src/libcore/marker.rs","byte_start":691924,"byte_end":692073,"line_start":32,"line_end":35,"column_start":1,"column_end":3}}]},{"kind":"Trait","id":{"krate":0,"index":1442},"span":{"file_name":"src/libcore/marker.rs","byte_start":694077,"byte_end":694082,"line_start":92,"line_end":92,"column_start":11,"column_end":16},"name":"Sized","qualname":"::marker::Sized","value":"Sized","parent":null,"children":[],"decl_id":null,"docs":" Types with a constant size known at compile time.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/marker.rs","byte_start":693511,"byte_end":693556,"line_start":82,"line_end":82,"column_start":1,"column_end":46}},{"value":"lang = \"sized\"","span":{"file_name":"src/libcore/marker.rs","byte_start":693557,"byte_end":693574,"line_start":83,"line_end":83,"column_start":1,"column_end":18}},{"value":"rustc_on_unimplemented(on(parent_trait = \"std::path::Path\",\n                            label = \"borrow the `Path` instead\"),\n                         message =\n                             \"the size for values of type `{Self}` cannot be known at compilation time\",\n                         label = \"doesn't have a size known at compile-time\",\n                         note =\n                             \"to learn more, visit <https://doc.rust-lang.org/book/\\\n          ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\")","span":{"file_name":"src/libcore/marker.rs","byte_start":693575,"byte_end":693971,"line_start":84,"line_end":90,"column_start":1,"column_end":3}},{"value":"fundamental","span":{"file_name":"src/libcore/marker.rs","byte_start":693972,"byte_end":693986,"line_start":91,"line_end":91,"column_start":1,"column_end":15}}]},{"kind":"Trait","id":{"krate":0,"index":1443},"span":{"file_name":"src/libcore/marker.rs","byte_start":695375,"byte_end":695381,"line_start":125,"line_end":125,"column_start":11,"column_end":17},"name":"Unsize","qualname":"::marker::Unsize","value":"Unsize<T: ?Sized>","parent":null,"children":[],"decl_id":null,"docs":" Types that can be \"unsized\" to a dynamically-sized type.","sig":null,"attributes":[{"value":"unstable(feature = \"unsize\", issue = \"27732\")","span":{"file_name":"src/libcore/marker.rs","byte_start":695297,"byte_end":695345,"line_start":123,"line_end":123,"column_start":1,"column_end":49}},{"value":"lang = \"unsize\"","span":{"file_name":"src/libcore/marker.rs","byte_start":695346,"byte_end":695364,"line_start":124,"line_end":124,"column_start":1,"column_end":19}}]},{"kind":"Trait","id":{"krate":0,"index":1445},"span":{"file_name":"src/libcore/marker.rs","byte_start":700935,"byte_end":700939,"line_start":287,"line_end":287,"column_start":11,"column_end":15},"name":"Copy","qualname":"::marker::Copy","value":"Copy: Clone","parent":null,"children":[],"decl_id":null,"docs":" Types whose values can be duplicated simply by copying bits.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/marker.rs","byte_start":700862,"byte_end":700907,"line_start":285,"line_end":285,"column_start":1,"column_end":46}},{"value":"lang = \"copy\"","span":{"file_name":"src/libcore/marker.rs","byte_start":700908,"byte_end":700924,"line_start":286,"line_end":286,"column_start":1,"column_end":17}}]},{"kind":"Trait","id":{"krate":0,"index":1446},"span":{"file_name":"src/libcore/marker.rs","byte_start":704602,"byte_end":704606,"line_start":365,"line_end":365,"column_start":23,"column_end":27},"name":"Sync","qualname":"::marker::Sync","value":"Sync","parent":null,"children":[],"decl_id":null,"docs":" Types for which it is safe to share references between threads.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/marker.rs","byte_start":704363,"byte_end":704408,"line_start":359,"line_end":359,"column_start":1,"column_end":46}},{"value":"lang = \"sync\"","span":{"file_name":"src/libcore/marker.rs","byte_start":704409,"byte_end":704425,"line_start":360,"line_end":360,"column_start":1,"column_end":17}},{"value":"rustc_on_unimplemented(message =\n                             \"`{Self}` cannot be shared between threads safely\",\n                         label =\n                             \"`{Self}` cannot be shared between threads safely\")","span":{"file_name":"src/libcore/marker.rs","byte_start":704426,"byte_end":704579,"line_start":361,"line_end":364,"column_start":1,"column_end":3}}]},{"kind":"Struct","id":{"krate":0,"index":1452},"span":{"file_name":"src/libcore/marker.rs","byte_start":711468,"byte_end":711479,"line_start":573,"line_end":573,"column_start":12,"column_end":23},"name":"PhantomData","qualname":"::marker::PhantomData","value":"","parent":null,"children":[],"decl_id":null,"docs":" Zero-sized type used to mark things that \"act like\" they own a `T`.","sig":null,"attributes":[{"value":"lang = \"phantom_data\"","span":{"file_name":"src/libcore/marker.rs","byte_start":711366,"byte_end":711390,"line_start":570,"line_end":570,"column_start":1,"column_end":25}},{"value":"structural_match","span":{"file_name":"src/libcore/marker.rs","byte_start":711391,"byte_end":711410,"line_start":571,"line_end":571,"column_start":1,"column_end":20}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/marker.rs","byte_start":711411,"byte_end":711456,"line_start":572,"line_end":572,"column_start":1,"column_end":46}}]},{"kind":"Trait","id":{"krate":0,"index":1473},"span":{"file_name":"src/libcore/marker.rs","byte_start":714225,"byte_end":714230,"line_start":640,"line_end":640,"column_start":16,"column_end":21},"name":"Unpin","qualname":"::marker::Unpin","value":"Unpin","parent":null,"children":[],"decl_id":null,"docs":" Types which can be safely moved after being pinned.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/marker.rs","byte_start":714147,"byte_end":714191,"line_start":638,"line_end":638,"column_start":1,"column_end":45}},{"value":"lang = \"unpin\"","span":{"file_name":"src/libcore/marker.rs","byte_start":714192,"byte_end":714209,"line_start":639,"line_end":639,"column_start":1,"column_end":18}}]},{"kind":"Struct","id":{"krate":0,"index":19100},"span":{"file_name":"src/libcore/marker.rs","byte_start":714499,"byte_end":714512,"line_start":647,"line_end":647,"column_start":12,"column_end":25},"name":"PhantomPinned","qualname":"::marker::PhantomPinned","value":"","parent":null,"children":[],"decl_id":null,"docs":" A marker type which does not implement `Unpin`.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/marker.rs","byte_start":714375,"byte_end":714419,"line_start":645,"line_end":645,"column_start":1,"column_end":45}},{"value":"structural_match","span":{"file_name":"src/libcore/marker.rs","byte_start":714488,"byte_end":714513,"line_start":647,"line_end":647,"column_start":1,"column_end":26}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/marker.rs","byte_start":714488,"byte_end":714513,"line_start":647,"line_end":647,"column_start":1,"column_end":26}}]},{"kind":"Mod","id":{"krate":0,"index":1491},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"ops","qualname":"::ops","value":"src/libcore/ops/mod.rs","parent":null,"children":[{"krate":0,"index":1492},{"krate":0,"index":1546},{"krate":0,"index":1600},{"krate":0,"index":1622},{"krate":0,"index":1625},{"krate":0,"index":1659},{"krate":0,"index":1676},{"krate":0,"index":1684},{"krate":0,"index":1818},{"krate":0,"index":1825},{"krate":0,"index":1880},{"krate":0,"index":1887},{"krate":0,"index":1893},{"krate":0,"index":1900},{"krate":0,"index":1906},{"krate":0,"index":1909},{"krate":0,"index":1910},{"krate":0,"index":1911},{"krate":0,"index":1915},{"krate":0,"index":1918},{"krate":0,"index":1923},{"krate":0,"index":1928},{"krate":0,"index":1929},{"krate":0,"index":1932},{"krate":0,"index":1933}],"decl_id":null,"docs":" Overloadable operators.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/mod.rs","byte_start":720718,"byte_end":720764,"line_start":145,"line_end":145,"column_start":1,"column_end":47}}]},{"kind":"Trait","id":{"krate":0,"index":1493},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":724417,"byte_end":724420,"line_start":81,"line_end":81,"column_start":11,"column_end":14},"name":"Add","qualname":"::ops::arith::Add","value":"Add<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1495},{"krate":0,"index":1496}],"decl_id":null,"docs":" The addition operator `+`.","sig":null,"attributes":[{"value":"lang = \"add\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":723970,"byte_end":723985,"line_start":66,"line_end":66,"column_start":1,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":723986,"byte_end":724031,"line_start":67,"line_end":67,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(on(all(_Self = \"{integer}\", Rhs = \"{float}\"),\n                            message = \"cannot add a float to an integer\"),\n                         on(all(_Self = \"{float}\", Rhs = \"{integer}\"),\n                            message = \"cannot add an integer to a float\"),\n                         message = \"cannot add `{Rhs}` to `{Self}`\",\n                         label = \"no implementation for `{Self} + {Rhs}`\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":724032,"byte_end":724386,"line_start":68,"line_end":79,"column_start":1,"column_end":3}}]},{"kind":"Type","id":{"krate":0,"index":1495},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":724552,"byte_end":724558,"line_start":84,"line_end":84,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::arith::Add::Output","value":"type Output;","parent":{"krate":0,"index":1493},"children":[],"decl_id":null,"docs":" The resulting type after applying the `+` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":724497,"byte_end":724542,"line_start":83,"line_end":83,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1496},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":724670,"byte_end":724673,"line_start":89,"line_end":89,"column_start":8,"column_end":11},"name":"add","qualname":"::ops::arith::Add::add","value":"fn (self, rhs: Rhs) -> Self::Output","parent":{"krate":0,"index":1493},"children":[],"decl_id":null,"docs":" Performs the `+` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":724601,"byte_end":724612,"line_start":87,"line_end":87,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":724617,"byte_end":724662,"line_start":88,"line_end":88,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1498},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":726956,"byte_end":726959,"line_start":179,"line_end":179,"column_start":11,"column_end":14},"name":"Sub","qualname":"::ops::arith::Sub","value":"Sub<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1500},{"krate":0,"index":1501}],"decl_id":null,"docs":" The subtraction operator `-`.","sig":null,"attributes":[{"value":"lang = \"sub\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":726716,"byte_end":726731,"line_start":174,"line_end":174,"column_start":1,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":726732,"byte_end":726777,"line_start":175,"line_end":175,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"cannot subtract `{Rhs}` from `{Self}`\",\n                         label = \"no implementation for `{Self} - {Rhs}`\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":726778,"byte_end":726925,"line_start":176,"line_end":177,"column_start":1,"column_end":74}}]},{"kind":"Type","id":{"krate":0,"index":1500},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":727091,"byte_end":727097,"line_start":182,"line_end":182,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::arith::Sub::Output","value":"type Output;","parent":{"krate":0,"index":1498},"children":[],"decl_id":null,"docs":" The resulting type after applying the `-` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":727036,"byte_end":727081,"line_start":181,"line_end":181,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1501},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":727209,"byte_end":727212,"line_start":187,"line_end":187,"column_start":8,"column_end":11},"name":"sub","qualname":"::ops::arith::Sub::sub","value":"fn (self, rhs: Rhs) -> Self::Output","parent":{"krate":0,"index":1498},"children":[],"decl_id":null,"docs":" Performs the `-` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":727140,"byte_end":727151,"line_start":185,"line_end":185,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":727156,"byte_end":727201,"line_start":186,"line_end":186,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1503},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":730370,"byte_end":730373,"line_start":299,"line_end":299,"column_start":11,"column_end":14},"name":"Mul","qualname":"::ops::arith::Mul","value":"Mul<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1505},{"krate":0,"index":1506}],"decl_id":null,"docs":" The multiplication operator `*`.","sig":null,"attributes":[{"value":"lang = \"mul\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":730132,"byte_end":730147,"line_start":294,"line_end":294,"column_start":1,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":730148,"byte_end":730193,"line_start":295,"line_end":295,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"cannot multiply `{Rhs}` to `{Self}`\",\n                         label = \"no implementation for `{Self} * {Rhs}`\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":730194,"byte_end":730339,"line_start":296,"line_end":297,"column_start":1,"column_end":74}}]},{"kind":"Type","id":{"krate":0,"index":1505},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":730505,"byte_end":730511,"line_start":302,"line_end":302,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::arith::Mul::Output","value":"type Output;","parent":{"krate":0,"index":1503},"children":[],"decl_id":null,"docs":" The resulting type after applying the `*` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":730450,"byte_end":730495,"line_start":301,"line_end":301,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1506},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":730623,"byte_end":730626,"line_start":307,"line_end":307,"column_start":8,"column_end":11},"name":"mul","qualname":"::ops::arith::Mul::mul","value":"fn (self, rhs: Rhs) -> Self::Output","parent":{"krate":0,"index":1503},"children":[],"decl_id":null,"docs":" Performs the `*` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":730554,"byte_end":730565,"line_start":305,"line_end":305,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":730570,"byte_end":730615,"line_start":306,"line_end":306,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1508},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":733909,"byte_end":733912,"line_start":423,"line_end":423,"column_start":11,"column_end":14},"name":"Div","qualname":"::ops::arith::Div","value":"Div<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1510},{"krate":0,"index":1511}],"decl_id":null,"docs":" The division operator `/`.","sig":null,"attributes":[{"value":"lang = \"div\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":733673,"byte_end":733688,"line_start":418,"line_end":418,"column_start":1,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":733689,"byte_end":733734,"line_start":419,"line_end":419,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"cannot divide `{Self}` by `{Rhs}`\",\n                         label = \"no implementation for `{Self} / {Rhs}`\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":733735,"byte_end":733878,"line_start":420,"line_end":421,"column_start":1,"column_end":74}}]},{"kind":"Type","id":{"krate":0,"index":1510},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":734044,"byte_end":734050,"line_start":426,"line_end":426,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::arith::Div::Output","value":"type Output;","parent":{"krate":0,"index":1508},"children":[],"decl_id":null,"docs":" The resulting type after applying the `/` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":733989,"byte_end":734034,"line_start":425,"line_end":425,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1511},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":734162,"byte_end":734165,"line_start":431,"line_end":431,"column_start":8,"column_end":11},"name":"div","qualname":"::ops::arith::Div::div","value":"fn (self, rhs: Rhs) -> Self::Output","parent":{"krate":0,"index":1508},"children":[],"decl_id":null,"docs":" Performs the `/` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":734093,"byte_end":734104,"line_start":429,"line_end":429,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":734109,"byte_end":734154,"line_start":430,"line_end":430,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1514},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":736376,"byte_end":736379,"line_start":508,"line_end":508,"column_start":11,"column_end":14},"name":"Rem","qualname":"::ops::arith::Rem","value":"Rem<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1516},{"krate":0,"index":1517}],"decl_id":null,"docs":" The remainder operator `%`.","sig":null,"attributes":[{"value":"lang = \"rem\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":736143,"byte_end":736158,"line_start":503,"line_end":503,"column_start":1,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":736159,"byte_end":736204,"line_start":504,"line_end":504,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"cannot mod `{Self}` by `{Rhs}`\",\n                         label = \"no implementation for `{Self} % {Rhs}`\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":736205,"byte_end":736345,"line_start":505,"line_end":506,"column_start":1,"column_end":74}}]},{"kind":"Type","id":{"krate":0,"index":1516},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":736511,"byte_end":736517,"line_start":511,"line_end":511,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::arith::Rem::Output","value":"type Output;","parent":{"krate":0,"index":1514},"children":[],"decl_id":null,"docs":" The resulting type after applying the `%` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":736456,"byte_end":736501,"line_start":510,"line_end":510,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1517},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":736629,"byte_end":736632,"line_start":516,"line_end":516,"column_start":8,"column_end":11},"name":"rem","qualname":"::ops::arith::Rem::rem","value":"fn (self, rhs: Rhs) -> Self::Output","parent":{"krate":0,"index":1514},"children":[],"decl_id":null,"docs":" Performs the `%` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":736560,"byte_end":736571,"line_start":514,"line_end":514,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":736576,"byte_end":736621,"line_start":515,"line_end":515,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1520},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":738984,"byte_end":738987,"line_start":608,"line_end":608,"column_start":11,"column_end":14},"name":"Neg","qualname":"::ops::arith::Neg","value":"Neg","parent":null,"children":[{"krate":0,"index":1521},{"krate":0,"index":1522}],"decl_id":null,"docs":" The unary negation operator `-`.","sig":null,"attributes":[{"value":"lang = \"neg\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":738892,"byte_end":738907,"line_start":605,"line_end":605,"column_start":1,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":738908,"byte_end":738953,"line_start":606,"line_end":606,"column_start":1,"column_end":46}}]},{"kind":"Type","id":{"krate":0,"index":1521},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":739109,"byte_end":739115,"line_start":611,"line_end":611,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::arith::Neg::Output","value":"type Output;","parent":{"krate":0,"index":1520},"children":[],"decl_id":null,"docs":" The resulting type after applying the `-` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":739054,"byte_end":739099,"line_start":610,"line_end":610,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1522},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":739233,"byte_end":739236,"line_start":616,"line_end":616,"column_start":8,"column_end":11},"name":"neg","qualname":"::ops::arith::Neg::neg","value":"fn (self) -> Self::Output","parent":{"krate":0,"index":1520},"children":[],"decl_id":null,"docs":" Performs the unary `-` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":739164,"byte_end":739175,"line_start":614,"line_end":614,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":739180,"byte_end":739225,"line_start":615,"line_end":615,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1526},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":740981,"byte_end":740990,"line_start":686,"line_end":686,"column_start":11,"column_end":20},"name":"AddAssign","qualname":"::ops::arith::AddAssign","value":"AddAssign<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1528}],"decl_id":null,"docs":" The addition assignment operator `+=`.","sig":null,"attributes":[{"value":"lang = \"add_assign\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":740701,"byte_end":740723,"line_start":680,"line_end":680,"column_start":1,"column_end":23}},{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":740724,"byte_end":740780,"line_start":681,"line_end":681,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(message = \"cannot add-assign `{Rhs}` to `{Self}`\",\n                         label = \"no implementation for `{Self} += {Rhs}`\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":740781,"byte_end":740929,"line_start":682,"line_end":683,"column_start":1,"column_end":75}}]},{"kind":"Method","id":{"krate":0,"index":1528},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":741108,"byte_end":741118,"line_start":689,"line_end":689,"column_start":8,"column_end":18},"name":"add_assign","qualname":"::ops::arith::AddAssign::add_assign","value":"fn (&mut self, rhs: Rhs) -> ()","parent":{"krate":0,"index":1526},"children":[],"decl_id":null,"docs":" Performs the `+=` operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":741044,"byte_end":741100,"line_start":688,"line_end":688,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":1530},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":742586,"byte_end":742595,"line_start":742,"line_end":742,"column_start":11,"column_end":20},"name":"SubAssign","qualname":"::ops::arith::SubAssign","value":"SubAssign<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1532}],"decl_id":null,"docs":" The subtraction assignment operator `-=`.","sig":null,"attributes":[{"value":"lang = \"sub_assign\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":742299,"byte_end":742321,"line_start":736,"line_end":736,"column_start":1,"column_end":23}},{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":742322,"byte_end":742378,"line_start":737,"line_end":737,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(message =\n                             \"cannot subtract-assign `{Rhs}` from `{Self}`\",\n                         label = \"no implementation for `{Self} -= {Rhs}`\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":742379,"byte_end":742534,"line_start":738,"line_end":739,"column_start":1,"column_end":75}}]},{"kind":"Method","id":{"krate":0,"index":1532},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":742713,"byte_end":742723,"line_start":745,"line_end":745,"column_start":8,"column_end":18},"name":"sub_assign","qualname":"::ops::arith::SubAssign::sub_assign","value":"fn (&mut self, rhs: Rhs) -> ()","parent":{"krate":0,"index":1530},"children":[],"decl_id":null,"docs":" Performs the `-=` operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":742649,"byte_end":742705,"line_start":744,"line_end":744,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":1534},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":743953,"byte_end":743962,"line_start":789,"line_end":789,"column_start":11,"column_end":20},"name":"MulAssign","qualname":"::ops::arith::MulAssign","value":"MulAssign<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1536}],"decl_id":null,"docs":" The multiplication assignment operator `*=`.","sig":null,"attributes":[{"value":"lang = \"mul_assign\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":743668,"byte_end":743690,"line_start":783,"line_end":783,"column_start":1,"column_end":23}},{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":743691,"byte_end":743747,"line_start":784,"line_end":784,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(message =\n                             \"cannot multiply-assign `{Rhs}` to `{Self}`\",\n                         label = \"no implementation for `{Self} *= {Rhs}`\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":743748,"byte_end":743901,"line_start":785,"line_end":786,"column_start":1,"column_end":75}}]},{"kind":"Method","id":{"krate":0,"index":1536},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":744080,"byte_end":744090,"line_start":792,"line_end":792,"column_start":8,"column_end":18},"name":"mul_assign","qualname":"::ops::arith::MulAssign::mul_assign","value":"fn (&mut self, rhs: Rhs) -> ()","parent":{"krate":0,"index":1534},"children":[],"decl_id":null,"docs":" Performs the `*=` operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":744016,"byte_end":744072,"line_start":791,"line_end":791,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":1538},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":745312,"byte_end":745321,"line_start":836,"line_end":836,"column_start":11,"column_end":20},"name":"DivAssign","qualname":"::ops::arith::DivAssign","value":"DivAssign<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1540}],"decl_id":null,"docs":" The division assignment operator `/=`.","sig":null,"attributes":[{"value":"lang = \"div_assign\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":745029,"byte_end":745051,"line_start":830,"line_end":830,"column_start":1,"column_end":23}},{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":745052,"byte_end":745108,"line_start":831,"line_end":831,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(message = \"cannot divide-assign `{Self}` by `{Rhs}`\",\n                         label = \"no implementation for `{Self} /= {Rhs}`\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":745109,"byte_end":745260,"line_start":832,"line_end":833,"column_start":1,"column_end":75}}]},{"kind":"Method","id":{"krate":0,"index":1540},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":745439,"byte_end":745449,"line_start":839,"line_end":839,"column_start":8,"column_end":18},"name":"div_assign","qualname":"::ops::arith::DivAssign::div_assign","value":"fn (&mut self, rhs: Rhs) -> ()","parent":{"krate":0,"index":1538},"children":[],"decl_id":null,"docs":" Performs the `/=` operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":745375,"byte_end":745431,"line_start":838,"line_end":838,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":1542},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":746715,"byte_end":746724,"line_start":886,"line_end":886,"column_start":11,"column_end":20},"name":"RemAssign","qualname":"::ops::arith::RemAssign","value":"RemAssign<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1544}],"decl_id":null,"docs":" The remainder assignment operator `%=`.","sig":null,"attributes":[{"value":"lang = \"rem_assign\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":746434,"byte_end":746456,"line_start":880,"line_end":880,"column_start":1,"column_end":23}},{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":746457,"byte_end":746513,"line_start":881,"line_end":881,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(message = \"cannot mod-assign `{Self}` by `{Rhs}``\",\n                         label = \"no implementation for `{Self} %= {Rhs}`\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":746514,"byte_end":746663,"line_start":882,"line_end":883,"column_start":1,"column_end":75}}]},{"kind":"Method","id":{"krate":0,"index":1544},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":746842,"byte_end":746852,"line_start":889,"line_end":889,"column_start":8,"column_end":18},"name":"rem_assign","qualname":"::ops::arith::RemAssign::rem_assign","value":"fn (&mut self, rhs: Rhs) -> ()","parent":{"krate":0,"index":1542},"children":[],"decl_id":null,"docs":" Performs the `%=` operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":746778,"byte_end":746834,"line_start":888,"line_end":888,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":1547},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":747993,"byte_end":747996,"line_start":33,"line_end":33,"column_start":11,"column_end":14},"name":"Not","qualname":"::ops::bit::Not","value":"Not","parent":null,"children":[{"krate":0,"index":1548},{"krate":0,"index":1549}],"decl_id":null,"docs":" The unary logical negation operator `!`.","sig":null,"attributes":[{"value":"lang = \"not\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":747921,"byte_end":747936,"line_start":31,"line_end":31,"column_start":1,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":747937,"byte_end":747982,"line_start":32,"line_end":32,"column_start":1,"column_end":46}}]},{"kind":"Type","id":{"krate":0,"index":1548},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":748118,"byte_end":748124,"line_start":36,"line_end":36,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::bit::Not::Output","value":"type Output;","parent":{"krate":0,"index":1547},"children":[],"decl_id":null,"docs":" The resulting type after applying the `!` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":748063,"byte_end":748108,"line_start":35,"line_end":35,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1549},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":748242,"byte_end":748245,"line_start":41,"line_end":41,"column_start":8,"column_end":11},"name":"not","qualname":"::ops::bit::Not::not","value":"fn (self) -> Self::Output","parent":{"krate":0,"index":1547},"children":[],"decl_id":null,"docs":" Performs the unary `!` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":748173,"byte_end":748184,"line_start":39,"line_end":39,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":748189,"byte_end":748234,"line_start":40,"line_end":40,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1551},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":750417,"byte_end":750423,"line_start":117,"line_end":117,"column_start":11,"column_end":17},"name":"BitAnd","qualname":"::ops::bit::BitAnd","value":"BitAnd<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1553},{"krate":0,"index":1554}],"decl_id":null,"docs":" The bitwise AND operator `&`.","sig":null,"attributes":[{"value":"lang = \"bitand\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":750173,"byte_end":750191,"line_start":112,"line_end":112,"column_start":1,"column_end":19}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":750212,"byte_end":750257,"line_start":114,"line_end":114,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"no implementation for `{Self} & {Rhs}`\",\n                         label = \"no implementation for `{Self} & {Rhs}`\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":750258,"byte_end":750406,"line_start":115,"line_end":116,"column_start":1,"column_end":74}}]},{"kind":"Type","id":{"krate":0,"index":1553},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":750555,"byte_end":750561,"line_start":120,"line_end":120,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::bit::BitAnd::Output","value":"type Output;","parent":{"krate":0,"index":1551},"children":[],"decl_id":null,"docs":" The resulting type after applying the `&` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":750500,"byte_end":750545,"line_start":119,"line_end":119,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1554},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":750673,"byte_end":750679,"line_start":125,"line_end":125,"column_start":8,"column_end":14},"name":"bitand","qualname":"::ops::bit::BitAnd::bitand","value":"fn (self, rhs: Rhs) -> Self::Output","parent":{"krate":0,"index":1551},"children":[],"decl_id":null,"docs":" Performs the `&` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":750604,"byte_end":750615,"line_start":123,"line_end":123,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":750620,"byte_end":750665,"line_start":124,"line_end":124,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1556},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":752876,"byte_end":752881,"line_start":201,"line_end":201,"column_start":11,"column_end":16},"name":"BitOr","qualname":"::ops::bit::BitOr","value":"BitOr<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1558},{"krate":0,"index":1559}],"decl_id":null,"docs":" The bitwise OR operator `|`.","sig":null,"attributes":[{"value":"lang = \"bitor\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":752633,"byte_end":752650,"line_start":196,"line_end":196,"column_start":1,"column_end":18}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":752671,"byte_end":752716,"line_start":198,"line_end":198,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"no implementation for `{Self} | {Rhs}`\",\n                         label = \"no implementation for `{Self} | {Rhs}`\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":752717,"byte_end":752865,"line_start":199,"line_end":200,"column_start":1,"column_end":74}}]},{"kind":"Type","id":{"krate":0,"index":1558},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":753013,"byte_end":753019,"line_start":204,"line_end":204,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::bit::BitOr::Output","value":"type Output;","parent":{"krate":0,"index":1556},"children":[],"decl_id":null,"docs":" The resulting type after applying the `|` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":752958,"byte_end":753003,"line_start":203,"line_end":203,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1559},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":753131,"byte_end":753136,"line_start":209,"line_end":209,"column_start":8,"column_end":13},"name":"bitor","qualname":"::ops::bit::BitOr::bitor","value":"fn (self, rhs: Rhs) -> Self::Output","parent":{"krate":0,"index":1556},"children":[],"decl_id":null,"docs":" Performs the `|` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":753062,"byte_end":753073,"line_start":207,"line_end":207,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":753078,"byte_end":753123,"line_start":208,"line_end":208,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1561},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":755474,"byte_end":755480,"line_start":288,"line_end":288,"column_start":11,"column_end":17},"name":"BitXor","qualname":"::ops::bit::BitXor","value":"BitXor<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1563},{"krate":0,"index":1564}],"decl_id":null,"docs":" The bitwise XOR operator `^`.","sig":null,"attributes":[{"value":"lang = \"bitxor\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":755230,"byte_end":755248,"line_start":283,"line_end":283,"column_start":1,"column_end":19}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":755269,"byte_end":755314,"line_start":285,"line_end":285,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"no implementation for `{Self} ^ {Rhs}`\",\n                         label = \"no implementation for `{Self} ^ {Rhs}`\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":755315,"byte_end":755463,"line_start":286,"line_end":287,"column_start":1,"column_end":74}}]},{"kind":"Type","id":{"krate":0,"index":1563},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":755612,"byte_end":755618,"line_start":291,"line_end":291,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::bit::BitXor::Output","value":"type Output;","parent":{"krate":0,"index":1561},"children":[],"decl_id":null,"docs":" The resulting type after applying the `^` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":755557,"byte_end":755602,"line_start":290,"line_end":290,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1564},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":755730,"byte_end":755736,"line_start":296,"line_end":296,"column_start":8,"column_end":14},"name":"bitxor","qualname":"::ops::bit::BitXor::bitxor","value":"fn (self, rhs: Rhs) -> Self::Output","parent":{"krate":0,"index":1561},"children":[],"decl_id":null,"docs":" Performs the `^` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":755661,"byte_end":755672,"line_start":294,"line_end":294,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":755677,"byte_end":755722,"line_start":295,"line_end":295,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1566},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":758155,"byte_end":758158,"line_start":376,"line_end":376,"column_start":11,"column_end":14},"name":"Shl","qualname":"::ops::bit::Shl","value":"Shl<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1568},{"krate":0,"index":1569}],"decl_id":null,"docs":" The left shift operator `<<`. Note that because this trait is implemented\n for all integer types with multiple right-hand-side types, Rust's type\n checker has special handling for `_ << _`, setting the result type for\n integer operations to the type of the left-hand-side operand. This means\n that though `a << b` and `a.shl(b)` are one and the same from an evaluation\n standpoint, they are different when it comes to type inference.","sig":null,"attributes":[{"value":"lang = \"shl\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":757911,"byte_end":757926,"line_start":371,"line_end":371,"column_start":1,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":757948,"byte_end":757993,"line_start":373,"line_end":373,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"no implementation for `{Self} << {Rhs}`\",\n                         label = \"no implementation for `{Self} << {Rhs}`\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":757994,"byte_end":758144,"line_start":374,"line_end":375,"column_start":1,"column_end":75}}]},{"kind":"Type","id":{"krate":0,"index":1568},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":758291,"byte_end":758297,"line_start":379,"line_end":379,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::bit::Shl::Output","value":"type Output;","parent":{"krate":0,"index":1566},"children":[],"decl_id":null,"docs":" The resulting type after applying the `<<` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":758236,"byte_end":758281,"line_start":378,"line_end":378,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1569},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":758410,"byte_end":758413,"line_start":384,"line_end":384,"column_start":8,"column_end":11},"name":"shl","qualname":"::ops::bit::Shl::shl","value":"fn (self, rhs: Rhs) -> Self::Output","parent":{"krate":0,"index":1566},"children":[],"decl_id":null,"docs":" Performs the `<<` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":758341,"byte_end":758352,"line_start":382,"line_end":382,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":758357,"byte_end":758402,"line_start":383,"line_end":383,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1572},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":761336,"byte_end":761339,"line_start":485,"line_end":485,"column_start":11,"column_end":14},"name":"Shr","qualname":"::ops::bit::Shr","value":"Shr<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1574},{"krate":0,"index":1575}],"decl_id":null,"docs":" The right shift operator `>>`. Note that because this trait is implemented\n for all integer types with multiple right-hand-side types, Rust's type\n checker has special handling for `_ >> _`, setting the result type for\n integer operations to the type of the left-hand-side operand. This means\n that though `a >> b` and `a.shr(b)` are one and the same from an evaluation\n standpoint, they are different when it comes to type inference.","sig":null,"attributes":[{"value":"lang = \"shr\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":761092,"byte_end":761107,"line_start":480,"line_end":480,"column_start":1,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":761129,"byte_end":761174,"line_start":482,"line_end":482,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"no implementation for `{Self} >> {Rhs}`\",\n                         label = \"no implementation for `{Self} >> {Rhs}`\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":761175,"byte_end":761325,"line_start":483,"line_end":484,"column_start":1,"column_end":75}}]},{"kind":"Type","id":{"krate":0,"index":1574},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":761472,"byte_end":761478,"line_start":488,"line_end":488,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::bit::Shr::Output","value":"type Output;","parent":{"krate":0,"index":1572},"children":[],"decl_id":null,"docs":" The resulting type after applying the `>>` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":761417,"byte_end":761462,"line_start":487,"line_end":487,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1575},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":761591,"byte_end":761594,"line_start":493,"line_end":493,"column_start":8,"column_end":11},"name":"shr","qualname":"::ops::bit::Shr::shr","value":"fn (self, rhs: Rhs) -> Self::Output","parent":{"krate":0,"index":1572},"children":[],"decl_id":null,"docs":" Performs the `>>` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":761522,"byte_end":761533,"line_start":491,"line_end":491,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":761538,"byte_end":761583,"line_start":492,"line_end":492,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1578},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":764640,"byte_end":764652,"line_start":601,"line_end":601,"column_start":11,"column_end":23},"name":"BitAndAssign","qualname":"::ops::bit::BitAndAssign","value":"BitAndAssign<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1580}],"decl_id":null,"docs":" The bitwise AND assignment operator `&=`.","sig":null,"attributes":[{"value":"lang = \"bitand_assign\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":764375,"byte_end":764400,"line_start":596,"line_end":596,"column_start":1,"column_end":26}},{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":764422,"byte_end":764478,"line_start":598,"line_end":598,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(message = \"no implementation for `{Self} &= {Rhs}`\",\n                         label = \"no implementation for `{Self} &= {Rhs}`\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":764479,"byte_end":764629,"line_start":599,"line_end":600,"column_start":1,"column_end":75}}]},{"kind":"Method","id":{"krate":0,"index":1580},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":764770,"byte_end":764783,"line_start":604,"line_end":604,"column_start":8,"column_end":21},"name":"bitand_assign","qualname":"::ops::bit::BitAndAssign::bitand_assign","value":"fn (&mut self, rhs: Rhs) -> ()","parent":{"krate":0,"index":1578},"children":[],"decl_id":null,"docs":" Performs the `&=` operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":764706,"byte_end":764762,"line_start":603,"line_end":603,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":1582},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":766198,"byte_end":766209,"line_start":650,"line_end":650,"column_start":11,"column_end":22},"name":"BitOrAssign","qualname":"::ops::bit::BitOrAssign","value":"BitOrAssign<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1584}],"decl_id":null,"docs":" The bitwise OR assignment operator `|=`.","sig":null,"attributes":[{"value":"lang = \"bitor_assign\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":765934,"byte_end":765958,"line_start":645,"line_end":645,"column_start":1,"column_end":25}},{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":765980,"byte_end":766036,"line_start":647,"line_end":647,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(message = \"no implementation for `{Self} |= {Rhs}`\",\n                         label = \"no implementation for `{Self} |= {Rhs}`\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":766037,"byte_end":766187,"line_start":648,"line_end":649,"column_start":1,"column_end":75}}]},{"kind":"Method","id":{"krate":0,"index":1584},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":766327,"byte_end":766339,"line_start":653,"line_end":653,"column_start":8,"column_end":20},"name":"bitor_assign","qualname":"::ops::bit::BitOrAssign::bitor_assign","value":"fn (&mut self, rhs: Rhs) -> ()","parent":{"krate":0,"index":1582},"children":[],"decl_id":null,"docs":" Performs the `|=` operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":766263,"byte_end":766319,"line_start":652,"line_end":652,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":1586},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":767742,"byte_end":767754,"line_start":699,"line_end":699,"column_start":11,"column_end":23},"name":"BitXorAssign","qualname":"::ops::bit::BitXorAssign","value":"BitXorAssign<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1588}],"decl_id":null,"docs":" The bitwise XOR assignment operator `^=`.","sig":null,"attributes":[{"value":"lang = \"bitxor_assign\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":767477,"byte_end":767502,"line_start":694,"line_end":694,"column_start":1,"column_end":26}},{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":767524,"byte_end":767580,"line_start":696,"line_end":696,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(message = \"no implementation for `{Self} ^= {Rhs}`\",\n                         label = \"no implementation for `{Self} ^= {Rhs}`\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":767581,"byte_end":767731,"line_start":697,"line_end":698,"column_start":1,"column_end":75}}]},{"kind":"Method","id":{"krate":0,"index":1588},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":767872,"byte_end":767885,"line_start":702,"line_end":702,"column_start":8,"column_end":21},"name":"bitxor_assign","qualname":"::ops::bit::BitXorAssign::bitxor_assign","value":"fn (&mut self, rhs: Rhs) -> ()","parent":{"krate":0,"index":1586},"children":[],"decl_id":null,"docs":" Performs the `^=` operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":767808,"byte_end":767864,"line_start":701,"line_end":701,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":1590},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":769079,"byte_end":769088,"line_start":746,"line_end":746,"column_start":11,"column_end":20},"name":"ShlAssign","qualname":"::ops::bit::ShlAssign","value":"ShlAssign<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1592}],"decl_id":null,"docs":" The left shift assignment operator `<<=`.","sig":null,"attributes":[{"value":"lang = \"shl_assign\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":768814,"byte_end":768836,"line_start":741,"line_end":741,"column_start":1,"column_end":23}},{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":768859,"byte_end":768915,"line_start":743,"line_end":743,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(message = \"no implementation for `{Self} <<= {Rhs}`\",\n                         label = \"no implementation for `{Self} <<= {Rhs}`\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":768916,"byte_end":769068,"line_start":744,"line_end":745,"column_start":1,"column_end":76}}]},{"kind":"Method","id":{"krate":0,"index":1592},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":769207,"byte_end":769217,"line_start":749,"line_end":749,"column_start":8,"column_end":18},"name":"shl_assign","qualname":"::ops::bit::ShlAssign::shl_assign","value":"fn (&mut self, rhs: Rhs) -> ()","parent":{"krate":0,"index":1590},"children":[],"decl_id":null,"docs":" Performs the `<<=` operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":769143,"byte_end":769199,"line_start":748,"line_end":748,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":1595},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":770988,"byte_end":770997,"line_start":814,"line_end":814,"column_start":11,"column_end":20},"name":"ShrAssign","qualname":"::ops::bit::ShrAssign","value":"ShrAssign<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1597}],"decl_id":null,"docs":" The right shift assignment operator `>>=`.","sig":null,"attributes":[{"value":"lang = \"shr_assign\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":770723,"byte_end":770745,"line_start":809,"line_end":809,"column_start":1,"column_end":23}},{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":770768,"byte_end":770824,"line_start":811,"line_end":811,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(message = \"no implementation for `{Self} >>= {Rhs}`\",\n                         label = \"no implementation for `{Self} >>= {Rhs}`\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":770825,"byte_end":770977,"line_start":812,"line_end":813,"column_start":1,"column_end":76}}]},{"kind":"Method","id":{"krate":0,"index":1597},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":771116,"byte_end":771126,"line_start":817,"line_end":817,"column_start":8,"column_end":18},"name":"shr_assign","qualname":"::ops::bit::ShrAssign::shr_assign","value":"fn (&mut self, rhs: Rhs) -> ()","parent":{"krate":0,"index":1595},"children":[],"decl_id":null,"docs":" Performs the `>>=` operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":771052,"byte_end":771108,"line_start":816,"line_end":816,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":1601},"span":{"file_name":"src/libcore/ops/deref.rs","byte_start":774523,"byte_end":774528,"line_start":64,"line_end":64,"column_start":11,"column_end":16},"name":"Deref","qualname":"::ops::deref::Deref","value":"Deref","parent":null,"children":[{"krate":0,"index":1602},{"krate":0,"index":1603}],"decl_id":null,"docs":" Used for immutable dereferencing operations, like `*v`.","sig":null,"attributes":[{"value":"lang = \"deref\"","span":{"file_name":"src/libcore/ops/deref.rs","byte_start":774408,"byte_end":774425,"line_start":60,"line_end":60,"column_start":1,"column_end":18}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/deref.rs","byte_start":774467,"byte_end":774512,"line_start":63,"line_end":63,"column_start":1,"column_end":46}}]},{"kind":"Type","id":{"krate":0,"index":1602},"span":{"file_name":"src/libcore/ops/deref.rs","byte_start":774638,"byte_end":774644,"line_start":67,"line_end":67,"column_start":10,"column_end":16},"name":"Target","qualname":"::ops::deref::Deref::Target","value":"type Target: ?Sized;","parent":{"krate":0,"index":1601},"children":[],"decl_id":null,"docs":" The resulting type after dereferencing.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/deref.rs","byte_start":774583,"byte_end":774628,"line_start":66,"line_end":66,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1603},"span":{"file_name":"src/libcore/ops/deref.rs","byte_start":774760,"byte_end":774765,"line_start":72,"line_end":72,"column_start":8,"column_end":13},"name":"deref","qualname":"::ops::deref::Deref::deref","value":"fn (&self) -> &Self::Target","parent":{"krate":0,"index":1601},"children":[],"decl_id":null,"docs":" Dereferences the value.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/deref.rs","byte_start":774691,"byte_end":774702,"line_start":70,"line_end":70,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/deref.rs","byte_start":774707,"byte_end":774752,"line_start":71,"line_end":71,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1612},"span":{"file_name":"src/libcore/ops/deref.rs","byte_start":777645,"byte_end":777653,"line_start":160,"line_end":160,"column_start":11,"column_end":19},"name":"DerefMut","qualname":"::ops::deref::DerefMut","value":"DerefMut: Deref","parent":null,"children":[{"krate":0,"index":1613}],"decl_id":null,"docs":" Used for mutable dereferencing operations, like in `*v = 1;`.","sig":null,"attributes":[{"value":"lang = \"deref_mut\"","span":{"file_name":"src/libcore/ops/deref.rs","byte_start":777547,"byte_end":777568,"line_start":157,"line_end":157,"column_start":1,"column_end":22}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/deref.rs","byte_start":777589,"byte_end":777634,"line_start":159,"line_end":159,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":1613},"span":{"file_name":"src/libcore/ops/deref.rs","byte_start":777760,"byte_end":777769,"line_start":163,"line_end":163,"column_start":8,"column_end":17},"name":"deref_mut","qualname":"::ops::deref::DerefMut::deref_mut","value":"fn (&mut self) -> &mut Self::Target","parent":{"krate":0,"index":1612},"children":[],"decl_id":null,"docs":" Mutably dereferences the value.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/deref.rs","byte_start":777707,"byte_end":777752,"line_start":162,"line_end":162,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1617},"span":{"file_name":"src/libcore/ops/deref.rs","byte_start":778242,"byte_end":778250,"line_start":177,"line_end":177,"column_start":11,"column_end":19},"name":"Receiver","qualname":"::ops::deref::Receiver","value":"Receiver","parent":null,"children":[],"decl_id":null,"docs":" Indicates that a struct can be used as a method receiver, without the\n `arbitrary_self_types` feature. This is implemented by stdlib pointer types like `Box<T>`,\n `Rc<T>`, `&T`, and `Pin<P>`.\n","sig":null,"attributes":[{"value":"lang = \"receiver\"","span":{"file_name":"src/libcore/ops/deref.rs","byte_start":778143,"byte_end":778163,"line_start":174,"line_end":174,"column_start":1,"column_end":21}},{"value":"unstable(feature = \"receiver_trait\", issue = \"0\")","span":{"file_name":"src/libcore/ops/deref.rs","byte_start":778164,"byte_end":778216,"line_start":175,"line_end":175,"column_start":1,"column_end":53}}]},{"kind":"Trait","id":{"krate":0,"index":1623},"span":{"file_name":"src/libcore/ops/drop.rs","byte_start":780570,"byte_end":780574,"line_start":85,"line_end":85,"column_start":11,"column_end":15},"name":"Drop","qualname":"::ops::drop::Drop","value":"Drop","parent":null,"children":[{"krate":0,"index":1624}],"decl_id":null,"docs":" Used to run some code when a value goes out of scope.\n This is sometimes called a 'destructor'.","sig":null,"attributes":[{"value":"lang = \"drop\"","span":{"file_name":"src/libcore/ops/drop.rs","byte_start":780497,"byte_end":780513,"line_start":83,"line_end":83,"column_start":1,"column_end":17}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/drop.rs","byte_start":780514,"byte_end":780559,"line_start":84,"line_end":84,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":1624},"span":{"file_name":"src/libcore/ops/drop.rs","byte_start":781493,"byte_end":781497,"line_start":106,"line_end":106,"column_start":8,"column_end":12},"name":"drop","qualname":"::ops::drop::Drop::drop","value":"fn (&mut self) -> ()","parent":{"krate":0,"index":1623},"children":[],"decl_id":null,"docs":" Executes the destructor for this type.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/drop.rs","byte_start":781440,"byte_end":781485,"line_start":105,"line_end":105,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1626},"span":{"file_name":"src/libcore/ops/function.rs","byte_start":783920,"byte_end":783922,"line_start":66,"line_end":66,"column_start":11,"column_end":13},"name":"Fn","qualname":"::ops::function::Fn","value":"Fn<Args>: FnMut<Args>","parent":null,"children":[{"krate":0,"index":1628}],"decl_id":null,"docs":" The version of the call operator that takes an immutable receiver.","sig":null,"attributes":[{"value":"lang = \"fn\"","span":{"file_name":"src/libcore/ops/function.rs","byte_start":783450,"byte_end":783464,"line_start":56,"line_end":56,"column_start":1,"column_end":15}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/function.rs","byte_start":783465,"byte_end":783510,"line_start":57,"line_end":57,"column_start":1,"column_end":46}},{"value":"rustc_paren_sugar","span":{"file_name":"src/libcore/ops/function.rs","byte_start":783511,"byte_end":783531,"line_start":58,"line_end":58,"column_start":1,"column_end":21}},{"value":"rustc_on_unimplemented(on(Args = \"()\",\n                            note =\n                                \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"),\n                         message =\n                             \"expected a `{Fn}<{Args}>` closure, found `{Self}`\",\n                         label =\n                             \"expected an `Fn<{Args}>` closure, found `{Self}`\")","span":{"file_name":"src/libcore/ops/function.rs","byte_start":783532,"byte_end":783785,"line_start":59,"line_end":63,"column_start":1,"column_end":3}},{"value":"fundamental","span":{"file_name":"src/libcore/ops/function.rs","byte_start":783786,"byte_end":783800,"line_start":64,"line_end":64,"column_start":1,"column_end":15}},{"value":"must_use = \"closures are lazy and do nothing unless called\"","span":{"file_name":"src/libcore/ops/function.rs","byte_start":783847,"byte_end":783909,"line_start":65,"line_end":65,"column_start":1,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":1628},"span":{"file_name":"src/libcore/ops/function.rs","byte_start":784064,"byte_end":784068,"line_start":69,"line_end":69,"column_start":27,"column_end":31},"name":"call","qualname":"::ops::function::Fn::call","value":"fn (&self, args: Args) -> Self::Output","parent":{"krate":0,"index":1626},"children":[],"decl_id":null,"docs":" Performs the call operation.\n","sig":null,"attributes":[{"value":"unstable(feature = \"fn_traits\", issue = \"29625\")","span":{"file_name":"src/libcore/ops/function.rs","byte_start":783986,"byte_end":784037,"line_start":68,"line_end":68,"column_start":5,"column_end":56}}]},{"kind":"Trait","id":{"krate":0,"index":1629},"span":{"file_name":"src/libcore/ops/function.rs","byte_start":786640,"byte_end":786645,"line_start":145,"line_end":145,"column_start":11,"column_end":16},"name":"FnMut","qualname":"::ops::function::FnMut","value":"FnMut<Args>: FnOnce<Args>","parent":null,"children":[{"krate":0,"index":1631}],"decl_id":null,"docs":" The version of the call operator that takes a mutable receiver.","sig":null,"attributes":[{"value":"lang = \"fn_mut\"","span":{"file_name":"src/libcore/ops/function.rs","byte_start":786160,"byte_end":786178,"line_start":135,"line_end":135,"column_start":1,"column_end":19}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/function.rs","byte_start":786179,"byte_end":786224,"line_start":136,"line_end":136,"column_start":1,"column_end":46}},{"value":"rustc_paren_sugar","span":{"file_name":"src/libcore/ops/function.rs","byte_start":786225,"byte_end":786245,"line_start":137,"line_end":137,"column_start":1,"column_end":21}},{"value":"rustc_on_unimplemented(on(Args = \"()\",\n                            note =\n                                \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"),\n                         message =\n                             \"expected a `{FnMut}<{Args}>` closure, found `{Self}`\",\n                         label =\n                             \"expected an `FnMut<{Args}>` closure, found `{Self}`\")","span":{"file_name":"src/libcore/ops/function.rs","byte_start":786246,"byte_end":786505,"line_start":138,"line_end":142,"column_start":1,"column_end":3}},{"value":"fundamental","span":{"file_name":"src/libcore/ops/function.rs","byte_start":786506,"byte_end":786520,"line_start":143,"line_end":143,"column_start":1,"column_end":15}},{"value":"must_use = \"closures are lazy and do nothing unless called\"","span":{"file_name":"src/libcore/ops/function.rs","byte_start":786567,"byte_end":786629,"line_start":144,"line_end":144,"column_start":1,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":1631},"span":{"file_name":"src/libcore/ops/function.rs","byte_start":786788,"byte_end":786796,"line_start":148,"line_end":148,"column_start":27,"column_end":35},"name":"call_mut","qualname":"::ops::function::FnMut::call_mut","value":"fn (&mut self, args: Args) -> Self::Output","parent":{"krate":0,"index":1629},"children":[],"decl_id":null,"docs":" Performs the call operation.\n","sig":null,"attributes":[{"value":"unstable(feature = \"fn_traits\", issue = \"29625\")","span":{"file_name":"src/libcore/ops/function.rs","byte_start":786710,"byte_end":786761,"line_start":147,"line_end":147,"column_start":5,"column_end":56}}]},{"kind":"Trait","id":{"krate":0,"index":1632},"span":{"file_name":"src/libcore/ops/function.rs","byte_start":789574,"byte_end":789580,"line_start":224,"line_end":224,"column_start":11,"column_end":17},"name":"FnOnce","qualname":"::ops::function::FnOnce","value":"FnOnce<Args>","parent":null,"children":[{"krate":0,"index":1634},{"krate":0,"index":1635}],"decl_id":null,"docs":" The version of the call operator that takes a by-value receiver.","sig":null,"attributes":[{"value":"lang = \"fn_once\"","span":{"file_name":"src/libcore/ops/function.rs","byte_start":789091,"byte_end":789110,"line_start":214,"line_end":214,"column_start":1,"column_end":20}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/function.rs","byte_start":789111,"byte_end":789156,"line_start":215,"line_end":215,"column_start":1,"column_end":46}},{"value":"rustc_paren_sugar","span":{"file_name":"src/libcore/ops/function.rs","byte_start":789157,"byte_end":789177,"line_start":216,"line_end":216,"column_start":1,"column_end":21}},{"value":"rustc_on_unimplemented(on(Args = \"()\",\n                            note =\n                                \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"),\n                         message =\n                             \"expected a `{FnOnce}<{Args}>` closure, found `{Self}`\",\n                         label =\n                             \"expected an `FnOnce<{Args}>` closure, found `{Self}`\")","span":{"file_name":"src/libcore/ops/function.rs","byte_start":789178,"byte_end":789439,"line_start":217,"line_end":221,"column_start":1,"column_end":3}},{"value":"fundamental","span":{"file_name":"src/libcore/ops/function.rs","byte_start":789440,"byte_end":789454,"line_start":222,"line_end":222,"column_start":1,"column_end":15}},{"value":"must_use = \"closures are lazy and do nothing unless called\"","span":{"file_name":"src/libcore/ops/function.rs","byte_start":789501,"byte_end":789563,"line_start":223,"line_end":223,"column_start":1,"column_end":63}}]},{"kind":"Type","id":{"krate":0,"index":1634},"span":{"file_name":"src/libcore/ops/function.rs","byte_start":789717,"byte_end":789723,"line_start":227,"line_end":227,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::function::FnOnce::Output","value":"type Output;","parent":{"krate":0,"index":1632},"children":[],"decl_id":null,"docs":" The returned type after the call operator is used.\n","sig":null,"attributes":[{"value":"stable(feature = \"fn_once_output\", since = \"1.12.0\")","span":{"file_name":"src/libcore/ops/function.rs","byte_start":789652,"byte_end":789707,"line_start":226,"line_end":226,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":1635},"span":{"file_name":"src/libcore/ops/function.rs","byte_start":789845,"byte_end":789854,"line_start":231,"line_end":231,"column_start":27,"column_end":36},"name":"call_once","qualname":"::ops::function::FnOnce::call_once","value":"fn (self, args: Args) -> Self::Output","parent":{"krate":0,"index":1632},"children":[],"decl_id":null,"docs":" Performs the call operation.\n","sig":null,"attributes":[{"value":"unstable(feature = \"fn_traits\", issue = \"29625\")","span":{"file_name":"src/libcore/ops/function.rs","byte_start":789767,"byte_end":789818,"line_start":230,"line_end":230,"column_start":5,"column_end":56}}]},{"kind":"TupleVariant","id":{"krate":0,"index":26012},"span":{"file_name":"src/libcore/ops/generator.rs","byte_start":792032,"byte_end":792039,"line_start":19,"line_end":19,"column_start":5,"column_end":12},"name":"Yielded","qualname":"::ops::generator::GeneratorState::Yielded","value":"GeneratorState::Yielded(Y)","parent":{"krate":0,"index":26009},"children":[],"decl_id":null,"docs":" The generator suspended with a value.","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":26015},"span":{"file_name":"src/libcore/ops/generator.rs","byte_start":792321,"byte_end":792329,"line_start":26,"line_end":26,"column_start":5,"column_end":13},"name":"Complete","qualname":"::ops::generator::GeneratorState::Complete","value":"GeneratorState::Complete(R)","parent":{"krate":0,"index":26009},"children":[],"decl_id":null,"docs":" The generator completed with a return value.","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":26009},"span":{"file_name":"src/libcore/ops/generator.rs","byte_start":791665,"byte_end":791679,"line_start":12,"line_end":12,"column_start":10,"column_end":24},"name":"GeneratorState","qualname":"::ops::generator::GeneratorState","value":"GeneratorState::{Yielded, Complete}","parent":null,"children":[{"krate":0,"index":26012},{"krate":0,"index":26015}],"decl_id":null,"docs":" The result of a generator resumption.","sig":null,"attributes":[{"value":"lang = \"generator_state\"","span":{"file_name":"src/libcore/ops/generator.rs","byte_start":791570,"byte_end":791597,"line_start":10,"line_end":10,"column_start":1,"column_end":28}},{"value":"unstable(feature = \"generator_trait\", issue = \"43122\")","span":{"file_name":"src/libcore/ops/generator.rs","byte_start":791598,"byte_end":791655,"line_start":11,"line_end":11,"column_start":1,"column_end":58}},{"value":"structural_match","span":{"file_name":"src/libcore/ops/generator.rs","byte_start":791656,"byte_end":792335,"line_start":12,"line_end":27,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/ops/generator.rs","byte_start":791656,"byte_end":792335,"line_start":12,"line_end":27,"column_start":1,"column_end":2}}]},{"kind":"Trait","id":{"krate":0,"index":1662},"span":{"file_name":"src/libcore/ops/generator.rs","byte_start":793747,"byte_end":793756,"line_start":70,"line_end":70,"column_start":11,"column_end":20},"name":"Generator","qualname":"::ops::generator::Generator","value":"Generator","parent":null,"children":[{"krate":0,"index":1663},{"krate":0,"index":1664},{"krate":0,"index":1665}],"decl_id":null,"docs":" The trait implemented by builtin generator types.","sig":null,"attributes":[{"value":"lang = \"generator\"","span":{"file_name":"src/libcore/ops/generator.rs","byte_start":793642,"byte_end":793663,"line_start":67,"line_end":67,"column_start":1,"column_end":22}},{"value":"unstable(feature = \"generator_trait\", issue = \"43122\")","span":{"file_name":"src/libcore/ops/generator.rs","byte_start":793664,"byte_end":793721,"line_start":68,"line_end":68,"column_start":1,"column_end":58}},{"value":"fundamental","span":{"file_name":"src/libcore/ops/generator.rs","byte_start":793722,"byte_end":793736,"line_start":69,"line_end":69,"column_start":1,"column_end":15}}]},{"kind":"Type","id":{"krate":0,"index":1663},"span":{"file_name":"src/libcore/ops/generator.rs","byte_start":794099,"byte_end":794104,"line_start":77,"line_end":77,"column_start":10,"column_end":15},"name":"Yield","qualname":"::ops::generator::Generator::Yield","value":"type Yield;","parent":{"krate":0,"index":1662},"children":[],"decl_id":null,"docs":" The type of value this generator yields.","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":1664},"span":{"file_name":"src/libcore/ops/generator.rs","byte_start":794445,"byte_end":794451,"line_start":85,"line_end":85,"column_start":10,"column_end":16},"name":"Return","qualname":"::ops::generator::Generator::Return","value":"type Return;","parent":{"krate":0,"index":1662},"children":[],"decl_id":null,"docs":" The type of value this generator returns.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":1665},"span":{"file_name":"src/libcore/ops/generator.rs","byte_start":795776,"byte_end":795782,"line_start":113,"line_end":113,"column_start":8,"column_end":14},"name":"resume","qualname":"::ops::generator::Generator::resume","value":"fn (self: Pin<&mut Self>) -> GeneratorState<Self::Yield, Self::Return>","parent":{"krate":0,"index":1662},"children":[],"decl_id":null,"docs":" Resumes the execution of this generator.","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":1677},"span":{"file_name":"src/libcore/ops/index.rs","byte_start":798305,"byte_end":798310,"line_start":61,"line_end":61,"column_start":11,"column_end":16},"name":"Index","qualname":"::ops::index::Index","value":"Index<Idx: ?Sized>","parent":null,"children":[{"krate":0,"index":1679},{"krate":0,"index":1680}],"decl_id":null,"docs":" Used for indexing operations (`container[index]`) in immutable contexts.","sig":null,"attributes":[{"value":"lang = \"index\"","span":{"file_name":"src/libcore/ops/index.rs","byte_start":798028,"byte_end":798045,"line_start":52,"line_end":52,"column_start":1,"column_end":18}},{"value":"rustc_on_unimplemented(message =\n                             \"the type `{Self}` cannot be indexed by `{Idx}`\",\n                         label = \"`{Self}` cannot be indexed by `{Idx}`\")","span":{"file_name":"src/libcore/ops/index.rs","byte_start":798046,"byte_end":798187,"line_start":53,"line_end":56,"column_start":1,"column_end":3}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/index.rs","byte_start":798188,"byte_end":798233,"line_start":57,"line_end":57,"column_start":1,"column_end":46}}]},{"kind":"Type","id":{"krate":0,"index":1679},"span":{"file_name":"src/libcore/ops/index.rs","byte_start":798427,"byte_end":798433,"line_start":64,"line_end":64,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::index::Index::Output","value":"type Output: ?Sized;","parent":{"krate":0,"index":1677},"children":[],"decl_id":null,"docs":" The returned type after indexing.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/index.rs","byte_start":798372,"byte_end":798417,"line_start":63,"line_end":63,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1680},"span":{"file_name":"src/libcore/ops/index.rs","byte_start":798563,"byte_end":798568,"line_start":68,"line_end":68,"column_start":8,"column_end":13},"name":"index","qualname":"::ops::index::Index::index","value":"fn (&self, index: Idx) -> &Self::Output","parent":{"krate":0,"index":1677},"children":[],"decl_id":null,"docs":" Performs the indexing (`container[index]`) operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/index.rs","byte_start":798510,"byte_end":798555,"line_start":67,"line_end":67,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1681},"span":{"file_name":"src/libcore/ops/index.rs","byte_start":801638,"byte_end":801646,"line_start":166,"line_end":166,"column_start":11,"column_end":19},"name":"IndexMut","qualname":"::ops::index::IndexMut","value":"IndexMut<Idx: ?Sized>: Index<Idx>","parent":null,"children":[{"krate":0,"index":1683}],"decl_id":null,"docs":" Used for indexing operations (`container[index]`) in mutable contexts.","sig":null,"attributes":[{"value":"lang = \"index_mut\"","span":{"file_name":"src/libcore/ops/index.rs","byte_start":800724,"byte_end":800745,"line_start":142,"line_end":142,"column_start":1,"column_end":22}},{"value":"rustc_on_unimplemented(on(_Self = \"&str\",\n                            note =\n                                \"you can use `.chars().nth()` or `.bytes().nth()`\nsee chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"),\n                         on(_Self = \"str\",\n                            note =\n                                \"you can use `.chars().nth()` or `.bytes().nth()`\nsee chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"),\n                         on(_Self = \"std::string::String\",\n                            note =\n                                \"you can use `.chars().nth()` or `.bytes().nth()`\nsee chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"),\n                         message =\n                             \"the type `{Self}` cannot be mutably indexed by `{Idx}`\",\n                         label =\n                             \"`{Self}` cannot be mutably indexed by `{Idx}`\")","span":{"file_name":"src/libcore/ops/index.rs","byte_start":800746,"byte_end":801520,"line_start":143,"line_end":161,"column_start":1,"column_end":3}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/index.rs","byte_start":801521,"byte_end":801566,"line_start":162,"line_end":162,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":1683},"span":{"file_name":"src/libcore/ops/index.rs","byte_start":801801,"byte_end":801810,"line_start":169,"line_end":169,"column_start":8,"column_end":17},"name":"index_mut","qualname":"::ops::index::IndexMut::index_mut","value":"fn (&mut self, index: Idx) -> &mut Self::Output","parent":{"krate":0,"index":1681},"children":[],"decl_id":null,"docs":" Performs the mutable indexing (`container[index]`) operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/index.rs","byte_start":801748,"byte_end":801793,"line_start":168,"line_end":168,"column_start":5,"column_end":50}}]},{"kind":"Struct","id":{"krate":0,"index":26055},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":803107,"byte_end":803116,"line_start":44,"line_end":44,"column_start":12,"column_end":21},"name":"RangeFull","qualname":"::ops::range::RangeFull","value":"","parent":null,"children":[],"decl_id":null,"docs":" An unbounded range (`..`).","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":803050,"byte_end":803095,"line_start":43,"line_end":43,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/ops/range.rs","byte_start":803096,"byte_end":803117,"line_start":44,"line_end":44,"column_start":1,"column_end":22}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/ops/range.rs","byte_start":803096,"byte_end":803117,"line_start":44,"line_end":44,"column_start":1,"column_end":22}}]},{"kind":"Struct","id":{"krate":0,"index":26067},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":804088,"byte_end":804093,"line_start":76,"line_end":76,"column_start":12,"column_end":17},"name":"Range","qualname":"::ops::range::Range","value":"Range { start, end }","parent":null,"children":[{"krate":0,"index":26069},{"krate":0,"index":26070}],"decl_id":null,"docs":" A (half-open) range bounded inclusively below and exclusively above\n (`start..end`).","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":804031,"byte_end":804076,"line_start":75,"line_end":75,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/ops/range.rs","byte_start":804077,"byte_end":804340,"line_start":76,"line_end":83,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":26069},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":804209,"byte_end":804214,"line_start":79,"line_end":79,"column_start":9,"column_end":14},"name":"start","qualname":"::ops::range::Range::start","value":"Idx","parent":{"krate":0,"index":26067},"children":[],"decl_id":null,"docs":" The lower bound of the range (inclusive).\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":804155,"byte_end":804200,"line_start":78,"line_end":78,"column_start":5,"column_end":50}}]},{"kind":"Field","id":{"krate":0,"index":26070},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":804329,"byte_end":804332,"line_start":82,"line_end":82,"column_start":9,"column_end":12},"name":"end","qualname":"::ops::range::Range::end","value":"Idx","parent":{"krate":0,"index":26067},"children":[],"decl_id":null,"docs":" The upper bound of the range (exclusive).\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":804275,"byte_end":804320,"line_start":81,"line_end":81,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1696},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":805318,"byte_end":805326,"line_start":117,"line_end":117,"column_start":12,"column_end":20},"name":"contains","qualname":"<Range<Idx>>::contains","value":"fn <U> (&self, item: &U) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `item` is contained in the range.","sig":null,"attributes":[{"value":"stable(feature = \"range_contains\", since = \"1.35.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":805251,"byte_end":805306,"line_start":116,"line_end":116,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":1698},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":806161,"byte_end":806169,"line_start":148,"line_end":148,"column_start":12,"column_end":20},"name":"is_empty","qualname":"<Range<Idx>>::is_empty","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the range contains no items.","sig":null,"attributes":[{"value":"unstable(feature = \"range_is_empty\",\n           reason = \"recently added\",\n           issue = \"48111\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":806066,"byte_end":806149,"line_start":147,"line_end":147,"column_start":5,"column_end":88}}]},{"kind":"Struct","id":{"krate":0,"index":26085},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":807280,"byte_end":807289,"line_start":181,"line_end":181,"column_start":12,"column_end":21},"name":"RangeFrom","qualname":"::ops::range::RangeFrom","value":"RangeFrom { start }","parent":null,"children":[{"krate":0,"index":26087}],"decl_id":null,"docs":" A range only bounded inclusively below (`start..`).","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":807223,"byte_end":807268,"line_start":180,"line_end":180,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/ops/range.rs","byte_start":807269,"byte_end":807418,"line_start":181,"line_end":185,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":26087},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":807405,"byte_end":807410,"line_start":184,"line_end":184,"column_start":9,"column_end":14},"name":"start","qualname":"::ops::range::RangeFrom::start","value":"Idx","parent":{"krate":0,"index":26085},"children":[],"decl_id":null,"docs":" The lower bound of the range (inclusive).\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":807351,"byte_end":807396,"line_start":183,"line_end":183,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1704},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":808201,"byte_end":808209,"line_start":213,"line_end":213,"column_start":12,"column_end":20},"name":"contains","qualname":"<RangeFrom<Idx>>::contains","value":"fn <U> (&self, item: &U) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `item` is contained in the range.","sig":null,"attributes":[{"value":"stable(feature = \"range_contains\", since = \"1.35.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":808134,"byte_end":808189,"line_start":212,"line_end":212,"column_start":5,"column_end":60}}]},{"kind":"Struct","id":{"krate":0,"index":26102},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":809760,"byte_end":809767,"line_start":265,"line_end":265,"column_start":12,"column_end":19},"name":"RangeTo","qualname":"::ops::range::RangeTo","value":"RangeTo { end }","parent":null,"children":[{"krate":0,"index":26104}],"decl_id":null,"docs":" A range only bounded exclusively above (`..end`).","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":809703,"byte_end":809748,"line_start":264,"line_end":264,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/ops/range.rs","byte_start":809749,"byte_end":809894,"line_start":265,"line_end":269,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/ops/range.rs","byte_start":809749,"byte_end":809894,"line_start":265,"line_end":269,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":26104},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":809883,"byte_end":809886,"line_start":268,"line_end":268,"column_start":9,"column_end":12},"name":"end","qualname":"::ops::range::RangeTo::end","value":"Idx","parent":{"krate":0,"index":26102},"children":[],"decl_id":null,"docs":" The upper bound of the range (exclusive).\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":809829,"byte_end":809874,"line_start":267,"line_end":267,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1711},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":810672,"byte_end":810680,"line_start":297,"line_end":297,"column_start":12,"column_end":20},"name":"contains","qualname":"<RangeTo<Idx>>::contains","value":"fn <U> (&self, item: &U) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `item` is contained in the range.","sig":null,"attributes":[{"value":"stable(feature = \"range_contains\", since = \"1.35.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":810605,"byte_end":810660,"line_start":296,"line_end":296,"column_start":5,"column_end":60}}]},{"kind":"Struct","id":{"krate":0,"index":26121},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":811946,"byte_end":811960,"line_start":335,"line_end":335,"column_start":12,"column_end":26},"name":"RangeInclusive","qualname":"::ops::range::RangeInclusive","value":"RangeInclusive {  }","parent":null,"children":[{"krate":0,"index":26123},{"krate":0,"index":26124},{"krate":0,"index":26125}],"decl_id":null,"docs":" A range bounded inclusively below and above (`start..=end`).","sig":null,"attributes":[{"value":"stable(feature = \"inclusive_range\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":811878,"byte_end":811934,"line_start":334,"line_end":334,"column_start":1,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":1714},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":812443,"byte_end":812465,"line_start":348,"line_end":348,"column_start":8,"column_end":30},"name":"canonicalized_is_empty","qualname":"::ops::range::RangeInclusiveEquality::canonicalized_is_empty","value":"fn (range: &RangeInclusive<Self>) -> bool","parent":{"krate":0,"index":1713},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":37152},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":814039,"byte_end":814042,"line_start":401,"line_end":401,"column_start":18,"column_end":21},"name":"new","qualname":"<RangeInclusive<Idx>>::new","value":"fn (start: Idx, end: Idx) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a new inclusive range. Equivalent to writing `start..=end`.","sig":null,"attributes":[{"value":"stable(feature = \"inclusive_range_methods\", since = \"1.27.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":813919,"byte_end":813983,"line_start":398,"line_end":398,"column_start":5,"column_end":69}},{"value":"inline","span":{"file_name":"src/libcore/ops/range.rs","byte_start":813988,"byte_end":813997,"line_start":399,"line_end":399,"column_start":5,"column_end":14}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/ops/range.rs","byte_start":814002,"byte_end":814021,"line_start":400,"line_end":400,"column_start":5,"column_end":24}}]},{"kind":"Method","id":{"krate":0,"index":1732},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":814924,"byte_end":814929,"line_start":429,"line_end":429,"column_start":18,"column_end":23},"name":"start","qualname":"<RangeInclusive<Idx>>::start","value":"fn (&self) -> &Idx","parent":null,"children":[],"decl_id":null,"docs":" Returns the lower bound of the range (inclusive).","sig":null,"attributes":[{"value":"stable(feature = \"inclusive_range_methods\", since = \"1.27.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":814828,"byte_end":814892,"line_start":427,"line_end":427,"column_start":5,"column_end":69}},{"value":"inline","span":{"file_name":"src/libcore/ops/range.rs","byte_start":814897,"byte_end":814906,"line_start":428,"line_end":428,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1733},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":815729,"byte_end":815732,"line_start":453,"line_end":453,"column_start":18,"column_end":21},"name":"end","qualname":"<RangeInclusive<Idx>>::end","value":"fn (&self) -> &Idx","parent":null,"children":[],"decl_id":null,"docs":" Returns the upper bound of the range (inclusive).","sig":null,"attributes":[{"value":"stable(feature = \"inclusive_range_methods\", since = \"1.27.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":815633,"byte_end":815697,"line_start":451,"line_end":451,"column_start":5,"column_end":69}},{"value":"inline","span":{"file_name":"src/libcore/ops/range.rs","byte_start":815702,"byte_end":815711,"line_start":452,"line_end":452,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1734},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":816193,"byte_end":816203,"line_start":469,"line_end":469,"column_start":12,"column_end":22},"name":"into_inner","qualname":"<RangeInclusive<Idx>>::into_inner","value":"fn (self) -> (Idx, Idx)","parent":null,"children":[],"decl_id":null,"docs":" Destructures the `RangeInclusive` into (lower bound, upper (inclusive) bound).","sig":null,"attributes":[{"value":"stable(feature = \"inclusive_range_methods\", since = \"1.27.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":816103,"byte_end":816167,"line_start":467,"line_end":467,"column_start":5,"column_end":69}},{"value":"inline","span":{"file_name":"src/libcore/ops/range.rs","byte_start":816172,"byte_end":816181,"line_start":468,"line_end":468,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1740},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":817322,"byte_end":817330,"line_start":507,"line_end":507,"column_start":12,"column_end":20},"name":"contains","qualname":"<RangeInclusive<Idx>>::contains","value":"fn <U> (&self, item: &U) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `item` is contained in the range.","sig":null,"attributes":[{"value":"stable(feature = \"range_contains\", since = \"1.35.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":817255,"byte_end":817310,"line_start":506,"line_end":506,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":1742},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":818476,"byte_end":818484,"line_start":550,"line_end":550,"column_start":12,"column_end":20},"name":"is_empty","qualname":"<RangeInclusive<Idx>>::is_empty","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the range contains no items.","sig":null,"attributes":[{"value":"unstable(feature = \"range_is_empty\",\n           reason = \"recently added\",\n           issue = \"48111\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":818367,"byte_end":818450,"line_start":548,"line_end":548,"column_start":5,"column_end":88}},{"value":"inline","span":{"file_name":"src/libcore/ops/range.rs","byte_start":818455,"byte_end":818464,"line_start":549,"line_end":549,"column_start":5,"column_end":14}}]},{"kind":"Struct","id":{"krate":0,"index":26129},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":820312,"byte_end":820328,"line_start":606,"line_end":606,"column_start":12,"column_end":28},"name":"RangeToInclusive","qualname":"::ops::range::RangeToInclusive","value":"RangeToInclusive { end }","parent":null,"children":[{"krate":0,"index":26131}],"decl_id":null,"docs":" A range only bounded inclusively above (`..=end`).","sig":null,"attributes":[{"value":"stable(feature = \"inclusive_range\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":820244,"byte_end":820300,"line_start":605,"line_end":605,"column_start":1,"column_end":57}},{"value":"structural_match","span":{"file_name":"src/libcore/ops/range.rs","byte_start":820301,"byte_end":820465,"line_start":606,"line_end":610,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/ops/range.rs","byte_start":820301,"byte_end":820465,"line_start":606,"line_end":610,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":26131},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":820454,"byte_end":820457,"line_start":609,"line_end":609,"column_start":9,"column_end":12},"name":"end","qualname":"::ops::range::RangeToInclusive::end","value":"Idx","parent":{"krate":0,"index":26129},"children":[],"decl_id":null,"docs":" The upper bound of the range (inclusive)\n","sig":null,"attributes":[{"value":"stable(feature = \"inclusive_range\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":820389,"byte_end":820445,"line_start":608,"line_end":608,"column_start":5,"column_end":61}}]},{"kind":"Method","id":{"krate":0,"index":1750},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":821279,"byte_end":821287,"line_start":638,"line_end":638,"column_start":12,"column_end":20},"name":"contains","qualname":"<RangeToInclusive<Idx>>::contains","value":"fn <U> (&self, item: &U) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `item` is contained in the range.","sig":null,"attributes":[{"value":"stable(feature = \"range_contains\", since = \"1.35.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":821212,"byte_end":821267,"line_start":637,"line_end":637,"column_start":5,"column_end":60}}]},{"kind":"TupleVariant","id":{"krate":0,"index":26150},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":822801,"byte_end":822809,"line_start":690,"line_end":690,"column_start":5,"column_end":13},"name":"Included","qualname":"::ops::range::Bound::Included","value":"Bound::Included(T)","parent":{"krate":0,"index":26148},"children":[],"decl_id":null,"docs":" An inclusive bound.\n","sig":null,"attributes":[{"value":"stable(feature = \"collections_bound\", since = \"1.17.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":822738,"byte_end":822796,"line_start":689,"line_end":689,"column_start":5,"column_end":63}}]},{"kind":"TupleVariant","id":{"krate":0,"index":26153},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":822968,"byte_end":822976,"line_start":693,"line_end":693,"column_start":5,"column_end":13},"name":"Excluded","qualname":"::ops::range::Bound::Excluded","value":"Bound::Excluded(T)","parent":{"krate":0,"index":26148},"children":[],"decl_id":null,"docs":" An exclusive bound.\n","sig":null,"attributes":[{"value":"stable(feature = \"collections_bound\", since = \"1.17.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":822905,"byte_end":822963,"line_start":692,"line_end":692,"column_start":5,"column_end":63}}]},{"kind":"TupleVariant","id":{"krate":0,"index":26156},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":823189,"byte_end":823198,"line_start":696,"line_end":696,"column_start":5,"column_end":14},"name":"Unbounded","qualname":"::ops::range::Bound::Unbounded","value":"Bound::Unbounded","parent":{"krate":0,"index":26148},"children":[],"decl_id":null,"docs":" An infinite endpoint. Indicates that there is no bound in this direction.\n","sig":null,"attributes":[{"value":"stable(feature = \"collections_bound\", since = \"1.17.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":823126,"byte_end":823184,"line_start":695,"line_end":695,"column_start":5,"column_end":63}}]},{"kind":"Enum","id":{"krate":0,"index":26148},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":822695,"byte_end":822700,"line_start":687,"line_end":687,"column_start":10,"column_end":15},"name":"Bound","qualname":"::ops::range::Bound","value":"Bound::{Included, Excluded, Unbounded}","parent":null,"children":[{"krate":0,"index":26150},{"krate":0,"index":26153},{"krate":0,"index":26156}],"decl_id":null,"docs":" An endpoint of a range of keys.","sig":null,"attributes":[{"value":"stable(feature = \"collections_bound\", since = \"1.17.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":822576,"byte_end":822634,"line_start":685,"line_end":685,"column_start":1,"column_end":59}},{"value":"structural_match","span":{"file_name":"src/libcore/ops/range.rs","byte_start":822686,"byte_end":823201,"line_start":687,"line_end":697,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/ops/range.rs","byte_start":822686,"byte_end":823201,"line_start":687,"line_end":697,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":1754},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":823670,"byte_end":823676,"line_start":713,"line_end":713,"column_start":12,"column_end":18},"name":"cloned","qualname":"<Bound<&'_ T>>::cloned","value":"fn (self) -> Bound<T>","parent":null,"children":[],"decl_id":null,"docs":" Map a `Bound<&T>` to a `Bound<T>` by cloning the contents of the bound.","sig":null,"attributes":[{"value":"unstable(feature = \"bound_cloned\", issue = \"61356\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":823604,"byte_end":823658,"line_start":712,"line_end":712,"column_start":5,"column_end":59}}]},{"kind":"Trait","id":{"krate":0,"index":1755},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":824127,"byte_end":824138,"line_start":725,"line_end":725,"column_start":11,"column_end":22},"name":"RangeBounds","qualname":"::ops::range::RangeBounds","value":"RangeBounds<T: ?Sized>","parent":null,"children":[{"krate":0,"index":1757},{"krate":0,"index":1758},{"krate":0,"index":1759}],"decl_id":null,"docs":" `RangeBounds` is implemented by Rust's built-in range types, produced\n by range syntax like `..`, `a..`, `..b`, `..=c`, `d..e`, or `f..=g`.\n","sig":null,"attributes":[{"value":"stable(feature = \"collections_range\", since = \"1.28.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":823911,"byte_end":823969,"line_start":722,"line_end":722,"column_start":1,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":1757},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":824581,"byte_end":824592,"line_start":742,"line_end":742,"column_start":8,"column_end":19},"name":"start_bound","qualname":"::ops::range::RangeBounds::start_bound","value":"fn (&self) -> Bound<&T>","parent":{"krate":0,"index":1755},"children":[],"decl_id":null,"docs":" Start index bound.","sig":null,"attributes":[{"value":"stable(feature = \"collections_range\", since = \"1.28.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":824515,"byte_end":824573,"line_start":741,"line_end":741,"column_start":5,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":1758},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":825036,"byte_end":825045,"line_start":760,"line_end":760,"column_start":8,"column_end":17},"name":"end_bound","qualname":"::ops::range::RangeBounds::end_bound","value":"fn (&self) -> Bound<&T>","parent":{"krate":0,"index":1755},"children":[],"decl_id":null,"docs":" End index bound.","sig":null,"attributes":[{"value":"stable(feature = \"collections_range\", since = \"1.28.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":824970,"byte_end":825028,"line_start":759,"line_end":759,"column_start":5,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":1759},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":825553,"byte_end":825561,"line_start":777,"line_end":777,"column_start":8,"column_end":16},"name":"contains","qualname":"::ops::range::RangeBounds::contains","value":"fn <U> (&self, item: &U) -> bool","parent":{"krate":0,"index":1755},"children":[],"decl_id":null,"docs":" Returns `true` if `item` is contained in the range.","sig":null,"attributes":[{"value":"stable(feature = \"range_contains\", since = \"1.35.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":825490,"byte_end":825545,"line_start":776,"line_end":776,"column_start":5,"column_end":60}}]},{"kind":"Trait","id":{"krate":0,"index":1819},"span":{"file_name":"src/libcore/ops/try.rs","byte_start":830662,"byte_end":830665,"line_start":22,"line_end":22,"column_start":11,"column_end":14},"name":"Try","qualname":"::ops::try::Try","value":"Try","parent":null,"children":[{"krate":0,"index":1820},{"krate":0,"index":1821},{"krate":0,"index":1822},{"krate":0,"index":1823},{"krate":0,"index":1824}],"decl_id":null,"docs":" A trait for customizing the behavior of the `?` operator.","sig":null,"attributes":[{"value":"unstable(feature = \"try_trait\", issue = \"42327\")","span":{"file_name":"src/libcore/ops/try.rs","byte_start":829965,"byte_end":830016,"line_start":7,"line_end":7,"column_start":1,"column_end":52}},{"value":"rustc_on_unimplemented(on(all(any(from_method = \"from_error\",\n                                    from_method = \"from_ok\"),\n                                from_desugaring = \"?\"),\n                            message =\n                                \"the `?` operator can only be used in a \\\n               function that returns `Result` or `Option` \\\n               (or another type that implements `{Try}`)\",\n                            label =\n                                \"cannot use the `?` operator in a function that returns `{Self}`\"),\n                         on(all(from_method = \"into_result\",\n                                from_desugaring = \"?\"),\n                            message =\n                                \"the `?` operator can only be applied to values \\\n               that implement `{Try}`\",\n                            label =\n                                \"the `?` operator cannot be applied to type `{Self}`\"))","span":{"file_name":"src/libcore/ops/try.rs","byte_start":830017,"byte_end":830631,"line_start":8,"line_end":20,"column_start":1,"column_end":3}}]},{"kind":"Type","id":{"krate":0,"index":1820},"span":{"file_name":"src/libcore/ops/try.rs","byte_start":830791,"byte_end":830793,"line_start":25,"line_end":25,"column_start":10,"column_end":12},"name":"Ok","qualname":"::ops::try::Try::Ok","value":"type Ok;","parent":{"krate":0,"index":1819},"children":[],"decl_id":null,"docs":" The type of this value when viewed as successful.\n","sig":null,"attributes":[{"value":"unstable(feature = \"try_trait\", issue = \"42327\")","span":{"file_name":"src/libcore/ops/try.rs","byte_start":830730,"byte_end":830781,"line_start":24,"line_end":24,"column_start":5,"column_end":56}}]},{"kind":"Type","id":{"krate":0,"index":1821},"span":{"file_name":"src/libcore/ops/try.rs","byte_start":830914,"byte_end":830919,"line_start":28,"line_end":28,"column_start":10,"column_end":15},"name":"Error","qualname":"::ops::try::Try::Error","value":"type Error;","parent":{"krate":0,"index":1819},"children":[],"decl_id":null,"docs":" The type of this value when viewed as failed.\n","sig":null,"attributes":[{"value":"unstable(feature = \"try_trait\", issue = \"42327\")","span":{"file_name":"src/libcore/ops/try.rs","byte_start":830853,"byte_end":830904,"line_start":27,"line_end":27,"column_start":5,"column_end":56}}]},{"kind":"Method","id":{"krate":0,"index":1822},"span":{"file_name":"src/libcore/ops/try.rs","byte_start":831585,"byte_end":831596,"line_start":40,"line_end":40,"column_start":8,"column_end":19},"name":"into_result","qualname":"::ops::try::Try::into_result","value":"fn (self) -> Result<Self::Ok, Self::Error>","parent":{"krate":0,"index":1819},"children":[],"decl_id":null,"docs":" Applies the \"?\" operator. A return of `Ok(t)` means that the\n execution should continue normally, and the result of `?` is the\n value `t`. A return of `Err(e)` means that execution should branch\n to the innermost enclosing `catch`, or return from the function.","sig":null,"attributes":[{"value":"unstable(feature = \"try_trait\", issue = \"42327\")","span":{"file_name":"src/libcore/ops/try.rs","byte_start":831526,"byte_end":831577,"line_start":39,"line_end":39,"column_start":5,"column_end":56}}]},{"kind":"Method","id":{"krate":0,"index":1823},"span":{"file_name":"src/libcore/ops/try.rs","byte_start":831846,"byte_end":831856,"line_start":45,"line_end":45,"column_start":8,"column_end":18},"name":"from_error","qualname":"::ops::try::Try::from_error","value":"fn (v: Self::Error) -> Self","parent":{"krate":0,"index":1819},"children":[],"decl_id":null,"docs":" Wrap an error value to construct the composite result. For example,\n `Result::Err(x)` and `Result::from_error(x)` are equivalent.\n","sig":null,"attributes":[{"value":"unstable(feature = \"try_trait\", issue = \"42327\")","span":{"file_name":"src/libcore/ops/try.rs","byte_start":831787,"byte_end":831838,"line_start":44,"line_end":44,"column_start":5,"column_end":56}}]},{"kind":"Method","id":{"krate":0,"index":1824},"span":{"file_name":"src/libcore/ops/try.rs","byte_start":832084,"byte_end":832091,"line_start":50,"line_end":50,"column_start":8,"column_end":15},"name":"from_ok","qualname":"::ops::try::Try::from_ok","value":"fn (v: Self::Ok) -> Self","parent":{"krate":0,"index":1819},"children":[],"decl_id":null,"docs":" Wrap an OK value to construct the composite result. For example,\n `Result::Ok(x)` and `Result::from_ok(x)` are equivalent.\n","sig":null,"attributes":[{"value":"unstable(feature = \"try_trait\", issue = \"42327\")","span":{"file_name":"src/libcore/ops/try.rs","byte_start":832025,"byte_end":832076,"line_start":49,"line_end":49,"column_start":5,"column_end":56}}]},{"kind":"Trait","id":{"krate":0,"index":1827},"span":{"file_name":"src/libcore/ops/unsize.rs","byte_start":833983,"byte_end":833996,"line_start":36,"line_end":36,"column_start":11,"column_end":24},"name":"CoerceUnsized","qualname":"::ops::unsize::CoerceUnsized","value":"CoerceUnsized<T: ?Sized>","parent":null,"children":[],"decl_id":null,"docs":" Trait that indicates that this is a pointer or a wrapper for one,\n where unsizing can be performed on the pointee.","sig":null,"attributes":[{"value":"unstable(feature = \"coerce_unsized\", issue = \"27732\")","span":{"file_name":"src/libcore/ops/unsize.rs","byte_start":833889,"byte_end":833945,"line_start":34,"line_end":34,"column_start":1,"column_end":57}},{"value":"lang = \"coerce_unsized\"","span":{"file_name":"src/libcore/ops/unsize.rs","byte_start":833946,"byte_end":833972,"line_start":35,"line_end":35,"column_start":1,"column_end":27}}]},{"kind":"Trait","id":{"krate":0,"index":1864},"span":{"file_name":"src/libcore/ops/unsize.rs","byte_start":835947,"byte_end":835962,"line_start":87,"line_end":87,"column_start":11,"column_end":26},"name":"DispatchFromDyn","qualname":"::ops::unsize::DispatchFromDyn","value":"DispatchFromDyn<T>","parent":null,"children":[],"decl_id":null,"docs":" This is used for object safety, to check that a method's receiver type can be dispatched on.","sig":null,"attributes":[{"value":"unstable(feature = \"dispatch_from_dyn\", issue = \"0\")","span":{"file_name":"src/libcore/ops/unsize.rs","byte_start":835851,"byte_end":835906,"line_start":85,"line_end":85,"column_start":1,"column_end":56}},{"value":"lang = \"dispatch_from_dyn\"","span":{"file_name":"src/libcore/ops/unsize.rs","byte_start":835907,"byte_end":835936,"line_start":86,"line_end":86,"column_start":1,"column_end":30}}]},{"kind":"Mod","id":{"krate":0,"index":1934},"span":{"file_name":"src/libcore/cmp.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"cmp","qualname":"::cmp","value":"src/libcore/cmp.rs","parent":null,"children":[{"krate":0,"index":1935},{"krate":0,"index":1936},{"krate":0,"index":1940},{"krate":0,"index":1942},{"krate":0,"index":26177},{"krate":0,"index":26195},{"krate":0,"index":26194},{"krate":0,"index":26192},{"krate":0,"index":26190},{"krate":0,"index":26187},{"krate":0,"index":1945},{"krate":0,"index":26197},{"krate":0,"index":26219},{"krate":0,"index":26216},{"krate":0,"index":26213},{"krate":0,"index":26211},{"krate":0,"index":26208},{"krate":0,"index":26205},{"krate":0,"index":26201},{"krate":0,"index":1950},{"krate":0,"index":1957},{"krate":0,"index":1960},{"krate":0,"index":1965},{"krate":0,"index":1966},{"krate":0,"index":1968},{"krate":0,"index":1970},{"krate":0,"index":1977},{"krate":0,"index":1979},{"krate":0,"index":1981}],"decl_id":null,"docs":" Functionality for ordering and comparison.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":837622,"byte_end":837668,"line_start":21,"line_end":21,"column_start":1,"column_end":47}}]},{"kind":"Trait","id":{"krate":0,"index":1936},"span":{"file_name":"src/libcore/cmp.rs","byte_start":842458,"byte_end":842467,"line_start":189,"line_end":189,"column_start":11,"column_end":20},"name":"PartialEq","qualname":"::cmp::PartialEq","value":"PartialEq<Rhs: ?Sized = Self>","parent":null,"children":[{"krate":0,"index":1938},{"krate":0,"index":1939}],"decl_id":null,"docs":" Trait for equality comparisons which are [partial equivalence\n relations](http://en.wikipedia.org/wiki/Partial_equivalence_relation).","sig":null,"attributes":[{"value":"lang = \"eq\"","span":{"file_name":"src/libcore/cmp.rs","byte_start":842212,"byte_end":842226,"line_start":181,"line_end":181,"column_start":1,"column_end":15}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":842227,"byte_end":842272,"line_start":182,"line_end":182,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"can't compare `{Self}` with `{Rhs}`\",\n                         label = \"no implementation for `{Self} == {Rhs}`\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":842315,"byte_end":842447,"line_start":185,"line_end":188,"column_start":1,"column_end":3}}]},{"kind":"Method","id":{"krate":0,"index":1938},"span":{"file_name":"src/libcore/cmp.rs","byte_start":842661,"byte_end":842663,"line_start":194,"line_end":194,"column_start":8,"column_end":10},"name":"eq","qualname":"::cmp::PartialEq::eq","value":"fn (&self, other: &Rhs) -> bool","parent":{"krate":0,"index":1936},"children":[],"decl_id":null,"docs":" This method tests for `self` and `other` values to be equal, and is used\n by `==`.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/cmp.rs","byte_start":842592,"byte_end":842603,"line_start":192,"line_end":192,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":842608,"byte_end":842653,"line_start":193,"line_end":193,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1939},"span":{"file_name":"src/libcore/cmp.rs","byte_start":842817,"byte_end":842819,"line_start":200,"line_end":200,"column_start":8,"column_end":10},"name":"ne","qualname":"::cmp::PartialEq::ne","value":"fn (&self, other: &Rhs) -> bool","parent":{"krate":0,"index":1936},"children":[],"decl_id":null,"docs":" This method tests for `!=`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":842734,"byte_end":842743,"line_start":197,"line_end":197,"column_start":5,"column_end":14}},{"value":"must_use","span":{"file_name":"src/libcore/cmp.rs","byte_start":842748,"byte_end":842759,"line_start":198,"line_end":198,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":842764,"byte_end":842809,"line_start":199,"line_end":199,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1940},"span":{"file_name":"src/libcore/cmp.rs","byte_start":844285,"byte_end":844287,"line_start":245,"line_end":245,"column_start":11,"column_end":13},"name":"Eq","qualname":"::cmp::Eq","value":"Eq: PartialEq<Self>","parent":null,"children":[{"krate":0,"index":1941}],"decl_id":null,"docs":" Trait for equality comparisons which are [equivalence relations](\n https://en.wikipedia.org/wiki/Equivalence_relation).","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":844229,"byte_end":844274,"line_start":244,"line_end":244,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":1941},"span":{"file_name":"src/libcore/cmp.rs","byte_start":844724,"byte_end":844751,"line_start":256,"line_end":256,"column_start":8,"column_end":35},"name":"assert_receiver_is_total_eq","qualname":"::cmp::Eq::assert_receiver_is_total_eq","value":"fn (&self) -> ()","parent":{"krate":0,"index":1940},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":844657,"byte_end":844666,"line_start":254,"line_end":254,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":844671,"byte_end":844716,"line_start":255,"line_end":255,"column_start":5,"column_end":50}}]},{"kind":"Struct","id":{"krate":0,"index":1942},"span":{"file_name":"src/libcore/cmp.rs","byte_start":845110,"byte_end":845125,"line_start":268,"line_end":268,"column_start":12,"column_end":27},"name":"AssertParamIsEq","qualname":"::cmp::AssertParamIsEq","value":"AssertParamIsEq {  }","parent":null,"children":[{"krate":0,"index":1944}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/cmp.rs","byte_start":844941,"byte_end":844980,"line_start":264,"line_end":264,"column_start":1,"column_end":40}},{"value":"unstable(feature = \"derive_eq\",\n           reason = \"deriving hack, should not be public\",\n           issue = \"0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":844981,"byte_end":845098,"line_start":265,"line_end":267,"column_start":1,"column_end":25}}]},{"kind":"TupleVariant","id":{"krate":0,"index":26178},"span":{"file_name":"src/libcore/cmp.rs","byte_start":845772,"byte_end":845776,"line_start":291,"line_end":291,"column_start":5,"column_end":9},"name":"Less","qualname":"::cmp::Ordering::Less","value":"Ordering::Less","parent":{"krate":0,"index":26177},"children":[],"decl_id":null,"docs":" An ordering where a compared value is less than another.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":845722,"byte_end":845767,"line_start":290,"line_end":290,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":26181},"span":{"file_name":"src/libcore/cmp.rs","byte_start":845901,"byte_end":845906,"line_start":294,"line_end":294,"column_start":5,"column_end":10},"name":"Equal","qualname":"::cmp::Ordering::Equal","value":"Ordering::Equal","parent":{"krate":0,"index":26177},"children":[],"decl_id":null,"docs":" An ordering where a compared value is equal to another.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":845851,"byte_end":845896,"line_start":293,"line_end":293,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":26184},"span":{"file_name":"src/libcore/cmp.rs","byte_start":846034,"byte_end":846041,"line_start":297,"line_end":297,"column_start":5,"column_end":12},"name":"Greater","qualname":"::cmp::Ordering::Greater","value":"Ordering::Greater","parent":{"krate":0,"index":26177},"children":[],"decl_id":null,"docs":" An ordering where a compared value is greater than another.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":845984,"byte_end":846029,"line_start":296,"line_end":296,"column_start":5,"column_end":50}}]},{"kind":"Enum","id":{"krate":0,"index":26177},"span":{"file_name":"src/libcore/cmp.rs","byte_start":845642,"byte_end":845650,"line_start":288,"line_end":288,"column_start":10,"column_end":18},"name":"Ordering","qualname":"::cmp::Ordering","value":"Ordering::{Less, Equal, Greater}","parent":null,"children":[{"krate":0,"index":26178},{"krate":0,"index":26181},{"krate":0,"index":26184}],"decl_id":null,"docs":" An `Ordering` is the result of a comparison between two values.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":845587,"byte_end":845632,"line_start":287,"line_end":287,"column_start":1,"column_end":46}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/cmp.rs","byte_start":845633,"byte_end":846048,"line_start":288,"line_end":298,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":1946},"span":{"file_name":"src/libcore/cmp.rs","byte_start":846955,"byte_end":846962,"line_start":332,"line_end":332,"column_start":12,"column_end":19},"name":"reverse","qualname":"<Ordering>::reverse","value":"fn (self) -> Ordering","parent":null,"children":[],"decl_id":null,"docs":" Reverses the `Ordering`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":846884,"byte_end":846893,"line_start":330,"line_end":330,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":846898,"byte_end":846943,"line_start":331,"line_end":331,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1947},"span":{"file_name":"src/libcore/cmp.rs","byte_start":848061,"byte_end":848065,"line_start":368,"line_end":368,"column_start":12,"column_end":16},"name":"then","qualname":"<Ordering>::then","value":"fn (self, other: Ordering) -> Ordering","parent":null,"children":[],"decl_id":null,"docs":" Chains two orderings.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":847977,"byte_end":847986,"line_start":366,"line_end":366,"column_start":5,"column_end":14}},{"value":"stable(feature = \"ordering_chaining\", since = \"1.17.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":847991,"byte_end":848049,"line_start":367,"line_end":367,"column_start":5,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":1948},"span":{"file_name":"src/libcore/cmp.rs","byte_start":849251,"byte_end":849260,"line_start":405,"line_end":405,"column_start":12,"column_end":21},"name":"then_with","qualname":"<Ordering>::then_with","value":"fn <F> (self, f: F) -> Ordering","parent":null,"children":[],"decl_id":null,"docs":" Chains the ordering with the given function.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":849167,"byte_end":849176,"line_start":403,"line_end":403,"column_start":5,"column_end":14}},{"value":"stable(feature = \"ordering_chaining\", since = \"1.17.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":849181,"byte_end":849239,"line_start":404,"line_end":404,"column_start":5,"column_end":63}}]},{"kind":"Struct","id":{"krate":0,"index":26197},"span":{"file_name":"src/libcore/cmp.rs","byte_start":849915,"byte_end":849922,"line_start":429,"line_end":429,"column_start":12,"column_end":19},"name":"Reverse","qualname":"::cmp::Reverse","value":"","parent":null,"children":[],"decl_id":null,"docs":" A helper struct for reverse ordering.","sig":null,"attributes":[{"value":"stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":849847,"byte_end":849903,"line_start":428,"line_end":428,"column_start":1,"column_end":57}},{"value":"structural_match","span":{"file_name":"src/libcore/cmp.rs","byte_start":849904,"byte_end":849990,"line_start":429,"line_end":429,"column_start":1,"column_end":87}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/cmp.rs","byte_start":849904,"byte_end":849990,"line_start":429,"line_end":429,"column_start":1,"column_end":87}}]},{"kind":"Trait","id":{"krate":0,"index":1960},"span":{"file_name":"src/libcore/cmp.rs","byte_start":852823,"byte_end":852826,"line_start":519,"line_end":519,"column_start":11,"column_end":14},"name":"Ord","qualname":"::cmp::Ord","value":"Ord: Eq + PartialOrd<Self>","parent":null,"children":[{"krate":0,"index":1961},{"krate":0,"index":1962},{"krate":0,"index":1963},{"krate":0,"index":1964}],"decl_id":null,"docs":" Trait for types that form a [total order](https://en.wikipedia.org/wiki/Total_order).","sig":null,"attributes":[{"value":"lang = \"ord\"","span":{"file_name":"src/libcore/cmp.rs","byte_start":852669,"byte_end":852684,"line_start":513,"line_end":513,"column_start":1,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":852767,"byte_end":852812,"line_start":518,"line_end":518,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":1961},"span":{"file_name":"src/libcore/cmp.rs","byte_start":853361,"byte_end":853364,"line_start":535,"line_end":535,"column_start":8,"column_end":11},"name":"cmp","qualname":"::cmp::Ord::cmp","value":"fn (&self, other: &Self) -> Ordering","parent":{"krate":0,"index":1960},"children":[],"decl_id":null,"docs":" This method returns an `Ordering` between `self` and `other`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":853308,"byte_end":853353,"line_start":534,"line_end":534,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1962},"span":{"file_name":"src/libcore/cmp.rs","byte_start":853750,"byte_end":853753,"line_start":549,"line_end":549,"column_start":8,"column_end":11},"name":"max","qualname":"::cmp::Ord::max","value":"fn (self, other: Self) -> Self","parent":{"krate":0,"index":1960},"children":[],"decl_id":null,"docs":" Compares and returns the maximum of two values.","sig":null,"attributes":[{"value":"stable(feature = \"ord_max_min\", since = \"1.21.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":853676,"byte_end":853728,"line_start":547,"line_end":547,"column_start":5,"column_end":57}},{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":853733,"byte_end":853742,"line_start":548,"line_end":548,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1963},"span":{"file_name":"src/libcore/cmp.rs","byte_start":854210,"byte_end":854213,"line_start":566,"line_end":566,"column_start":8,"column_end":11},"name":"min","qualname":"::cmp::Ord::min","value":"fn (self, other: Self) -> Self","parent":{"krate":0,"index":1960},"children":[],"decl_id":null,"docs":" Compares and returns the minimum of two values.","sig":null,"attributes":[{"value":"stable(feature = \"ord_max_min\", since = \"1.21.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":854136,"byte_end":854188,"line_start":564,"line_end":564,"column_start":5,"column_end":57}},{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":854193,"byte_end":854202,"line_start":565,"line_end":565,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1964},"span":{"file_name":"src/libcore/cmp.rs","byte_start":854846,"byte_end":854851,"line_start":590,"line_end":590,"column_start":8,"column_end":13},"name":"clamp","qualname":"::cmp::Ord::clamp","value":"fn (self, min: Self, max: Self) -> Self","parent":{"krate":0,"index":1960},"children":[],"decl_id":null,"docs":" Restrict a value to a certain interval.","sig":null,"attributes":[{"value":"unstable(feature = \"clamp\", issue = \"44095\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":854791,"byte_end":854838,"line_start":589,"line_end":589,"column_start":5,"column_end":52}}]},{"kind":"Trait","id":{"krate":0,"index":1970},"span":{"file_name":"src/libcore/cmp.rs","byte_start":858888,"byte_end":858898,"line_start":730,"line_end":730,"column_start":11,"column_end":21},"name":"PartialOrd","qualname":"::cmp::PartialOrd","value":"PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs>","parent":null,"children":[{"krate":0,"index":1972},{"krate":0,"index":1973},{"krate":0,"index":1974},{"krate":0,"index":1975},{"krate":0,"index":1976}],"decl_id":null,"docs":" Trait for values that can be compared for a sort-order.","sig":null,"attributes":[{"value":"lang = \"partial_ord\"","span":{"file_name":"src/libcore/cmp.rs","byte_start":858573,"byte_end":858596,"line_start":720,"line_end":720,"column_start":1,"column_end":24}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":858597,"byte_end":858642,"line_start":721,"line_end":721,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"can't compare `{Self}` with `{Rhs}`\",\n                         label =\n                             \"no implementation for `{Self} < {Rhs}` and `{Self} > {Rhs}`\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":858725,"byte_end":858877,"line_start":726,"line_end":729,"column_start":1,"column_end":3}}]},{"kind":"Method","id":{"krate":0,"index":1972},"span":{"file_name":"src/libcore/cmp.rs","byte_start":859667,"byte_end":859678,"line_start":756,"line_end":756,"column_start":8,"column_end":19},"name":"partial_cmp","qualname":"::cmp::PartialOrd::partial_cmp","value":"fn (&self, other: &Rhs) -> Option<Ordering>","parent":{"krate":0,"index":1970},"children":[],"decl_id":null,"docs":" This method returns an ordering between `self` and `other` values if one exists.","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/cmp.rs","byte_start":859598,"byte_end":859609,"line_start":754,"line_end":754,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":859614,"byte_end":859659,"line_start":755,"line_end":755,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1973},"span":{"file_name":"src/libcore/cmp.rs","byte_start":860102,"byte_end":860104,"line_start":772,"line_end":772,"column_start":8,"column_end":10},"name":"lt","qualname":"::cmp::PartialOrd::lt","value":"fn (&self, other: &Rhs) -> bool","parent":{"krate":0,"index":1970},"children":[],"decl_id":null,"docs":" This method tests less than (for `self` and `other`) and is used by the `<` operator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":860019,"byte_end":860028,"line_start":769,"line_end":769,"column_start":5,"column_end":14}},{"value":"must_use","span":{"file_name":"src/libcore/cmp.rs","byte_start":860033,"byte_end":860044,"line_start":770,"line_end":770,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":860049,"byte_end":860094,"line_start":771,"line_end":771,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1974},"span":{"file_name":"src/libcore/cmp.rs","byte_start":860651,"byte_end":860653,"line_start":794,"line_end":794,"column_start":8,"column_end":10},"name":"le","qualname":"::cmp::PartialOrd::le","value":"fn (&self, other: &Rhs) -> bool","parent":{"krate":0,"index":1970},"children":[],"decl_id":null,"docs":" This method tests less than or equal to (for `self` and `other`) and is used by the `<=`\n operator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":860568,"byte_end":860577,"line_start":791,"line_end":791,"column_start":5,"column_end":14}},{"value":"must_use","span":{"file_name":"src/libcore/cmp.rs","byte_start":860582,"byte_end":860593,"line_start":792,"line_end":792,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":860598,"byte_end":860643,"line_start":793,"line_end":793,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1975},"span":{"file_name":"src/libcore/cmp.rs","byte_start":861196,"byte_end":861198,"line_start":815,"line_end":815,"column_start":8,"column_end":10},"name":"gt","qualname":"::cmp::PartialOrd::gt","value":"fn (&self, other: &Rhs) -> bool","parent":{"krate":0,"index":1970},"children":[],"decl_id":null,"docs":" This method tests greater than (for `self` and `other`) and is used by the `>` operator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":861113,"byte_end":861122,"line_start":812,"line_end":812,"column_start":5,"column_end":14}},{"value":"must_use","span":{"file_name":"src/libcore/cmp.rs","byte_start":861127,"byte_end":861138,"line_start":813,"line_end":813,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":861143,"byte_end":861188,"line_start":814,"line_end":814,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1976},"span":{"file_name":"src/libcore/cmp.rs","byte_start":861751,"byte_end":861753,"line_start":837,"line_end":837,"column_start":8,"column_end":10},"name":"ge","qualname":"::cmp::PartialOrd::ge","value":"fn (&self, other: &Rhs) -> bool","parent":{"krate":0,"index":1970},"children":[],"decl_id":null,"docs":" This method tests greater than or equal to (for `self` and `other`) and is used by the `>=`\n operator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":861668,"byte_end":861677,"line_start":834,"line_end":834,"column_start":5,"column_end":14}},{"value":"must_use","span":{"file_name":"src/libcore/cmp.rs","byte_start":861682,"byte_end":861693,"line_start":835,"line_end":835,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":861698,"byte_end":861743,"line_start":836,"line_end":836,"column_start":5,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":1977},"span":{"file_name":"src/libcore/cmp.rs","byte_start":862292,"byte_end":862295,"line_start":861,"line_end":861,"column_start":8,"column_end":11},"name":"min","qualname":"::cmp::min","value":"fn <T> (v1: T, v2: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Compares and returns the minimum of two values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":862229,"byte_end":862238,"line_start":859,"line_end":859,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":862239,"byte_end":862284,"line_start":860,"line_end":860,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1979},"span":{"file_name":"src/libcore/cmp.rs","byte_start":862720,"byte_end":862723,"line_start":881,"line_end":881,"column_start":8,"column_end":11},"name":"max","qualname":"::cmp::max","value":"fn <T> (v1: T, v2: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Compares and returns the maximum of two values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":862657,"byte_end":862666,"line_start":879,"line_end":879,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":862667,"byte_end":862712,"line_start":880,"line_end":880,"column_start":1,"column_end":46}}]},{"kind":"Mod","id":{"krate":0,"index":2055},"span":{"file_name":"src/libcore/clone.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"clone","qualname":"::clone","value":"src/libcore/clone.rs","parent":null,"children":[{"krate":0,"index":2056},{"krate":0,"index":2059},{"krate":0,"index":2062},{"krate":0,"index":2065}],"decl_id":null,"docs":" The `Clone` trait for types that cannot be 'implicitly copied'.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/clone.rs","byte_start":871971,"byte_end":872017,"line_start":39,"line_end":39,"column_start":1,"column_end":47}}]},{"kind":"Trait","id":{"krate":0,"index":2056},"span":{"file_name":"src/libcore/clone.rs","byte_start":874720,"byte_end":874725,"line_start":110,"line_end":110,"column_start":11,"column_end":16},"name":"Clone","qualname":"::clone::Clone","value":"Clone: Sized","parent":null,"children":[{"krate":0,"index":2057},{"krate":0,"index":2058}],"decl_id":null,"docs":" A common trait for the ability to explicitly duplicate an object.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/clone.rs","byte_start":874646,"byte_end":874691,"line_start":108,"line_end":108,"column_start":1,"column_end":46}},{"value":"lang = \"clone\"","span":{"file_name":"src/libcore/clone.rs","byte_start":874692,"byte_end":874709,"line_start":109,"line_end":109,"column_start":1,"column_end":18}}]},{"kind":"Method","id":{"krate":0,"index":2057},"span":{"file_name":"src/libcore/clone.rs","byte_start":875083,"byte_end":875088,"line_start":122,"line_end":122,"column_start":8,"column_end":13},"name":"clone","qualname":"::clone::Clone::clone","value":"fn (&self) -> Self","parent":{"krate":0,"index":2056},"children":[],"decl_id":null,"docs":" Returns a copy of the value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/clone.rs","byte_start":874942,"byte_end":874987,"line_start":120,"line_end":120,"column_start":5,"column_end":50}},{"value":"must_use =\n      \"cloning is often expensive and is not expected to have side effects\"","span":{"file_name":"src/libcore/clone.rs","byte_start":874992,"byte_end":875075,"line_start":121,"line_end":121,"column_start":5,"column_end":88}}]},{"kind":"Method","id":{"krate":0,"index":2058},"span":{"file_name":"src/libcore/clone.rs","byte_start":875413,"byte_end":875423,"line_start":131,"line_end":131,"column_start":8,"column_end":18},"name":"clone_from","qualname":"::clone::Clone::clone_from","value":"fn (&mut self, source: &Self) -> ()","parent":{"krate":0,"index":2056},"children":[],"decl_id":null,"docs":" Performs copy-assignment from `source`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/clone.rs","byte_start":875346,"byte_end":875355,"line_start":129,"line_end":129,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/clone.rs","byte_start":875360,"byte_end":875405,"line_start":130,"line_end":130,"column_start":5,"column_end":50}}]},{"kind":"Struct","id":{"krate":0,"index":2059},"span":{"file_name":"src/libcore/clone.rs","byte_start":875869,"byte_end":875887,"line_start":145,"line_end":145,"column_start":12,"column_end":30},"name":"AssertParamIsClone","qualname":"::clone::AssertParamIsClone","value":"AssertParamIsClone {  }","parent":null,"children":[{"krate":0,"index":2061}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/clone.rs","byte_start":875692,"byte_end":875731,"line_start":141,"line_end":141,"column_start":1,"column_end":40}},{"value":"unstable(feature = \"derive_clone_copy\",\n           reason = \"deriving hack, should not be public\",\n           issue = \"0\")","span":{"file_name":"src/libcore/clone.rs","byte_start":875732,"byte_end":875857,"line_start":142,"line_end":144,"column_start":1,"column_end":25}}]},{"kind":"Struct","id":{"krate":0,"index":2062},"span":{"file_name":"src/libcore/clone.rs","byte_start":876141,"byte_end":876158,"line_start":151,"line_end":151,"column_start":12,"column_end":29},"name":"AssertParamIsCopy","qualname":"::clone::AssertParamIsCopy","value":"AssertParamIsCopy {  }","parent":null,"children":[{"krate":0,"index":2064}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/clone.rs","byte_start":875964,"byte_end":876003,"line_start":147,"line_end":147,"column_start":1,"column_end":40}},{"value":"unstable(feature = \"derive_clone_copy\",\n           reason = \"deriving hack, should not be public\",\n           issue = \"0\")","span":{"file_name":"src/libcore/clone.rs","byte_start":876004,"byte_end":876129,"line_start":148,"line_end":150,"column_start":1,"column_end":25}}]},{"kind":"Mod","id":{"krate":0,"index":2079},"span":{"file_name":"src/libcore/default.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"default","qualname":"::default","value":"src/libcore/default.rs","parent":null,"children":[{"krate":0,"index":2080},{"krate":0,"index":2082},{"krate":0,"index":26434},{"krate":0,"index":26436},{"krate":0,"index":26438},{"krate":0,"index":26440},{"krate":0,"index":26442},{"krate":0,"index":26444},{"krate":0,"index":26446},{"krate":0,"index":26448},{"krate":0,"index":26450},{"krate":0,"index":26452},{"krate":0,"index":26454},{"krate":0,"index":26456},{"krate":0,"index":26458},{"krate":0,"index":26460},{"krate":0,"index":26462},{"krate":0,"index":26464},{"krate":0,"index":26466}],"decl_id":null,"docs":" The `Default` trait for types which may have meaningful default values.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/default.rs","byte_start":877764,"byte_end":877810,"line_start":3,"line_end":3,"column_start":1,"column_end":47}}]},{"kind":"Trait","id":{"krate":0,"index":2080},"span":{"file_name":"src/libcore/default.rs","byte_start":879637,"byte_end":879644,"line_start":84,"line_end":84,"column_start":11,"column_end":18},"name":"Default","qualname":"::default::Default","value":"Default: Sized","parent":null,"children":[{"krate":0,"index":2081}],"decl_id":null,"docs":" A trait for giving a type a useful default value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/default.rs","byte_start":879581,"byte_end":879626,"line_start":83,"line_end":83,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":2081},"span":{"file_name":"src/libcore/default.rs","byte_start":880453,"byte_end":880460,"line_start":115,"line_end":115,"column_start":8,"column_end":15},"name":"default","qualname":"::default::Default::default","value":"fn () -> Self","parent":{"krate":0,"index":2080},"children":[],"decl_id":null,"docs":" Returns the \"default value\" for a type.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/default.rs","byte_start":880400,"byte_end":880445,"line_start":114,"line_end":114,"column_start":5,"column_end":50}}]},{"kind":"Mod","id":{"krate":0,"index":2083},"span":{"file_name":"src/libcore/convert.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"convert","qualname":"::convert","value":"src/libcore/convert.rs","parent":null,"children":[{"krate":0,"index":2084},{"krate":0,"index":2085},{"krate":0,"index":2087},{"krate":0,"index":2090},{"krate":0,"index":2093},{"krate":0,"index":2096},{"krate":0,"index":2099},{"krate":0,"index":2103},{"krate":0,"index":2107},{"krate":0,"index":2111},{"krate":0,"index":2115},{"krate":0,"index":2119},{"krate":0,"index":2123},{"krate":0,"index":2126},{"krate":0,"index":2131},{"krate":0,"index":2136},{"krate":0,"index":2139},{"krate":0,"index":2142},{"krate":0,"index":26468},{"krate":0,"index":26469},{"krate":0,"index":2144},{"krate":0,"index":2146},{"krate":0,"index":2148},{"krate":0,"index":2150},{"krate":0,"index":2152},{"krate":0,"index":2153},{"krate":0,"index":2155},{"krate":0,"index":2157}],"decl_id":null,"docs":" Traits for conversions between types.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":883762,"byte_end":883808,"line_start":41,"line_end":41,"column_start":1,"column_end":47}}]},{"kind":"Function","id":{"krate":0,"index":2085},"span":{"file_name":"src/libcore/convert.rs","byte_start":885300,"byte_end":885308,"line_start":99,"line_end":99,"column_start":14,"column_end":22},"name":"identity","qualname":"::convert::identity","value":"fn <T> (x: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" An identity function.","sig":null,"attributes":[{"value":"stable(feature = \"convert_id\", since = \"1.33.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":885225,"byte_end":885276,"line_start":97,"line_end":97,"column_start":1,"column_end":52}},{"value":"inline","span":{"file_name":"src/libcore/convert.rs","byte_start":885277,"byte_end":885286,"line_start":98,"line_end":98,"column_start":1,"column_end":10}}]},{"kind":"Trait","id":{"krate":0,"index":2087},"span":{"file_name":"src/libcore/convert.rs","byte_start":887378,"byte_end":887383,"line_start":152,"line_end":152,"column_start":11,"column_end":16},"name":"AsRef","qualname":"::convert::AsRef","value":"AsRef<T: ?Sized>","parent":null,"children":[{"krate":0,"index":2089}],"decl_id":null,"docs":" Used to do a cheap reference-to-reference conversion.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":887322,"byte_end":887367,"line_start":151,"line_end":151,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":2089},"span":{"file_name":"src/libcore/convert.rs","byte_start":887487,"byte_end":887493,"line_start":155,"line_end":155,"column_start":8,"column_end":14},"name":"as_ref","qualname":"::convert::AsRef::as_ref","value":"fn (&self) -> &T","parent":{"krate":0,"index":2087},"children":[],"decl_id":null,"docs":" Performs the conversion.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":887434,"byte_end":887479,"line_start":154,"line_end":154,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":2090},"span":{"file_name":"src/libcore/convert.rs","byte_start":888997,"byte_end":889002,"line_start":196,"line_end":196,"column_start":11,"column_end":16},"name":"AsMut","qualname":"::convert::AsMut","value":"AsMut<T: ?Sized>","parent":null,"children":[{"krate":0,"index":2092}],"decl_id":null,"docs":" Used to do a cheap mutable-to-mutable reference conversion.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":888941,"byte_end":888986,"line_start":195,"line_end":195,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":2092},"span":{"file_name":"src/libcore/convert.rs","byte_start":889106,"byte_end":889112,"line_start":199,"line_end":199,"column_start":8,"column_end":14},"name":"as_mut","qualname":"::convert::AsMut::as_mut","value":"fn (&mut self) -> &mut T","parent":{"krate":0,"index":2090},"children":[],"decl_id":null,"docs":" Performs the conversion.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":889053,"byte_end":889098,"line_start":198,"line_end":198,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":2093},"span":{"file_name":"src/libcore/convert.rs","byte_start":892000,"byte_end":892004,"line_start":278,"line_end":278,"column_start":11,"column_end":15},"name":"Into","qualname":"::convert::Into","value":"Into<T>: Sized","parent":null,"children":[{"krate":0,"index":2095}],"decl_id":null,"docs":" A value-to-value conversion that consumes the input value. The\n opposite of [`From`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":891944,"byte_end":891989,"line_start":277,"line_end":277,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":2095},"span":{"file_name":"src/libcore/convert.rs","byte_start":892107,"byte_end":892111,"line_start":281,"line_end":281,"column_start":8,"column_end":12},"name":"into","qualname":"::convert::Into::into","value":"fn (self) -> T","parent":{"krate":0,"index":2093},"children":[],"decl_id":null,"docs":" Performs the conversion.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":892054,"byte_end":892099,"line_start":280,"line_end":280,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":2096},"span":{"file_name":"src/libcore/convert.rs","byte_start":895616,"byte_end":895620,"line_start":374,"line_end":374,"column_start":11,"column_end":15},"name":"From","qualname":"::convert::From","value":"From<T>: Sized","parent":null,"children":[{"krate":0,"index":2098}],"decl_id":null,"docs":" Used to do value-to-value conversions while consuming the input value. It is the reciprocal of\n [`Into`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":895393,"byte_end":895438,"line_start":367,"line_end":367,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(on(all(_Self = \"&str\", T = \"std::string::String\"),\n                            note =\n                                \"to coerce a `{T}` into a `{Self}`, use `&*` as a prefix\"))","span":{"file_name":"src/libcore/convert.rs","byte_start":895439,"byte_end":895605,"line_start":368,"line_end":373,"column_start":1,"column_end":3}}]},{"kind":"Method","id":{"krate":0,"index":2098},"span":{"file_name":"src/libcore/convert.rs","byte_start":895723,"byte_end":895727,"line_start":377,"line_end":377,"column_start":8,"column_end":12},"name":"from","qualname":"::convert::From::from","value":"fn (_: T) -> Self","parent":{"krate":0,"index":2096},"children":[],"decl_id":null,"docs":" Performs the conversion.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":895670,"byte_end":895715,"line_start":376,"line_end":376,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":2099},"span":{"file_name":"src/libcore/convert.rs","byte_start":896477,"byte_end":896484,"line_start":398,"line_end":398,"column_start":11,"column_end":18},"name":"TryInto","qualname":"::convert::TryInto","value":"TryInto<T>: Sized","parent":null,"children":[{"krate":0,"index":2101},{"krate":0,"index":2102}],"decl_id":null,"docs":" An attempted conversion that consumes `self`, which may or may not be\n expensive.","sig":null,"attributes":[{"value":"stable(feature = \"try_from\", since = \"1.34.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":896417,"byte_end":896466,"line_start":397,"line_end":397,"column_start":1,"column_end":50}}]},{"kind":"Type","id":{"krate":0,"index":2101},"span":{"file_name":"src/libcore/convert.rs","byte_start":896622,"byte_end":896627,"line_start":401,"line_end":401,"column_start":10,"column_end":15},"name":"Error","qualname":"::convert::TryInto::Error","value":"type Error;","parent":{"krate":0,"index":2099},"children":[],"decl_id":null,"docs":" The type returned in the event of a conversion error.\n","sig":null,"attributes":[{"value":"stable(feature = \"try_from\", since = \"1.34.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":896563,"byte_end":896612,"line_start":400,"line_end":400,"column_start":5,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":2102},"span":{"file_name":"src/libcore/convert.rs","byte_start":896724,"byte_end":896732,"line_start":405,"line_end":405,"column_start":8,"column_end":16},"name":"try_into","qualname":"::convert::TryInto::try_into","value":"fn (self) -> Result<T, Self::Error>","parent":{"krate":0,"index":2099},"children":[],"decl_id":null,"docs":" Performs the conversion.\n","sig":null,"attributes":[{"value":"stable(feature = \"try_from\", since = \"1.34.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":896667,"byte_end":896716,"line_start":404,"line_end":404,"column_start":5,"column_end":54}}]},{"kind":"Trait","id":{"krate":0,"index":2103},"span":{"file_name":"src/libcore/convert.rs","byte_start":899341,"byte_end":899348,"line_start":478,"line_end":478,"column_start":11,"column_end":18},"name":"TryFrom","qualname":"::convert::TryFrom","value":"TryFrom<T>: Sized","parent":null,"children":[{"krate":0,"index":2105},{"krate":0,"index":2106}],"decl_id":null,"docs":" Simple and safe type conversions that may fail in a controlled\n way under some circumstances. It is the reciprocal of [`TryInto`].","sig":null,"attributes":[{"value":"stable(feature = \"try_from\", since = \"1.34.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":899281,"byte_end":899330,"line_start":477,"line_end":477,"column_start":1,"column_end":50}}]},{"kind":"Type","id":{"krate":0,"index":2105},"span":{"file_name":"src/libcore/convert.rs","byte_start":899486,"byte_end":899491,"line_start":481,"line_end":481,"column_start":10,"column_end":15},"name":"Error","qualname":"::convert::TryFrom::Error","value":"type Error;","parent":{"krate":0,"index":2103},"children":[],"decl_id":null,"docs":" The type returned in the event of a conversion error.\n","sig":null,"attributes":[{"value":"stable(feature = \"try_from\", since = \"1.34.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":899427,"byte_end":899476,"line_start":480,"line_end":480,"column_start":5,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":2106},"span":{"file_name":"src/libcore/convert.rs","byte_start":899588,"byte_end":899596,"line_start":485,"line_end":485,"column_start":8,"column_end":16},"name":"try_from","qualname":"::convert::TryFrom::try_from","value":"fn (value: T) -> Result<Self, Self::Error>","parent":{"krate":0,"index":2103},"children":[],"decl_id":null,"docs":" Performs the conversion.\n","sig":null,"attributes":[{"value":"stable(feature = \"try_from\", since = \"1.34.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":899531,"byte_end":899580,"line_start":484,"line_end":484,"column_start":5,"column_end":54}}]},{"kind":"Enum","id":{"krate":0,"index":26468},"span":{"file_name":"src/libcore/convert.rs","byte_start":904747,"byte_end":904757,"line_start":657,"line_end":657,"column_start":10,"column_end":20},"name":"Infallible","qualname":"::convert::Infallible","value":"Infallible::{}","parent":null,"children":[],"decl_id":null,"docs":" The error type for errors that can never happen.","sig":null,"attributes":[{"value":"stable(feature = \"convert_infallible\", since = \"1.34.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":904662,"byte_end":904721,"line_start":655,"line_end":655,"column_start":1,"column_end":60}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/convert.rs","byte_start":904738,"byte_end":904760,"line_start":657,"line_end":657,"column_start":1,"column_end":23}}]},{"kind":"Mod","id":{"krate":0,"index":2159},"span":{"file_name":"src/libcore/borrow.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"borrow","qualname":"::borrow","value":"src/libcore/borrow.rs","parent":null,"children":[{"krate":0,"index":2160},{"krate":0,"index":2163},{"krate":0,"index":2166},{"krate":0,"index":2169},{"krate":0,"index":2172},{"krate":0,"index":2175},{"krate":0,"index":2178}],"decl_id":null,"docs":" A module for working with borrowed data.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/borrow.rs","byte_start":906110,"byte_end":906156,"line_start":3,"line_end":3,"column_start":1,"column_end":47}}]},{"kind":"Trait","id":{"krate":0,"index":2160},"span":{"file_name":"src/libcore/borrow.rs","byte_start":912869,"byte_end":912875,"line_start":160,"line_end":160,"column_start":11,"column_end":17},"name":"Borrow","qualname":"::borrow::Borrow","value":"Borrow<Borrowed: ?Sized>","parent":null,"children":[{"krate":0,"index":2162}],"decl_id":null,"docs":" A trait for borrowing data.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/borrow.rs","byte_start":912813,"byte_end":912858,"line_start":159,"line_end":159,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":2162},"span":{"file_name":"src/libcore/borrow.rs","byte_start":913326,"byte_end":913332,"line_start":181,"line_end":181,"column_start":8,"column_end":14},"name":"borrow","qualname":"::borrow::Borrow::borrow","value":"fn (&self) -> &Borrowed","parent":{"krate":0,"index":2160},"children":[],"decl_id":null,"docs":" Immutably borrows from an owned value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/borrow.rs","byte_start":913273,"byte_end":913318,"line_start":180,"line_end":180,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":2163},"span":{"file_name":"src/libcore/borrow.rs","byte_start":913702,"byte_end":913711,"line_start":192,"line_end":192,"column_start":11,"column_end":20},"name":"BorrowMut","qualname":"::borrow::BorrowMut","value":"BorrowMut<Borrowed: ?Sized>: Borrow<Borrowed>","parent":null,"children":[{"krate":0,"index":2165}],"decl_id":null,"docs":" A trait for mutably borrowing data.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/borrow.rs","byte_start":913646,"byte_end":913691,"line_start":191,"line_end":191,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":2165},"span":{"file_name":"src/libcore/borrow.rs","byte_start":914137,"byte_end":914147,"line_start":209,"line_end":209,"column_start":8,"column_end":18},"name":"borrow_mut","qualname":"::borrow::BorrowMut::borrow_mut","value":"fn (&mut self) -> &mut Borrowed","parent":{"krate":0,"index":2163},"children":[],"decl_id":null,"docs":" Mutably borrows from an owned value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/borrow.rs","byte_start":914084,"byte_end":914129,"line_start":208,"line_end":208,"column_start":5,"column_end":50}}]},{"kind":"Mod","id":{"krate":0,"index":2181},"span":{"file_name":"src/libcore/any.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"any","qualname":"::any","value":"src/libcore/any.rs","parent":null,"children":[{"krate":0,"index":2182},{"krate":0,"index":2183},{"krate":0,"index":2184},{"krate":0,"index":2186},{"krate":0,"index":2189},{"krate":0,"index":2191},{"krate":0,"index":2193},{"krate":0,"index":2195},{"krate":0,"index":2202},{"krate":0,"index":2209},{"krate":0,"index":26470},{"krate":0,"index":26491},{"krate":0,"index":26490},{"krate":0,"index":26487},{"krate":0,"index":26485},{"krate":0,"index":26479},{"krate":0,"index":26477},{"krate":0,"index":26475},{"krate":0,"index":26472},{"krate":0,"index":2216}],"decl_id":null,"docs":" This module implements the `Any` trait, which enables dynamic typing\n of any `'static` type through runtime reflection.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":917214,"byte_end":917260,"line_start":62,"line_end":62,"column_start":1,"column_end":47}}]},{"kind":"Trait","id":{"krate":0,"index":2184},"span":{"file_name":"src/libcore/any.rs","byte_start":917765,"byte_end":917768,"line_start":78,"line_end":78,"column_start":11,"column_end":14},"name":"Any","qualname":"::any::Any","value":"Any: 'static","parent":null,"children":[{"krate":0,"index":2185}],"decl_id":null,"docs":" A type to emulate dynamic typing.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":917709,"byte_end":917754,"line_start":77,"line_end":77,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":2185},"span":{"file_name":"src/libcore/any.rs","byte_start":918245,"byte_end":918252,"line_start":96,"line_end":96,"column_start":8,"column_end":15},"name":"type_id","qualname":"::any::Any::type_id","value":"fn (&self) -> TypeId","parent":{"krate":0,"index":2184},"children":[],"decl_id":null,"docs":" Gets the `TypeId` of `self`.","sig":null,"attributes":[{"value":"stable(feature = \"get_type_id\", since = \"1.34.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":918185,"byte_end":918237,"line_start":95,"line_end":95,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":2196},"span":{"file_name":"src/libcore/any.rs","byte_start":919906,"byte_end":919908,"line_start":155,"line_end":155,"column_start":12,"column_end":14},"name":"is","qualname":"<Any>::is","value":"fn <T> (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the boxed type is the same as `T`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":919835,"byte_end":919880,"line_start":153,"line_end":153,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/any.rs","byte_start":919885,"byte_end":919894,"line_start":154,"line_end":154,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2198},"span":{"file_name":"src/libcore/any.rs","byte_start":920879,"byte_end":920891,"line_start":189,"line_end":189,"column_start":12,"column_end":24},"name":"downcast_ref","qualname":"<Any>::downcast_ref","value":"fn <T> (&self) -> Option<&T>","parent":null,"children":[],"decl_id":null,"docs":" Returns some reference to the boxed value if it is of type `T`, or\n `None` if it isn't.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":920808,"byte_end":920853,"line_start":187,"line_end":187,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/any.rs","byte_start":920858,"byte_end":920867,"line_start":188,"line_end":188,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2200},"span":{"file_name":"src/libcore/any.rs","byte_start":921804,"byte_end":921816,"line_start":226,"line_end":226,"column_start":12,"column_end":24},"name":"downcast_mut","qualname":"<Any>::downcast_mut","value":"fn <T> (&mut self) -> Option<&mut T>","parent":null,"children":[],"decl_id":null,"docs":" Returns some mutable reference to the boxed value if it is of type `T`, or\n `None` if it isn't.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":921733,"byte_end":921778,"line_start":224,"line_end":224,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/any.rs","byte_start":921783,"byte_end":921792,"line_start":225,"line_end":225,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2203},"span":{"file_name":"src/libcore/any.rs","byte_start":922612,"byte_end":922614,"line_start":260,"line_end":260,"column_start":12,"column_end":14},"name":"is","qualname":"<Any + Send>::is","value":"fn <T> (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Forwards to the method defined on the type `Any`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":922541,"byte_end":922586,"line_start":258,"line_end":258,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/any.rs","byte_start":922591,"byte_end":922600,"line_start":259,"line_end":259,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2205},"span":{"file_name":"src/libcore/any.rs","byte_start":923311,"byte_end":923323,"line_start":286,"line_end":286,"column_start":12,"column_end":24},"name":"downcast_ref","qualname":"<Any + Send>::downcast_ref","value":"fn <T> (&self) -> Option<&T>","parent":null,"children":[],"decl_id":null,"docs":" Forwards to the method defined on the type `Any`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":923240,"byte_end":923285,"line_start":284,"line_end":284,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/any.rs","byte_start":923290,"byte_end":923299,"line_start":285,"line_end":285,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2207},"span":{"file_name":"src/libcore/any.rs","byte_start":924061,"byte_end":924073,"line_start":316,"line_end":316,"column_start":12,"column_end":24},"name":"downcast_mut","qualname":"<Any + Send>::downcast_mut","value":"fn <T> (&mut self) -> Option<&mut T>","parent":null,"children":[],"decl_id":null,"docs":" Forwards to the method defined on the type `Any`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":923990,"byte_end":924035,"line_start":314,"line_end":314,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/any.rs","byte_start":924040,"byte_end":924049,"line_start":315,"line_end":315,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2210},"span":{"file_name":"src/libcore/any.rs","byte_start":924767,"byte_end":924769,"line_start":344,"line_end":344,"column_start":12,"column_end":14},"name":"is","qualname":"<Any + Send + Sync>::is","value":"fn <T> (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Forwards to the method defined on the type `Any`.","sig":null,"attributes":[{"value":"stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":924679,"byte_end":924741,"line_start":342,"line_end":342,"column_start":5,"column_end":67}},{"value":"inline","span":{"file_name":"src/libcore/any.rs","byte_start":924746,"byte_end":924755,"line_start":343,"line_end":343,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2212},"span":{"file_name":"src/libcore/any.rs","byte_start":925490,"byte_end":925502,"line_start":370,"line_end":370,"column_start":12,"column_end":24},"name":"downcast_ref","qualname":"<Any + Send + Sync>::downcast_ref","value":"fn <T> (&self) -> Option<&T>","parent":null,"children":[],"decl_id":null,"docs":" Forwards to the method defined on the type `Any`.","sig":null,"attributes":[{"value":"stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":925402,"byte_end":925464,"line_start":368,"line_end":368,"column_start":5,"column_end":67}},{"value":"inline","span":{"file_name":"src/libcore/any.rs","byte_start":925469,"byte_end":925478,"line_start":369,"line_end":369,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2214},"span":{"file_name":"src/libcore/any.rs","byte_start":926264,"byte_end":926276,"line_start":400,"line_end":400,"column_start":12,"column_end":24},"name":"downcast_mut","qualname":"<Any + Send + Sync>::downcast_mut","value":"fn <T> (&mut self) -> Option<&mut T>","parent":null,"children":[],"decl_id":null,"docs":" Forwards to the method defined on the type `Any`.","sig":null,"attributes":[{"value":"stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":926176,"byte_end":926238,"line_start":398,"line_end":398,"column_start":5,"column_end":67}},{"value":"inline","span":{"file_name":"src/libcore/any.rs","byte_start":926243,"byte_end":926252,"line_start":399,"line_end":399,"column_start":5,"column_end":14}}]},{"kind":"Struct","id":{"krate":0,"index":26470},"span":{"file_name":"src/libcore/any.rs","byte_start":927266,"byte_end":927272,"line_start":423,"line_end":423,"column_start":12,"column_end":18},"name":"TypeId","qualname":"::any::TypeId","value":"TypeId {  }","parent":null,"children":[{"krate":0,"index":26471}],"decl_id":null,"docs":" A `TypeId` represents a globally unique identifier for a type.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":927209,"byte_end":927254,"line_start":422,"line_end":422,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/any.rs","byte_start":927255,"byte_end":927288,"line_start":423,"line_end":425,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/any.rs","byte_start":927255,"byte_end":927288,"line_start":423,"line_end":425,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":2217},"span":{"file_name":"src/libcore/any.rs","byte_start":927905,"byte_end":927907,"line_start":447,"line_end":447,"column_start":18,"column_end":20},"name":"of","qualname":"<TypeId>::of","value":"fn <T> () -> TypeId","parent":null,"children":[],"decl_id":null,"docs":" Returns the `TypeId` of the type this generic function has been\n instantiated with.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":927789,"byte_end":927834,"line_start":445,"line_end":445,"column_start":5,"column_end":50}},{"value":"rustc_const_unstable(feature = \"const_type_id\")","span":{"file_name":"src/libcore/any.rs","byte_start":927839,"byte_end":927887,"line_start":446,"line_end":446,"column_start":5,"column_end":53}}]},{"kind":"Mod","id":{"krate":0,"index":2219},"span":{"file_name":"src/libcore/array.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"array","qualname":"::array","value":"src/libcore/array.rs","parent":null,"children":[{"krate":0,"index":2220},{"krate":0,"index":2223},{"krate":0,"index":2224},{"krate":0,"index":2227},{"krate":0,"index":2228},{"krate":0,"index":2231},{"krate":0,"index":2232},{"krate":0,"index":2235},{"krate":0,"index":2239},{"krate":0,"index":26493},{"krate":0,"index":26499},{"krate":0,"index":26498},{"krate":0,"index":26496},{"krate":0,"index":2244},{"krate":0,"index":2246},{"krate":0,"index":2248},{"krate":0,"index":2250},{"krate":0,"index":2251},{"krate":0,"index":2252},{"krate":0,"index":26501},{"krate":0,"index":26505},{"krate":0,"index":26509},{"krate":0,"index":26513},{"krate":0,"index":26517},{"krate":0,"index":26524},{"krate":0,"index":26532},{"krate":0,"index":26540},{"krate":0,"index":26545},{"krate":0,"index":26549},{"krate":0,"index":26556},{"krate":0,"index":29240},{"krate":0,"index":29261},{"krate":0,"index":29251},{"krate":0,"index":29279},{"krate":0,"index":29269},{"krate":0,"index":29297},{"krate":0,"index":29287},{"krate":0,"index":26563},{"krate":0,"index":26566},{"krate":0,"index":26579},{"krate":0,"index":26584},{"krate":0,"index":26588},{"krate":0,"index":26592},{"krate":0,"index":26596},{"krate":0,"index":26600},{"krate":0,"index":26607},{"krate":0,"index":26615},{"krate":0,"index":26623},{"krate":0,"index":26628},{"krate":0,"index":26632},{"krate":0,"index":26639},{"krate":0,"index":29305},{"krate":0,"index":29326},{"krate":0,"index":29316},{"krate":0,"index":29344},{"krate":0,"index":29334},{"krate":0,"index":29362},{"krate":0,"index":29352},{"krate":0,"index":26646},{"krate":0,"index":26649},{"krate":0,"index":26662},{"krate":0,"index":26667},{"krate":0,"index":26671},{"krate":0,"index":26675},{"krate":0,"index":26679},{"krate":0,"index":26683},{"krate":0,"index":26690},{"krate":0,"index":26698},{"krate":0,"index":26706},{"krate":0,"index":26711},{"krate":0,"index":26715},{"krate":0,"index":26722},{"krate":0,"index":29370},{"krate":0,"index":29391},{"krate":0,"index":29381},{"krate":0,"index":29409},{"krate":0,"index":29399},{"krate":0,"index":29427},{"krate":0,"index":29417},{"krate":0,"index":26729},{"krate":0,"index":26732},{"krate":0,"index":26745},{"krate":0,"index":26750},{"krate":0,"index":26754},{"krate":0,"index":26758},{"krate":0,"index":26762},{"krate":0,"index":26766},{"krate":0,"index":26773},{"krate":0,"index":26781},{"krate":0,"index":26789},{"krate":0,"index":26794},{"krate":0,"index":26798},{"krate":0,"index":26805},{"krate":0,"index":29435},{"krate":0,"index":29456},{"krate":0,"index":29446},{"krate":0,"index":29474},{"krate":0,"index":29464},{"krate":0,"index":29492},{"krate":0,"index":29482},{"krate":0,"index":26812},{"krate":0,"index":26815},{"krate":0,"index":26828},{"krate":0,"index":26833},{"krate":0,"index":26837},{"krate":0,"index":26841},{"krate":0,"index":26845},{"krate":0,"index":26849},{"krate":0,"index":26856},{"krate":0,"index":26864},{"krate":0,"index":26872},{"krate":0,"index":26877},{"krate":0,"index":26881},{"krate":0,"index":26888},{"krate":0,"index":29500},{"krate":0,"index":29521},{"krate":0,"index":29511},{"krate":0,"index":29539},{"krate":0,"index":29529},{"krate":0,"index":29557},{"krate":0,"index":29547},{"krate":0,"index":26895},{"krate":0,"index":26898},{"krate":0,"index":26911},{"krate":0,"index":26916},{"krate":0,"index":26920},{"krate":0,"index":26924},{"krate":0,"index":26928},{"krate":0,"index":26932},{"krate":0,"index":26939},{"krate":0,"index":26947},{"krate":0,"index":26955},{"krate":0,"index":26960},{"krate":0,"index":26964},{"krate":0,"index":26971},{"krate":0,"index":29565},{"krate":0,"index":29586},{"krate":0,"index":29576},{"krate":0,"index":29604},{"krate":0,"index":29594},{"krate":0,"index":29622},{"krate":0,"index":29612},{"krate":0,"index":26978},{"krate":0,"index":26981},{"krate":0,"index":26994},{"krate":0,"index":26999},{"krate":0,"index":27003},{"krate":0,"index":27007},{"krate":0,"index":27011},{"krate":0,"index":27015},{"krate":0,"index":27022},{"krate":0,"index":27030},{"krate":0,"index":27038},{"krate":0,"index":27043},{"krate":0,"index":27047},{"krate":0,"index":27054},{"krate":0,"index":29630},{"krate":0,"index":29651},{"krate":0,"index":29641},{"krate":0,"index":29669},{"krate":0,"index":29659},{"krate":0,"index":29687},{"krate":0,"index":29677},{"krate":0,"index":27061},{"krate":0,"index":27064},{"krate":0,"index":27077},{"krate":0,"index":27082},{"krate":0,"index":27086},{"krate":0,"index":27090},{"krate":0,"index":27094},{"krate":0,"index":27098},{"krate":0,"index":27105},{"krate":0,"index":27113},{"krate":0,"index":27121},{"krate":0,"index":27126},{"krate":0,"index":27130},{"krate":0,"index":27137},{"krate":0,"index":29695},{"krate":0,"index":29716},{"krate":0,"index":29706},{"krate":0,"index":29734},{"krate":0,"index":29724},{"krate":0,"index":29752},{"krate":0,"index":29742},{"krate":0,"index":27144},{"krate":0,"index":27147},{"krate":0,"index":27160},{"krate":0,"index":27165},{"krate":0,"index":27169},{"krate":0,"index":27173},{"krate":0,"index":27177},{"krate":0,"index":27181},{"krate":0,"index":27188},{"krate":0,"index":27196},{"krate":0,"index":27204},{"krate":0,"index":27209},{"krate":0,"index":27213},{"krate":0,"index":27220},{"krate":0,"index":29760},{"krate":0,"index":29781},{"krate":0,"index":29771},{"krate":0,"index":29799},{"krate":0,"index":29789},{"krate":0,"index":29817},{"krate":0,"index":29807},{"krate":0,"index":27227},{"krate":0,"index":27230},{"krate":0,"index":27243},{"krate":0,"index":27248},{"krate":0,"index":27252},{"krate":0,"index":27256},{"krate":0,"index":27260},{"krate":0,"index":27264},{"krate":0,"index":27271},{"krate":0,"index":27279},{"krate":0,"index":27287},{"krate":0,"index":27292},{"krate":0,"index":27296},{"krate":0,"index":27303},{"krate":0,"index":29825},{"krate":0,"index":29846},{"krate":0,"index":29836},{"krate":0,"index":29864},{"krate":0,"index":29854},{"krate":0,"index":29882},{"krate":0,"index":29872},{"krate":0,"index":27310},{"krate":0,"index":27313},{"krate":0,"index":27326},{"krate":0,"index":27331},{"krate":0,"index":27335},{"krate":0,"index":27339},{"krate":0,"index":27343},{"krate":0,"index":27347},{"krate":0,"index":27354},{"krate":0,"index":27362},{"krate":0,"index":27370},{"krate":0,"index":27375},{"krate":0,"index":27379},{"krate":0,"index":27386},{"krate":0,"index":29890},{"krate":0,"index":29911},{"krate":0,"index":29901},{"krate":0,"index":29929},{"krate":0,"index":29919},{"krate":0,"index":29947},{"krate":0,"index":29937},{"krate":0,"index":27393},{"krate":0,"index":27396},{"krate":0,"index":27409},{"krate":0,"index":27414},{"krate":0,"index":27418},{"krate":0,"index":27422},{"krate":0,"index":27426},{"krate":0,"index":27430},{"krate":0,"index":27437},{"krate":0,"index":27445},{"krate":0,"index":27453},{"krate":0,"index":27458},{"krate":0,"index":27462},{"krate":0,"index":27469},{"krate":0,"index":29955},{"krate":0,"index":29976},{"krate":0,"index":29966},{"krate":0,"index":29994},{"krate":0,"index":29984},{"krate":0,"index":30012},{"krate":0,"index":30002},{"krate":0,"index":27476},{"krate":0,"index":27479},{"krate":0,"index":27492},{"krate":0,"index":27497},{"krate":0,"index":27501},{"krate":0,"index":27505},{"krate":0,"index":27509},{"krate":0,"index":27513},{"krate":0,"index":27520},{"krate":0,"index":27528},{"krate":0,"index":27536},{"krate":0,"index":27541},{"krate":0,"index":27545},{"krate":0,"index":27552},{"krate":0,"index":30020},{"krate":0,"index":30041},{"krate":0,"index":30031},{"krate":0,"index":30059},{"krate":0,"index":30049},{"krate":0,"index":30077},{"krate":0,"index":30067},{"krate":0,"index":27559},{"krate":0,"index":27562},{"krate":0,"index":27575},{"krate":0,"index":27580},{"krate":0,"index":27584},{"krate":0,"index":27588},{"krate":0,"index":27592},{"krate":0,"index":27596},{"krate":0,"index":27603},{"krate":0,"index":27611},{"krate":0,"index":27619},{"krate":0,"index":27624},{"krate":0,"index":27628},{"krate":0,"index":27635},{"krate":0,"index":30085},{"krate":0,"index":30106},{"krate":0,"index":30096},{"krate":0,"index":30124},{"krate":0,"index":30114},{"krate":0,"index":30142},{"krate":0,"index":30132},{"krate":0,"index":27642},{"krate":0,"index":27645},{"krate":0,"index":27658},{"krate":0,"index":27663},{"krate":0,"index":27667},{"krate":0,"index":27671},{"krate":0,"index":27675},{"krate":0,"index":27679},{"krate":0,"index":27686},{"krate":0,"index":27694},{"krate":0,"index":27702},{"krate":0,"index":27707},{"krate":0,"index":27711},{"krate":0,"index":27718},{"krate":0,"index":30150},{"krate":0,"index":30171},{"krate":0,"index":30161},{"krate":0,"index":30189},{"krate":0,"index":30179},{"krate":0,"index":30207},{"krate":0,"index":30197},{"krate":0,"index":27725},{"krate":0,"index":27728},{"krate":0,"index":27741},{"krate":0,"index":27746},{"krate":0,"index":27750},{"krate":0,"index":27754},{"krate":0,"index":27758},{"krate":0,"index":27762},{"krate":0,"index":27769},{"krate":0,"index":27777},{"krate":0,"index":27785},{"krate":0,"index":27790},{"krate":0,"index":27794},{"krate":0,"index":27801},{"krate":0,"index":30215},{"krate":0,"index":30236},{"krate":0,"index":30226},{"krate":0,"index":30254},{"krate":0,"index":30244},{"krate":0,"index":30272},{"krate":0,"index":30262},{"krate":0,"index":27808},{"krate":0,"index":27811},{"krate":0,"index":27824},{"krate":0,"index":27829},{"krate":0,"index":27833},{"krate":0,"index":27837},{"krate":0,"index":27841},{"krate":0,"index":27845},{"krate":0,"index":27852},{"krate":0,"index":27860},{"krate":0,"index":27868},{"krate":0,"index":27873},{"krate":0,"index":27877},{"krate":0,"index":27884},{"krate":0,"index":30280},{"krate":0,"index":30301},{"krate":0,"index":30291},{"krate":0,"index":30319},{"krate":0,"index":30309},{"krate":0,"index":30337},{"krate":0,"index":30327},{"krate":0,"index":27891},{"krate":0,"index":27894},{"krate":0,"index":27907},{"krate":0,"index":27912},{"krate":0,"index":27916},{"krate":0,"index":27920},{"krate":0,"index":27924},{"krate":0,"index":27928},{"krate":0,"index":27935},{"krate":0,"index":27943},{"krate":0,"index":27951},{"krate":0,"index":27956},{"krate":0,"index":27960},{"krate":0,"index":27967},{"krate":0,"index":30345},{"krate":0,"index":30366},{"krate":0,"index":30356},{"krate":0,"index":30384},{"krate":0,"index":30374},{"krate":0,"index":30402},{"krate":0,"index":30392},{"krate":0,"index":27974},{"krate":0,"index":27977},{"krate":0,"index":27990},{"krate":0,"index":27995},{"krate":0,"index":27999},{"krate":0,"index":28003},{"krate":0,"index":28007},{"krate":0,"index":28011},{"krate":0,"index":28018},{"krate":0,"index":28026},{"krate":0,"index":28034},{"krate":0,"index":28039},{"krate":0,"index":28043},{"krate":0,"index":28050},{"krate":0,"index":30410},{"krate":0,"index":30431},{"krate":0,"index":30421},{"krate":0,"index":30449},{"krate":0,"index":30439},{"krate":0,"index":30467},{"krate":0,"index":30457},{"krate":0,"index":28057},{"krate":0,"index":28060},{"krate":0,"index":28073},{"krate":0,"index":28078},{"krate":0,"index":28082},{"krate":0,"index":28086},{"krate":0,"index":28090},{"krate":0,"index":28094},{"krate":0,"index":28101},{"krate":0,"index":28109},{"krate":0,"index":28117},{"krate":0,"index":28122},{"krate":0,"index":28126},{"krate":0,"index":28133},{"krate":0,"index":30475},{"krate":0,"index":30496},{"krate":0,"index":30486},{"krate":0,"index":30514},{"krate":0,"index":30504},{"krate":0,"index":30532},{"krate":0,"index":30522},{"krate":0,"index":28140},{"krate":0,"index":28143},{"krate":0,"index":28156},{"krate":0,"index":28161},{"krate":0,"index":28165},{"krate":0,"index":28169},{"krate":0,"index":28173},{"krate":0,"index":28177},{"krate":0,"index":28184},{"krate":0,"index":28192},{"krate":0,"index":28200},{"krate":0,"index":28205},{"krate":0,"index":28209},{"krate":0,"index":28216},{"krate":0,"index":30540},{"krate":0,"index":30561},{"krate":0,"index":30551},{"krate":0,"index":30579},{"krate":0,"index":30569},{"krate":0,"index":30597},{"krate":0,"index":30587},{"krate":0,"index":28223},{"krate":0,"index":28226},{"krate":0,"index":28239},{"krate":0,"index":28244},{"krate":0,"index":28248},{"krate":0,"index":28252},{"krate":0,"index":28256},{"krate":0,"index":28260},{"krate":0,"index":28267},{"krate":0,"index":28275},{"krate":0,"index":28283},{"krate":0,"index":28288},{"krate":0,"index":28292},{"krate":0,"index":28299},{"krate":0,"index":30605},{"krate":0,"index":30626},{"krate":0,"index":30616},{"krate":0,"index":30644},{"krate":0,"index":30634},{"krate":0,"index":30662},{"krate":0,"index":30652},{"krate":0,"index":28306},{"krate":0,"index":28309},{"krate":0,"index":28322},{"krate":0,"index":28327},{"krate":0,"index":28331},{"krate":0,"index":28335},{"krate":0,"index":28339},{"krate":0,"index":28343},{"krate":0,"index":28350},{"krate":0,"index":28358},{"krate":0,"index":28366},{"krate":0,"index":28371},{"krate":0,"index":28375},{"krate":0,"index":28382},{"krate":0,"index":30670},{"krate":0,"index":30691},{"krate":0,"index":30681},{"krate":0,"index":30709},{"krate":0,"index":30699},{"krate":0,"index":30727},{"krate":0,"index":30717},{"krate":0,"index":28389},{"krate":0,"index":28392},{"krate":0,"index":28405},{"krate":0,"index":28410},{"krate":0,"index":28414},{"krate":0,"index":28418},{"krate":0,"index":28422},{"krate":0,"index":28426},{"krate":0,"index":28433},{"krate":0,"index":28441},{"krate":0,"index":28449},{"krate":0,"index":28454},{"krate":0,"index":28458},{"krate":0,"index":28465},{"krate":0,"index":30735},{"krate":0,"index":30756},{"krate":0,"index":30746},{"krate":0,"index":30774},{"krate":0,"index":30764},{"krate":0,"index":30792},{"krate":0,"index":30782},{"krate":0,"index":28472},{"krate":0,"index":28475},{"krate":0,"index":28488},{"krate":0,"index":28493},{"krate":0,"index":28497},{"krate":0,"index":28501},{"krate":0,"index":28505},{"krate":0,"index":28509},{"krate":0,"index":28516},{"krate":0,"index":28524},{"krate":0,"index":28532},{"krate":0,"index":28537},{"krate":0,"index":28541},{"krate":0,"index":28548},{"krate":0,"index":30800},{"krate":0,"index":30821},{"krate":0,"index":30811},{"krate":0,"index":30839},{"krate":0,"index":30829},{"krate":0,"index":30857},{"krate":0,"index":30847},{"krate":0,"index":28555},{"krate":0,"index":28558},{"krate":0,"index":28571},{"krate":0,"index":28576},{"krate":0,"index":28580},{"krate":0,"index":28584},{"krate":0,"index":28588},{"krate":0,"index":28592},{"krate":0,"index":28599},{"krate":0,"index":28607},{"krate":0,"index":28615},{"krate":0,"index":28620},{"krate":0,"index":28624},{"krate":0,"index":28631},{"krate":0,"index":30865},{"krate":0,"index":30886},{"krate":0,"index":30876},{"krate":0,"index":30904},{"krate":0,"index":30894},{"krate":0,"index":30922},{"krate":0,"index":30912},{"krate":0,"index":28638},{"krate":0,"index":28641},{"krate":0,"index":28654},{"krate":0,"index":28659},{"krate":0,"index":28663},{"krate":0,"index":28667},{"krate":0,"index":28671},{"krate":0,"index":28675},{"krate":0,"index":28682},{"krate":0,"index":28690},{"krate":0,"index":28698},{"krate":0,"index":28703},{"krate":0,"index":28707},{"krate":0,"index":28714},{"krate":0,"index":30930},{"krate":0,"index":30951},{"krate":0,"index":30941},{"krate":0,"index":30969},{"krate":0,"index":30959},{"krate":0,"index":30987},{"krate":0,"index":30977},{"krate":0,"index":28721},{"krate":0,"index":28724},{"krate":0,"index":28737},{"krate":0,"index":28742},{"krate":0,"index":28746},{"krate":0,"index":28750},{"krate":0,"index":28754},{"krate":0,"index":28758},{"krate":0,"index":28765},{"krate":0,"index":28773},{"krate":0,"index":28781},{"krate":0,"index":28786},{"krate":0,"index":28790},{"krate":0,"index":28797},{"krate":0,"index":30995},{"krate":0,"index":31016},{"krate":0,"index":31006},{"krate":0,"index":31034},{"krate":0,"index":31024},{"krate":0,"index":31052},{"krate":0,"index":31042},{"krate":0,"index":28804},{"krate":0,"index":28807},{"krate":0,"index":28820},{"krate":0,"index":28825},{"krate":0,"index":28829},{"krate":0,"index":28833},{"krate":0,"index":28837},{"krate":0,"index":28841},{"krate":0,"index":28848},{"krate":0,"index":28856},{"krate":0,"index":28864},{"krate":0,"index":28869},{"krate":0,"index":28873},{"krate":0,"index":28880},{"krate":0,"index":31060},{"krate":0,"index":31081},{"krate":0,"index":31071},{"krate":0,"index":31099},{"krate":0,"index":31089},{"krate":0,"index":31117},{"krate":0,"index":31107},{"krate":0,"index":28887},{"krate":0,"index":28890},{"krate":0,"index":28903},{"krate":0,"index":28908},{"krate":0,"index":28912},{"krate":0,"index":28916},{"krate":0,"index":28920},{"krate":0,"index":28924},{"krate":0,"index":28931},{"krate":0,"index":28939},{"krate":0,"index":28947},{"krate":0,"index":28952},{"krate":0,"index":28956},{"krate":0,"index":28963},{"krate":0,"index":31125},{"krate":0,"index":31146},{"krate":0,"index":31136},{"krate":0,"index":31164},{"krate":0,"index":31154},{"krate":0,"index":31182},{"krate":0,"index":31172},{"krate":0,"index":28970},{"krate":0,"index":28973},{"krate":0,"index":28986},{"krate":0,"index":28991},{"krate":0,"index":28995},{"krate":0,"index":28999},{"krate":0,"index":29003},{"krate":0,"index":29007},{"krate":0,"index":29014},{"krate":0,"index":29022},{"krate":0,"index":29030},{"krate":0,"index":29035},{"krate":0,"index":29039},{"krate":0,"index":29046},{"krate":0,"index":31190},{"krate":0,"index":31211},{"krate":0,"index":31201},{"krate":0,"index":31229},{"krate":0,"index":31219},{"krate":0,"index":31247},{"krate":0,"index":31237},{"krate":0,"index":29053},{"krate":0,"index":29056},{"krate":0,"index":29069},{"krate":0,"index":29074},{"krate":0,"index":29078},{"krate":0,"index":29082},{"krate":0,"index":29086},{"krate":0,"index":29090},{"krate":0,"index":29097},{"krate":0,"index":29105},{"krate":0,"index":29113},{"krate":0,"index":29118},{"krate":0,"index":29122},{"krate":0,"index":29129},{"krate":0,"index":31255},{"krate":0,"index":31276},{"krate":0,"index":31266},{"krate":0,"index":31294},{"krate":0,"index":31284},{"krate":0,"index":31312},{"krate":0,"index":31302},{"krate":0,"index":29136},{"krate":0,"index":29139},{"krate":0,"index":29152},{"krate":0,"index":29157},{"krate":0,"index":29161},{"krate":0,"index":29165},{"krate":0,"index":29169},{"krate":0,"index":29173},{"krate":0,"index":29180},{"krate":0,"index":29188},{"krate":0,"index":29196},{"krate":0,"index":29201},{"krate":0,"index":29205},{"krate":0,"index":29212},{"krate":0,"index":31320},{"krate":0,"index":31341},{"krate":0,"index":31331},{"krate":0,"index":31359},{"krate":0,"index":31349},{"krate":0,"index":31377},{"krate":0,"index":31367},{"krate":0,"index":29219},{"krate":0,"index":29222},{"krate":0,"index":29235},{"krate":0,"index":2253},{"krate":0,"index":31385},{"krate":0,"index":31390},{"krate":0,"index":31395},{"krate":0,"index":31400},{"krate":0,"index":31405},{"krate":0,"index":31410},{"krate":0,"index":31415},{"krate":0,"index":31420},{"krate":0,"index":31425},{"krate":0,"index":31430},{"krate":0,"index":31435},{"krate":0,"index":31440},{"krate":0,"index":31445},{"krate":0,"index":31450},{"krate":0,"index":31455},{"krate":0,"index":31460},{"krate":0,"index":31465},{"krate":0,"index":31470},{"krate":0,"index":31475},{"krate":0,"index":31480},{"krate":0,"index":31485},{"krate":0,"index":31490},{"krate":0,"index":31495},{"krate":0,"index":31500},{"krate":0,"index":31505},{"krate":0,"index":31510},{"krate":0,"index":31515},{"krate":0,"index":31520},{"krate":0,"index":31525},{"krate":0,"index":31530},{"krate":0,"index":31535},{"krate":0,"index":31540},{"krate":0,"index":31545}],"decl_id":null,"docs":" Implementations of things like `Eq` for fixed-length arrays\n up to a certain length. Eventually we should able to generalize\n to all lengths.","sig":null,"attributes":[{"value":"stable(feature = \"core_array\", since = \"1.36.0\")","span":{"file_name":"src/libcore/array.rs","byte_start":928265,"byte_end":928317,"line_start":7,"line_end":7,"column_start":1,"column_end":53}}]},{"kind":"Trait","id":{"krate":0,"index":2235},"span":{"file_name":"src/libcore/array.rs","byte_start":929210,"byte_end":929224,"line_start":31,"line_end":31,"column_start":18,"column_end":32},"name":"FixedSizeArray","qualname":"::array::FixedSizeArray","value":"FixedSizeArray<T>","parent":null,"children":[{"krate":0,"index":2237},{"krate":0,"index":2238}],"decl_id":null,"docs":" Utility trait implemented only on arrays of fixed size","sig":null,"attributes":[{"value":"unstable(feature = \"fixed_size_array\", issue = \"27778\")","span":{"file_name":"src/libcore/array.rs","byte_start":929134,"byte_end":929192,"line_start":30,"line_end":30,"column_start":1,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":2237},"span":{"file_name":"src/libcore/array.rs","byte_start":929346,"byte_end":929354,"line_start":34,"line_end":34,"column_start":8,"column_end":16},"name":"as_slice","qualname":"::array::FixedSizeArray::as_slice","value":"fn (&self) -> &[T]","parent":{"krate":0,"index":2235},"children":[],"decl_id":null,"docs":" Converts the array to immutable slice\n","sig":null,"attributes":[{"value":"unstable(feature = \"fixed_size_array\", issue = \"27778\")","span":{"file_name":"src/libcore/array.rs","byte_start":929280,"byte_end":929338,"line_start":33,"line_end":33,"column_start":5,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":2238},"span":{"file_name":"src/libcore/array.rs","byte_start":929485,"byte_end":929497,"line_start":37,"line_end":37,"column_start":8,"column_end":20},"name":"as_mut_slice","qualname":"::array::FixedSizeArray::as_mut_slice","value":"fn (&mut self) -> &mut [T]","parent":{"krate":0,"index":2235},"children":[],"decl_id":null,"docs":" Converts the array to mutable slice\n","sig":null,"attributes":[{"value":"unstable(feature = \"fixed_size_array\", issue = \"27778\")","span":{"file_name":"src/libcore/array.rs","byte_start":929419,"byte_end":929477,"line_start":36,"line_end":36,"column_start":5,"column_end":63}}]},{"kind":"Struct","id":{"krate":0,"index":26493},"span":{"file_name":"src/libcore/array.rs","byte_start":929957,"byte_end":929974,"line_start":55,"line_end":55,"column_start":12,"column_end":29},"name":"TryFromSliceError","qualname":"::array::TryFromSliceError","value":"","parent":null,"children":[],"decl_id":null,"docs":" The error type returned when a conversion from a slice to an array fails.\n","sig":null,"attributes":[{"value":"stable(feature = \"try_from\", since = \"1.34.0\")","span":{"file_name":"src/libcore/array.rs","byte_start":929866,"byte_end":929915,"line_start":53,"line_end":53,"column_start":1,"column_end":50}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/array.rs","byte_start":929946,"byte_end":929979,"line_start":55,"line_end":55,"column_start":1,"column_end":34}}]},{"kind":"Method","id":{"krate":0,"index":2247},"span":{"file_name":"src/libcore/array.rs","byte_start":930479,"byte_end":930492,"line_start":72,"line_end":72,"column_start":12,"column_end":25},"name":"__description","qualname":"<TryFromSliceError>::__description","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"array_error_internals\",\n           reason =\n               \"available through Error trait and this method should not \\\n                     be exposed publicly\",\n           issue = \"0\")","span":{"file_name":"src/libcore/array.rs","byte_start":930241,"byte_end":930434,"line_start":66,"line_end":69,"column_start":5,"column_end":25}},{"value":"inline","span":{"file_name":"src/libcore/array.rs","byte_start":930439,"byte_end":930448,"line_start":70,"line_end":70,"column_start":5,"column_end":14}}]},{"kind":"Mod","id":{"krate":0,"index":2254},"span":{"file_name":"src/libcore/ascii.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"ascii","qualname":"::ascii","value":"src/libcore/ascii.rs","parent":null,"children":[{"krate":0,"index":2255},{"krate":0,"index":2256},{"krate":0,"index":2257},{"krate":0,"index":2258},{"krate":0,"index":2262},{"krate":0,"index":2264},{"krate":0,"index":2269},{"krate":0,"index":2272},{"krate":0,"index":2273},{"krate":0,"index":2274}],"decl_id":null,"docs":" Operations on ASCII strings and characters.","sig":null,"attributes":[{"value":"stable(feature = \"core_ascii\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ascii.rs","byte_start":938517,"byte_end":938569,"line_start":12,"line_end":12,"column_start":1,"column_end":53}}]},{"kind":"Struct","id":{"krate":0,"index":2258},"span":{"file_name":"src/libcore/ascii.rs","byte_start":938908,"byte_end":938921,"line_start":25,"line_end":25,"column_start":12,"column_end":25},"name":"EscapeDefault","qualname":"::ascii::EscapeDefault","value":"EscapeDefault {  }","parent":null,"children":[{"krate":0,"index":2259},{"krate":0,"index":2260}],"decl_id":null,"docs":" An iterator over the escaped version of a byte.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ascii.rs","byte_start":938851,"byte_end":938896,"line_start":24,"line_end":24,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":2262},"span":{"file_name":"src/libcore/ascii.rs","byte_start":941068,"byte_end":941082,"line_start":93,"line_end":93,"column_start":8,"column_end":22},"name":"escape_default","qualname":"::ascii::escape_default","value":"fn (c: u8) -> EscapeDefault","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator that produces an escaped version of a `u8`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ascii.rs","byte_start":941015,"byte_end":941060,"line_start":92,"line_end":92,"column_start":1,"column_end":46}}]},{"kind":"Mod","id":{"krate":0,"index":2276},"span":{"file_name":"src/libcore/sync/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"sync","qualname":"::sync","value":"src/libcore/sync/mod.rs","parent":null,"children":[{"krate":0,"index":2277}],"decl_id":null,"docs":" Synchronization primitives\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/mod.rs","byte_start":942569,"byte_end":942615,"line_start":3,"line_end":3,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":2277},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"atomic","qualname":"::sync::atomic","value":"src/libcore/sync/atomic.rs","parent":null,"children":[{"krate":0,"index":2278},{"krate":0,"index":2279},{"krate":0,"index":2280},{"krate":0,"index":2281},{"krate":0,"index":2282},{"krate":0,"index":2283},{"krate":0,"index":2284},{"krate":0,"index":2286},{"krate":0,"index":2288},{"krate":0,"index":2289},{"krate":0,"index":2292},{"krate":0,"index":2295},{"krate":0,"index":2297},{"krate":0,"index":31550},{"krate":0,"index":31572},{"krate":0,"index":31570},{"krate":0,"index":31568},{"krate":0,"index":31566},{"krate":0,"index":31564},{"krate":0,"index":31561},{"krate":0,"index":2299},{"krate":0,"index":2300},{"krate":0,"index":2314},{"krate":0,"index":2325},{"krate":0,"index":2327},{"krate":0,"index":2330},{"krate":0,"index":31573},{"krate":0,"index":31575},{"krate":0,"index":31576},{"krate":0,"index":31578},{"krate":0,"index":31579},{"krate":0,"index":31581},{"krate":0,"index":31582},{"krate":0,"index":31603},{"krate":0,"index":31605},{"krate":0,"index":31606},{"krate":0,"index":31608},{"krate":0,"index":31609},{"krate":0,"index":31611},{"krate":0,"index":31612},{"krate":0,"index":31633},{"krate":0,"index":31635},{"krate":0,"index":31636},{"krate":0,"index":31638},{"krate":0,"index":31639},{"krate":0,"index":31641},{"krate":0,"index":31642},{"krate":0,"index":31663},{"krate":0,"index":31665},{"krate":0,"index":31666},{"krate":0,"index":31668},{"krate":0,"index":31669},{"krate":0,"index":31671},{"krate":0,"index":31672},{"krate":0,"index":31693},{"krate":0,"index":31695},{"krate":0,"index":31696},{"krate":0,"index":31698},{"krate":0,"index":31699},{"krate":0,"index":31701},{"krate":0,"index":31702},{"krate":0,"index":31723},{"krate":0,"index":31725},{"krate":0,"index":31726},{"krate":0,"index":31728},{"krate":0,"index":31729},{"krate":0,"index":31731},{"krate":0,"index":31732},{"krate":0,"index":31753},{"krate":0,"index":31755},{"krate":0,"index":31756},{"krate":0,"index":31758},{"krate":0,"index":31759},{"krate":0,"index":31761},{"krate":0,"index":31762},{"krate":0,"index":31783},{"krate":0,"index":31785},{"krate":0,"index":31786},{"krate":0,"index":31788},{"krate":0,"index":31789},{"krate":0,"index":31791},{"krate":0,"index":31792},{"krate":0,"index":2331},{"krate":0,"index":31813},{"krate":0,"index":31815},{"krate":0,"index":31816},{"krate":0,"index":31818},{"krate":0,"index":31819},{"krate":0,"index":31821},{"krate":0,"index":31822},{"krate":0,"index":31843},{"krate":0,"index":31845},{"krate":0,"index":31846},{"krate":0,"index":31848},{"krate":0,"index":31849},{"krate":0,"index":31851},{"krate":0,"index":31852},{"krate":0,"index":2332},{"krate":0,"index":2333},{"krate":0,"index":2335},{"krate":0,"index":2337},{"krate":0,"index":2339},{"krate":0,"index":2341},{"krate":0,"index":2343},{"krate":0,"index":2345},{"krate":0,"index":2347},{"krate":0,"index":2349},{"krate":0,"index":2351},{"krate":0,"index":2353},{"krate":0,"index":2355},{"krate":0,"index":2357},{"krate":0,"index":2359},{"krate":0,"index":2361},{"krate":0,"index":2363},{"krate":0,"index":2364},{"krate":0,"index":2365},{"krate":0,"index":2367},{"krate":0,"index":2370}],"decl_id":null,"docs":" Atomic types","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":947243,"byte_end":947289,"line_start":115,"line_end":115,"column_start":1,"column_end":47}}]},{"kind":"Function","id":{"krate":0,"index":2283},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":949011,"byte_end":949025,"line_start":151,"line_end":151,"column_start":8,"column_end":22},"name":"spin_loop_hint","qualname":"::sync::atomic::spin_loop_hint","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Signals the processor that it is entering a busy-wait spin-loop.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":948938,"byte_end":948947,"line_start":149,"line_end":149,"column_start":1,"column_end":10}},{"value":"stable(feature = \"spin_loop_hint\", since = \"1.24.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":948948,"byte_end":949003,"line_start":150,"line_end":150,"column_start":1,"column_end":56}}]},{"kind":"Struct","id":{"krate":0,"index":2284},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":949344,"byte_end":949354,"line_start":163,"line_end":163,"column_start":12,"column_end":22},"name":"AtomicBool","qualname":"::sync::atomic::AtomicBool","value":"AtomicBool {  }","parent":null,"children":[{"krate":0,"index":2285}],"decl_id":null,"docs":" A boolean type which can be safely shared between threads.","sig":null,"attributes":[{"value":"cfg(target_has_atomic = \"8\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":949234,"byte_end":949265,"line_start":160,"line_end":160,"column_start":1,"column_end":32}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":949266,"byte_end":949311,"line_start":161,"line_end":161,"column_start":1,"column_end":46}},{"value":"repr(C, align(1))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":949312,"byte_end":949332,"line_start":162,"line_end":162,"column_start":1,"column_end":21}}]},{"kind":"Struct","id":{"krate":0,"index":2289},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":950181,"byte_end":950190,"line_start":189,"line_end":189,"column_start":12,"column_end":21},"name":"AtomicPtr","qualname":"::sync::atomic::AtomicPtr","value":"AtomicPtr {  }","parent":null,"children":[{"krate":0,"index":2291}],"decl_id":null,"docs":" A raw pointer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"cfg(target_has_atomic = \"ptr\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":949910,"byte_end":949943,"line_start":184,"line_end":184,"column_start":1,"column_end":34}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":949944,"byte_end":949989,"line_start":185,"line_end":185,"column_start":1,"column_end":46}},{"value":"repr(C, align(8))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":950150,"byte_end":950167,"line_start":188,"line_end":188,"column_start":41,"column_end":58}}]},{"kind":"TupleVariant","id":{"krate":0,"index":31551},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":951837,"byte_end":951844,"line_start":235,"line_end":235,"column_start":5,"column_end":12},"name":"Relaxed","qualname":"::sync::atomic::Ordering::Relaxed","value":"Ordering::Relaxed","parent":{"krate":0,"index":31550},"children":[],"decl_id":null,"docs":" No ordering constraints, only atomic operations.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":951787,"byte_end":951832,"line_start":234,"line_end":234,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":31553},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":952691,"byte_end":952698,"line_start":252,"line_end":252,"column_start":5,"column_end":12},"name":"Release","qualname":"::sync::atomic::Ordering::Release","value":"Ordering::Release","parent":{"krate":0,"index":31550},"children":[],"decl_id":null,"docs":" When coupled with a store, all previous operations become ordered\n before any load of this value with [`Acquire`] (or stronger) ordering.\n In particular, all previous writes become visible to all threads\n that perform an [`Acquire`] (or stronger) load of this value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":952641,"byte_end":952686,"line_start":251,"line_end":251,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":31555},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":953541,"byte_end":953548,"line_start":269,"line_end":269,"column_start":5,"column_end":12},"name":"Acquire","qualname":"::sync::atomic::Ordering::Acquire","value":"Ordering::Acquire","parent":{"krate":0,"index":31550},"children":[],"decl_id":null,"docs":" When coupled with a load, if the loaded value was written by a store operation with\n [`Release`] (or stronger) ordering, then all subsequent operations\n become ordered after that store. In particular, all subsequent loads will see data\n written before the store.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":953491,"byte_end":953536,"line_start":268,"line_end":268,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":31557},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":954483,"byte_end":954489,"line_start":286,"line_end":286,"column_start":5,"column_end":11},"name":"AcqRel","qualname":"::sync::atomic::Ordering::AcqRel","value":"Ordering::AcqRel","parent":{"krate":0,"index":31550},"children":[],"decl_id":null,"docs":" Has the effects of both [`Acquire`] and [`Release`] together:\n For loads it uses [`Acquire`] ordering. For stores it uses the [`Release`] ordering.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":954433,"byte_end":954478,"line_start":285,"line_end":285,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":31559},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":955157,"byte_end":955163,"line_start":298,"line_end":298,"column_start":5,"column_end":11},"name":"SeqCst","qualname":"::sync::atomic::Ordering::SeqCst","value":"Ordering::SeqCst","parent":{"krate":0,"index":31550},"children":[],"decl_id":null,"docs":" Like [`Acquire`]/[`Release`]/[`AcqRel`] (for load, store, and load-with-store\n operations, respectively) with the additional guarantee that all threads see all\n sequentially consistent operations in the same order.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":955107,"byte_end":955152,"line_start":297,"line_end":297,"column_start":5,"column_end":50}}]},{"kind":"Enum","id":{"krate":0,"index":31550},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":951577,"byte_end":951585,"line_start":228,"line_end":228,"column_start":10,"column_end":18},"name":"Ordering","qualname":"::sync::atomic::Ordering","value":"Ordering::{Relaxed, Release, Acquire, AcqRel, SeqCst}","parent":null,"children":[{"krate":0,"index":31551},{"krate":0,"index":31553},{"krate":0,"index":31555},{"krate":0,"index":31557},{"krate":0,"index":31559}],"decl_id":null,"docs":" Atomic memory orderings","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":951453,"byte_end":951498,"line_start":225,"line_end":225,"column_start":1,"column_end":46}},{"value":"non_exhaustive","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":951550,"byte_end":951567,"line_start":227,"line_end":227,"column_start":1,"column_end":18}},{"value":"structural_match","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":951568,"byte_end":955166,"line_start":228,"line_end":299,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":951568,"byte_end":955166,"line_start":228,"line_end":299,"column_start":1,"column_end":2}}]},{"kind":"Const","id":{"krate":0,"index":2299},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":955489,"byte_end":955505,"line_start":311,"line_end":311,"column_start":11,"column_end":27},"name":"ATOMIC_BOOL_INIT","qualname":"::sync::atomic::ATOMIC_BOOL_INIT","value":"AtomicBool","parent":null,"children":[],"decl_id":null,"docs":" An [`AtomicBool`] initialized to `false`.","sig":null,"attributes":[{"value":"cfg(target_has_atomic = \"8\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":955261,"byte_end":955292,"line_start":304,"line_end":304,"column_start":1,"column_end":32}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":955293,"byte_end":955338,"line_start":305,"line_end":305,"column_start":1,"column_end":46}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicBool::new(false)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":955339,"byte_end":955478,"line_start":306,"line_end":310,"column_start":1,"column_end":3}}]},{"kind":"Method","id":{"krate":0,"index":2301},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":955923,"byte_end":955926,"line_start":327,"line_end":327,"column_start":18,"column_end":21},"name":"new","qualname":"<AtomicBool>::new","value":"fn (v: bool) -> AtomicBool","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `AtomicBool`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":955846,"byte_end":955855,"line_start":325,"line_end":325,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":955860,"byte_end":955905,"line_start":326,"line_end":326,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2302},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":956681,"byte_end":956688,"line_start":350,"line_end":350,"column_start":12,"column_end":19},"name":"get_mut","qualname":"<AtomicBool>::get_mut","value":"fn (&mut self) -> &mut bool","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable reference to the underlying [`bool`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":956601,"byte_end":956610,"line_start":348,"line_end":348,"column_start":5,"column_end":14}},{"value":"stable(feature = \"atomic_access\", since = \"1.15.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":956615,"byte_end":956669,"line_start":349,"line_end":349,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":2303},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":957273,"byte_end":957283,"line_start":369,"line_end":369,"column_start":12,"column_end":22},"name":"into_inner","qualname":"<AtomicBool>::into_inner","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Consumes the atomic and returns the contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":957193,"byte_end":957202,"line_start":367,"line_end":367,"column_start":5,"column_end":14}},{"value":"stable(feature = \"atomic_access\", since = \"1.15.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":957207,"byte_end":957261,"line_start":368,"line_end":368,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":2304},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":958282,"byte_end":958286,"line_start":400,"line_end":400,"column_start":12,"column_end":16},"name":"load","qualname":"<AtomicBool>::load","value":"fn (&self, order: Ordering) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Loads a value from the bool.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":958211,"byte_end":958220,"line_start":398,"line_end":398,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":958225,"byte_end":958270,"line_start":399,"line_end":399,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2305},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":959381,"byte_end":959386,"line_start":432,"line_end":432,"column_start":12,"column_end":17},"name":"store","qualname":"<AtomicBool>::store","value":"fn (&self, val: bool, order: Ordering) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores a value into the bool.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":959310,"byte_end":959319,"line_start":430,"line_end":430,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":959324,"byte_end":959369,"line_start":431,"line_end":431,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2306},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":960522,"byte_end":960526,"line_start":463,"line_end":463,"column_start":12,"column_end":16},"name":"swap","qualname":"<AtomicBool>::swap","value":"fn (&self, val: bool, order: Ordering) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Stores a value into the bool, returning the previous value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":960413,"byte_end":960422,"line_start":460,"line_end":460,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":960427,"byte_end":960472,"line_start":461,"line_end":461,"column_start":5,"column_end":50}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":960477,"byte_end":960510,"line_start":462,"line_end":462,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":2307},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":962227,"byte_end":962243,"line_start":501,"line_end":501,"column_start":12,"column_end":28},"name":"compare_and_swap","qualname":"<AtomicBool>::compare_and_swap","value":"fn (&self, current: bool, new: bool, order: Ordering) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Stores a value into the [`bool`] if the current value is the same as the `current` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":962118,"byte_end":962127,"line_start":498,"line_end":498,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":962132,"byte_end":962177,"line_start":499,"line_end":499,"column_start":5,"column_end":50}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":962182,"byte_end":962215,"line_start":500,"line_end":500,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":2308},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":964612,"byte_end":964628,"line_start":552,"line_end":552,"column_start":12,"column_end":28},"name":"compare_exchange","qualname":"<AtomicBool>::compare_exchange","value":"fn (&self, current: bool, new: bool, success: Ordering, failure: Ordering) -> Result<bool, bool>","parent":null,"children":[],"decl_id":null,"docs":" Stores a value into the [`bool`] if the current value is the same as the `current` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":964482,"byte_end":964491,"line_start":549,"line_end":549,"column_start":5,"column_end":14}},{"value":"stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":964496,"byte_end":964562,"line_start":550,"line_end":550,"column_start":5,"column_end":71}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":964567,"byte_end":964600,"line_start":551,"line_end":551,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":2309},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":967050,"byte_end":967071,"line_start":608,"line_end":608,"column_start":12,"column_end":33},"name":"compare_exchange_weak","qualname":"<AtomicBool>::compare_exchange_weak","value":"fn (&self, current: bool, new: bool, success: Ordering, failure: Ordering) -> Result<bool, bool>","parent":null,"children":[],"decl_id":null,"docs":" Stores a value into the [`bool`] if the current value is the same as the `current` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":966920,"byte_end":966929,"line_start":605,"line_end":605,"column_start":5,"column_end":14}},{"value":"stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":966934,"byte_end":967000,"line_start":606,"line_end":606,"column_start":5,"column_end":71}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":967005,"byte_end":967038,"line_start":607,"line_end":607,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":2310},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969041,"byte_end":969050,"line_start":659,"line_end":659,"column_start":12,"column_end":21},"name":"fetch_and","qualname":"<AtomicBool>::fetch_and","value":"fn (&self, val: bool, order: Ordering) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Logical \"and\" with a boolean value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":968932,"byte_end":968941,"line_start":656,"line_end":656,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":968946,"byte_end":968991,"line_start":657,"line_end":657,"column_start":5,"column_end":50}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":968996,"byte_end":969029,"line_start":658,"line_end":658,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":2311},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":970725,"byte_end":970735,"line_start":701,"line_end":701,"column_start":12,"column_end":22},"name":"fetch_nand","qualname":"<AtomicBool>::fetch_nand","value":"fn (&self, val: bool, order: Ordering) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Logical \"nand\" with a boolean value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":970616,"byte_end":970625,"line_start":698,"line_end":698,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":970630,"byte_end":970675,"line_start":699,"line_end":699,"column_start":5,"column_end":50}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":970680,"byte_end":970713,"line_start":700,"line_end":700,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":2312},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":972833,"byte_end":972841,"line_start":754,"line_end":754,"column_start":12,"column_end":20},"name":"fetch_or","qualname":"<AtomicBool>::fetch_or","value":"fn (&self, val: bool, order: Ordering) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Logical \"or\" with a boolean value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":972724,"byte_end":972733,"line_start":751,"line_end":751,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":972738,"byte_end":972783,"line_start":752,"line_end":752,"column_start":5,"column_end":50}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":972788,"byte_end":972821,"line_start":753,"line_end":753,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":2313},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":974450,"byte_end":974459,"line_start":795,"line_end":795,"column_start":12,"column_end":21},"name":"fetch_xor","qualname":"<AtomicBool>::fetch_xor","value":"fn (&self, val: bool, order: Ordering) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Logical \"xor\" with a boolean value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":974341,"byte_end":974350,"line_start":792,"line_end":792,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":974355,"byte_end":974400,"line_start":793,"line_end":793,"column_start":5,"column_end":50}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":974405,"byte_end":974438,"line_start":794,"line_end":794,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":2316},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":974936,"byte_end":974939,"line_start":814,"line_end":814,"column_start":18,"column_end":21},"name":"new","qualname":"<AtomicPtr<T>>::new","value":"fn (p: *mut T) -> AtomicPtr<T>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `AtomicPtr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":974859,"byte_end":974868,"line_start":812,"line_end":812,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":974873,"byte_end":974918,"line_start":813,"line_end":813,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2317},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":975596,"byte_end":975603,"line_start":834,"line_end":834,"column_start":12,"column_end":19},"name":"get_mut","qualname":"<AtomicPtr<T>>::get_mut","value":"fn (&mut self) -> &mut *mut T","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable reference to the underlying pointer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":975516,"byte_end":975525,"line_start":832,"line_end":832,"column_start":5,"column_end":14}},{"value":"stable(feature = \"atomic_access\", since = \"1.15.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":975530,"byte_end":975584,"line_start":833,"line_end":833,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":2318},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":976186,"byte_end":976196,"line_start":853,"line_end":853,"column_start":12,"column_end":22},"name":"into_inner","qualname":"<AtomicPtr<T>>::into_inner","value":"fn (self) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Consumes the atomic and returns the contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":976106,"byte_end":976115,"line_start":851,"line_end":851,"column_start":5,"column_end":14}},{"value":"stable(feature = \"atomic_access\", since = \"1.15.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":976120,"byte_end":976174,"line_start":852,"line_end":852,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":2319},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":977211,"byte_end":977215,"line_start":885,"line_end":885,"column_start":12,"column_end":16},"name":"load","qualname":"<AtomicPtr<T>>::load","value":"fn (&self, order: Ordering) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Loads a value from the pointer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":977140,"byte_end":977149,"line_start":883,"line_end":883,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":977154,"byte_end":977199,"line_start":884,"line_end":884,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2320},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":978339,"byte_end":978344,"line_start":919,"line_end":919,"column_start":12,"column_end":17},"name":"store","qualname":"<AtomicPtr<T>>::store","value":"fn (&self, ptr: *mut T, order: Ordering) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores a value into the pointer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":978268,"byte_end":978277,"line_start":917,"line_end":917,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":978282,"byte_end":978327,"line_start":918,"line_end":918,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2321},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":979501,"byte_end":979505,"line_start":952,"line_end":952,"column_start":12,"column_end":16},"name":"swap","qualname":"<AtomicPtr<T>>::swap","value":"fn (&self, ptr: *mut T, order: Ordering) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Stores a value into the pointer, returning the previous value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":979392,"byte_end":979401,"line_start":949,"line_end":949,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":979406,"byte_end":979451,"line_start":950,"line_end":950,"column_start":5,"column_end":50}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":979456,"byte_end":979489,"line_start":951,"line_end":951,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":2322},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":981067,"byte_end":981083,"line_start":989,"line_end":989,"column_start":12,"column_end":28},"name":"compare_and_swap","qualname":"<AtomicPtr<T>>::compare_and_swap","value":"fn (&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Stores a value into the pointer if the current value is the same as the `current` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":980958,"byte_end":980967,"line_start":986,"line_end":986,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":980972,"byte_end":981017,"line_start":987,"line_end":987,"column_start":5,"column_end":50}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":981022,"byte_end":981055,"line_start":988,"line_end":988,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":2323},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":983035,"byte_end":983051,"line_start":1032,"line_end":1032,"column_start":12,"column_end":28},"name":"compare_exchange","qualname":"<AtomicPtr<T>>::compare_exchange","value":"fn (&self, current: *mut T, new: *mut T, success: Ordering, failure: Ordering) -> Result<*mut T, *mut T>","parent":null,"children":[],"decl_id":null,"docs":" Stores a value into the pointer if the current value is the same as the `current` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":982905,"byte_end":982914,"line_start":1029,"line_end":1029,"column_start":5,"column_end":14}},{"value":"stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":982919,"byte_end":982985,"line_start":1030,"line_end":1030,"column_start":5,"column_end":71}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":982990,"byte_end":983023,"line_start":1031,"line_end":1031,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":2324},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":985699,"byte_end":985720,"line_start":1092,"line_end":1092,"column_start":12,"column_end":33},"name":"compare_exchange_weak","qualname":"<AtomicPtr<T>>::compare_exchange_weak","value":"fn (&self, current: *mut T, new: *mut T, success: Ordering, failure: Ordering) -> Result<*mut T, *mut T>","parent":null,"children":[],"decl_id":null,"docs":" Stores a value into the pointer if the current value is the same as the `current` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":985569,"byte_end":985578,"line_start":1089,"line_end":1089,"column_start":5,"column_end":14}},{"value":"stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":985583,"byte_end":985649,"line_start":1090,"line_end":1090,"column_start":5,"column_end":71}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":985654,"byte_end":985687,"line_start":1091,"line_end":1091,"column_start":5,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":31573},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1015296,"byte_end":1015304,"line_start":1906,"line_end":1906,"column_start":8,"column_end":16},"name":"AtomicI8","qualname":"::sync::atomic::AtomicI8","value":"AtomicI8 {  }","parent":null,"children":[{"krate":0,"index":31574}],"decl_id":null,"docs":" An integer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988107,"byte_end":988117,"line_start":1162,"line_end":1162,"column_start":9,"column_end":19}},{"value":"repr(C, align(1))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988126,"byte_end":988151,"line_start":1163,"line_end":1163,"column_start":9,"column_end":34}}]},{"kind":"Const","id":{"krate":0,"index":31575},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1015305,"byte_end":1015319,"line_start":1906,"line_end":1906,"column_start":17,"column_end":31},"name":"ATOMIC_I8_INIT","qualname":"::sync::atomic::ATOMIC_I8_INIT","value":"AtomicI8","parent":null,"children":[],"decl_id":null,"docs":" An atomic integer initialized to `0`.\n","sig":null,"attributes":[{"value":"unstable(feature = \"integer_atomics\", issue = \"32976\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988293,"byte_end":988314,"line_start":1169,"line_end":1169,"column_start":9,"column_end":30}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicI8::new(0)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988323,"byte_end":988481,"line_start":1170,"line_end":1174,"column_start":9,"column_end":11}}]},{"kind":"Struct","id":{"krate":0,"index":31603},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1015944,"byte_end":1015952,"line_start":1922,"line_end":1922,"column_start":8,"column_end":16},"name":"AtomicU8","qualname":"::sync::atomic::AtomicU8","value":"AtomicU8 {  }","parent":null,"children":[{"krate":0,"index":31604}],"decl_id":null,"docs":" An integer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988107,"byte_end":988117,"line_start":1162,"line_end":1162,"column_start":9,"column_end":19}},{"value":"repr(C, align(1))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988126,"byte_end":988151,"line_start":1163,"line_end":1163,"column_start":9,"column_end":34}}]},{"kind":"Const","id":{"krate":0,"index":31605},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1015953,"byte_end":1015967,"line_start":1922,"line_end":1922,"column_start":17,"column_end":31},"name":"ATOMIC_U8_INIT","qualname":"::sync::atomic::ATOMIC_U8_INIT","value":"AtomicU8","parent":null,"children":[],"decl_id":null,"docs":" An atomic integer initialized to `0`.\n","sig":null,"attributes":[{"value":"unstable(feature = \"integer_atomics\", issue = \"32976\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988293,"byte_end":988314,"line_start":1169,"line_end":1169,"column_start":9,"column_end":30}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicU8::new(0)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988323,"byte_end":988481,"line_start":1170,"line_end":1174,"column_start":9,"column_end":11}}]},{"kind":"Struct","id":{"krate":0,"index":31633},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1016595,"byte_end":1016604,"line_start":1938,"line_end":1938,"column_start":9,"column_end":18},"name":"AtomicI16","qualname":"::sync::atomic::AtomicI16","value":"AtomicI16 {  }","parent":null,"children":[{"krate":0,"index":31634}],"decl_id":null,"docs":" An integer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988107,"byte_end":988117,"line_start":1162,"line_end":1162,"column_start":9,"column_end":19}},{"value":"repr(C, align(2))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988126,"byte_end":988151,"line_start":1163,"line_end":1163,"column_start":9,"column_end":34}}]},{"kind":"Const","id":{"krate":0,"index":31635},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1016605,"byte_end":1016620,"line_start":1938,"line_end":1938,"column_start":19,"column_end":34},"name":"ATOMIC_I16_INIT","qualname":"::sync::atomic::ATOMIC_I16_INIT","value":"AtomicI16","parent":null,"children":[],"decl_id":null,"docs":" An atomic integer initialized to `0`.\n","sig":null,"attributes":[{"value":"unstable(feature = \"integer_atomics\", issue = \"32976\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988293,"byte_end":988314,"line_start":1169,"line_end":1169,"column_start":9,"column_end":30}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicI16::new(0)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988323,"byte_end":988481,"line_start":1170,"line_end":1174,"column_start":9,"column_end":11}}]},{"kind":"Struct","id":{"krate":0,"index":31663},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1017250,"byte_end":1017259,"line_start":1954,"line_end":1954,"column_start":9,"column_end":18},"name":"AtomicU16","qualname":"::sync::atomic::AtomicU16","value":"AtomicU16 {  }","parent":null,"children":[{"krate":0,"index":31664}],"decl_id":null,"docs":" An integer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988107,"byte_end":988117,"line_start":1162,"line_end":1162,"column_start":9,"column_end":19}},{"value":"repr(C, align(2))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988126,"byte_end":988151,"line_start":1163,"line_end":1163,"column_start":9,"column_end":34}}]},{"kind":"Const","id":{"krate":0,"index":31665},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1017260,"byte_end":1017275,"line_start":1954,"line_end":1954,"column_start":19,"column_end":34},"name":"ATOMIC_U16_INIT","qualname":"::sync::atomic::ATOMIC_U16_INIT","value":"AtomicU16","parent":null,"children":[],"decl_id":null,"docs":" An atomic integer initialized to `0`.\n","sig":null,"attributes":[{"value":"unstable(feature = \"integer_atomics\", issue = \"32976\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988293,"byte_end":988314,"line_start":1169,"line_end":1169,"column_start":9,"column_end":30}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicU16::new(0)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988323,"byte_end":988481,"line_start":1170,"line_end":1174,"column_start":9,"column_end":11}}]},{"kind":"Struct","id":{"krate":0,"index":31693},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1017903,"byte_end":1017912,"line_start":1970,"line_end":1970,"column_start":9,"column_end":18},"name":"AtomicI32","qualname":"::sync::atomic::AtomicI32","value":"AtomicI32 {  }","parent":null,"children":[{"krate":0,"index":31694}],"decl_id":null,"docs":" An integer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988107,"byte_end":988117,"line_start":1162,"line_end":1162,"column_start":9,"column_end":19}},{"value":"repr(C, align(4))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988126,"byte_end":988151,"line_start":1163,"line_end":1163,"column_start":9,"column_end":34}}]},{"kind":"Const","id":{"krate":0,"index":31695},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1017913,"byte_end":1017928,"line_start":1970,"line_end":1970,"column_start":19,"column_end":34},"name":"ATOMIC_I32_INIT","qualname":"::sync::atomic::ATOMIC_I32_INIT","value":"AtomicI32","parent":null,"children":[],"decl_id":null,"docs":" An atomic integer initialized to `0`.\n","sig":null,"attributes":[{"value":"unstable(feature = \"integer_atomics\", issue = \"32976\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988293,"byte_end":988314,"line_start":1169,"line_end":1169,"column_start":9,"column_end":30}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicI32::new(0)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988323,"byte_end":988481,"line_start":1170,"line_end":1174,"column_start":9,"column_end":11}}]},{"kind":"Struct","id":{"krate":0,"index":31723},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1018558,"byte_end":1018567,"line_start":1986,"line_end":1986,"column_start":9,"column_end":18},"name":"AtomicU32","qualname":"::sync::atomic::AtomicU32","value":"AtomicU32 {  }","parent":null,"children":[{"krate":0,"index":31724}],"decl_id":null,"docs":" An integer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988107,"byte_end":988117,"line_start":1162,"line_end":1162,"column_start":9,"column_end":19}},{"value":"repr(C, align(4))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988126,"byte_end":988151,"line_start":1163,"line_end":1163,"column_start":9,"column_end":34}}]},{"kind":"Const","id":{"krate":0,"index":31725},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1018568,"byte_end":1018583,"line_start":1986,"line_end":1986,"column_start":19,"column_end":34},"name":"ATOMIC_U32_INIT","qualname":"::sync::atomic::ATOMIC_U32_INIT","value":"AtomicU32","parent":null,"children":[],"decl_id":null,"docs":" An atomic integer initialized to `0`.\n","sig":null,"attributes":[{"value":"unstable(feature = \"integer_atomics\", issue = \"32976\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988293,"byte_end":988314,"line_start":1169,"line_end":1169,"column_start":9,"column_end":30}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicU32::new(0)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988323,"byte_end":988481,"line_start":1170,"line_end":1174,"column_start":9,"column_end":11}}]},{"kind":"Struct","id":{"krate":0,"index":31753},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1019211,"byte_end":1019220,"line_start":2002,"line_end":2002,"column_start":9,"column_end":18},"name":"AtomicI64","qualname":"::sync::atomic::AtomicI64","value":"AtomicI64 {  }","parent":null,"children":[{"krate":0,"index":31754}],"decl_id":null,"docs":" An integer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988107,"byte_end":988117,"line_start":1162,"line_end":1162,"column_start":9,"column_end":19}},{"value":"repr(C, align(8))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988126,"byte_end":988151,"line_start":1163,"line_end":1163,"column_start":9,"column_end":34}}]},{"kind":"Const","id":{"krate":0,"index":31755},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1019221,"byte_end":1019236,"line_start":2002,"line_end":2002,"column_start":19,"column_end":34},"name":"ATOMIC_I64_INIT","qualname":"::sync::atomic::ATOMIC_I64_INIT","value":"AtomicI64","parent":null,"children":[],"decl_id":null,"docs":" An atomic integer initialized to `0`.\n","sig":null,"attributes":[{"value":"unstable(feature = \"integer_atomics\", issue = \"32976\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988293,"byte_end":988314,"line_start":1169,"line_end":1169,"column_start":9,"column_end":30}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicI64::new(0)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988323,"byte_end":988481,"line_start":1170,"line_end":1174,"column_start":9,"column_end":11}}]},{"kind":"Struct","id":{"krate":0,"index":31783},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1019866,"byte_end":1019875,"line_start":2018,"line_end":2018,"column_start":9,"column_end":18},"name":"AtomicU64","qualname":"::sync::atomic::AtomicU64","value":"AtomicU64 {  }","parent":null,"children":[{"krate":0,"index":31784}],"decl_id":null,"docs":" An integer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988107,"byte_end":988117,"line_start":1162,"line_end":1162,"column_start":9,"column_end":19}},{"value":"repr(C, align(8))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988126,"byte_end":988151,"line_start":1163,"line_end":1163,"column_start":9,"column_end":34}}]},{"kind":"Const","id":{"krate":0,"index":31785},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1019876,"byte_end":1019891,"line_start":2018,"line_end":2018,"column_start":19,"column_end":34},"name":"ATOMIC_U64_INIT","qualname":"::sync::atomic::ATOMIC_U64_INIT","value":"AtomicU64","parent":null,"children":[],"decl_id":null,"docs":" An atomic integer initialized to `0`.\n","sig":null,"attributes":[{"value":"unstable(feature = \"integer_atomics\", issue = \"32976\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988293,"byte_end":988314,"line_start":1169,"line_end":1169,"column_start":9,"column_end":30}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicU64::new(0)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988323,"byte_end":988481,"line_start":1170,"line_end":1174,"column_start":9,"column_end":11}}]},{"kind":"Struct","id":{"krate":0,"index":31813},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1022022,"byte_end":1022033,"line_start":2078,"line_end":2078,"column_start":11,"column_end":22},"name":"AtomicIsize","qualname":"::sync::atomic::AtomicIsize","value":"AtomicIsize {  }","parent":null,"children":[{"krate":0,"index":31814}],"decl_id":null,"docs":" An integer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988107,"byte_end":988117,"line_start":1162,"line_end":1162,"column_start":9,"column_end":19}},{"value":"repr(C, align(8))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988126,"byte_end":988151,"line_start":1163,"line_end":1163,"column_start":9,"column_end":34}}]},{"kind":"Const","id":{"krate":0,"index":31815},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1022034,"byte_end":1022051,"line_start":2078,"line_end":2078,"column_start":23,"column_end":40},"name":"ATOMIC_ISIZE_INIT","qualname":"::sync::atomic::ATOMIC_ISIZE_INIT","value":"AtomicIsize","parent":null,"children":[],"decl_id":null,"docs":" An atomic integer initialized to `0`.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988293,"byte_end":988314,"line_start":1169,"line_end":1169,"column_start":9,"column_end":30}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicIsize::new(0)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988323,"byte_end":988481,"line_start":1170,"line_end":1174,"column_start":9,"column_end":11}}]},{"kind":"Struct","id":{"krate":0,"index":31843},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1022631,"byte_end":1022642,"line_start":2094,"line_end":2094,"column_start":11,"column_end":22},"name":"AtomicUsize","qualname":"::sync::atomic::AtomicUsize","value":"AtomicUsize {  }","parent":null,"children":[{"krate":0,"index":31844}],"decl_id":null,"docs":" An integer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988107,"byte_end":988117,"line_start":1162,"line_end":1162,"column_start":9,"column_end":19}},{"value":"repr(C, align(8))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988126,"byte_end":988151,"line_start":1163,"line_end":1163,"column_start":9,"column_end":34}}]},{"kind":"Const","id":{"krate":0,"index":31845},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1022643,"byte_end":1022660,"line_start":2094,"line_end":2094,"column_start":23,"column_end":40},"name":"ATOMIC_USIZE_INIT","qualname":"::sync::atomic::ATOMIC_USIZE_INIT","value":"AtomicUsize","parent":null,"children":[],"decl_id":null,"docs":" An atomic integer initialized to `0`.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988293,"byte_end":988314,"line_start":1169,"line_end":1169,"column_start":9,"column_end":30}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicUsize::new(0)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":988323,"byte_end":988481,"line_start":1170,"line_end":1174,"column_start":9,"column_end":11}}]},{"kind":"Function","id":{"krate":0,"index":2363},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1034540,"byte_end":1034545,"line_start":2398,"line_end":2398,"column_start":8,"column_end":13},"name":"fence","qualname":"::sync::atomic::fence","value":"fn (order: Ordering) -> ()","parent":null,"children":[],"decl_id":null,"docs":" An atomic fence.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1034416,"byte_end":1034425,"line_start":2395,"line_end":2395,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1034426,"byte_end":1034471,"line_start":2396,"line_end":2396,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":2364},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1038879,"byte_end":1038893,"line_start":2493,"line_end":2493,"column_start":8,"column_end":22},"name":"compiler_fence","qualname":"::sync::atomic::compiler_fence","value":"fn (order: Ordering) -> ()","parent":null,"children":[],"decl_id":null,"docs":" A compiler memory fence.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1038805,"byte_end":1038814,"line_start":2491,"line_end":2491,"column_start":1,"column_end":10}},{"value":"stable(feature = \"compiler_fences\", since = \"1.21.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1038815,"byte_end":1038871,"line_start":2492,"line_end":2492,"column_start":1,"column_end":57}}]},{"kind":"Mod","id":{"krate":0,"index":2373},"span":{"file_name":"src/libcore/cell.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"cell","qualname":"::cell","value":"src/libcore/cell.rs","parent":null,"children":[{"krate":0,"index":2374},{"krate":0,"index":2375},{"krate":0,"index":2379},{"krate":0,"index":2380},{"krate":0,"index":2381},{"krate":0,"index":2385},{"krate":0,"index":2386},{"krate":0,"index":2389},{"krate":0,"index":2394},{"krate":0,"index":2396},{"krate":0,"index":2398},{"krate":0,"index":2401},{"krate":0,"index":2404},{"krate":0,"index":2407},{"krate":0,"index":2409},{"krate":0,"index":2416},{"krate":0,"index":2419},{"krate":0,"index":2422},{"krate":0,"index":2429},{"krate":0,"index":2434},{"krate":0,"index":2437},{"krate":0,"index":2440},{"krate":0,"index":2443},{"krate":0,"index":2447},{"krate":0,"index":2449},{"krate":0,"index":2451},{"krate":0,"index":2453},{"krate":0,"index":2455},{"krate":0,"index":2457},{"krate":0,"index":2459},{"krate":0,"index":2460},{"krate":0,"index":2461},{"krate":0,"index":2462},{"krate":0,"index":2463},{"krate":0,"index":2471},{"krate":0,"index":2480},{"krate":0,"index":2482},{"krate":0,"index":2484},{"krate":0,"index":2487},{"krate":0,"index":2490},{"krate":0,"index":2493},{"krate":0,"index":2495},{"krate":0,"index":2502},{"krate":0,"index":2505},{"krate":0,"index":2508},{"krate":0,"index":2511},{"krate":0,"index":2514},{"krate":0,"index":2517},{"krate":0,"index":2519},{"krate":0,"index":2521},{"krate":0,"index":2526},{"krate":0,"index":2530},{"krate":0,"index":2541},{"krate":0,"index":2545},{"krate":0,"index":2548},{"krate":0,"index":2558},{"krate":0,"index":2561},{"krate":0,"index":2563},{"krate":0,"index":2567},{"krate":0,"index":2572},{"krate":0,"index":2576},{"krate":0,"index":2579},{"krate":0,"index":2583},{"krate":0,"index":2586},{"krate":0,"index":2589},{"krate":0,"index":2591},{"krate":0,"index":2595},{"krate":0,"index":2598},{"krate":0,"index":2601},{"krate":0,"index":2604},{"krate":0,"index":2607}],"decl_id":null,"docs":" Shareable mutable containers.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1047821,"byte_end":1047867,"line_start":185,"line_end":185,"column_start":1,"column_end":47}}]},{"kind":"Struct","id":{"krate":0,"index":2386},"span":{"file_name":"src/libcore/cell.rs","byte_start":1048972,"byte_end":1048976,"line_start":228,"line_end":228,"column_start":12,"column_end":16},"name":"Cell","qualname":"::cell::Cell","value":"Cell {  }","parent":null,"children":[{"krate":0,"index":2388}],"decl_id":null,"docs":" A mutable memory location.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1048894,"byte_end":1048939,"line_start":226,"line_end":226,"column_start":1,"column_end":46}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/cell.rs","byte_start":1048940,"byte_end":1048960,"line_start":227,"line_end":227,"column_start":1,"column_end":21}}]},{"kind":"Method","id":{"krate":0,"index":2391},"span":{"file_name":"src/libcore/cell.rs","byte_start":1049326,"byte_end":1049329,"line_start":246,"line_end":246,"column_start":12,"column_end":15},"name":"get","qualname":"<Cell<T>>::get","value":"fn (&self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns a copy of the contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1049255,"byte_end":1049264,"line_start":244,"line_end":244,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1049269,"byte_end":1049314,"line_start":245,"line_end":245,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2392},"span":{"file_name":"src/libcore/cell.rs","byte_start":1049824,"byte_end":1049830,"line_start":267,"line_end":267,"column_start":12,"column_end":18},"name":"update","qualname":"<Cell<T>>::update","value":"fn <F> (&self, f: F) -> T","parent":null,"children":[],"decl_id":null,"docs":" Updates the contained value using a function and returns the new value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1049745,"byte_end":1049754,"line_start":265,"line_end":265,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"cell_update\", issue = \"50186\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1049759,"byte_end":1049812,"line_start":266,"line_end":266,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":2424},"span":{"file_name":"src/libcore/cell.rs","byte_start":1052113,"byte_end":1052116,"line_start":367,"line_end":367,"column_start":18,"column_end":21},"name":"new","qualname":"<Cell<T>>::new","value":"fn (value: T) -> Cell<T>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Cell` containing the given value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1052036,"byte_end":1052081,"line_start":365,"line_end":365,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1052086,"byte_end":1052095,"line_start":366,"line_end":366,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2425},"span":{"file_name":"src/libcore/cell.rs","byte_start":1052477,"byte_end":1052480,"line_start":386,"line_end":386,"column_start":12,"column_end":15},"name":"set","qualname":"<Cell<T>>::set","value":"fn (&self, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Sets the contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1052406,"byte_end":1052415,"line_start":384,"line_end":384,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1052420,"byte_end":1052465,"line_start":385,"line_end":385,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2426},"span":{"file_name":"src/libcore/cell.rs","byte_start":1053031,"byte_end":1053035,"line_start":407,"line_end":407,"column_start":12,"column_end":16},"name":"swap","qualname":"<Cell<T>>::swap","value":"fn (&self, other: &Self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Swaps the values of two Cells.\n Difference with `std::mem::swap` is that this function doesn't require `&mut` reference.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1052955,"byte_end":1052964,"line_start":405,"line_end":405,"column_start":5,"column_end":14}},{"value":"stable(feature = \"move_cell\", since = \"1.17.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1052969,"byte_end":1053019,"line_start":406,"line_end":406,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":2427},"span":{"file_name":"src/libcore/cell.rs","byte_start":1053578,"byte_end":1053585,"line_start":429,"line_end":429,"column_start":12,"column_end":19},"name":"replace","qualname":"<Cell<T>>::replace","value":"fn (&self, val: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Replaces the contained value, and returns it.","sig":null,"attributes":[{"value":"stable(feature = \"move_cell\", since = \"1.17.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1053516,"byte_end":1053566,"line_start":428,"line_end":428,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":2428},"span":{"file_name":"src/libcore/cell.rs","byte_start":1053967,"byte_end":1053977,"line_start":446,"line_end":446,"column_start":12,"column_end":22},"name":"into_inner","qualname":"<Cell<T>>::into_inner","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Unwraps the value.","sig":null,"attributes":[{"value":"stable(feature = \"move_cell\", since = \"1.17.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1053905,"byte_end":1053955,"line_start":445,"line_end":445,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":2431},"span":{"file_name":"src/libcore/cell.rs","byte_start":1054377,"byte_end":1054383,"line_start":465,"line_end":465,"column_start":18,"column_end":24},"name":"as_ptr","qualname":"<Cell<T>>::as_ptr","value":"fn (&self) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Returns a raw pointer to the underlying data in this cell.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1054293,"byte_end":1054302,"line_start":463,"line_end":463,"column_start":5,"column_end":14}},{"value":"stable(feature = \"cell_as_ptr\", since = \"1.12.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1054307,"byte_end":1054359,"line_start":464,"line_end":464,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":2432},"span":{"file_name":"src/libcore/cell.rs","byte_start":1054903,"byte_end":1054910,"line_start":486,"line_end":486,"column_start":12,"column_end":19},"name":"get_mut","qualname":"<Cell<T>>::get_mut","value":"fn (&mut self) -> &mut T","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable reference to the underlying data.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1054824,"byte_end":1054833,"line_start":484,"line_end":484,"column_start":5,"column_end":14}},{"value":"stable(feature = \"cell_get_mut\", since = \"1.11.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1054838,"byte_end":1054891,"line_start":485,"line_end":485,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":2433},"span":{"file_name":"src/libcore/cell.rs","byte_start":1055452,"byte_end":1055460,"line_start":507,"line_end":507,"column_start":12,"column_end":20},"name":"from_mut","qualname":"<Cell<T>>::from_mut","value":"fn (t: &mut T) -> &Cell<T>","parent":null,"children":[],"decl_id":null,"docs":" Returns a `&Cell<T>` from a `&mut T`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1055378,"byte_end":1055387,"line_start":505,"line_end":505,"column_start":5,"column_end":14}},{"value":"stable(feature = \"as_cell\", since = \"1.37.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1055392,"byte_end":1055440,"line_start":506,"line_end":506,"column_start":5,"column_end":53}}]},{"kind":"Method","id":{"krate":0,"index":2436},"span":{"file_name":"src/libcore/cell.rs","byte_start":1055972,"byte_end":1055976,"line_start":529,"line_end":529,"column_start":12,"column_end":16},"name":"take","qualname":"<Cell<T>>::take","value":"fn (&self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Takes the value of the cell, leaving `Default::default()` in its place.","sig":null,"attributes":[{"value":"stable(feature = \"move_cell\", since = \"1.17.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1055910,"byte_end":1055960,"line_start":528,"line_end":528,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":2442},"span":{"file_name":"src/libcore/cell.rs","byte_start":1056627,"byte_end":1056644,"line_start":552,"line_end":552,"column_start":12,"column_end":29},"name":"as_slice_of_cells","qualname":"<Cell<[T]>>::as_slice_of_cells","value":"fn (&self) -> &[Cell<T>]","parent":null,"children":[],"decl_id":null,"docs":" Returns a `&[Cell<T>]` from a `&Cell<[T]>`","sig":null,"attributes":[{"value":"stable(feature = \"as_cell\", since = \"1.37.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1056567,"byte_end":1056615,"line_start":551,"line_end":551,"column_start":5,"column_end":53}}]},{"kind":"Struct","id":{"krate":0,"index":2443},"span":{"file_name":"src/libcore/cell.rs","byte_start":1056957,"byte_end":1056964,"line_start":563,"line_end":563,"column_start":12,"column_end":19},"name":"RefCell","qualname":"::cell::RefCell","value":"RefCell {  }","parent":null,"children":[{"krate":0,"index":2445},{"krate":0,"index":2446}],"decl_id":null,"docs":" A mutable memory location with dynamically checked borrow rules","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1056900,"byte_end":1056945,"line_start":562,"line_end":562,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":2447},"span":{"file_name":"src/libcore/cell.rs","byte_start":1057189,"byte_end":1057200,"line_start":570,"line_end":570,"column_start":12,"column_end":23},"name":"BorrowError","qualname":"::cell::BorrowError","value":"BorrowError {  }","parent":null,"children":[{"krate":0,"index":2448}],"decl_id":null,"docs":" An error returned by [`RefCell::try_borrow`](struct.RefCell.html#method.try_borrow).\n","sig":null,"attributes":[{"value":"stable(feature = \"try_borrow\", since = \"1.13.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1057126,"byte_end":1057177,"line_start":569,"line_end":569,"column_start":1,"column_end":52}}]},{"kind":"Struct","id":{"krate":0,"index":2453},"span":{"file_name":"src/libcore/cell.rs","byte_start":1057791,"byte_end":1057805,"line_start":590,"line_end":590,"column_start":12,"column_end":26},"name":"BorrowMutError","qualname":"::cell::BorrowMutError","value":"BorrowMutError {  }","parent":null,"children":[{"krate":0,"index":2454}],"decl_id":null,"docs":" An error returned by [`RefCell::try_borrow_mut`](struct.RefCell.html#method.try_borrow_mut).\n","sig":null,"attributes":[{"value":"stable(feature = \"try_borrow\", since = \"1.13.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1057728,"byte_end":1057779,"line_start":589,"line_end":589,"column_start":1,"column_end":52}}]},{"kind":"Method","id":{"krate":0,"index":2465},"span":{"file_name":"src/libcore/cell.rs","byte_start":1059579,"byte_end":1059582,"line_start":646,"line_end":646,"column_start":18,"column_end":21},"name":"new","qualname":"<RefCell<T>>::new","value":"fn (value: T) -> RefCell<T>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `RefCell` containing `value`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1059502,"byte_end":1059547,"line_start":644,"line_end":644,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1059552,"byte_end":1059561,"line_start":645,"line_end":645,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2466},"span":{"file_name":"src/libcore/cell.rs","byte_start":1060037,"byte_end":1060047,"line_start":666,"line_end":666,"column_start":12,"column_end":22},"name":"into_inner","qualname":"<RefCell<T>>::into_inner","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Consumes the `RefCell`, returning the wrapped value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1059966,"byte_end":1060011,"line_start":664,"line_end":664,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1060016,"byte_end":1060025,"line_start":665,"line_end":665,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2467},"span":{"file_name":"src/libcore/cell.rs","byte_start":1060997,"byte_end":1061004,"line_start":694,"line_end":694,"column_start":12,"column_end":19},"name":"replace","qualname":"<RefCell<T>>::replace","value":"fn (&self, t: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Replaces the wrapped value with a new one, returning the old value,\n without deinitializing either one.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1060917,"byte_end":1060926,"line_start":692,"line_end":692,"column_start":5,"column_end":14}},{"value":"stable(feature = \"refcell_replace\", since = \"1.24.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1060931,"byte_end":1060985,"line_start":693,"line_end":693,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":2468},"span":{"file_name":"src/libcore/cell.rs","byte_start":1061658,"byte_end":1061670,"line_start":716,"line_end":716,"column_start":12,"column_end":24},"name":"replace_with","qualname":"<RefCell<T>>::replace_with","value":"fn <F> (&self, f: F) -> T","parent":null,"children":[],"decl_id":null,"docs":" Replaces the wrapped value with a new one computed from `f`, returning\n the old value, without deinitializing either one.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1061573,"byte_end":1061582,"line_start":714,"line_end":714,"column_start":5,"column_end":14}},{"value":"stable(feature = \"refcell_replace_swap\", since = \"1.35.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1061587,"byte_end":1061646,"line_start":715,"line_end":715,"column_start":5,"column_end":64}}]},{"kind":"Method","id":{"krate":0,"index":2470},"span":{"file_name":"src/libcore/cell.rs","byte_start":1062507,"byte_end":1062511,"line_start":743,"line_end":743,"column_start":12,"column_end":16},"name":"swap","qualname":"<RefCell<T>>::swap","value":"fn (&self, other: &Self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Swaps the wrapped value of `self` with the wrapped value of `other`,\n without deinitializing either one.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1062430,"byte_end":1062439,"line_start":741,"line_end":741,"column_start":5,"column_end":14}},{"value":"stable(feature = \"refcell_swap\", since = \"1.24.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1062444,"byte_end":1062495,"line_start":742,"line_end":742,"column_start":5,"column_end":56}}]},{"kind":"Method","id":{"krate":0,"index":2473},"span":{"file_name":"src/libcore/cell.rs","byte_start":1063666,"byte_end":1063672,"line_start":787,"line_end":787,"column_start":12,"column_end":18},"name":"borrow","qualname":"<RefCell<T>>::borrow","value":"fn (&self) -> Ref<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Immutably borrows the wrapped value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1063595,"byte_end":1063640,"line_start":785,"line_end":785,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1063645,"byte_end":1063654,"line_start":786,"line_end":786,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2474},"span":{"file_name":"src/libcore/cell.rs","byte_start":1064530,"byte_end":1064540,"line_start":818,"line_end":818,"column_start":12,"column_end":22},"name":"try_borrow","qualname":"<RefCell<T>>::try_borrow","value":"fn (&self) -> Result<Ref<'_, T>, BorrowError>","parent":null,"children":[],"decl_id":null,"docs":" Immutably borrows the wrapped value, returning an error if the value is currently mutably\n borrowed.","sig":null,"attributes":[{"value":"stable(feature = \"try_borrow\", since = \"1.13.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1064453,"byte_end":1064504,"line_start":816,"line_end":816,"column_start":5,"column_end":56}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1064509,"byte_end":1064518,"line_start":817,"line_end":817,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2475},"span":{"file_name":"src/libcore/cell.rs","byte_start":1065884,"byte_end":1065894,"line_start":868,"line_end":868,"column_start":12,"column_end":22},"name":"borrow_mut","qualname":"<RefCell<T>>::borrow_mut","value":"fn (&self) -> RefMut<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Mutably borrows the wrapped value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1065813,"byte_end":1065858,"line_start":866,"line_end":866,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1065863,"byte_end":1065872,"line_start":867,"line_end":867,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2476},"span":{"file_name":"src/libcore/cell.rs","byte_start":1066728,"byte_end":1066742,"line_start":896,"line_end":896,"column_start":12,"column_end":26},"name":"try_borrow_mut","qualname":"<RefCell<T>>::try_borrow_mut","value":"fn (&self) -> Result<RefMut<'_, T>, BorrowMutError>","parent":null,"children":[],"decl_id":null,"docs":" Mutably borrows the wrapped value, returning an error if the value is currently borrowed.","sig":null,"attributes":[{"value":"stable(feature = \"try_borrow\", since = \"1.13.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1066651,"byte_end":1066702,"line_start":894,"line_end":894,"column_start":5,"column_end":56}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1066707,"byte_end":1066716,"line_start":895,"line_end":895,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2477},"span":{"file_name":"src/libcore/cell.rs","byte_start":1067371,"byte_end":1067377,"line_start":919,"line_end":919,"column_start":12,"column_end":18},"name":"as_ptr","qualname":"<RefCell<T>>::as_ptr","value":"fn (&self) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Returns a raw pointer to the underlying data in this cell.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1067293,"byte_end":1067302,"line_start":917,"line_end":917,"column_start":5,"column_end":14}},{"value":"stable(feature = \"cell_as_ptr\", since = \"1.12.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1067307,"byte_end":1067359,"line_start":918,"line_end":918,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":2478},"span":{"file_name":"src/libcore/cell.rs","byte_start":1068354,"byte_end":1068361,"line_start":949,"line_end":949,"column_start":12,"column_end":19},"name":"get_mut","qualname":"<RefCell<T>>::get_mut","value":"fn (&mut self) -> &mut T","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable reference to the underlying data.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1068275,"byte_end":1068284,"line_start":947,"line_end":947,"column_start":5,"column_end":14}},{"value":"stable(feature = \"cell_get_mut\", since = \"1.11.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1068289,"byte_end":1068342,"line_start":948,"line_end":948,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":2479},"span":{"file_name":"src/libcore/cell.rs","byte_start":1069347,"byte_end":1069367,"line_start":984,"line_end":984,"column_start":19,"column_end":39},"name":"try_borrow_unguarded","qualname":"<RefCell<T>>::try_borrow_unguarded","value":"fn (&self) -> Result<&T, BorrowError>","parent":null,"children":[],"decl_id":null,"docs":" Immutably borrows the wrapped value, returning an error if the value is\n currently mutably borrowed.","sig":null,"attributes":[{"value":"stable(feature = \"borrow_state\", since = \"1.37.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1069261,"byte_end":1069314,"line_start":982,"line_end":982,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1069319,"byte_end":1069328,"line_start":983,"line_end":983,"column_start":5,"column_end":14}}]},{"kind":"Struct","id":{"krate":0,"index":2521},"span":{"file_name":"src/libcore/cell.rs","byte_start":1073877,"byte_end":1073880,"line_start":1145,"line_end":1145,"column_start":12,"column_end":15},"name":"Ref","qualname":"::cell::Ref","value":"Ref {  }","parent":null,"children":[{"krate":0,"index":2524},{"krate":0,"index":2525}],"decl_id":null,"docs":" Wraps a borrowed reference to a value in a `RefCell` box.\n A wrapper type for an immutably borrowed value from a `RefCell<T>`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1073820,"byte_end":1073865,"line_start":1144,"line_end":1144,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":2533},"span":{"file_name":"src/libcore/cell.rs","byte_start":1074603,"byte_end":1074608,"line_start":1171,"line_end":1171,"column_start":12,"column_end":17},"name":"clone","qualname":"<Ref>::clone","value":"fn (orig: &Ref<'b, T>) -> Ref<'b, T>","parent":null,"children":[],"decl_id":null,"docs":" Copies a `Ref`.","sig":null,"attributes":[{"value":"stable(feature = \"cell_extras\", since = \"1.15.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1074525,"byte_end":1074577,"line_start":1169,"line_end":1169,"column_start":5,"column_end":57}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1074582,"byte_end":1074591,"line_start":1170,"line_end":1170,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2534},"span":{"file_name":"src/libcore/cell.rs","byte_start":1075455,"byte_end":1075458,"line_start":1198,"line_end":1198,"column_start":12,"column_end":15},"name":"map","qualname":"<Ref>::map","value":"fn <U, F> (orig: Ref<'b, T>, f: F) -> Ref<'b, U>","parent":null,"children":[],"decl_id":null,"docs":" Makes a new `Ref` for a component of the borrowed data.","sig":null,"attributes":[{"value":"stable(feature = \"cell_map\", since = \"1.8.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1075381,"byte_end":1075429,"line_start":1196,"line_end":1196,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1075434,"byte_end":1075443,"line_start":1197,"line_end":1197,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2537},"span":{"file_name":"src/libcore/cell.rs","byte_start":1076474,"byte_end":1076483,"line_start":1229,"line_end":1229,"column_start":12,"column_end":21},"name":"map_split","qualname":"<Ref>::map_split","value":"fn <U, V, F> (orig: Ref<'b, T>, f: F) -> (Ref<'b, U>, Ref<'b, V>)","parent":null,"children":[],"decl_id":null,"docs":" Splits a `Ref` into multiple `Ref`s for different components of the\n borrowed data.","sig":null,"attributes":[{"value":"stable(feature = \"refcell_map_split\", since = \"1.35.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1076390,"byte_end":1076448,"line_start":1227,"line_end":1227,"column_start":5,"column_end":63}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1076453,"byte_end":1076462,"line_start":1228,"line_end":1228,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2551},"span":{"file_name":"src/libcore/cell.rs","byte_start":1078031,"byte_end":1078034,"line_start":1274,"line_end":1274,"column_start":12,"column_end":15},"name":"map","qualname":"<RefMut>::map","value":"fn <U, F> (orig: RefMut<'b, T>, f: F) -> RefMut<'b, U>","parent":null,"children":[],"decl_id":null,"docs":" Makes a new `RefMut` for a component of the borrowed data, e.g., an enum\n variant.","sig":null,"attributes":[{"value":"stable(feature = \"cell_map\", since = \"1.8.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1077957,"byte_end":1078005,"line_start":1272,"line_end":1272,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1078010,"byte_end":1078019,"line_start":1273,"line_end":1273,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2554},"span":{"file_name":"src/libcore/cell.rs","byte_start":1079373,"byte_end":1079382,"line_start":1312,"line_end":1312,"column_start":12,"column_end":21},"name":"map_split","qualname":"<RefMut>::map_split","value":"fn <U, V, F> (orig: RefMut<'b, T>, f: F) -> (RefMut<'b, U>, RefMut<'b, V>)","parent":null,"children":[],"decl_id":null,"docs":" Splits a `RefMut` into multiple `RefMut`s for different components of the\n borrowed data.","sig":null,"attributes":[{"value":"stable(feature = \"refcell_map_split\", since = \"1.35.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1079289,"byte_end":1079347,"line_start":1310,"line_end":1310,"column_start":5,"column_end":63}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1079352,"byte_end":1079361,"line_start":1311,"line_end":1311,"column_start":5,"column_end":14}}]},{"kind":"Struct","id":{"krate":0,"index":2567},"span":{"file_name":"src/libcore/cell.rs","byte_start":1081377,"byte_end":1081383,"line_start":1372,"line_end":1372,"column_start":12,"column_end":18},"name":"RefMut","qualname":"::cell::RefMut","value":"RefMut {  }","parent":null,"children":[{"krate":0,"index":2570},{"krate":0,"index":2571}],"decl_id":null,"docs":" A wrapper type for a mutably borrowed value from a `RefCell<T>`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1081320,"byte_end":1081365,"line_start":1371,"line_end":1371,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":2586},"span":{"file_name":"src/libcore/cell.rs","byte_start":1085318,"byte_end":1085328,"line_start":1465,"line_end":1465,"column_start":12,"column_end":22},"name":"UnsafeCell","qualname":"::cell::UnsafeCell","value":"UnsafeCell {  }","parent":null,"children":[{"krate":0,"index":2588}],"decl_id":null,"docs":" The core primitive for interior mutability in Rust.","sig":null,"attributes":[{"value":"lang = \"unsafe_cell\"","span":{"file_name":"src/libcore/cell.rs","byte_start":1085216,"byte_end":1085239,"line_start":1462,"line_end":1462,"column_start":1,"column_end":24}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1085240,"byte_end":1085285,"line_start":1463,"line_end":1463,"column_start":1,"column_end":46}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/cell.rs","byte_start":1085286,"byte_end":1085306,"line_start":1464,"line_end":1464,"column_start":1,"column_end":21}}]},{"kind":"Method","id":{"krate":0,"index":2593},"span":{"file_name":"src/libcore/cell.rs","byte_start":1085863,"byte_end":1085866,"line_start":1487,"line_end":1487,"column_start":18,"column_end":21},"name":"new","qualname":"<UnsafeCell<T>>::new","value":"fn (value: T) -> UnsafeCell<T>","parent":null,"children":[],"decl_id":null,"docs":" Constructs a new instance of `UnsafeCell` which will wrap the specified\n value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1085786,"byte_end":1085831,"line_start":1485,"line_end":1485,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1085836,"byte_end":1085845,"line_start":1486,"line_end":1486,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2594},"span":{"file_name":"src/libcore/cell.rs","byte_start":1086217,"byte_end":1086227,"line_start":1504,"line_end":1504,"column_start":12,"column_end":22},"name":"into_inner","qualname":"<UnsafeCell<T>>::into_inner","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Unwraps the value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1086146,"byte_end":1086155,"line_start":1502,"line_end":1502,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1086160,"byte_end":1086205,"line_start":1503,"line_end":1503,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2597},"span":{"file_name":"src/libcore/cell.rs","byte_start":1086880,"byte_end":1086883,"line_start":1528,"line_end":1528,"column_start":18,"column_end":21},"name":"get","qualname":"<UnsafeCell<T>>::get","value":"fn (&self) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Gets a mutable pointer to the wrapped value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1086803,"byte_end":1086812,"line_start":1526,"line_end":1526,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1086817,"byte_end":1086862,"line_start":1527,"line_end":1527,"column_start":5,"column_end":50}}]},{"kind":"Mod","id":{"krate":0,"index":2608},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"char","qualname":"::char","value":"src/libcore/char/mod.rs","parent":null,"children":[{"krate":0,"index":2609},{"krate":0,"index":2634},{"krate":0,"index":2648},{"krate":0,"index":2697},{"krate":0,"index":2700},{"krate":0,"index":2701},{"krate":0,"index":2702},{"krate":0,"index":2703},{"krate":0,"index":2707},{"krate":0,"index":2708},{"krate":0,"index":2709},{"krate":0,"index":2712},{"krate":0,"index":2713},{"krate":0,"index":2714},{"krate":0,"index":2715},{"krate":0,"index":2716},{"krate":0,"index":2717},{"krate":0,"index":2718},{"krate":0,"index":2719},{"krate":0,"index":2720},{"krate":0,"index":2721},{"krate":0,"index":31932},{"krate":0,"index":31938},{"krate":0,"index":31936},{"krate":0,"index":31940},{"krate":0,"index":31955},{"krate":0,"index":31953},{"krate":0,"index":2722},{"krate":0,"index":2728},{"krate":0,"index":2730},{"krate":0,"index":2731},{"krate":0,"index":31957},{"krate":0,"index":31961},{"krate":0,"index":31959},{"krate":0,"index":31963},{"krate":0,"index":31977},{"krate":0,"index":31975},{"krate":0,"index":2733},{"krate":0,"index":2740},{"krate":0,"index":2742},{"krate":0,"index":2743},{"krate":0,"index":31979},{"krate":0,"index":31984},{"krate":0,"index":31982},{"krate":0,"index":2745},{"krate":0,"index":2749},{"krate":0,"index":2750},{"krate":0,"index":2751},{"krate":0,"index":31986},{"krate":0,"index":31991},{"krate":0,"index":31989},{"krate":0,"index":2753},{"krate":0,"index":2757},{"krate":0,"index":2758},{"krate":0,"index":31993},{"krate":0,"index":31998},{"krate":0,"index":31996},{"krate":0,"index":2759},{"krate":0,"index":2763},{"krate":0,"index":2764},{"krate":0,"index":32000},{"krate":0,"index":32017},{"krate":0,"index":32015},{"krate":0,"index":2765},{"krate":0,"index":2768},{"krate":0,"index":2772},{"krate":0,"index":2774},{"krate":0,"index":2776}],"decl_id":null,"docs":" A character type.","sig":null,"attributes":[{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1088661,"byte_end":1088686,"line_start":19,"line_end":19,"column_start":1,"column_end":26}},{"value":"stable(feature = \"core_char\", since = \"1.2.0\")","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1088687,"byte_end":1088737,"line_start":20,"line_end":20,"column_start":1,"column_end":51}}]},{"kind":"Function","id":{"krate":0,"index":2615},"span":{"file_name":"src/libcore/char/convert.rs","byte_start":1106094,"byte_end":1106102,"line_start":57,"line_end":57,"column_start":8,"column_end":16},"name":"from_u32","qualname":"::char::convert::from_u32","value":"fn (i: u32) -> Option<char>","parent":null,"children":[],"decl_id":null,"docs":" Converts a `u32` to a `char`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1106031,"byte_end":1106040,"line_start":55,"line_end":55,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1106041,"byte_end":1106086,"line_start":56,"line_end":56,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":2616},"span":{"file_name":"src/libcore/char/convert.rs","byte_start":1107146,"byte_end":1107164,"line_start":101,"line_end":101,"column_start":15,"column_end":33},"name":"from_u32_unchecked","qualname":"::char::convert::from_u32_unchecked","value":"fn (i: u32) -> char","parent":null,"children":[],"decl_id":null,"docs":" Converts a `u32` to a `char`, ignoring validity.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1107062,"byte_end":1107071,"line_start":99,"line_end":99,"column_start":1,"column_end":10}},{"value":"stable(feature = \"char_from_unchecked\", since = \"1.5.0\")","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1107072,"byte_end":1107131,"line_start":100,"line_end":100,"column_start":1,"column_end":60}}]},{"kind":"Struct","id":{"krate":0,"index":31873},"span":{"file_name":"src/libcore/char/convert.rs","byte_start":1109206,"byte_end":1109220,"line_start":169,"line_end":169,"column_start":12,"column_end":26},"name":"ParseCharError","qualname":"::char::convert::ParseCharError","value":"ParseCharError {  }","parent":null,"children":[{"krate":0,"index":31874}],"decl_id":null,"docs":" An error which can be returned when parsing a char.\n","sig":null,"attributes":[{"value":"stable(feature = \"char_from_str\", since = \"1.20.0\")","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1109101,"byte_end":1109155,"line_start":167,"line_end":167,"column_start":1,"column_end":55}},{"value":"structural_match","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1109195,"byte_end":1109249,"line_start":169,"line_end":171,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":2622},"span":{"file_name":"src/libcore/char/convert.rs","byte_start":1109453,"byte_end":1109466,"line_start":178,"line_end":178,"column_start":12,"column_end":25},"name":"__description","qualname":"<ParseCharError>::__description","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"char_error_internals\",\n           reason = \"this method should not be available publicly\",\n           issue = \"0\")","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1109277,"byte_end":1109422,"line_start":174,"line_end":176,"column_start":5,"column_end":29}}]},{"kind":"Struct","id":{"krate":0,"index":31898},"span":{"file_name":"src/libcore/char/convert.rs","byte_start":1111108,"byte_end":1111124,"line_start":239,"line_end":239,"column_start":12,"column_end":28},"name":"CharTryFromError","qualname":"::char::convert::CharTryFromError","value":"","parent":null,"children":[],"decl_id":null,"docs":" The error type returned when a conversion from u32 to char fails.\n","sig":null,"attributes":[{"value":"stable(feature = \"try_from\", since = \"1.34.0\")","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1111002,"byte_end":1111051,"line_start":237,"line_end":237,"column_start":1,"column_end":50}},{"value":"structural_match","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1111097,"byte_end":1111129,"line_start":239,"line_end":239,"column_start":1,"column_end":33}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1111097,"byte_end":1111129,"line_start":239,"line_end":239,"column_start":1,"column_end":33}}]},{"kind":"Function","id":{"krate":0,"index":2633},"span":{"file_name":"src/libcore/char/convert.rs","byte_start":1112567,"byte_end":1112577,"line_start":304,"line_end":304,"column_start":8,"column_end":18},"name":"from_digit","qualname":"::char::convert::from_digit","value":"fn (num: u32, radix: u32) -> Option<char>","parent":null,"children":[],"decl_id":null,"docs":" Converts a digit in the given radix to a `char`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1112504,"byte_end":1112513,"line_start":302,"line_end":302,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1112514,"byte_end":1112559,"line_start":303,"line_end":303,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":31911},"span":{"file_name":"src/libcore/char/decode.rs","byte_start":1113185,"byte_end":1113196,"line_start":10,"line_end":10,"column_start":12,"column_end":23},"name":"DecodeUtf16","qualname":"::char::decode::DecodeUtf16","value":"DecodeUtf16 {  }","parent":null,"children":[{"krate":0,"index":31913},{"krate":0,"index":31914}],"decl_id":null,"docs":" An iterator that decodes UTF-16 encoded code points from an iterator of `u16`s.\n","sig":null,"attributes":[{"value":"stable(feature = \"decode_utf16\", since = \"1.9.0\")","span":{"file_name":"src/libcore/char/decode.rs","byte_start":1113097,"byte_end":1113149,"line_start":8,"line_end":8,"column_start":1,"column_end":53}}]},{"kind":"Struct","id":{"krate":0,"index":31921},"span":{"file_name":"src/libcore/char/decode.rs","byte_start":1113445,"byte_end":1113461,"line_start":20,"line_end":20,"column_start":12,"column_end":28},"name":"DecodeUtf16Error","qualname":"::char::decode::DecodeUtf16Error","value":"DecodeUtf16Error {  }","parent":null,"children":[{"krate":0,"index":31922}],"decl_id":null,"docs":" An error that can be returned when decoding UTF-16 code points.\n","sig":null,"attributes":[{"value":"stable(feature = \"decode_utf16\", since = \"1.9.0\")","span":{"file_name":"src/libcore/char/decode.rs","byte_start":1113342,"byte_end":1113394,"line_start":18,"line_end":18,"column_start":1,"column_end":53}},{"value":"structural_match","span":{"file_name":"src/libcore/char/decode.rs","byte_start":1113434,"byte_end":1113480,"line_start":20,"line_end":22,"column_start":1,"column_end":2}}]},{"kind":"Function","id":{"krate":0,"index":2637},"span":{"file_name":"src/libcore/char/decode.rs","byte_start":1114915,"byte_end":1114927,"line_start":70,"line_end":70,"column_start":8,"column_end":20},"name":"decode_utf16","qualname":"::char::decode::decode_utf16","value":"fn <I> (iter: I) -> DecodeUtf16<I::IntoIter>","parent":null,"children":[],"decl_id":null,"docs":" Creates an iterator over the UTF-16 encoded code points in `iter`,\n returning unpaired surrogates as `Err`s.","sig":null,"attributes":[{"value":"stable(feature = \"decode_utf16\", since = \"1.9.0\")","span":{"file_name":"src/libcore/char/decode.rs","byte_start":1114845,"byte_end":1114897,"line_start":68,"line_end":68,"column_start":1,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/char/decode.rs","byte_start":1114898,"byte_end":1114907,"line_start":69,"line_end":69,"column_start":1,"column_end":10}}]},{"kind":"Method","id":{"krate":0,"index":2645},"span":{"file_name":"src/libcore/char/decode.rs","byte_start":1116809,"byte_end":1116827,"line_start":124,"line_end":124,"column_start":12,"column_end":30},"name":"unpaired_surrogate","qualname":"<DecodeUtf16Error>::unpaired_surrogate","value":"fn (&self) -> u16","parent":null,"children":[],"decl_id":null,"docs":" Returns the unpaired surrogate which caused this error.\n","sig":null,"attributes":[{"value":"stable(feature = \"decode_utf16\", since = \"1.9.0\")","span":{"file_name":"src/libcore/char/decode.rs","byte_start":1116745,"byte_end":1116797,"line_start":123,"line_end":123,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":2659},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1118695,"byte_end":1118703,"line_start":60,"line_end":60,"column_start":12,"column_end":20},"name":"is_digit","qualname":"<char>::is_digit","value":"fn (self, radix: u32) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if a `char` is a digit in the given radix.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1118624,"byte_end":1118669,"line_start":58,"line_end":58,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1118674,"byte_end":1118683,"line_start":59,"line_end":59,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2660},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1120101,"byte_end":1120109,"line_start":114,"line_end":114,"column_start":12,"column_end":20},"name":"to_digit","qualname":"<char>::to_digit","value":"fn (self, radix: u32) -> Option<u32>","parent":null,"children":[],"decl_id":null,"docs":" Converts a `char` to a digit in the given radix.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1120030,"byte_end":1120075,"line_start":112,"line_end":112,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1120080,"byte_end":1120089,"line_start":113,"line_end":113,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2661},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1121745,"byte_end":1121759,"line_start":173,"line_end":173,"column_start":12,"column_end":26},"name":"escape_unicode","qualname":"<char>::escape_unicode","value":"fn (self) -> EscapeUnicode","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator that yields the hexadecimal Unicode escape of a\n character as `char`s.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1121674,"byte_end":1121719,"line_start":171,"line_end":171,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1121724,"byte_end":1121733,"line_start":172,"line_end":172,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2663},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1124105,"byte_end":1124117,"line_start":245,"line_end":245,"column_start":12,"column_end":24},"name":"escape_debug","qualname":"<char>::escape_debug","value":"fn (self) -> EscapeDebug","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator that yields the literal escape code of a character\n as `char`s.","sig":null,"attributes":[{"value":"stable(feature = \"char_escape_debug\", since = \"1.20.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1124021,"byte_end":1124079,"line_start":243,"line_end":243,"column_start":5,"column_end":63}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1124084,"byte_end":1124093,"line_start":244,"line_end":244,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2664},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1125646,"byte_end":1125660,"line_start":300,"line_end":300,"column_start":12,"column_end":26},"name":"escape_default","qualname":"<char>::escape_default","value":"fn (self) -> EscapeDefault","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator that yields the literal escape code of a character\n as `char`s.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1125575,"byte_end":1125620,"line_start":298,"line_end":298,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1125625,"byte_end":1125634,"line_start":299,"line_end":299,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2665},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1127544,"byte_end":1127552,"line_start":359,"line_end":359,"column_start":12,"column_end":20},"name":"len_utf8","qualname":"<char>::len_utf8","value":"fn (self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the number of bytes this `char` would need if encoded in UTF-8.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1127473,"byte_end":1127518,"line_start":357,"line_end":357,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1127523,"byte_end":1127532,"line_start":358,"line_end":358,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2666},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1128404,"byte_end":1128413,"line_start":393,"line_end":393,"column_start":12,"column_end":21},"name":"len_utf16","qualname":"<char>::len_utf16","value":"fn (self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the number of 16-bit code units this `char` would need if\n encoded in UTF-16.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1128333,"byte_end":1128378,"line_start":391,"line_end":391,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1128383,"byte_end":1128392,"line_start":392,"line_end":392,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2667},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1129536,"byte_end":1129547,"line_start":436,"line_end":436,"column_start":12,"column_end":23},"name":"encode_utf8","qualname":"<char>::encode_utf8","value":"fn (self, dst: &mut [u8]) -> &mut str","parent":null,"children":[],"decl_id":null,"docs":" Encodes this character as UTF-8 into the provided byte buffer,\n and then returns the subslice of the buffer that contains the encoded character.","sig":null,"attributes":[{"value":"stable(feature = \"unicode_encode_char\", since = \"1.15.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1129450,"byte_end":1129510,"line_start":434,"line_end":434,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1129515,"byte_end":1129524,"line_start":435,"line_end":435,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2668},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1132034,"byte_end":1132046,"line_start":504,"line_end":504,"column_start":12,"column_end":24},"name":"encode_utf16","qualname":"<char>::encode_utf16","value":"fn (self, dst: &mut [u16]) -> &mut [u16]","parent":null,"children":[],"decl_id":null,"docs":" Encodes this character as UTF-16 into the provided `u16` buffer,\n and then returns the subslice of the buffer that contains the encoded character.","sig":null,"attributes":[{"value":"stable(feature = \"unicode_encode_char\", since = \"1.15.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1131948,"byte_end":1132008,"line_start":502,"line_end":502,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1132013,"byte_end":1132022,"line_start":503,"line_end":503,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2669},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1133465,"byte_end":1133478,"line_start":542,"line_end":542,"column_start":12,"column_end":25},"name":"is_alphabetic","qualname":"<char>::is_alphabetic","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this `char` is an alphabetic code point, and false if not.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1133394,"byte_end":1133439,"line_start":540,"line_end":540,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1133444,"byte_end":1133453,"line_start":541,"line_end":541,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2670},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1134158,"byte_end":1134170,"line_start":560,"line_end":560,"column_start":12,"column_end":24},"name":"is_xid_start","qualname":"<char>::is_xid_start","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this `char` satisfies the 'XID_Start' Unicode property, and false\n otherwise.","sig":null,"attributes":[{"value":"unstable(feature = \"rustc_private\",\n           reason = \"mainly needed for compiler internals\",\n           issue = \"27812\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1133998,"byte_end":1134132,"line_start":556,"line_end":558,"column_start":5,"column_end":33}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1134137,"byte_end":1134146,"line_start":559,"line_end":559,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2671},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1134737,"byte_end":1134752,"line_start":574,"line_end":574,"column_start":12,"column_end":27},"name":"is_xid_continue","qualname":"<char>::is_xid_continue","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this `char` satisfies the 'XID_Continue' Unicode property, and false\n otherwise.","sig":null,"attributes":[{"value":"unstable(feature = \"rustc_private\",\n           reason = \"mainly needed for compiler internals\",\n           issue = \"27812\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1134577,"byte_end":1134711,"line_start":570,"line_end":572,"column_start":5,"column_end":33}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1134716,"byte_end":1134725,"line_start":573,"line_end":573,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2672},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1135421,"byte_end":1135433,"line_start":598,"line_end":598,"column_start":12,"column_end":24},"name":"is_lowercase","qualname":"<char>::is_lowercase","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this `char` is lowercase.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1135350,"byte_end":1135395,"line_start":596,"line_end":596,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1135400,"byte_end":1135409,"line_start":597,"line_end":597,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2673},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1136206,"byte_end":1136218,"line_start":626,"line_end":626,"column_start":12,"column_end":24},"name":"is_uppercase","qualname":"<char>::is_uppercase","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this `char` is uppercase.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1136135,"byte_end":1136180,"line_start":624,"line_end":624,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1136185,"byte_end":1136194,"line_start":625,"line_end":625,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2674},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1136900,"byte_end":1136913,"line_start":653,"line_end":653,"column_start":12,"column_end":25},"name":"is_whitespace","qualname":"<char>::is_whitespace","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this `char` is whitespace.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1136829,"byte_end":1136874,"line_start":651,"line_end":651,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1136879,"byte_end":1136888,"line_start":652,"line_end":652,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2675},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1137798,"byte_end":1137813,"line_start":682,"line_end":682,"column_start":12,"column_end":27},"name":"is_alphanumeric","qualname":"<char>::is_alphanumeric","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this `char` is alphanumeric.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1137727,"byte_end":1137772,"line_start":680,"line_end":680,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1137777,"byte_end":1137786,"line_start":681,"line_end":681,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2676},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1138325,"byte_end":1138335,"line_start":702,"line_end":702,"column_start":12,"column_end":22},"name":"is_control","qualname":"<char>::is_control","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this `char` is a control code point.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1138254,"byte_end":1138299,"line_start":700,"line_end":700,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1138304,"byte_end":1138313,"line_start":701,"line_end":701,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2678},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1139346,"byte_end":1139356,"line_start":736,"line_end":736,"column_start":12,"column_end":22},"name":"is_numeric","qualname":"<char>::is_numeric","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this `char` is numeric.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1139275,"byte_end":1139320,"line_start":734,"line_end":734,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1139325,"byte_end":1139334,"line_start":735,"line_end":735,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2679},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1141357,"byte_end":1141369,"line_start":801,"line_end":801,"column_start":12,"column_end":24},"name":"to_lowercase","qualname":"<char>::to_lowercase","value":"fn (self) -> ToLowercase","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator that yields the lowercase equivalent of a `char`\n as one or more `char`s.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1141286,"byte_end":1141331,"line_start":799,"line_end":799,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1141336,"byte_end":1141345,"line_start":800,"line_end":800,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2680},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1144087,"byte_end":1144099,"line_start":887,"line_end":887,"column_start":12,"column_end":24},"name":"to_uppercase","qualname":"<char>::to_uppercase","value":"fn (self) -> ToUppercase","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator that yields the uppercase equivalent of a `char`\n as one or more `char`s.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1144016,"byte_end":1144061,"line_start":885,"line_end":885,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1144066,"byte_end":1144075,"line_start":886,"line_end":886,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2681},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1144558,"byte_end":1144566,"line_start":904,"line_end":904,"column_start":18,"column_end":26},"name":"is_ascii","qualname":"<char>::is_ascii","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is within the ASCII range.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1144458,"byte_end":1144526,"line_start":902,"line_end":902,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1144531,"byte_end":1144540,"line_start":903,"line_end":903,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2682},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1145445,"byte_end":1145463,"line_start":932,"line_end":932,"column_start":12,"column_end":30},"name":"to_ascii_uppercase","qualname":"<char>::to_ascii_uppercase","value":"fn (&self) -> char","parent":null,"children":[],"decl_id":null,"docs":" Makes a copy of the value in its ASCII upper case equivalent.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1145351,"byte_end":1145419,"line_start":930,"line_end":930,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1145424,"byte_end":1145433,"line_start":931,"line_end":931,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2683},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1146442,"byte_end":1146460,"line_start":964,"line_end":964,"column_start":12,"column_end":30},"name":"to_ascii_lowercase","qualname":"<char>::to_ascii_lowercase","value":"fn (&self) -> char","parent":null,"children":[],"decl_id":null,"docs":" Makes a copy of the value in its ASCII lower case equivalent.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1146348,"byte_end":1146416,"line_start":962,"line_end":962,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1146421,"byte_end":1146430,"line_start":963,"line_end":963,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2684},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1147180,"byte_end":1147200,"line_start":989,"line_end":989,"column_start":12,"column_end":32},"name":"eq_ignore_ascii_case","qualname":"<char>::eq_ignore_ascii_case","value":"fn (&self, other: &char) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks that two values are an ASCII case-insensitive match.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1147086,"byte_end":1147154,"line_start":987,"line_end":987,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1147159,"byte_end":1147168,"line_start":988,"line_end":988,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2685},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1147947,"byte_end":1147967,"line_start":1014,"line_end":1014,"column_start":12,"column_end":32},"name":"make_ascii_uppercase","qualname":"<char>::make_ascii_uppercase","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Converts this type to its ASCII upper case equivalent in-place.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1147853,"byte_end":1147921,"line_start":1012,"line_end":1012,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1147926,"byte_end":1147935,"line_start":1013,"line_end":1013,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2686},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1148675,"byte_end":1148695,"line_start":1039,"line_end":1039,"column_start":12,"column_end":32},"name":"make_ascii_lowercase","qualname":"<char>::make_ascii_lowercase","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Converts this type to its ASCII lower case equivalent in-place.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1148581,"byte_end":1148649,"line_start":1037,"line_end":1037,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1148654,"byte_end":1148663,"line_start":1038,"line_end":1038,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2687},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1149731,"byte_end":1149750,"line_start":1073,"line_end":1073,"column_start":12,"column_end":31},"name":"is_ascii_alphabetic","qualname":"<char>::is_ascii_alphabetic","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII alphabetic character:","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1149639,"byte_end":1149705,"line_start":1071,"line_end":1071,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1149710,"byte_end":1149719,"line_start":1072,"line_end":1072,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2688},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1150752,"byte_end":1150770,"line_start":1105,"line_end":1105,"column_start":12,"column_end":30},"name":"is_ascii_uppercase","qualname":"<char>::is_ascii_uppercase","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII uppercase character:\n U+0041 'A' ..= U+005A 'Z'.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1150660,"byte_end":1150726,"line_start":1103,"line_end":1103,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1150731,"byte_end":1150740,"line_start":1104,"line_end":1104,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2689},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1151771,"byte_end":1151789,"line_start":1137,"line_end":1137,"column_start":12,"column_end":30},"name":"is_ascii_lowercase","qualname":"<char>::is_ascii_lowercase","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII lowercase character:\n U+0061 'a' ..= U+007A 'z'.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1151679,"byte_end":1151745,"line_start":1135,"line_end":1135,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1151750,"byte_end":1151759,"line_start":1136,"line_end":1136,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2690},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1152907,"byte_end":1152928,"line_start":1172,"line_end":1172,"column_start":12,"column_end":33},"name":"is_ascii_alphanumeric","qualname":"<char>::is_ascii_alphanumeric","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII alphanumeric character:","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1152815,"byte_end":1152881,"line_start":1170,"line_end":1170,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1152886,"byte_end":1152895,"line_start":1171,"line_end":1171,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2691},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1153891,"byte_end":1153905,"line_start":1204,"line_end":1204,"column_start":12,"column_end":26},"name":"is_ascii_digit","qualname":"<char>::is_ascii_digit","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII decimal digit:\n U+0030 '0' ..= U+0039 '9'.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1153799,"byte_end":1153865,"line_start":1202,"line_end":1202,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1153870,"byte_end":1153879,"line_start":1203,"line_end":1203,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2692},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1154980,"byte_end":1154997,"line_start":1239,"line_end":1239,"column_start":12,"column_end":29},"name":"is_ascii_hexdigit","qualname":"<char>::is_ascii_hexdigit","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII hexadecimal digit:","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1154888,"byte_end":1154954,"line_start":1237,"line_end":1237,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1154959,"byte_end":1154968,"line_start":1238,"line_end":1238,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2693},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1156190,"byte_end":1156210,"line_start":1275,"line_end":1275,"column_start":12,"column_end":32},"name":"is_ascii_punctuation","qualname":"<char>::is_ascii_punctuation","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII punctuation character:","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1156098,"byte_end":1156164,"line_start":1273,"line_end":1273,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1156169,"byte_end":1156178,"line_start":1274,"line_end":1274,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2694},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1157189,"byte_end":1157205,"line_start":1307,"line_end":1307,"column_start":12,"column_end":28},"name":"is_ascii_graphic","qualname":"<char>::is_ascii_graphic","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII graphic character:\n U+0021 '!' ..= U+007E '~'.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1157097,"byte_end":1157163,"line_start":1305,"line_end":1305,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1157168,"byte_end":1157177,"line_start":1306,"line_end":1306,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2695},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1159232,"byte_end":1159251,"line_start":1356,"line_end":1356,"column_start":12,"column_end":31},"name":"is_ascii_whitespace","qualname":"<char>::is_ascii_whitespace","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII whitespace character:\n U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n U+000C FORM FEED, or U+000D CARRIAGE RETURN.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1159140,"byte_end":1159206,"line_start":1354,"line_end":1354,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1159211,"byte_end":1159220,"line_start":1355,"line_end":1355,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2696},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1160363,"byte_end":1160379,"line_start":1390,"line_end":1390,"column_start":12,"column_end":28},"name":"is_ascii_control","qualname":"<char>::is_ascii_control","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII control character:\n U+0000 NUL ..= U+001F UNIT SEPARATOR, or U+007F DELETE.\n Note that most ASCII whitespace characters are control\n characters, but SPACE is not.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1160271,"byte_end":1160337,"line_start":1388,"line_end":1388,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1160342,"byte_end":1160351,"line_start":1389,"line_end":1389,"column_start":5,"column_end":14}}]},{"kind":"Const","id":{"krate":0,"index":2720},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1092356,"byte_end":1092359,"line_start":99,"line_end":99,"column_start":11,"column_end":14},"name":"MAX","qualname":"::char::MAX","value":"char","parent":null,"children":[],"decl_id":null,"docs":" The highest valid code point a `char` can have.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1092300,"byte_end":1092345,"line_start":98,"line_end":98,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":2721},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1092707,"byte_end":1092728,"line_start":107,"line_end":107,"column_start":11,"column_end":32},"name":"REPLACEMENT_CHARACTER","qualname":"::char::REPLACEMENT_CHARACTER","value":"char","parent":null,"children":[],"decl_id":null,"docs":" `U+FFFD REPLACEMENT CHARACTER` (�) is used in Unicode to represent a\n decoding error.","sig":null,"attributes":[{"value":"stable(feature = \"decode_utf16\", since = \"1.9.0\")","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1092644,"byte_end":1092696,"line_start":106,"line_end":106,"column_start":1,"column_end":53}}]},{"kind":"Struct","id":{"krate":0,"index":31932},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1093169,"byte_end":1093182,"line_start":119,"line_end":119,"column_start":12,"column_end":25},"name":"EscapeUnicode","qualname":"::char::EscapeUnicode","value":"EscapeUnicode {  }","parent":null,"children":[{"krate":0,"index":31933},{"krate":0,"index":31934},{"krate":0,"index":31935}],"decl_id":null,"docs":" Returns an iterator that yields the hexadecimal Unicode escape of a\n character, as `char`s.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1093112,"byte_end":1093157,"line_start":118,"line_end":118,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":31957},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1096843,"byte_end":1096856,"line_start":240,"line_end":240,"column_start":12,"column_end":25},"name":"EscapeDefault","qualname":"::char::EscapeDefault","value":"EscapeDefault {  }","parent":null,"children":[{"krate":0,"index":31958}],"decl_id":null,"docs":" An iterator that yields the literal escape code of a `char`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1096786,"byte_end":1096831,"line_start":239,"line_end":239,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":31979},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1100099,"byte_end":1100110,"line_start":353,"line_end":353,"column_start":12,"column_end":23},"name":"EscapeDebug","qualname":"::char::EscapeDebug","value":"","parent":null,"children":[],"decl_id":null,"docs":" An iterator that yields the literal escape code of a `char`.","sig":null,"attributes":[{"value":"stable(feature = \"char_escape_debug\", since = \"1.20.0\")","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1100005,"byte_end":1100063,"line_start":351,"line_end":351,"column_start":1,"column_end":59}}]},{"kind":"Struct","id":{"krate":0,"index":31986},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1101156,"byte_end":1101167,"line_start":384,"line_end":384,"column_start":12,"column_end":23},"name":"ToLowercase","qualname":"::char::ToLowercase","value":"","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator that yields the lowercase equivalent of a `char`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1101075,"byte_end":1101120,"line_start":382,"line_end":382,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":31993},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1102031,"byte_end":1102042,"line_start":412,"line_end":412,"column_start":12,"column_end":23},"name":"ToUppercase","qualname":"::char::ToUppercase","value":"","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator that yields the uppercase equivalent of a `char`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1101950,"byte_end":1101995,"line_start":410,"line_end":410,"column_start":1,"column_end":46}}]},{"kind":"Mod","id":{"krate":0,"index":2778},"span":{"file_name":"src/libcore/panic.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"panic","qualname":"::panic","value":"src/libcore/panic.rs","parent":null,"children":[{"krate":0,"index":2779},{"krate":0,"index":2780},{"krate":0,"index":32019},{"krate":0,"index":32024},{"krate":0,"index":2781},{"krate":0,"index":2790},{"krate":0,"index":32027},{"krate":0,"index":32032},{"krate":0,"index":2792},{"krate":0,"index":2798},{"krate":0,"index":2800}],"decl_id":null,"docs":" Panic support in the standard library.\n","sig":null,"attributes":[{"value":"unstable(feature = \"core_panic_info\",\n           reason = \"newly available in libcore\",\n           issue = \"44489\")","span":{"file_name":"src/libcore/panic.rs","byte_start":1160510,"byte_end":1160631,"line_start":3,"line_end":5,"column_start":1,"column_end":30}}]},{"kind":"Struct","id":{"krate":0,"index":32019},"span":{"file_name":"src/libcore/panic.rs","byte_start":1161321,"byte_end":1161330,"line_start":35,"line_end":35,"column_start":12,"column_end":21},"name":"PanicInfo","qualname":"::panic::PanicInfo","value":"PanicInfo {  }","parent":null,"children":[{"krate":0,"index":32021},{"krate":0,"index":32022},{"krate":0,"index":32023}],"decl_id":null,"docs":" A struct providing information about a panic.","sig":null,"attributes":[{"value":"lang = \"panic_info\"","span":{"file_name":"src/libcore/panic.rs","byte_start":1161217,"byte_end":1161239,"line_start":32,"line_end":32,"column_start":1,"column_end":23}},{"value":"stable(feature = \"panic_hooks\", since = \"1.10.0\")","span":{"file_name":"src/libcore/panic.rs","byte_start":1161240,"byte_end":1161292,"line_start":33,"line_end":33,"column_start":1,"column_end":53}}]},{"kind":"Method","id":{"krate":0,"index":2783},"span":{"file_name":"src/libcore/panic.rs","byte_start":1161722,"byte_end":1161742,"line_start":48,"line_end":48,"column_start":12,"column_end":32},"name":"internal_constructor","qualname":"<PanicInfo>::internal_constructor","value":"fn (message: Option<&'a fmt::Arguments<'a>>, location: Location<'a>) -> Self","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/panic.rs","byte_start":1161701,"byte_end":1161710,"line_start":47,"line_end":47,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2786},"span":{"file_name":"src/libcore/panic.rs","byte_start":1162020,"byte_end":1162031,"line_start":57,"line_end":57,"column_start":12,"column_end":23},"name":"set_payload","qualname":"<PanicInfo>::set_payload","value":"fn (&mut self, info: &'a (dyn Any + Send)) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/panic.rs","byte_start":1161999,"byte_end":1162008,"line_start":56,"line_end":56,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2787},"span":{"file_name":"src/libcore/panic.rs","byte_start":1162687,"byte_end":1162694,"line_start":79,"line_end":79,"column_start":12,"column_end":19},"name":"payload","qualname":"<PanicInfo>::payload","value":"fn (&self) -> &(dyn Any + Send)","parent":null,"children":[],"decl_id":null,"docs":" Returns the payload associated with the panic.","sig":null,"attributes":[{"value":"stable(feature = \"panic_hooks\", since = \"1.10.0\")","span":{"file_name":"src/libcore/panic.rs","byte_start":1162623,"byte_end":1162675,"line_start":78,"line_end":78,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":2788},"span":{"file_name":"src/libcore/panic.rs","byte_start":1163102,"byte_end":1163109,"line_start":89,"line_end":89,"column_start":12,"column_end":19},"name":"message","qualname":"<PanicInfo>::message","value":"fn (&self) -> Option<&fmt::Arguments<'_>>","parent":null,"children":[],"decl_id":null,"docs":" If the `panic!` macro from the `core` crate (not from `std`)\n was used with a formatting string and some additional arguments,\n returns that message ready to be used for example with [`fmt::write`]","sig":null,"attributes":[{"value":"unstable(feature = \"panic_info_message\", issue = \"44489\")","span":{"file_name":"src/libcore/panic.rs","byte_start":1163030,"byte_end":1163090,"line_start":88,"line_end":88,"column_start":5,"column_end":65}}]},{"kind":"Method","id":{"krate":0,"index":2789},"span":{"file_name":"src/libcore/panic.rs","byte_start":1164039,"byte_end":1164047,"line_start":118,"line_end":118,"column_start":12,"column_end":20},"name":"location","qualname":"<PanicInfo>::location","value":"fn (&self) -> Option<&Location<'_>>","parent":null,"children":[],"decl_id":null,"docs":" Returns information about the location from which the panic originated,\n if available.","sig":null,"attributes":[{"value":"stable(feature = \"panic_hooks\", since = \"1.10.0\")","span":{"file_name":"src/libcore/panic.rs","byte_start":1163975,"byte_end":1164027,"line_start":117,"line_end":117,"column_start":5,"column_end":57}}]},{"kind":"Struct","id":{"krate":0,"index":32027},"span":{"file_name":"src/libcore/panic.rs","byte_start":1165825,"byte_end":1165833,"line_start":167,"line_end":167,"column_start":12,"column_end":20},"name":"Location","qualname":"::panic::Location","value":"Location {  }","parent":null,"children":[{"krate":0,"index":32029},{"krate":0,"index":32030},{"krate":0,"index":32031}],"decl_id":null,"docs":" A struct containing information about the location of a panic.","sig":null,"attributes":[{"value":"stable(feature = \"panic_hooks\", since = \"1.10.0\")","span":{"file_name":"src/libcore/panic.rs","byte_start":1165761,"byte_end":1165813,"line_start":166,"line_end":166,"column_start":1,"column_end":53}}]},{"kind":"Method","id":{"krate":0,"index":2794},"span":{"file_name":"src/libcore/panic.rs","byte_start":1166150,"byte_end":1166170,"line_start":179,"line_end":179,"column_start":12,"column_end":32},"name":"internal_constructor","qualname":"<Location>::internal_constructor","value":"fn (file: &'a str, line: u32, col: u32) -> Self","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":2795},"span":{"file_name":"src/libcore/panic.rs","byte_start":1166861,"byte_end":1166865,"line_start":201,"line_end":201,"column_start":12,"column_end":16},"name":"file","qualname":"<Location>::file","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":" Returns the name of the source file from which the panic originated.","sig":null,"attributes":[{"value":"stable(feature = \"panic_hooks\", since = \"1.10.0\")","span":{"file_name":"src/libcore/panic.rs","byte_start":1166797,"byte_end":1166849,"line_start":200,"line_end":200,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":2796},"span":{"file_name":"src/libcore/panic.rs","byte_start":1167494,"byte_end":1167498,"line_start":223,"line_end":223,"column_start":12,"column_end":16},"name":"line","qualname":"<Location>::line","value":"fn (&self) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Returns the line number from which the panic originated.","sig":null,"attributes":[{"value":"stable(feature = \"panic_hooks\", since = \"1.10.0\")","span":{"file_name":"src/libcore/panic.rs","byte_start":1167430,"byte_end":1167482,"line_start":222,"line_end":222,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":2797},"span":{"file_name":"src/libcore/panic.rs","byte_start":1168123,"byte_end":1168129,"line_start":245,"line_end":245,"column_start":12,"column_end":18},"name":"column","qualname":"<Location>::column","value":"fn (&self) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Returns the column from which the panic originated.","sig":null,"attributes":[{"value":"stable(feature = \"panic_col\", since = \"1.25.0\")","span":{"file_name":"src/libcore/panic.rs","byte_start":1168061,"byte_end":1168111,"line_start":244,"line_end":244,"column_start":5,"column_end":55}}]},{"kind":"Trait","id":{"krate":0,"index":2800},"span":{"file_name":"src/libcore/panic.rs","byte_start":1168674,"byte_end":1168681,"line_start":262,"line_end":262,"column_start":18,"column_end":25},"name":"BoxMeUp","qualname":"::panic::BoxMeUp","value":"BoxMeUp","parent":null,"children":[{"krate":0,"index":2801},{"krate":0,"index":2802}],"decl_id":null,"docs":" An internal trait used by libstd to pass data from libstd to `panic_unwind`\n and other panic runtimes. Not intended to be stabilized any time soon, do\n not use.\n","sig":null,"attributes":[{"value":"unstable(feature = \"std_internals\", issue = \"0\")","span":{"file_name":"src/libcore/panic.rs","byte_start":1168590,"byte_end":1168641,"line_start":260,"line_end":260,"column_start":1,"column_end":52}}]},{"kind":"Method","id":{"krate":0,"index":2801},"span":{"file_name":"src/libcore/panic.rs","byte_start":1168691,"byte_end":1168700,"line_start":263,"line_end":263,"column_start":8,"column_end":17},"name":"box_me_up","qualname":"::panic::BoxMeUp::box_me_up","value":"fn (&mut self) -> *mut (dyn Any + Send)","parent":{"krate":0,"index":2800},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":2802},"span":{"file_name":"src/libcore/panic.rs","byte_start":1168745,"byte_end":1168748,"line_start":264,"line_end":264,"column_start":8,"column_end":11},"name":"get","qualname":"::panic::BoxMeUp::get","value":"fn (&mut self) -> &(dyn Any + Send)","parent":{"krate":0,"index":2800},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2803},"span":{"file_name":"src/libcore/panicking.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"panicking","qualname":"::panicking","value":"src/libcore/panicking.rs","parent":null,"children":[{"krate":0,"index":2804},{"krate":0,"index":2805},{"krate":0,"index":2808},{"krate":0,"index":2809},{"krate":0,"index":2810}],"decl_id":null,"docs":" Panic support for libcore","sig":null,"attributes":[{"value":"allow(dead_code, missing_docs)","span":{"file_name":"src/libcore/panicking.rs","byte_start":1169744,"byte_end":1169778,"line_start":23,"line_end":23,"column_start":1,"column_end":35}},{"value":"unstable(feature = \"core_panic\",\n           reason =\n               \"internal details of the implementation of the `panic!` \\\n                      and related macros\",\n           issue = \"0\")","span":{"file_name":"src/libcore/panicking.rs","byte_start":1169779,"byte_end":1169962,"line_start":24,"line_end":27,"column_start":1,"column_end":26}}]},{"kind":"Function","id":{"krate":0,"index":2808},"span":{"file_name":"src/libcore/panicking.rs","byte_start":1170225,"byte_end":1170230,"line_start":37,"line_end":37,"column_start":8,"column_end":13},"name":"panic","qualname":"::panicking::panic","value":"fn (expr_file_line_col: &(&'static str, &'static str, u32, u32)) -> !","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"cold","span":{"file_name":"src/libcore/panicking.rs","byte_start":1170022,"byte_end":1170029,"line_start":32,"line_end":32,"column_start":1,"column_end":8}},{"value":"inline(never)","span":{"file_name":"src/libcore/panicking.rs","byte_start":1170184,"byte_end":1170197,"line_start":35,"line_end":35,"column_start":49,"column_end":62}},{"value":"lang = \"panic\"","span":{"file_name":"src/libcore/panicking.rs","byte_start":1170200,"byte_end":1170217,"line_start":36,"line_end":36,"column_start":1,"column_end":18}}]},{"kind":"Function","id":{"krate":0,"index":2810},"span":{"file_name":"src/libcore/panicking.rs","byte_start":1171571,"byte_end":1171580,"line_start":68,"line_end":68,"column_start":8,"column_end":17},"name":"panic_fmt","qualname":"::panicking::panic_fmt","value":"fn (fmt: fmt::Arguments<'_>, file_line_col: &(&'static str, u32, u32)) -> !","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"cold","span":{"file_name":"src/libcore/panicking.rs","byte_start":1171435,"byte_end":1171442,"line_start":65,"line_end":65,"column_start":1,"column_end":8}},{"value":"inline(never)","span":{"file_name":"src/libcore/panicking.rs","byte_start":1171491,"byte_end":1171504,"line_start":66,"line_end":66,"column_start":49,"column_end":62}}]},{"kind":"Mod","id":{"krate":0,"index":2813},"span":{"file_name":"src/libcore/pin.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"pin","qualname":"::pin","value":"src/libcore/pin.rs","parent":null,"children":[{"krate":0,"index":2814},{"krate":0,"index":2815},{"krate":0,"index":2818},{"krate":0,"index":2822},{"krate":0,"index":32035},{"krate":0,"index":32051},{"krate":0,"index":32048},{"krate":0,"index":32044},{"krate":0,"index":32041},{"krate":0,"index":32038},{"krate":0,"index":2828},{"krate":0,"index":2833},{"krate":0,"index":2841},{"krate":0,"index":2845},{"krate":0,"index":2850},{"krate":0,"index":2854},{"krate":0,"index":2861},{"krate":0,"index":2870},{"krate":0,"index":2874},{"krate":0,"index":2877},{"krate":0,"index":2879},{"krate":0,"index":2882},{"krate":0,"index":2885},{"krate":0,"index":2888},{"krate":0,"index":2891}],"decl_id":null,"docs":" Types that pin data to its location in memory.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1191074,"byte_end":1191119,"line_start":354,"line_end":354,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":32035},"span":{"file_name":"src/libcore/pin.rs","byte_start":1192040,"byte_end":1192043,"line_start":380,"line_end":380,"column_start":12,"column_end":15},"name":"Pin","qualname":"::pin::Pin","value":"Pin {  }","parent":null,"children":[{"krate":0,"index":32037}],"decl_id":null,"docs":" A pinned pointer.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1191894,"byte_end":1191938,"line_start":375,"line_end":375,"column_start":1,"column_end":45}},{"value":"lang = \"pin\"","span":{"file_name":"src/libcore/pin.rs","byte_start":1191939,"byte_end":1191954,"line_start":376,"line_end":376,"column_start":1,"column_end":16}},{"value":"fundamental","span":{"file_name":"src/libcore/pin.rs","byte_start":1191955,"byte_end":1191969,"line_start":377,"line_end":377,"column_start":1,"column_end":15}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/pin.rs","byte_start":1191970,"byte_end":1191990,"line_start":378,"line_end":378,"column_start":1,"column_end":21}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/pin.rs","byte_start":1192029,"byte_end":1192066,"line_start":380,"line_end":382,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":2843},"span":{"file_name":"src/libcore/pin.rs","byte_start":1193506,"byte_end":1193509,"line_start":437,"line_end":437,"column_start":12,"column_end":15},"name":"new","qualname":"<Pin<P>>::new","value":"fn (pointer: P) -> Pin<P>","parent":null,"children":[],"decl_id":null,"docs":" Construct a new `Pin<P>` around a pointer to some data of a type that\n implements [`Unpin`].","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1193428,"byte_end":1193472,"line_start":435,"line_end":435,"column_start":5,"column_end":49}},{"value":"inline(always)","span":{"file_name":"src/libcore/pin.rs","byte_start":1193477,"byte_end":1193494,"line_start":436,"line_end":436,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":2844},"span":{"file_name":"src/libcore/pin.rs","byte_start":1194061,"byte_end":1194071,"line_start":451,"line_end":451,"column_start":12,"column_end":22},"name":"into_inner","qualname":"<Pin<P>>::into_inner","value":"fn (pin: Pin<P>) -> P","parent":null,"children":[],"decl_id":null,"docs":" Unwraps this `Pin<P>` returning the underlying pointer.","sig":null,"attributes":[{"value":"unstable(feature = \"pin_into_inner\", issue = \"60245\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1193971,"byte_end":1194027,"line_start":449,"line_end":449,"column_start":5,"column_end":61}},{"value":"inline(always)","span":{"file_name":"src/libcore/pin.rs","byte_start":1194032,"byte_end":1194049,"line_start":450,"line_end":450,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":2847},"span":{"file_name":"src/libcore/pin.rs","byte_start":1197407,"byte_end":1197420,"line_start":523,"line_end":523,"column_start":19,"column_end":32},"name":"new_unchecked","qualname":"<Pin<P>>::new_unchecked","value":"fn (pointer: P) -> Pin<P>","parent":null,"children":[],"decl_id":null,"docs":" Construct a new `Pin<P>` around a reference to some data of a type that\n may or may not implement `Unpin`.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1197322,"byte_end":1197366,"line_start":521,"line_end":521,"column_start":5,"column_end":49}},{"value":"inline(always)","span":{"file_name":"src/libcore/pin.rs","byte_start":1197371,"byte_end":1197388,"line_start":522,"line_end":522,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":2848},"span":{"file_name":"src/libcore/pin.rs","byte_start":1197982,"byte_end":1197988,"line_start":536,"line_end":536,"column_start":12,"column_end":18},"name":"as_ref","qualname":"<Pin<P>>::as_ref","value":"fn (self: &Pin<P>) -> Pin<&P::Target>","parent":null,"children":[],"decl_id":null,"docs":" Gets a pinned shared reference from this pinned pointer.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1197904,"byte_end":1197948,"line_start":534,"line_end":534,"column_start":5,"column_end":49}},{"value":"inline(always)","span":{"file_name":"src/libcore/pin.rs","byte_start":1197953,"byte_end":1197970,"line_start":535,"line_end":535,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":2849},"span":{"file_name":"src/libcore/pin.rs","byte_start":1198926,"byte_end":1198946,"line_start":558,"line_end":558,"column_start":19,"column_end":39},"name":"into_inner_unchecked","qualname":"<Pin<P>>::into_inner_unchecked","value":"fn (pin: Pin<P>) -> P","parent":null,"children":[],"decl_id":null,"docs":" Unwraps this `Pin<P>` returning the underlying pointer.","sig":null,"attributes":[{"value":"unstable(feature = \"pin_into_inner\", issue = \"60245\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1198829,"byte_end":1198885,"line_start":556,"line_end":556,"column_start":5,"column_end":61}},{"value":"inline(always)","span":{"file_name":"src/libcore/pin.rs","byte_start":1198890,"byte_end":1198907,"line_start":557,"line_end":557,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":2852},"span":{"file_name":"src/libcore/pin.rs","byte_start":1199541,"byte_end":1199547,"line_start":573,"line_end":573,"column_start":12,"column_end":18},"name":"as_mut","qualname":"<Pin<P>>::as_mut","value":"fn (self: &mut Pin<P>) -> Pin<&mut P::Target>","parent":null,"children":[],"decl_id":null,"docs":" Gets a pinned mutable reference from this pinned pointer.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1199463,"byte_end":1199507,"line_start":571,"line_end":571,"column_start":5,"column_end":49}},{"value":"inline(always)","span":{"file_name":"src/libcore/pin.rs","byte_start":1199512,"byte_end":1199529,"line_start":572,"line_end":572,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":2853},"span":{"file_name":"src/libcore/pin.rs","byte_start":1199968,"byte_end":1199971,"line_start":583,"line_end":583,"column_start":12,"column_end":15},"name":"set","qualname":"<Pin<P>>::set","value":"fn (self: &mut Pin<P>, value: P::Target) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Assigns a new value to the memory behind the pinned reference.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1199890,"byte_end":1199934,"line_start":581,"line_end":581,"column_start":5,"column_end":49}},{"value":"inline(always)","span":{"file_name":"src/libcore/pin.rs","byte_start":1199939,"byte_end":1199956,"line_start":582,"line_end":582,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":2857},"span":{"file_name":"src/libcore/pin.rs","byte_start":1201004,"byte_end":1201017,"line_start":608,"line_end":608,"column_start":19,"column_end":32},"name":"map_unchecked","qualname":"<Pin<&'a T>>::map_unchecked","value":"fn <U, F> (self: Pin<&'a T>, func: F) -> Pin<&'a U>","parent":null,"children":[],"decl_id":null,"docs":" Constructs a new pin by mapping the interior value.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1200941,"byte_end":1200985,"line_start":607,"line_end":607,"column_start":5,"column_end":49}}]},{"kind":"Method","id":{"krate":0,"index":2860},"span":{"file_name":"src/libcore/pin.rs","byte_start":1202357,"byte_end":1202364,"line_start":635,"line_end":635,"column_start":12,"column_end":19},"name":"get_ref","qualname":"<Pin<&'a T>>::get_ref","value":"fn (self: Pin<&'a T>) -> &'a T","parent":null,"children":[],"decl_id":null,"docs":" Gets a shared reference out of a pin.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1202279,"byte_end":1202323,"line_start":633,"line_end":633,"column_start":5,"column_end":49}},{"value":"inline(always)","span":{"file_name":"src/libcore/pin.rs","byte_start":1202328,"byte_end":1202345,"line_start":634,"line_end":634,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":2864},"span":{"file_name":"src/libcore/pin.rs","byte_start":1202620,"byte_end":1202628,"line_start":644,"line_end":644,"column_start":12,"column_end":20},"name":"into_ref","qualname":"<Pin<&'a mut T>>::into_ref","value":"fn (self: Pin<&'a mut T>) -> Pin<&'a T>","parent":null,"children":[],"decl_id":null,"docs":" Converts this `Pin<&mut T>` into a `Pin<&T>` with the same lifetime.\n","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1202542,"byte_end":1202586,"line_start":642,"line_end":642,"column_start":5,"column_end":49}},{"value":"inline(always)","span":{"file_name":"src/libcore/pin.rs","byte_start":1202591,"byte_end":1202608,"line_start":643,"line_end":643,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":2865},"span":{"file_name":"src/libcore/pin.rs","byte_start":1203315,"byte_end":1203322,"line_start":659,"line_end":659,"column_start":12,"column_end":19},"name":"get_mut","qualname":"<Pin<&'a mut T>>::get_mut","value":"fn (self: Pin<&'a mut T>) -> &'a mut T","parent":null,"children":[],"decl_id":null,"docs":" Gets a mutable reference to the data inside of this `Pin`.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1203237,"byte_end":1203281,"line_start":657,"line_end":657,"column_start":5,"column_end":49}},{"value":"inline(always)","span":{"file_name":"src/libcore/pin.rs","byte_start":1203286,"byte_end":1203303,"line_start":658,"line_end":658,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":2866},"span":{"file_name":"src/libcore/pin.rs","byte_start":1203931,"byte_end":1203948,"line_start":677,"line_end":677,"column_start":19,"column_end":36},"name":"get_unchecked_mut","qualname":"<Pin<&'a mut T>>::get_unchecked_mut","value":"fn (self: Pin<&'a mut T>) -> &'a mut T","parent":null,"children":[],"decl_id":null,"docs":" Gets a mutable reference to the data inside of this `Pin`.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1203846,"byte_end":1203890,"line_start":675,"line_end":675,"column_start":5,"column_end":49}},{"value":"inline(always)","span":{"file_name":"src/libcore/pin.rs","byte_start":1203895,"byte_end":1203912,"line_start":676,"line_end":676,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":2867},"span":{"file_name":"src/libcore/pin.rs","byte_start":1204891,"byte_end":1204908,"line_start":697,"line_end":697,"column_start":19,"column_end":36},"name":"map_unchecked_mut","qualname":"<Pin<&'a mut T>>::map_unchecked_mut","value":"fn <U, F> (self: Pin<&'a mut T>, func: F) -> Pin<&'a mut U>","parent":null,"children":[],"decl_id":null,"docs":" Construct a new pin by mapping the interior value.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1204828,"byte_end":1204872,"line_start":696,"line_end":696,"column_start":5,"column_end":49}}]},{"kind":"Mod","id":{"krate":0,"index":2895},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"iter","qualname":"::iter","value":"src/libcore/iter/mod.rs","parent":null,"children":[{"krate":0,"index":2896},{"krate":0,"index":2897},{"krate":0,"index":2898},{"krate":0,"index":2899},{"krate":0,"index":2902},{"krate":0,"index":2905},{"krate":0,"index":2908},{"krate":0,"index":2911},{"krate":0,"index":2914},{"krate":0,"index":2917},{"krate":0,"index":2920},{"krate":0,"index":2925},{"krate":0,"index":2929},{"krate":0,"index":2930},{"krate":0,"index":2931},{"krate":0,"index":2940},{"krate":0,"index":2948},{"krate":0,"index":2951},{"krate":0,"index":2952},{"krate":0,"index":2953},{"krate":0,"index":2954},{"krate":0,"index":2955},{"krate":0,"index":2956},{"krate":0,"index":3033},{"krate":0,"index":3168},{"krate":0,"index":3510},{"krate":0,"index":32833},{"krate":0,"index":32842},{"krate":0,"index":4410},{"krate":0,"index":4418},{"krate":0,"index":4422}],"decl_id":null,"docs":" Composable external iteration.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1217195,"byte_end":1217241,"line_start":312,"line_end":312,"column_start":1,"column_end":47}}]},{"kind":"Trait","id":{"krate":0,"index":2968},"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1221032,"byte_end":1221036,"line_start":15,"line_end":15,"column_start":11,"column_end":15},"name":"Step","qualname":"::iter::range::Step","value":"Step: Clone + PartialOrd + Sized","parent":null,"children":[{"krate":0,"index":2969},{"krate":0,"index":2970},{"krate":0,"index":2971},{"krate":0,"index":2972},{"krate":0,"index":2973},{"krate":0,"index":2974},{"krate":0,"index":2975}],"decl_id":null,"docs":" Objects that can be stepped over in both directions.","sig":null,"attributes":[{"value":"unstable(feature = \"step_trait\",\n           reason = \"likely to be replaced by finer-grained traits\",\n           issue = \"42168\")","span":{"file_name":"src/libcore/iter/range.rs","byte_start":1220889,"byte_end":1221021,"line_start":12,"line_end":14,"column_start":1,"column_end":29}}]},{"kind":"Method","id":{"krate":0,"index":2969},"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1221310,"byte_end":1221323,"line_start":21,"line_end":21,"column_start":8,"column_end":21},"name":"steps_between","qualname":"::iter::range::Step::steps_between","value":"fn (start: &Self, end: &Self) -> Option<usize>","parent":{"krate":0,"index":2968},"children":[],"decl_id":null,"docs":" Returns the number of steps between two step objects. The count is\n inclusive of `start` and exclusive of `end`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":2970},"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1221431,"byte_end":1221442,"line_start":24,"line_end":24,"column_start":8,"column_end":19},"name":"replace_one","qualname":"::iter::range::Step::replace_one","value":"fn (&mut self) -> Self","parent":{"krate":0,"index":2968},"children":[],"decl_id":null,"docs":" Replaces this step with `1`, returning itself.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":2971},"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1221526,"byte_end":1221538,"line_start":27,"line_end":27,"column_start":8,"column_end":20},"name":"replace_zero","qualname":"::iter::range::Step::replace_zero","value":"fn (&mut self) -> Self","parent":{"krate":0,"index":2968},"children":[],"decl_id":null,"docs":" Replaces this step with `0`, returning itself.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":2972},"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1221620,"byte_end":1221627,"line_start":30,"line_end":30,"column_start":8,"column_end":15},"name":"add_one","qualname":"::iter::range::Step::add_one","value":"fn (&self) -> Self","parent":{"krate":0,"index":2968},"children":[],"decl_id":null,"docs":" Adds one to this step, returning the result.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":2973},"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1221710,"byte_end":1221717,"line_start":33,"line_end":33,"column_start":8,"column_end":15},"name":"sub_one","qualname":"::iter::range::Step::sub_one","value":"fn (&self) -> Self","parent":{"krate":0,"index":2968},"children":[],"decl_id":null,"docs":" Subtracts one to this step, returning the result.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":2974},"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1221796,"byte_end":1221805,"line_start":36,"line_end":36,"column_start":8,"column_end":17},"name":"add_usize","qualname":"::iter::range::Step::add_usize","value":"fn (&self, n: usize) -> Option<Self>","parent":{"krate":0,"index":2968},"children":[],"decl_id":null,"docs":" Adds a `usize`, returning `None` on overflow.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":2975},"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1221908,"byte_end":1221917,"line_start":39,"line_end":39,"column_start":8,"column_end":17},"name":"sub_usize","qualname":"::iter::range::Step::sub_usize","value":"fn (&self, n: usize) -> Option<Self>","parent":{"krate":0,"index":2968},"children":[],"decl_id":null,"docs":" Subtracts a `usize`, returning `None` on underflow.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":32185},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1235946,"byte_end":1235952,"line_start":14,"line_end":14,"column_start":12,"column_end":18},"name":"Repeat","qualname":"::iter::sources::Repeat","value":"Repeat {  }","parent":null,"children":[{"krate":0,"index":32187}],"decl_id":null,"docs":" An iterator that repeats an element endlessly.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1235889,"byte_end":1235934,"line_start":13,"line_end":13,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":3052},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1238134,"byte_end":1238140,"line_start":93,"line_end":93,"column_start":8,"column_end":14},"name":"repeat","qualname":"::iter::sources::repeat","value":"fn <T> (elt: T) -> Repeat<T>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new iterator that endlessly repeats a single element.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1238071,"byte_end":1238080,"line_start":91,"line_end":91,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1238081,"byte_end":1238126,"line_start":92,"line_end":92,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":32194},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1238568,"byte_end":1238578,"line_start":106,"line_end":106,"column_start":12,"column_end":22},"name":"RepeatWith","qualname":"::iter::sources::RepeatWith","value":"RepeatWith {  }","parent":null,"children":[{"krate":0,"index":32196}],"decl_id":null,"docs":" An iterator that repeats elements of type `A` endlessly by\n applying the provided closure `F: FnMut() -> A`.","sig":null,"attributes":[{"value":"stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1238495,"byte_end":1238556,"line_start":105,"line_end":105,"column_start":1,"column_end":62}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1238557,"byte_end":1238601,"line_start":106,"line_end":108,"column_start":1,"column_end":2}}]},{"kind":"Function","id":{"krate":0,"index":3066},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1241160,"byte_end":1241171,"line_start":189,"line_end":189,"column_start":8,"column_end":19},"name":"repeat_with","qualname":"::iter::sources::repeat_with","value":"fn <A, F> (repeater: F) -> RepeatWith<F>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new iterator that repeats elements of type `A` endlessly by\n applying the provided closure, the repeater, `F: FnMut() -> A`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1241081,"byte_end":1241090,"line_start":187,"line_end":187,"column_start":1,"column_end":10}},{"value":"stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1241091,"byte_end":1241152,"line_start":188,"line_end":188,"column_start":1,"column_end":62}}]},{"kind":"Struct","id":{"krate":0,"index":3069},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1241479,"byte_end":1241484,"line_start":199,"line_end":199,"column_start":12,"column_end":17},"name":"Empty","qualname":"::iter::sources::Empty","value":"","parent":null,"children":[],"decl_id":null,"docs":" An iterator that yields nothing.","sig":null,"attributes":[{"value":"stable(feature = \"iter_empty\", since = \"1.2.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1241417,"byte_end":1241467,"line_start":198,"line_end":198,"column_start":1,"column_end":51}}]},{"kind":"Function","id":{"krate":0,"index":3097},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1243249,"byte_end":1243254,"line_start":274,"line_end":274,"column_start":14,"column_end":19},"name":"empty","qualname":"::iter::sources::empty","value":"fn <T> () -> Empty<T>","parent":null,"children":[],"decl_id":null,"docs":" Creates an iterator that yields nothing.","sig":null,"attributes":[{"value":"stable(feature = \"iter_empty\", since = \"1.2.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1243185,"byte_end":1243235,"line_start":273,"line_end":273,"column_start":1,"column_end":51}}]},{"kind":"Struct","id":{"krate":0,"index":32205},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1243568,"byte_end":1243572,"line_start":285,"line_end":285,"column_start":12,"column_end":16},"name":"Once","qualname":"::iter::sources::Once","value":"Once {  }","parent":null,"children":[{"krate":0,"index":32207}],"decl_id":null,"docs":" An iterator that yields an element exactly once.","sig":null,"attributes":[{"value":"stable(feature = \"iter_once\", since = \"1.2.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1243507,"byte_end":1243556,"line_start":284,"line_end":284,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":3114},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1245939,"byte_end":1245943,"line_start":374,"line_end":374,"column_start":8,"column_end":12},"name":"once","qualname":"::iter::sources::once","value":"fn <T> (value: T) -> Once<T>","parent":null,"children":[],"decl_id":null,"docs":" Creates an iterator that yields an element exactly once.","sig":null,"attributes":[{"value":"stable(feature = \"iter_once\", since = \"1.2.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1245882,"byte_end":1245931,"line_start":373,"line_end":373,"column_start":1,"column_end":50}}]},{"kind":"Struct","id":{"krate":0,"index":32214},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1246370,"byte_end":1246378,"line_start":387,"line_end":387,"column_start":12,"column_end":20},"name":"OnceWith","qualname":"::iter::sources::OnceWith","value":"OnceWith {  }","parent":null,"children":[{"krate":0,"index":32216}],"decl_id":null,"docs":" An iterator that yields a single element of type `A` by\n applying the provided closure `F: FnOnce() -> A`.","sig":null,"attributes":[{"value":"unstable(feature = \"iter_once_with\", issue = \"57581\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1246302,"byte_end":1246358,"line_start":386,"line_end":386,"column_start":1,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1246359,"byte_end":1246405,"line_start":387,"line_end":389,"column_start":1,"column_end":2}}]},{"kind":"Function","id":{"krate":0,"index":3137},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1249177,"byte_end":1249186,"line_start":487,"line_end":487,"column_start":8,"column_end":17},"name":"once_with","qualname":"::iter::sources::once_with","value":"fn <A, F> (gen: F) -> OnceWith<F>","parent":null,"children":[],"decl_id":null,"docs":" Creates an iterator that lazily generates a value exactly once by invoking\n the provided closure.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1249103,"byte_end":1249112,"line_start":485,"line_end":485,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"iter_once_with\", issue = \"57581\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1249113,"byte_end":1249169,"line_start":486,"line_end":486,"column_start":1,"column_end":57}}]},{"kind":"Function","id":{"krate":0,"index":3140},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1250741,"byte_end":1250748,"line_start":531,"line_end":531,"column_start":8,"column_end":15},"name":"from_fn","qualname":"::iter::sources::from_fn","value":"fn <T, F> (f: F) -> FromFn<F>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new iterator where each iteration calls the provided closure\n `F: FnMut() -> Option<T>`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1250670,"byte_end":1250679,"line_start":529,"line_end":529,"column_start":1,"column_end":10}},{"value":"stable(feature = \"iter_from_fn\", since = \"1.34.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1250680,"byte_end":1250733,"line_start":530,"line_end":530,"column_start":1,"column_end":54}}]},{"kind":"Struct","id":{"krate":0,"index":32225},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1251147,"byte_end":1251153,"line_start":545,"line_end":545,"column_start":12,"column_end":18},"name":"FromFn","qualname":"::iter::sources::FromFn","value":"","parent":null,"children":[],"decl_id":null,"docs":" An iterator where each iteration calls the provided closure `F: FnMut() -> Option<T>`.","sig":null,"attributes":[{"value":"stable(feature = \"iter_from_fn\", since = \"1.34.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1251082,"byte_end":1251135,"line_start":544,"line_end":544,"column_start":1,"column_end":54}}]},{"kind":"Function","id":{"krate":0,"index":3151},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1252118,"byte_end":1252128,"line_start":578,"line_end":578,"column_start":8,"column_end":18},"name":"successors","qualname":"::iter::sources::successors","value":"fn <T, F> (first: Option<T>, succ: F) -> Successors<T, F>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new iterator where each successive item is computed based on the preceding one.","sig":null,"attributes":[{"value":"stable(feature = \"iter_successors\", since = \"1.34.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1252054,"byte_end":1252110,"line_start":577,"line_end":577,"column_start":1,"column_end":57}}]},{"kind":"Struct","id":{"krate":0,"index":32232},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1252822,"byte_end":1252832,"line_start":598,"line_end":598,"column_start":12,"column_end":22},"name":"Successors","qualname":"::iter::sources::Successors","value":"Successors {  }","parent":null,"children":[{"krate":0,"index":32235},{"krate":0,"index":32236}],"decl_id":null,"docs":" An new iterator where each successive item is computed based on the preceding one.","sig":null,"attributes":[{"value":"stable(feature = \"iter_successors\", since = \"1.34.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1252754,"byte_end":1252810,"line_start":597,"line_end":597,"column_start":1,"column_end":57}}]},{"kind":"Trait","id":{"krate":0,"index":3202},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1258360,"byte_end":1258368,"line_start":91,"line_end":91,"column_start":11,"column_end":19},"name":"Iterator","qualname":"::iter::traits::iterator::Iterator","value":"Iterator","parent":null,"children":[{"krate":0,"index":3203},{"krate":0,"index":3204},{"krate":0,"index":3205},{"krate":0,"index":3206},{"krate":0,"index":3208},{"krate":0,"index":3209},{"krate":0,"index":3210},{"krate":0,"index":3211},{"krate":0,"index":3213},{"krate":0,"index":3215},{"krate":0,"index":3218},{"krate":0,"index":3221},{"krate":0,"index":3223},{"krate":0,"index":3226},{"krate":0,"index":3227},{"krate":0,"index":3228},{"krate":0,"index":3230},{"krate":0,"index":3232},{"krate":0,"index":3233},{"krate":0,"index":3234},{"krate":0,"index":3238},{"krate":0,"index":3241},{"krate":0,"index":3242},{"krate":0,"index":3243},{"krate":0,"index":3245},{"krate":0,"index":3246},{"krate":0,"index":3248},{"krate":0,"index":3252},{"krate":0,"index":3256},{"krate":0,"index":3260},{"krate":0,"index":3264},{"krate":0,"index":3267},{"krate":0,"index":3270},{"krate":0,"index":3273},{"krate":0,"index":3277},{"krate":0,"index":3280},{"krate":0,"index":3283},{"krate":0,"index":3284},{"krate":0,"index":3285},{"krate":0,"index":3291},{"krate":0,"index":3294},{"krate":0,"index":3300},{"krate":0,"index":3303},{"krate":0,"index":3304},{"krate":0,"index":3310},{"krate":0,"index":3313},{"krate":0,"index":3316},{"krate":0,"index":3317},{"krate":0,"index":3319},{"krate":0,"index":3321},{"krate":0,"index":3323},{"krate":0,"index":3325},{"krate":0,"index":3327},{"krate":0,"index":3329},{"krate":0,"index":3331},{"krate":0,"index":3333},{"krate":0,"index":3335},{"krate":0,"index":3337},{"krate":0,"index":3339},{"krate":0,"index":3342}],"decl_id":null,"docs":" An interface for dealing with iterators.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1255042,"byte_end":1255087,"line_start":20,"line_end":20,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(on(_Self = \"[std::ops::Range<Idx>; 1]\",\n                            label =\n                                \"if you meant to iterate between two values, remove the square brackets\",\n                            note =\n                                \"`[start..end]` is an array of one `Range`; you might have meant to have a `Range` \\\n              without the brackets: `start..end`\"),\n                         on(_Self = \"[std::ops::RangeFrom<Idx>; 1]\",\n                            label =\n                                \"if you meant to iterate from a value onwards, remove the square brackets\",\n                            note =\n                                \"`[start..]` is an array of one `RangeFrom`; you might have meant to have a \\\n              `RangeFrom` without the brackets: `start..`, keeping in mind that iterating over an \\\n              unbounded iterator will run forever unless you `break` or `return` from within the \\\n              loop\"),\n                         on(_Self = \"[std::ops::RangeTo<Idx>; 1]\",\n                            label =\n                                \"if you meant to iterate until a value, remove the square brackets and add a \\\n               starting value\",\n                            note =\n                                \"`[..end]` is an array of one `RangeTo`; you might have meant to have a bounded \\\n              `Range` without the brackets: `0..end`\"),\n                         on(_Self = \"[std::ops::RangeInclusive<Idx>; 1]\",\n                            label =\n                                \"if you meant to iterate between two values, remove the square brackets\",\n                            note =\n                                \"`[start..=end]` is an array of one `RangeInclusive`; you might have meant to have a \\\n              `RangeInclusive` without the brackets: `start..=end`\"),\n                         on(_Self = \"[std::ops::RangeToInclusive<Idx>; 1]\",\n                            label =\n                                \"if you meant to iterate until a value (including it), remove the square brackets \\\n               and add a starting value\",\n                            note =\n                                \"`[..=end]` is an array of one `RangeToInclusive`; you might have meant to have a \\\n              bounded `RangeInclusive` without the brackets: `0..=end`\"),\n                         on(_Self = \"std::ops::RangeTo<Idx>\",\n                            label =\n                                \"if you meant to iterate until a value, add a starting value\",\n                            note =\n                                \"`..end` is a `RangeTo`, which cannot be iterated on; you might have meant to have a \\\n              bounded `Range`: `0..end`\"),\n                         on(_Self = \"std::ops::RangeToInclusive<Idx>\",\n                            label =\n                                \"if you meant to iterate until a value (including it), add a starting value\",\n                            note =\n                                \"`..=end` is a `RangeToInclusive`, which cannot be iterated on; you might have meant \\\n              to have a bounded `RangeInclusive`: `0..=end`\"),\n                         on(_Self = \"&str\",\n                            label =\n                                \"`{Self}` is not an iterator; try calling `.chars()` or `.bytes()`\"),\n                         on(_Self = \"std::string::String\",\n                            label =\n                                \"`{Self}` is not an iterator; try calling `.chars()` or `.bytes()`\"),\n                         on(_Self = \"[]\",\n                            label =\n                                \"borrow the array with `&` or call `.iter()` on it to iterate over it\",\n                            note =\n                                \"arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\"),\n                         on(_Self = \"{integral}\",\n                            note =\n                                \"if you want to iterate between `start` until a value `end`, use the exclusive range \\\n              syntax `start..end` or the inclusive range syntax `start..=end`\"),\n                         label = \"`{Self}` is not an iterator\",\n                         message = \"`{Self}` is not an iterator\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1255088,"byte_end":1258265,"line_start":21,"line_end":88,"column_start":1,"column_end":3}},{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1258284,"byte_end":1258349,"line_start":90,"line_end":90,"column_start":1,"column_end":66}}]},{"kind":"Type","id":{"krate":0,"index":3203},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1258484,"byte_end":1258488,"line_start":94,"line_end":94,"column_start":10,"column_end":14},"name":"Item","qualname":"::iter::traits::iterator::Iterator::Item","value":"type Item;","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" The type of the elements being iterated over.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1258429,"byte_end":1258474,"line_start":93,"line_end":93,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3204},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1259612,"byte_end":1259616,"line_start":128,"line_end":128,"column_start":8,"column_end":12},"name":"next","qualname":"::iter::traits::iterator::Iterator::next","value":"fn (&mut self) -> Option<Self::Item>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Advances the iterator and returns the next value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1259559,"byte_end":1259604,"line_start":127,"line_end":127,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3205},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1262294,"byte_end":1262303,"line_start":200,"line_end":200,"column_start":8,"column_end":17},"name":"size_hint","qualname":"::iter::traits::iterator::Iterator::size_hint","value":"fn (&self) -> (usize, Option<usize>)","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Returns the bounds on the remaining length of the iterator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1262227,"byte_end":1262236,"line_start":198,"line_end":198,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1262241,"byte_end":1262286,"line_start":199,"line_end":199,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3206},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1263577,"byte_end":1263582,"line_start":239,"line_end":239,"column_start":8,"column_end":13},"name":"count","qualname":"::iter::traits::iterator::Iterator::count","value":"fn (self) -> usize","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Consumes the iterator, counting the number of iterations and returning it.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1263473,"byte_end":1263482,"line_start":236,"line_end":236,"column_start":5,"column_end":14}},{"value":"rustc_inherit_overflow_checks","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1263487,"byte_end":1263519,"line_start":237,"line_end":237,"column_start":5,"column_end":37}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1263524,"byte_end":1263569,"line_start":238,"line_end":238,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3208},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1264376,"byte_end":1264380,"line_start":265,"line_end":265,"column_start":8,"column_end":12},"name":"last","qualname":"::iter::traits::iterator::Iterator::last","value":"fn (self) -> Option<Self::Item>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Consumes the iterator, returning the last element.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1264309,"byte_end":1264318,"line_start":263,"line_end":263,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1264323,"byte_end":1264368,"line_start":264,"line_end":264,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3209},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1265888,"byte_end":1265891,"line_start":314,"line_end":314,"column_start":8,"column_end":11},"name":"nth","qualname":"::iter::traits::iterator::Iterator::nth","value":"fn (&mut self, mut n: usize) -> Option<Self::Item>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Returns the `n`th element of the iterator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1265821,"byte_end":1265830,"line_start":312,"line_end":312,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1265835,"byte_end":1265880,"line_start":313,"line_end":313,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3210},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1267660,"byte_end":1267667,"line_start":368,"line_end":368,"column_start":8,"column_end":15},"name":"step_by","qualname":"::iter::traits::iterator::Iterator::step_by","value":"fn (self, step: usize) -> StepBy<Self>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Creates an iterator starting at the same point, but stepping by\n the given amount at each iteration.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1267581,"byte_end":1267590,"line_start":366,"line_end":366,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iterator_step_by\", since = \"1.28.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1267595,"byte_end":1267652,"line_start":367,"line_end":367,"column_start":5,"column_end":62}}]},{"kind":"Method","id":{"krate":0,"index":3211},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1269519,"byte_end":1269524,"line_start":423,"line_end":423,"column_start":8,"column_end":13},"name":"chain","qualname":"::iter::traits::iterator::Iterator::chain","value":"fn <U> (self, other: U) -> Chain<Self, U::IntoIter>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Takes two iterators and creates a new iterator over both in sequence.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1269452,"byte_end":1269461,"line_start":421,"line_end":421,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1269466,"byte_end":1269511,"line_start":422,"line_end":422,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3213},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1272406,"byte_end":1272409,"line_start":501,"line_end":501,"column_start":8,"column_end":11},"name":"zip","qualname":"::iter::traits::iterator::Iterator::zip","value":"fn <U> (self, other: U) -> Zip<Self, U::IntoIter>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" 'Zips up' two iterators into a single iterator of pairs.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1272339,"byte_end":1272348,"line_start":499,"line_end":499,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1272353,"byte_end":1272398,"line_start":500,"line_end":500,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3215},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1274471,"byte_end":1274474,"line_start":558,"line_end":558,"column_start":8,"column_end":11},"name":"map","qualname":"::iter::traits::iterator::Iterator::map","value":"fn <B, F> (self, f: F) -> Map<Self, F>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Takes a closure and creates an iterator which calls that closure on each\n element.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1274404,"byte_end":1274413,"line_start":556,"line_end":556,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1274418,"byte_end":1274463,"line_start":557,"line_end":557,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3218},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1276026,"byte_end":1276034,"line_start":601,"line_end":601,"column_start":8,"column_end":16},"name":"for_each","qualname":"::iter::traits::iterator::Iterator::for_each","value":"fn <F> (self, mut f: F) -> ()","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Calls a closure on each element of an iterator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1275946,"byte_end":1275955,"line_start":599,"line_end":599,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iterator_for_each\", since = \"1.21.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1275960,"byte_end":1276018,"line_start":600,"line_end":600,"column_start":5,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":3221},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1278071,"byte_end":1278077,"line_start":669,"line_end":669,"column_start":8,"column_end":14},"name":"filter","qualname":"::iter::traits::iterator::Iterator::filter","value":"fn <P> (self, predicate: P) -> Filter<Self, P>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Creates an iterator which uses a closure to determine if an element\n should be yielded.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1278004,"byte_end":1278013,"line_start":667,"line_end":667,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1278018,"byte_end":1278063,"line_start":668,"line_end":668,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3223},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1280226,"byte_end":1280236,"line_start":726,"line_end":726,"column_start":8,"column_end":18},"name":"filter_map","qualname":"::iter::traits::iterator::Iterator::filter_map","value":"fn <B, F> (self, f: F) -> FilterMap<Self, F>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Creates an iterator that both filters and maps.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1280159,"byte_end":1280168,"line_start":724,"line_end":724,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1280173,"byte_end":1280218,"line_start":725,"line_end":725,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3226},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1281802,"byte_end":1281811,"line_start":772,"line_end":772,"column_start":8,"column_end":17},"name":"enumerate","qualname":"::iter::traits::iterator::Iterator::enumerate","value":"fn (self) -> Enumerate<Self>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Creates an iterator which gives the current iteration count as well as\n the next value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1281735,"byte_end":1281744,"line_start":770,"line_end":770,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1281749,"byte_end":1281794,"line_start":771,"line_end":771,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3227},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1283377,"byte_end":1283385,"line_start":818,"line_end":818,"column_start":8,"column_end":16},"name":"peekable","qualname":"::iter::traits::iterator::Iterator::peekable","value":"fn (self) -> Peekable<Self>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Creates an iterator which can use `peek` to look at the next element of\n the iterator without consuming it.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1283310,"byte_end":1283319,"line_start":816,"line_end":816,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1283324,"byte_end":1283369,"line_start":817,"line_end":817,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3228},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1285286,"byte_end":1285296,"line_start":879,"line_end":879,"column_start":8,"column_end":18},"name":"skip_while","qualname":"::iter::traits::iterator::Iterator::skip_while","value":"fn <P> (self, predicate: P) -> SkipWhile<Self, P>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Creates an iterator that [`skip`]s elements based on a predicate.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1285219,"byte_end":1285228,"line_start":877,"line_end":877,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1285233,"byte_end":1285278,"line_start":878,"line_end":878,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3230},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1287865,"byte_end":1287875,"line_start":958,"line_end":958,"column_start":8,"column_end":18},"name":"take_while","qualname":"::iter::traits::iterator::Iterator::take_while","value":"fn <P> (self, predicate: P) -> TakeWhile<Self, P>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Creates an iterator that yields elements based on a predicate.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1287798,"byte_end":1287807,"line_start":956,"line_end":956,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1287812,"byte_end":1287857,"line_start":957,"line_end":957,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3232},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1288593,"byte_end":1288597,"line_start":983,"line_end":983,"column_start":8,"column_end":12},"name":"skip","qualname":"::iter::traits::iterator::Iterator::skip","value":"fn (self, n: usize) -> Skip<Self>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Creates an iterator that skips the first `n` elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1288526,"byte_end":1288535,"line_start":981,"line_end":981,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1288540,"byte_end":1288585,"line_start":982,"line_end":982,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3233},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1289442,"byte_end":1289446,"line_start":1015,"line_end":1015,"column_start":8,"column_end":12},"name":"take","qualname":"::iter::traits::iterator::Iterator::take","value":"fn (self, n: usize) -> Take<Self>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Creates an iterator that yields its first `n` elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1289375,"byte_end":1289384,"line_start":1013,"line_end":1013,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1289389,"byte_end":1289434,"line_start":1014,"line_end":1014,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3234},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1290900,"byte_end":1290904,"line_start":1058,"line_end":1058,"column_start":8,"column_end":12},"name":"scan","qualname":"::iter::traits::iterator::Iterator::scan","value":"fn <St, B, F> (self, initial_state: St, f: F) -> Scan<Self, St, F>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" An iterator adaptor similar to [`fold`] that holds internal state and\n produces a new iterator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1290833,"byte_end":1290842,"line_start":1056,"line_end":1056,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1290847,"byte_end":1290892,"line_start":1057,"line_end":1057,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3238},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1292293,"byte_end":1292301,"line_start":1096,"line_end":1096,"column_start":8,"column_end":16},"name":"flat_map","qualname":"::iter::traits::iterator::Iterator::flat_map","value":"fn <U, F> (self, f: F) -> FlatMap<Self, U, F>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Creates an iterator that works like map, but flattens nested structure.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1292226,"byte_end":1292235,"line_start":1094,"line_end":1094,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1292240,"byte_end":1292285,"line_start":1095,"line_end":1095,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3241},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1294741,"byte_end":1294748,"line_start":1165,"line_end":1165,"column_start":8,"column_end":15},"name":"flatten","qualname":"::iter::traits::iterator::Iterator::flatten","value":"fn (self) -> Flatten<Self>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Creates an iterator that flattens nested structure.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1294662,"byte_end":1294671,"line_start":1163,"line_end":1163,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iterator_flatten\", since = \"1.29.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1294676,"byte_end":1294733,"line_start":1164,"line_end":1164,"column_start":5,"column_end":62}}]},{"kind":"Method","id":{"krate":0,"index":3242},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1296647,"byte_end":1296651,"line_start":1226,"line_end":1226,"column_start":8,"column_end":12},"name":"fuse","qualname":"::iter::traits::iterator::Iterator::fuse","value":"fn (self) -> Fuse<Self>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Creates an iterator which ends after the first [`None`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1296580,"byte_end":1296589,"line_start":1224,"line_end":1224,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1296594,"byte_end":1296639,"line_start":1225,"line_end":1225,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3243},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1298961,"byte_end":1298968,"line_start":1307,"line_end":1307,"column_start":8,"column_end":15},"name":"inspect","qualname":"::iter::traits::iterator::Iterator::inspect","value":"fn <F> (self, f: F) -> Inspect<Self, F>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Do something with each element of an iterator, passing the value on.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1298894,"byte_end":1298903,"line_start":1305,"line_end":1305,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1298908,"byte_end":1298953,"line_start":1306,"line_end":1306,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3245},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1300169,"byte_end":1300175,"line_start":1350,"line_end":1350,"column_start":8,"column_end":14},"name":"by_ref","qualname":"::iter::traits::iterator::Iterator::by_ref","value":"fn (&mut self) -> &mut Self","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Borrows an iterator, rather than consuming it.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1300116,"byte_end":1300161,"line_start":1349,"line_end":1349,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3246},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1304218,"byte_end":1304225,"line_start":1465,"line_end":1465,"column_start":8,"column_end":15},"name":"collect","qualname":"::iter::traits::iterator::Iterator::collect","value":"fn <B> (self) -> B","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Transforms an iterator into a collection.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1304052,"byte_end":1304061,"line_start":1462,"line_end":1462,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1304066,"byte_end":1304111,"line_start":1463,"line_end":1463,"column_start":5,"column_end":50}},{"value":"must_use =\n      \"if you really need to exhaust the iterator, consider `.for_each(drop)` instead\"","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1304116,"byte_end":1304210,"line_start":1464,"line_end":1464,"column_start":5,"column_end":99}}]},{"kind":"Method","id":{"krate":0,"index":3248},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1305002,"byte_end":1305011,"line_start":1490,"line_end":1490,"column_start":8,"column_end":17},"name":"partition","qualname":"::iter::traits::iterator::Iterator::partition","value":"fn <B, F> (self, mut f: F) -> (B, B)","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Consumes an iterator, creating two collections from it.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1304949,"byte_end":1304994,"line_start":1489,"line_end":1489,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3252},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1307939,"byte_end":1307947,"line_start":1568,"line_end":1568,"column_start":8,"column_end":16},"name":"try_fold","qualname":"::iter::traits::iterator::Iterator::try_fold","value":"fn <B, F, R> (&mut self, init: B, mut f: F) -> R","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" An iterator method that applies a function as long as it returns\n successfully, producing a single, final value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1307859,"byte_end":1307868,"line_start":1566,"line_end":1566,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iterator_try_fold\", since = \"1.27.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1307873,"byte_end":1307931,"line_start":1567,"line_end":1567,"column_start":5,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":3256},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1309345,"byte_end":1309357,"line_start":1607,"line_end":1607,"column_start":8,"column_end":20},"name":"try_for_each","qualname":"::iter::traits::iterator::Iterator::try_for_each","value":"fn <F, R> (&mut self, mut f: F) -> R","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" An iterator method that applies a fallible function to each item in the\n iterator, stopping at the first error and returning that error.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1309265,"byte_end":1309274,"line_start":1605,"line_end":1605,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iterator_try_fold\", since = \"1.27.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1309279,"byte_end":1309337,"line_start":1606,"line_end":1606,"column_start":5,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":3260},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1311825,"byte_end":1311829,"line_start":1682,"line_end":1682,"column_start":8,"column_end":12},"name":"fold","qualname":"::iter::traits::iterator::Iterator::fold","value":"fn <B, F> (mut self, init: B, mut f: F) -> B","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" An iterator method that applies a function, producing a single, final value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1311758,"byte_end":1311767,"line_start":1680,"line_end":1680,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1311772,"byte_end":1311817,"line_start":1681,"line_end":1681,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3264},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1313194,"byte_end":1313197,"line_start":1727,"line_end":1727,"column_start":8,"column_end":11},"name":"all","qualname":"::iter::traits::iterator::Iterator::all","value":"fn <F> (&mut self, mut f: F) -> bool","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Tests if every element of the iterator matches a predicate.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1313127,"byte_end":1313136,"line_start":1725,"line_end":1725,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1313141,"byte_end":1313186,"line_start":1726,"line_end":1726,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3267},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1314639,"byte_end":1314642,"line_start":1775,"line_end":1775,"column_start":8,"column_end":11},"name":"any","qualname":"::iter::traits::iterator::Iterator::any","value":"fn <F> (&mut self, mut f: F) -> bool","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Tests if any element of the iterator matches a predicate.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1314572,"byte_end":1314581,"line_start":1773,"line_end":1773,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1314586,"byte_end":1314631,"line_start":1774,"line_end":1774,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3270},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1316453,"byte_end":1316457,"line_start":1829,"line_end":1829,"column_start":8,"column_end":12},"name":"find","qualname":"::iter::traits::iterator::Iterator::find","value":"fn <P> (&mut self, mut predicate: P) -> Option<Self::Item>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Searches for an element of an iterator that satisfies a predicate.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1316386,"byte_end":1316395,"line_start":1827,"line_end":1827,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1316400,"byte_end":1316445,"line_start":1828,"line_end":1828,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3273},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1317250,"byte_end":1317258,"line_start":1856,"line_end":1856,"column_start":8,"column_end":16},"name":"find_map","qualname":"::iter::traits::iterator::Iterator::find_map","value":"fn <B, F> (&mut self, mut f: F) -> Option<B>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Applies function to the elements of iterator and returns\n the first non-none result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1317170,"byte_end":1317179,"line_start":1854,"line_end":1854,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iterator_find_map\", since = \"1.30.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1317184,"byte_end":1317242,"line_start":1855,"line_end":1855,"column_start":5,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":3277},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1319515,"byte_end":1319523,"line_start":1925,"line_end":1925,"column_start":8,"column_end":16},"name":"position","qualname":"::iter::traits::iterator::Iterator::position","value":"fn <P> (&mut self, mut predicate: P) -> Option<usize>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Searches for an element in an iterator, returning its index.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1319411,"byte_end":1319420,"line_start":1922,"line_end":1922,"column_start":5,"column_end":14}},{"value":"rustc_inherit_overflow_checks","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1319425,"byte_end":1319457,"line_start":1923,"line_end":1923,"column_start":5,"column_end":37}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1319462,"byte_end":1319507,"line_start":1924,"line_end":1924,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3280},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1321192,"byte_end":1321201,"line_start":1976,"line_end":1976,"column_start":8,"column_end":17},"name":"rposition","qualname":"::iter::traits::iterator::Iterator::rposition","value":"fn <P> (&mut self, mut predicate: P) -> Option<usize>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Searches for an element in an iterator from the right, returning its\n index.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1321125,"byte_end":1321134,"line_start":1974,"line_end":1974,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1321139,"byte_end":1321184,"line_start":1975,"line_end":1975,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3283},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1322317,"byte_end":1322320,"line_start":2010,"line_end":2010,"column_start":8,"column_end":11},"name":"max","qualname":"::iter::traits::iterator::Iterator::max","value":"fn (self) -> Option<Self::Item>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Returns the maximum element of an iterator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1322250,"byte_end":1322259,"line_start":2008,"line_end":2008,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1322264,"byte_end":1322309,"line_start":2009,"line_end":2009,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3284},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1323016,"byte_end":1323019,"line_start":2035,"line_end":2035,"column_start":8,"column_end":11},"name":"min","qualname":"::iter::traits::iterator::Iterator::min","value":"fn (self) -> Option<Self::Item>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Returns the minimum element of an iterator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1322949,"byte_end":1322958,"line_start":2033,"line_end":2033,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1322963,"byte_end":1323008,"line_start":2034,"line_end":2034,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3285},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1323685,"byte_end":1323695,"line_start":2056,"line_end":2056,"column_start":8,"column_end":18},"name":"max_by_key","qualname":"::iter::traits::iterator::Iterator::max_by_key","value":"fn <B, F> (self, mut f: F) -> Option<Self::Item>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Returns the element that gives the maximum value from the\n specified function.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1323608,"byte_end":1323617,"line_start":2054,"line_end":2054,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1323622,"byte_end":1323677,"line_start":2055,"line_end":2055,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":3291},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1324557,"byte_end":1324563,"line_start":2079,"line_end":2079,"column_start":8,"column_end":14},"name":"max_by","qualname":"::iter::traits::iterator::Iterator::max_by","value":"fn <F> (self, mut compare: F) -> Option<Self::Item>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Returns the element that gives the maximum value with respect to the\n specified comparison function.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1324483,"byte_end":1324492,"line_start":2077,"line_end":2077,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iter_max_by\", since = \"1.15.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1324497,"byte_end":1324549,"line_start":2078,"line_end":2078,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":3294},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1325385,"byte_end":1325395,"line_start":2101,"line_end":2101,"column_start":8,"column_end":18},"name":"min_by_key","qualname":"::iter::traits::iterator::Iterator::min_by_key","value":"fn <B, F> (self, mut f: F) -> Option<Self::Item>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Returns the element that gives the minimum value from the\n specified function.","sig":null,"attributes":[{"value":"stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1325322,"byte_end":1325377,"line_start":2100,"line_end":2100,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":3300},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1326265,"byte_end":1326271,"line_start":2124,"line_end":2124,"column_start":8,"column_end":14},"name":"min_by","qualname":"::iter::traits::iterator::Iterator::min_by","value":"fn <F> (self, mut compare: F) -> Option<Self::Item>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Returns the element that gives the minimum value with respect to the\n specified comparison function.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1326191,"byte_end":1326200,"line_start":2122,"line_end":2122,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iter_min_by\", since = \"1.15.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1326205,"byte_end":1326257,"line_start":2123,"line_end":2123,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":3303},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1327328,"byte_end":1327331,"line_start":2157,"line_end":2157,"column_start":8,"column_end":11},"name":"rev","qualname":"::iter::traits::iterator::Iterator::rev","value":"fn (self) -> Rev<Self>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Reverses an iterator's direction.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1327261,"byte_end":1327270,"line_start":2155,"line_end":2155,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1327275,"byte_end":1327320,"line_start":2156,"line_end":2156,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3304},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1328117,"byte_end":1328122,"line_start":2184,"line_end":2184,"column_start":8,"column_end":13},"name":"unzip","qualname":"::iter::traits::iterator::Iterator::unzip","value":"fn <A, B, FromA, FromB> (self) -> (FromA, FromB)","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Converts an iterator of pairs into a pair of containers.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1328064,"byte_end":1328109,"line_start":2183,"line_end":2183,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3310},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1329156,"byte_end":1329162,"line_start":2221,"line_end":2221,"column_start":8,"column_end":14},"name":"copied","qualname":"::iter::traits::iterator::Iterator::copied","value":"fn <'a, T> (self) -> Copied<Self>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Creates an iterator which copies all of its elements.","sig":null,"attributes":[{"value":"stable(feature = \"iter_copied\", since = \"1.36.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1329096,"byte_end":1329148,"line_start":2220,"line_end":2220,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":3313},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1330008,"byte_end":1330014,"line_start":2250,"line_end":2250,"column_start":8,"column_end":14},"name":"cloned","qualname":"::iter::traits::iterator::Iterator::cloned","value":"fn <'a, T> (self) -> Cloned<Self>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Creates an iterator which [`clone`]s all of its elements.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1329955,"byte_end":1330000,"line_start":2249,"line_end":2249,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3316},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1331002,"byte_end":1331007,"line_start":2283,"line_end":2283,"column_start":8,"column_end":13},"name":"cycle","qualname":"::iter::traits::iterator::Iterator::cycle","value":"fn (self) -> Cycle<Self>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Repeats an iterator endlessly.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1330935,"byte_end":1330980,"line_start":2281,"line_end":2281,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1330985,"byte_end":1330994,"line_start":2282,"line_end":2282,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3317},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1331746,"byte_end":1331749,"line_start":2310,"line_end":2310,"column_start":8,"column_end":11},"name":"sum","qualname":"::iter::traits::iterator::Iterator::sum","value":"fn <S> (self) -> S","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Sums the elements of an iterator.","sig":null,"attributes":[{"value":"stable(feature = \"iter_arith\", since = \"1.11.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1331687,"byte_end":1331738,"line_start":2309,"line_end":2309,"column_start":5,"column_end":56}}]},{"kind":"Method","id":{"krate":0,"index":3319},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1332526,"byte_end":1332533,"line_start":2338,"line_end":2338,"column_start":8,"column_end":15},"name":"product","qualname":"::iter::traits::iterator::Iterator::product","value":"fn <P> (self) -> P","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Iterates over the entire iterator, multiplying all the elements","sig":null,"attributes":[{"value":"stable(feature = \"iter_arith\", since = \"1.11.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1332467,"byte_end":1332518,"line_start":2337,"line_end":2337,"column_start":5,"column_end":56}}]},{"kind":"Method","id":{"krate":0,"index":3321},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1332817,"byte_end":1332820,"line_start":2348,"line_end":2348,"column_start":8,"column_end":11},"name":"cmp","qualname":"::iter::traits::iterator::Iterator::cmp","value":"fn <I> (mut self, other: I) -> Ordering","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Lexicographically compares the elements of this `Iterator` with those\n of another.\n","sig":null,"attributes":[{"value":"stable(feature = \"iter_order\", since = \"1.5.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1332759,"byte_end":1332809,"line_start":2347,"line_end":2347,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":3323},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1333730,"byte_end":1333741,"line_start":2380,"line_end":2380,"column_start":8,"column_end":19},"name":"partial_cmp","qualname":"::iter::traits::iterator::Iterator::partial_cmp","value":"fn <I> (mut self, other: I) -> Option<Ordering>","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Lexicographically compares the elements of this `Iterator` with those\n of another.\n","sig":null,"attributes":[{"value":"stable(feature = \"iter_order\", since = \"1.5.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1333672,"byte_end":1333722,"line_start":2379,"line_end":2379,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":3325},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1334683,"byte_end":1334685,"line_start":2412,"line_end":2412,"column_start":8,"column_end":10},"name":"eq","qualname":"::iter::traits::iterator::Iterator::eq","value":"fn <I> (mut self, other: I) -> bool","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Determines if the elements of this `Iterator` are equal to those of\n another.\n","sig":null,"attributes":[{"value":"stable(feature = \"iter_order\", since = \"1.5.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1334625,"byte_end":1334675,"line_start":2411,"line_end":2411,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":3327},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1335361,"byte_end":1335363,"line_start":2437,"line_end":2437,"column_start":8,"column_end":10},"name":"ne","qualname":"::iter::traits::iterator::Iterator::ne","value":"fn <I> (self, other: I) -> bool","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Determines if the elements of this `Iterator` are unequal to those of\n another.\n","sig":null,"attributes":[{"value":"stable(feature = \"iter_order\", since = \"1.5.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1335303,"byte_end":1335353,"line_start":2436,"line_end":2436,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":3329},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1335694,"byte_end":1335696,"line_start":2448,"line_end":2448,"column_start":8,"column_end":10},"name":"lt","qualname":"::iter::traits::iterator::Iterator::lt","value":"fn <I> (self, other: I) -> bool","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Determines if the elements of this `Iterator` are lexicographically\n less than those of another.\n","sig":null,"attributes":[{"value":"stable(feature = \"iter_order\", since = \"1.5.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1335636,"byte_end":1335686,"line_start":2447,"line_end":2447,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":3331},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1336067,"byte_end":1336069,"line_start":2459,"line_end":2459,"column_start":8,"column_end":10},"name":"le","qualname":"::iter::traits::iterator::Iterator::le","value":"fn <I> (self, other: I) -> bool","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Determines if the elements of this `Iterator` are lexicographically\n less or equal to those of another.\n","sig":null,"attributes":[{"value":"stable(feature = \"iter_order\", since = \"1.5.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1336009,"byte_end":1336059,"line_start":2458,"line_end":2458,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":3333},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1336520,"byte_end":1336522,"line_start":2473,"line_end":2473,"column_start":8,"column_end":10},"name":"gt","qualname":"::iter::traits::iterator::Iterator::gt","value":"fn <I> (self, other: I) -> bool","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Determines if the elements of this `Iterator` are lexicographically\n greater than those of another.\n","sig":null,"attributes":[{"value":"stable(feature = \"iter_order\", since = \"1.5.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1336462,"byte_end":1336512,"line_start":2472,"line_end":2472,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":3335},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1336904,"byte_end":1336906,"line_start":2484,"line_end":2484,"column_start":8,"column_end":10},"name":"ge","qualname":"::iter::traits::iterator::Iterator::ge","value":"fn <I> (self, other: I) -> bool","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Determines if the elements of this `Iterator` are lexicographically\n greater than or equal to those of another.\n","sig":null,"attributes":[{"value":"stable(feature = \"iter_order\", since = \"1.5.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1336846,"byte_end":1336896,"line_start":2483,"line_end":2483,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":3337},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1338085,"byte_end":1338094,"line_start":2517,"line_end":2517,"column_start":8,"column_end":17},"name":"is_sorted","qualname":"::iter::traits::iterator::Iterator::is_sorted","value":"fn (self) -> bool","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Checks if the elements of this iterator are sorted.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1337992,"byte_end":1338001,"line_start":2515,"line_end":2515,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1338006,"byte_end":1338077,"line_start":2516,"line_end":2516,"column_start":5,"column_end":76}}]},{"kind":"Method","id":{"krate":0,"index":3339},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1338745,"byte_end":1338757,"line_start":2533,"line_end":2533,"column_start":8,"column_end":20},"name":"is_sorted_by","qualname":"::iter::traits::iterator::Iterator::is_sorted_by","value":"fn <F> (mut self, mut compare: F) -> bool","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Checks if the elements of this iterator are sorted using the given comparator function.","sig":null,"attributes":[{"value":"unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1338666,"byte_end":1338737,"line_start":2532,"line_end":2532,"column_start":5,"column_end":76}}]},{"kind":"Method","id":{"krate":0,"index":3342},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1340059,"byte_end":1340075,"line_start":2575,"line_end":2575,"column_start":8,"column_end":24},"name":"is_sorted_by_key","qualname":"::iter::traits::iterator::Iterator::is_sorted_by_key","value":"fn <F, K> (self, mut f: F) -> bool","parent":{"krate":0,"index":3202},"children":[],"decl_id":null,"docs":" Checks if the elements of this iterator are sorted using the given key extraction\n function.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1339966,"byte_end":1339975,"line_start":2573,"line_end":2573,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1339980,"byte_end":1340051,"line_start":2574,"line_end":2574,"column_start":5,"column_end":76}}]},{"kind":"Trait","id":{"krate":0,"index":3360},"span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1342602,"byte_end":1342621,"line_start":39,"line_end":39,"column_start":11,"column_end":30},"name":"DoubleEndedIterator","qualname":"::iter::traits::double_ended::DoubleEndedIterator","value":"DoubleEndedIterator: Iterator","parent":null,"children":[{"krate":0,"index":3361},{"krate":0,"index":3362},{"krate":0,"index":3363},{"krate":0,"index":3367},{"krate":0,"index":3371}],"decl_id":null,"docs":" An iterator able to yield elements from both ends.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1342546,"byte_end":1342591,"line_start":38,"line_end":38,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":3361},"span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1343487,"byte_end":1343496,"line_start":67,"line_end":67,"column_start":8,"column_end":17},"name":"next_back","qualname":"::iter::traits::double_ended::DoubleEndedIterator::next_back","value":"fn (&mut self) -> Option<Self::Item>","parent":{"krate":0,"index":3360},"children":[],"decl_id":null,"docs":" Removes and returns an element from the end of the iterator.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1343434,"byte_end":1343479,"line_start":66,"line_end":66,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3362},"span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1345072,"byte_end":1345080,"line_start":114,"line_end":114,"column_start":8,"column_end":16},"name":"nth_back","qualname":"::iter::traits::double_ended::DoubleEndedIterator::nth_back","value":"fn (&mut self, mut n: usize) -> Option<Self::Item>","parent":{"krate":0,"index":3360},"children":[],"decl_id":null,"docs":" Returns the `n`th element from the end of the iterator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1344996,"byte_end":1345005,"line_start":112,"line_end":112,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iter_nth_back\", since = \"1.37.0\")","span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1345010,"byte_end":1345064,"line_start":113,"line_end":113,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":3363},"span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1346292,"byte_end":1346301,"line_start":156,"line_end":156,"column_start":8,"column_end":17},"name":"try_rfold","qualname":"::iter::traits::double_ended::DoubleEndedIterator::try_rfold","value":"fn <B, F, R> (&mut self, init: B, mut f: F) -> R","parent":{"krate":0,"index":3360},"children":[],"decl_id":null,"docs":" This is the reverse version of [`try_fold()`]: it takes elements\n starting from the back of the iterator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1346212,"byte_end":1346221,"line_start":154,"line_end":154,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iterator_try_fold\", since = \"1.27.0\")","span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1346226,"byte_end":1346284,"line_start":155,"line_end":155,"column_start":5,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":3367},"span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1348381,"byte_end":1348386,"line_start":222,"line_end":222,"column_start":8,"column_end":13},"name":"rfold","qualname":"::iter::traits::double_ended::DoubleEndedIterator::rfold","value":"fn <B, F> (mut self, accum: B, mut f: F) -> B","parent":{"krate":0,"index":3360},"children":[],"decl_id":null,"docs":" An iterator method that reduces the iterator's elements to a single,\n final value, starting from the back.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1348308,"byte_end":1348317,"line_start":220,"line_end":220,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iter_rfold\", since = \"1.27.0\")","span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1348322,"byte_end":1348373,"line_start":221,"line_end":221,"column_start":5,"column_end":56}}]},{"kind":"Method","id":{"krate":0,"index":3371},"span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1350178,"byte_end":1350183,"line_start":274,"line_end":274,"column_start":8,"column_end":13},"name":"rfind","qualname":"::iter::traits::double_ended::DoubleEndedIterator::rfind","value":"fn <P> (&mut self, mut predicate: P) -> Option<Self::Item>","parent":{"krate":0,"index":3360},"children":[],"decl_id":null,"docs":" Searches for an element of an iterator from the back that satisfies a predicate.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1350105,"byte_end":1350114,"line_start":272,"line_end":272,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iter_rfind\", since = \"1.27.0\")","span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1350119,"byte_end":1350170,"line_start":273,"line_end":273,"column_start":5,"column_end":56}}]},{"kind":"Trait","id":{"krate":0,"index":3380},"span":{"file_name":"src/libcore/iter/traits/exact_size.rs","byte_start":1352872,"byte_end":1352889,"line_start":71,"line_end":71,"column_start":11,"column_end":28},"name":"ExactSizeIterator","qualname":"::iter::traits::exact_size::ExactSizeIterator","value":"ExactSizeIterator: Iterator","parent":null,"children":[{"krate":0,"index":3381},{"krate":0,"index":3382}],"decl_id":null,"docs":" An iterator that knows its exact length.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/exact_size.rs","byte_start":1352816,"byte_end":1352861,"line_start":70,"line_end":70,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":3381},"span":{"file_name":"src/libcore/iter/traits/exact_size.rs","byte_start":1353739,"byte_end":1353742,"line_start":97,"line_end":97,"column_start":8,"column_end":11},"name":"len","qualname":"::iter::traits::exact_size::ExactSizeIterator::len","value":"fn (&self) -> usize","parent":{"krate":0,"index":3380},"children":[],"decl_id":null,"docs":" Returns the exact number of times the iterator will iterate.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/exact_size.rs","byte_start":1353672,"byte_end":1353681,"line_start":95,"line_end":95,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/exact_size.rs","byte_start":1353686,"byte_end":1353731,"line_start":96,"line_end":96,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3382},"span":{"file_name":"src/libcore/iter/traits/exact_size.rs","byte_start":1354773,"byte_end":1354781,"line_start":129,"line_end":129,"column_start":8,"column_end":16},"name":"is_empty","qualname":"::iter::traits::exact_size::ExactSizeIterator::is_empty","value":"fn (&self) -> bool","parent":{"krate":0,"index":3380},"children":[],"decl_id":null,"docs":" Returns `true` if the iterator is empty.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/exact_size.rs","byte_start":1354690,"byte_end":1354699,"line_start":127,"line_end":127,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"exact_size_is_empty\", issue = \"35428\")","span":{"file_name":"src/libcore/iter/traits/exact_size.rs","byte_start":1354704,"byte_end":1354765,"line_start":128,"line_end":128,"column_start":5,"column_end":66}}]},{"kind":"Trait","id":{"krate":0,"index":3388},"span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1357649,"byte_end":1357661,"line_start":98,"line_end":98,"column_start":11,"column_end":23},"name":"FromIterator","qualname":"::iter::traits::collect::FromIterator","value":"FromIterator<A>: Sized","parent":null,"children":[{"krate":0,"index":3390}],"decl_id":null,"docs":" Conversion from an `Iterator`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1357347,"byte_end":1357392,"line_start":92,"line_end":92,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message =\n                             \"a collection of type `{Self}` cannot be built from an iterator \\\n             over elements of type `{A}`\",\n                         label =\n                             \"a collection of type `{Self}` cannot be built from `std::iter::Iterator<Item={A}>`\")","span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1357393,"byte_end":1357638,"line_start":93,"line_end":97,"column_start":1,"column_end":3}}]},{"kind":"Method","id":{"krate":0,"index":3390},"span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1358185,"byte_end":1358194,"line_start":119,"line_end":119,"column_start":8,"column_end":17},"name":"from_iter","qualname":"::iter::traits::collect::FromIterator::from_iter","value":"fn <T> (iter: T) -> Self","parent":{"krate":0,"index":3388},"children":[],"decl_id":null,"docs":" Creates a value from an iterator.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1358132,"byte_end":1358177,"line_start":118,"line_end":118,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":3392},"span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1360560,"byte_end":1360572,"line_start":208,"line_end":208,"column_start":11,"column_end":23},"name":"IntoIterator","qualname":"::iter::traits::collect::IntoIterator","value":"IntoIterator","parent":null,"children":[{"krate":0,"index":3393},{"krate":0,"index":3394},{"krate":0,"index":3395}],"decl_id":null,"docs":" Conversion into an `Iterator`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1360504,"byte_end":1360549,"line_start":207,"line_end":207,"column_start":1,"column_end":46}}]},{"kind":"Type","id":{"krate":0,"index":3393},"span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1360688,"byte_end":1360692,"line_start":211,"line_end":211,"column_start":10,"column_end":14},"name":"Item","qualname":"::iter::traits::collect::IntoIterator::Item","value":"type Item;","parent":{"krate":0,"index":3392},"children":[],"decl_id":null,"docs":" The type of the elements being iterated over.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1360633,"byte_end":1360678,"line_start":210,"line_end":210,"column_start":5,"column_end":50}}]},{"kind":"Type","id":{"krate":0,"index":3394},"span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1360811,"byte_end":1360819,"line_start":215,"line_end":215,"column_start":10,"column_end":18},"name":"IntoIter","qualname":"::iter::traits::collect::IntoIterator::IntoIter","value":"type IntoIter: Iterator<Item=Self::Item>;","parent":{"krate":0,"index":3392},"children":[],"decl_id":null,"docs":" Which kind of iterator are we turning this into?\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1360756,"byte_end":1360801,"line_start":214,"line_end":214,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3395},"span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1361398,"byte_end":1361407,"line_start":237,"line_end":237,"column_start":8,"column_end":17},"name":"into_iter","qualname":"::iter::traits::collect::IntoIterator::into_iter","value":"fn (self) -> Self::IntoIter","parent":{"krate":0,"index":3392},"children":[],"decl_id":null,"docs":" Creates an iterator from a value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1361345,"byte_end":1361390,"line_start":236,"line_end":236,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":3401},"span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1363830,"byte_end":1363836,"line_start":320,"line_end":320,"column_start":11,"column_end":17},"name":"Extend","qualname":"::iter::traits::collect::Extend","value":"Extend<A>","parent":null,"children":[{"krate":0,"index":3403}],"decl_id":null,"docs":" Extend a collection with the contents of an iterator.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1363774,"byte_end":1363819,"line_start":319,"line_end":319,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":3403},"span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1364414,"byte_end":1364420,"line_start":341,"line_end":341,"column_start":8,"column_end":14},"name":"extend","qualname":"::iter::traits::collect::Extend::extend","value":"fn <T> (&mut self, iter: T) -> ()","parent":{"krate":0,"index":3401},"children":[],"decl_id":null,"docs":" Extends a collection with the contents of an iterator.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1364361,"byte_end":1364406,"line_start":340,"line_end":340,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":3413},"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1365333,"byte_end":1365336,"line_start":15,"line_end":15,"column_start":11,"column_end":14},"name":"Sum","qualname":"::iter::traits::accum::Sum","value":"Sum<A = Self>: Sized","parent":null,"children":[{"krate":0,"index":3415}],"decl_id":null,"docs":" Trait to represent types that can be created by summing up an iterator.","sig":null,"attributes":[{"value":"stable(feature = \"iter_arith_traits\", since = \"1.12.0\")","span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1365264,"byte_end":1365322,"line_start":14,"line_end":14,"column_start":1,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":3415},"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1365539,"byte_end":1365542,"line_start":19,"line_end":19,"column_start":8,"column_end":11},"name":"sum","qualname":"::iter::traits::accum::Sum::sum","value":"fn <I> (iter: I) -> Self","parent":{"krate":0,"index":3413},"children":[],"decl_id":null,"docs":" Method which takes an iterator and generates `Self` from the elements by\n \"summing up\" the items.\n","sig":null,"attributes":[{"value":"stable(feature = \"iter_arith_traits\", since = \"1.12.0\")","span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1365473,"byte_end":1365531,"line_start":18,"line_end":18,"column_start":5,"column_end":63}}]},{"kind":"Trait","id":{"krate":0,"index":3417},"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1366247,"byte_end":1366254,"line_start":34,"line_end":34,"column_start":11,"column_end":18},"name":"Product","qualname":"::iter::traits::accum::Product","value":"Product<A = Self>: Sized","parent":null,"children":[{"krate":0,"index":3419}],"decl_id":null,"docs":" Trait to represent types that can be created by multiplying elements of an\n iterator.","sig":null,"attributes":[{"value":"stable(feature = \"iter_arith_traits\", since = \"1.12.0\")","span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1366178,"byte_end":1366236,"line_start":33,"line_end":33,"column_start":1,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":3419},"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1366456,"byte_end":1366463,"line_start":38,"line_end":38,"column_start":8,"column_end":15},"name":"product","qualname":"::iter::traits::accum::Product::product","value":"fn <I> (iter: I) -> Self","parent":{"krate":0,"index":3417},"children":[],"decl_id":null,"docs":" Method which takes an iterator and generates `Self` from the elements by\n multiplying the items.\n","sig":null,"attributes":[{"value":"stable(feature = \"iter_arith_traits\", since = \"1.12.0\")","span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1366390,"byte_end":1366448,"line_start":37,"line_end":37,"column_start":5,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":3432},"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1369455,"byte_end":1369462,"line_start":133,"line_end":133,"column_start":12,"column_end":19},"name":"process","qualname":"<ResultShunt<I, E>>::process","value":"fn <F, U> (iter: I, mut f: F) -> Result<U, E>","parent":null,"children":[],"decl_id":null,"docs":" Process the given iterator as if it yielded a `T` instead of a\n `Result<T, _>`. Any errors will stop the inner iterator and\n the overall result will be an error.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3466},"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1372537,"byte_end":1372544,"line_start":241,"line_end":241,"column_start":12,"column_end":19},"name":"process","qualname":"<OptionShunt<I>>::process","value":"fn <F, U> (iter: I, mut f: F) -> Option<U>","parent":null,"children":[],"decl_id":null,"docs":" Process the given iterator as if it yielded a `T` instead of a\n `Option<T>`. Any `None` value will stop the inner iterator and\n the overall result will be a `None`.\n","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":3491},"span":{"file_name":"src/libcore/iter/traits/marker.rs","byte_start":1375896,"byte_end":1375909,"line_start":16,"line_end":16,"column_start":11,"column_end":24},"name":"FusedIterator","qualname":"::iter::traits::marker::FusedIterator","value":"FusedIterator: Iterator","parent":null,"children":[],"decl_id":null,"docs":" An iterator that always continues to yield `None` when exhausted.","sig":null,"attributes":[{"value":"stable(feature = \"fused\", since = \"1.26.0\")","span":{"file_name":"src/libcore/iter/traits/marker.rs","byte_start":1375839,"byte_end":1375885,"line_start":15,"line_end":15,"column_start":1,"column_end":47}}]},{"kind":"Trait","id":{"krate":0,"index":3494},"span":{"file_name":"src/libcore/iter/traits/marker.rs","byte_start":1377000,"byte_end":1377010,"line_start":41,"line_end":41,"column_start":18,"column_end":28},"name":"TrustedLen","qualname":"::iter::traits::marker::TrustedLen","value":"TrustedLen: Iterator","parent":null,"children":[],"decl_id":null,"docs":" An iterator that reports an accurate length using size_hint.","sig":null,"attributes":[{"value":"unstable(feature = \"trusted_len\", issue = \"37572\")","span":{"file_name":"src/libcore/iter/traits/marker.rs","byte_start":1376929,"byte_end":1376982,"line_start":40,"line_end":40,"column_start":1,"column_end":54}}]},{"kind":"Struct","id":{"krate":0,"index":32613},"span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1436161,"byte_end":1436166,"line_start":16,"line_end":16,"column_start":12,"column_end":17},"name":"Chain","qualname":"::iter::adapters::chain::Chain","value":"Chain {  }","parent":null,"children":[{"krate":0,"index":32616},{"krate":0,"index":32617},{"krate":0,"index":32618}],"decl_id":null,"docs":" An iterator that strings two iterators together.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1436038,"byte_end":1436103,"line_start":14,"line_end":14,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1436104,"byte_end":1436149,"line_start":15,"line_end":15,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":3578},"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1443792,"byte_end":1443799,"line_start":17,"line_end":17,"column_start":12,"column_end":19},"name":"FlatMap","qualname":"::iter::adapters::flatten::FlatMap","value":"FlatMap {  }","parent":null,"children":[{"krate":0,"index":3582}],"decl_id":null,"docs":" An iterator that maps each element to an iterator, and yields the elements\n of the produced iterators.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1443669,"byte_end":1443734,"line_start":15,"line_end":15,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1443735,"byte_end":1443780,"line_start":16,"line_end":16,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":3628},"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1446729,"byte_end":1446736,"line_start":107,"line_end":107,"column_start":12,"column_end":19},"name":"Flatten","qualname":"::iter::adapters::flatten::Flatten","value":"Flatten {  }","parent":null,"children":[{"krate":0,"index":3630}],"decl_id":null,"docs":" An iterator that flattens one level of nesting in an iterator of things\n that can be turned into iterators.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1446594,"byte_end":1446659,"line_start":105,"line_end":105,"column_start":1,"column_end":66}},{"value":"stable(feature = \"iterator_flatten\", since = \"1.29.0\")","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1446660,"byte_end":1446717,"line_start":106,"line_end":106,"column_start":1,"column_end":58}}]},{"kind":"Struct","id":{"krate":0,"index":32652},"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1454350,"byte_end":1454353,"line_start":15,"line_end":15,"column_start":12,"column_end":15},"name":"Zip","qualname":"::iter::adapters::zip::Zip","value":"Zip {  }","parent":null,"children":[{"krate":0,"index":32655},{"krate":0,"index":32656},{"krate":0,"index":32657},{"krate":0,"index":32658}],"decl_id":null,"docs":" An iterator that iterates two other iterators simultaneously.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1454227,"byte_end":1454292,"line_start":13,"line_end":13,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1454293,"byte_end":1454338,"line_start":14,"line_end":14,"column_start":1,"column_end":46}}]},{"kind":"Type","id":{"krate":0,"index":3732},"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1455686,"byte_end":1455690,"line_start":70,"line_end":70,"column_start":10,"column_end":14},"name":"Item","qualname":"::iter::adapters::zip::ZipImpl::Item","value":"type Item;","parent":{"krate":0,"index":3729},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3733},"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1455699,"byte_end":1455702,"line_start":71,"line_end":71,"column_start":8,"column_end":11},"name":"new","qualname":"::iter::adapters::zip::ZipImpl::new","value":"fn (a: A, b: B) -> Self","parent":{"krate":0,"index":3729},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3734},"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1455731,"byte_end":1455735,"line_start":72,"line_end":72,"column_start":8,"column_end":12},"name":"next","qualname":"::iter::adapters::zip::ZipImpl::next","value":"fn (&mut self) -> Option<Self::Item>","parent":{"krate":0,"index":3729},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3735},"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1455777,"byte_end":1455786,"line_start":73,"line_end":73,"column_start":8,"column_end":17},"name":"size_hint","qualname":"::iter::adapters::zip::ZipImpl::size_hint","value":"fn (&self) -> (usize, Option<usize>)","parent":{"krate":0,"index":3729},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3736},"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1455828,"byte_end":1455831,"line_start":74,"line_end":74,"column_start":8,"column_end":11},"name":"nth","qualname":"::iter::adapters::zip::ZipImpl::nth","value":"fn (&mut self, n: usize) -> Option<Self::Item>","parent":{"krate":0,"index":3729},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3737},"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1455883,"byte_end":1455892,"line_start":75,"line_end":75,"column_start":8,"column_end":17},"name":"next_back","qualname":"::iter::adapters::zip::ZipImpl::next_back","value":"fn (&mut self) -> Option<Self::Item>","parent":{"krate":0,"index":3729},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3772},"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1461670,"byte_end":1461683,"line_start":279,"line_end":279,"column_start":15,"column_end":28},"name":"get_unchecked","qualname":"::iter::adapters::zip::TrustedRandomAccess::get_unchecked","value":"fn (&mut self, i: usize) -> Self::Item","parent":{"krate":0,"index":3771},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3773},"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1461859,"byte_end":1461879,"line_start":282,"line_end":282,"column_start":8,"column_end":28},"name":"may_have_side_effect","qualname":"::iter::adapters::zip::TrustedRandomAccess::may_have_side_effect","value":"fn () -> bool","parent":{"krate":0,"index":3771},"children":[],"decl_id":null,"docs":" Returns `true` if getting an iterator element may have\n side effects. Remember to take inner iterators into account.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":32667},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1377971,"byte_end":1377974,"line_start":30,"line_end":30,"column_start":12,"column_end":15},"name":"Rev","qualname":"::iter::adapters::Rev","value":"Rev {  }","parent":null,"children":[{"krate":0,"index":32669}],"decl_id":null,"docs":" A double-ended iterator with the direction inverted.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1377848,"byte_end":1377913,"line_start":28,"line_end":28,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1377914,"byte_end":1377959,"line_start":29,"line_end":29,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":32676},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1380945,"byte_end":1380951,"line_start":136,"line_end":136,"column_start":12,"column_end":18},"name":"Copied","qualname":"::iter::adapters::Copied","value":"Copied {  }","parent":null,"children":[{"krate":0,"index":32678}],"decl_id":null,"docs":" An iterator that copies the elements of an underlying iterator.","sig":null,"attributes":[{"value":"stable(feature = \"iter_copied\", since = \"1.36.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1380791,"byte_end":1380843,"line_start":133,"line_end":133,"column_start":1,"column_end":53}},{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1380844,"byte_end":1380909,"line_start":134,"line_end":134,"column_start":1,"column_end":66}}]},{"kind":"Struct","id":{"krate":0,"index":32685},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1383757,"byte_end":1383763,"line_start":242,"line_end":242,"column_start":12,"column_end":18},"name":"Cloned","qualname":"::iter::adapters::Cloned","value":"Cloned {  }","parent":null,"children":[{"krate":0,"index":32687}],"decl_id":null,"docs":" An iterator that clones the elements of an underlying iterator.","sig":null,"attributes":[{"value":"stable(feature = \"iter_cloned\", since = \"1.1.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1383604,"byte_end":1383655,"line_start":239,"line_end":239,"column_start":1,"column_end":52}},{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1383656,"byte_end":1383721,"line_start":240,"line_end":240,"column_start":1,"column_end":66}}]},{"kind":"Struct","id":{"krate":0,"index":32694},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1386881,"byte_end":1386886,"line_start":359,"line_end":359,"column_start":12,"column_end":17},"name":"Cycle","qualname":"::iter::adapters::Cycle","value":"Cycle {  }","parent":null,"children":[{"krate":0,"index":32696},{"krate":0,"index":32697}],"decl_id":null,"docs":" An iterator that repeats endlessly.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1386758,"byte_end":1386823,"line_start":357,"line_end":357,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1386824,"byte_end":1386869,"line_start":358,"line_end":358,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":32704},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1388223,"byte_end":1388229,"line_start":405,"line_end":405,"column_start":12,"column_end":18},"name":"StepBy","qualname":"::iter::adapters::StepBy","value":"StepBy {  }","parent":null,"children":[{"krate":0,"index":32706},{"krate":0,"index":32707},{"krate":0,"index":32708}],"decl_id":null,"docs":" An iterator for stepping iterators by a custom amount.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1388064,"byte_end":1388129,"line_start":402,"line_end":402,"column_start":1,"column_end":66}},{"value":"stable(feature = \"iterator_step_by\", since = \"1.28.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1388130,"byte_end":1388187,"line_start":403,"line_end":403,"column_start":1,"column_end":58}}]},{"kind":"Struct","id":{"krate":0,"index":32715},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1392658,"byte_end":1392661,"line_start":545,"line_end":545,"column_start":12,"column_end":15},"name":"Map","qualname":"::iter::adapters::Map","value":"Map {  }","parent":null,"children":[{"krate":0,"index":32718},{"krate":0,"index":32719}],"decl_id":null,"docs":" An iterator that maps the values of `iter` with `f`.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1392518,"byte_end":1392583,"line_start":542,"line_end":542,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1392584,"byte_end":1392629,"line_start":543,"line_end":543,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":32724},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1395901,"byte_end":1395907,"line_start":661,"line_end":661,"column_start":12,"column_end":18},"name":"Filter","qualname":"::iter::adapters::Filter","value":"Filter {  }","parent":null,"children":[{"krate":0,"index":32727},{"krate":0,"index":32728}],"decl_id":null,"docs":" An iterator that filters the elements of `iter` with `predicate`.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1395761,"byte_end":1395826,"line_start":658,"line_end":658,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1395827,"byte_end":1395872,"line_start":659,"line_end":659,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":32733},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1399911,"byte_end":1399920,"line_start":785,"line_end":785,"column_start":12,"column_end":21},"name":"FilterMap","qualname":"::iter::adapters::FilterMap","value":"FilterMap {  }","parent":null,"children":[{"krate":0,"index":32736},{"krate":0,"index":32737}],"decl_id":null,"docs":" An iterator that uses `f` to both filter and map elements from `iter`.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1399771,"byte_end":1399836,"line_start":782,"line_end":782,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1399837,"byte_end":1399882,"line_start":783,"line_end":783,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":32742},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1403015,"byte_end":1403024,"line_start":890,"line_end":890,"column_start":12,"column_end":21},"name":"Enumerate","qualname":"::iter::adapters::Enumerate","value":"Enumerate {  }","parent":null,"children":[{"krate":0,"index":32744},{"krate":0,"index":32745}],"decl_id":null,"docs":" An iterator that yields the current count and the element during iteration.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1402892,"byte_end":1402957,"line_start":888,"line_end":888,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1402958,"byte_end":1403003,"line_start":889,"line_end":889,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":32752},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1408235,"byte_end":1408243,"line_start":1066,"line_end":1066,"column_start":12,"column_end":20},"name":"Peekable","qualname":"::iter::adapters::Peekable","value":"Peekable {  }","parent":null,"children":[{"krate":0,"index":32754},{"krate":0,"index":32755}],"decl_id":null,"docs":" An iterator with a `peek()` that returns an optional reference to the next\n element.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1408112,"byte_end":1408177,"line_start":1064,"line_end":1064,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1408178,"byte_end":1408223,"line_start":1065,"line_end":1065,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":4172},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1412514,"byte_end":1412518,"line_start":1207,"line_end":1207,"column_start":12,"column_end":16},"name":"peek","qualname":"<Peekable<I>>::peek","value":"fn (&mut self) -> Option<&I::Item>","parent":null,"children":[],"decl_id":null,"docs":" Returns a reference to the next() value without advancing the iterator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1412443,"byte_end":1412452,"line_start":1205,"line_end":1205,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1412457,"byte_end":1412502,"line_start":1206,"line_end":1206,"column_start":5,"column_end":50}}]},{"kind":"Struct","id":{"krate":0,"index":32762},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1413087,"byte_end":1413096,"line_start":1223,"line_end":1223,"column_start":12,"column_end":21},"name":"SkipWhile","qualname":"::iter::adapters::SkipWhile","value":"SkipWhile {  }","parent":null,"children":[{"krate":0,"index":32765},{"krate":0,"index":32766},{"krate":0,"index":32767}],"decl_id":null,"docs":" An iterator that rejects elements while `predicate` returns `true`.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1412947,"byte_end":1413012,"line_start":1220,"line_end":1220,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1413013,"byte_end":1413058,"line_start":1221,"line_end":1221,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":32772},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1415644,"byte_end":1415653,"line_start":1311,"line_end":1311,"column_start":12,"column_end":21},"name":"TakeWhile","qualname":"::iter::adapters::TakeWhile","value":"TakeWhile {  }","parent":null,"children":[{"krate":0,"index":32775},{"krate":0,"index":32776},{"krate":0,"index":32777}],"decl_id":null,"docs":" An iterator that only accepts elements while `predicate` returns `true`.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1415504,"byte_end":1415569,"line_start":1308,"line_end":1308,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1415570,"byte_end":1415615,"line_start":1309,"line_end":1309,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":32782},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1418170,"byte_end":1418174,"line_start":1399,"line_end":1399,"column_start":12,"column_end":16},"name":"Skip","qualname":"::iter::adapters::Skip","value":"Skip {  }","parent":null,"children":[{"krate":0,"index":32784},{"krate":0,"index":32785}],"decl_id":null,"docs":" An iterator that skips over `n` elements of `iter`.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1418047,"byte_end":1418112,"line_start":1397,"line_end":1397,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1418113,"byte_end":1418158,"line_start":1398,"line_end":1398,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":32792},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1422400,"byte_end":1422404,"line_start":1556,"line_end":1556,"column_start":12,"column_end":16},"name":"Take","qualname":"::iter::adapters::Take","value":"Take {  }","parent":null,"children":[{"krate":0,"index":32794},{"krate":0,"index":32795}],"decl_id":null,"docs":" An iterator that only iterates over the first `n` iterations of `iter`.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1422277,"byte_end":1422342,"line_start":1554,"line_end":1554,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1422343,"byte_end":1422388,"line_start":1555,"line_end":1555,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":32802},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1424873,"byte_end":1424877,"line_start":1649,"line_end":1649,"column_start":12,"column_end":16},"name":"Scan","qualname":"::iter::adapters::Scan","value":"Scan {  }","parent":null,"children":[{"krate":0,"index":32806},{"krate":0,"index":32807},{"krate":0,"index":32808}],"decl_id":null,"docs":" An iterator to maintain state while iterating another iterator.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1424733,"byte_end":1424798,"line_start":1646,"line_end":1646,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1424799,"byte_end":1424844,"line_start":1647,"line_end":1647,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":32814},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1426832,"byte_end":1426836,"line_start":1714,"line_end":1714,"column_start":12,"column_end":16},"name":"Fuse","qualname":"::iter::adapters::Fuse","value":"Fuse {  }","parent":null,"children":[{"krate":0,"index":32816},{"krate":0,"index":32817}],"decl_id":null,"docs":" An iterator that yields `None` forever after the underlying iterator\n yields `None` once.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1426709,"byte_end":1426774,"line_start":1712,"line_end":1712,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1426775,"byte_end":1426820,"line_start":1713,"line_end":1713,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":32824},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1432806,"byte_end":1432813,"line_start":1960,"line_end":1960,"column_start":12,"column_end":19},"name":"Inspect","qualname":"::iter::adapters::Inspect","value":"Inspect {  }","parent":null,"children":[{"krate":0,"index":32827},{"krate":0,"index":32828}],"decl_id":null,"docs":" An iterator that calls a function with a reference to each element before\n yielding it.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1432666,"byte_end":1432731,"line_start":1957,"line_end":1957,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1432732,"byte_end":1432777,"line_start":1958,"line_end":1958,"column_start":1,"column_end":46}}]},{"kind":"Mod","id":{"krate":0,"index":4426},"span":{"file_name":"src/libcore/option.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"option","qualname":"::option","value":"src/libcore/option.rs","parent":null,"children":[{"krate":0,"index":4427},{"krate":0,"index":4431},{"krate":0,"index":4438},{"krate":0,"index":32847},{"krate":0,"index":32878},{"krate":0,"index":32874},{"krate":0,"index":32867},{"krate":0,"index":32864},{"krate":0,"index":32861},{"krate":0,"index":32858},{"krate":0,"index":32854},{"krate":0,"index":4439},{"krate":0,"index":4489},{"krate":0,"index":4493},{"krate":0,"index":4497},{"krate":0,"index":4501},{"krate":0,"index":4505},{"krate":0,"index":4508},{"krate":0,"index":4512},{"krate":0,"index":4516},{"krate":0,"index":4517},{"krate":0,"index":4521},{"krate":0,"index":4524},{"krate":0,"index":4529},{"krate":0,"index":4535},{"krate":0,"index":4541},{"krate":0,"index":4544},{"krate":0,"index":4548},{"krate":0,"index":32880},{"krate":0,"index":32886},{"krate":0,"index":32883},{"krate":0,"index":4552},{"krate":0,"index":4557},{"krate":0,"index":4560},{"krate":0,"index":4562},{"krate":0,"index":4564},{"krate":0,"index":32889},{"krate":0,"index":32893},{"krate":0,"index":4566},{"krate":0,"index":4572},{"krate":0,"index":4576},{"krate":0,"index":4578},{"krate":0,"index":4580},{"krate":0,"index":4582},{"krate":0,"index":32897},{"krate":0,"index":32901},{"krate":0,"index":4585},{"krate":0,"index":4591},{"krate":0,"index":4595},{"krate":0,"index":4597},{"krate":0,"index":4599},{"krate":0,"index":32905},{"krate":0,"index":32911},{"krate":0,"index":32908},{"krate":0,"index":4601},{"krate":0,"index":4606},{"krate":0,"index":4609},{"krate":0,"index":4611},{"krate":0,"index":4613},{"krate":0,"index":4615},{"krate":0,"index":32914},{"krate":0,"index":32930},{"krate":0,"index":32929},{"krate":0,"index":32927},{"krate":0,"index":32925},{"krate":0,"index":32923},{"krate":0,"index":32921},{"krate":0,"index":32919},{"krate":0,"index":32916},{"krate":0,"index":4630},{"krate":0,"index":4637}],"decl_id":null,"docs":" Optional values.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1466369,"byte_end":1466415,"line_start":136,"line_end":136,"column_start":1,"column_end":47}}]},{"kind":"TupleVariant","id":{"krate":0,"index":32849},"span":{"file_name":"src/libcore/option.rs","byte_start":1467109,"byte_end":1467113,"line_start":153,"line_end":153,"column_start":5,"column_end":9},"name":"None","qualname":"::option::Option::None","value":"Option::None","parent":{"krate":0,"index":32847},"children":[],"decl_id":null,"docs":" No value\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1467059,"byte_end":1467104,"line_start":152,"line_end":152,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":32851},"span":{"file_name":"src/libcore/option.rs","byte_start":1467192,"byte_end":1467196,"line_start":156,"line_end":156,"column_start":5,"column_end":9},"name":"Some","qualname":"::option::Option::Some","value":"Option::Some(T)","parent":{"krate":0,"index":32847},"children":[],"decl_id":null,"docs":" Some value `T`\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1467142,"byte_end":1467187,"line_start":155,"line_end":155,"column_start":5,"column_end":50}}]},{"kind":"Enum","id":{"krate":0,"index":32847},"span":{"file_name":"src/libcore/option.rs","byte_start":1467026,"byte_end":1467032,"line_start":150,"line_end":150,"column_start":10,"column_end":16},"name":"Option","qualname":"::option::Option","value":"Option::{None, Some}","parent":null,"children":[{"krate":0,"index":32849},{"krate":0,"index":32851}],"decl_id":null,"docs":" The `Option` type. See [the module level documentation](index.html) for more.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1466971,"byte_end":1467016,"line_start":149,"line_end":149,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/option.rs","byte_start":1467017,"byte_end":1467248,"line_start":150,"line_end":157,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/option.rs","byte_start":1467017,"byte_end":1467248,"line_start":150,"line_end":157,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":4441},"span":{"file_name":"src/libcore/option.rs","byte_start":1468052,"byte_end":1468059,"line_start":184,"line_end":184,"column_start":12,"column_end":19},"name":"is_some","qualname":"<Option<T>>::is_some","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the option is a [`Some`] value.","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/option.rs","byte_start":1467965,"byte_end":1467976,"line_start":181,"line_end":181,"column_start":5,"column_end":16}},{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1467981,"byte_end":1467990,"line_start":182,"line_end":182,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1467995,"byte_end":1468040,"line_start":183,"line_end":183,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4442},"span":{"file_name":"src/libcore/option.rs","byte_start":1468580,"byte_end":1468587,"line_start":207,"line_end":207,"column_start":12,"column_end":19},"name":"is_none","qualname":"<Option<T>>::is_none","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the option is a [`None`] value.","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/option.rs","byte_start":1468493,"byte_end":1468504,"line_start":204,"line_end":204,"column_start":5,"column_end":16}},{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1468509,"byte_end":1468518,"line_start":205,"line_end":205,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1468523,"byte_end":1468568,"line_start":206,"line_end":206,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4443},"span":{"file_name":"src/libcore/option.rs","byte_start":1469843,"byte_end":1469849,"line_start":237,"line_end":237,"column_start":12,"column_end":18},"name":"as_ref","qualname":"<Option<T>>::as_ref","value":"fn (&self) -> Option<&T>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `&Option<T>` to `Option<&T>`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1469772,"byte_end":1469781,"line_start":235,"line_end":235,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1469786,"byte_end":1469831,"line_start":236,"line_end":236,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4444},"span":{"file_name":"src/libcore/option.rs","byte_start":1470323,"byte_end":1470329,"line_start":258,"line_end":258,"column_start":12,"column_end":18},"name":"as_mut","qualname":"<Option<T>>::as_mut","value":"fn (&mut self) -> Option<&mut T>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `&mut Option<T>` to `Option<&mut T>`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1470252,"byte_end":1470261,"line_start":256,"line_end":256,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1470266,"byte_end":1470311,"line_start":257,"line_end":257,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4445},"span":{"file_name":"src/libcore/option.rs","byte_start":1470602,"byte_end":1470612,"line_start":269,"line_end":269,"column_start":12,"column_end":22},"name":"as_pin_ref","qualname":"<Option<T>>::as_pin_ref","value":"fn <'a> (self: Pin<&'a Option<T>>) -> Option<Pin<&'a T>>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `Pin<&Option<T>>` to `Option<Pin<&T>>`\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1470532,"byte_end":1470541,"line_start":267,"line_end":267,"column_start":5,"column_end":14}},{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1470546,"byte_end":1470590,"line_start":268,"line_end":268,"column_start":5,"column_end":49}}]},{"kind":"Method","id":{"krate":0,"index":4448},"span":{"file_name":"src/libcore/option.rs","byte_start":1470915,"byte_end":1470925,"line_start":278,"line_end":278,"column_start":12,"column_end":22},"name":"as_pin_mut","qualname":"<Option<T>>::as_pin_mut","value":"fn <'a> (self: Pin<&'a mut Option<T>>) -> Option<Pin<&'a mut T>>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `Pin<&mut Option<T>>` to `Option<Pin<&mut T>>`\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1470845,"byte_end":1470854,"line_start":276,"line_end":276,"column_start":5,"column_end":14}},{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1470859,"byte_end":1470903,"line_start":277,"line_end":277,"column_start":5,"column_end":49}}]},{"kind":"Method","id":{"krate":0,"index":4451},"span":{"file_name":"src/libcore/option.rs","byte_start":1471948,"byte_end":1471954,"line_start":311,"line_end":311,"column_start":12,"column_end":18},"name":"expect","qualname":"<Option<T>>::expect","value":"fn (self, msg: &str) -> T","parent":null,"children":[],"decl_id":null,"docs":" Unwraps an option, yielding the content of a [`Some`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1471877,"byte_end":1471886,"line_start":309,"line_end":309,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1471891,"byte_end":1471936,"line_start":310,"line_end":310,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4452},"span":{"file_name":"src/libcore/option.rs","byte_start":1472833,"byte_end":1472839,"line_start":344,"line_end":344,"column_start":12,"column_end":18},"name":"unwrap","qualname":"<Option<T>>::unwrap","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Moves the value `v` out of the `Option<T>` if it is [`Some(v)`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1472762,"byte_end":1472771,"line_start":342,"line_end":342,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1472776,"byte_end":1472821,"line_start":343,"line_end":343,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4453},"span":{"file_name":"src/libcore/option.rs","byte_start":1473558,"byte_end":1473567,"line_start":367,"line_end":367,"column_start":12,"column_end":21},"name":"unwrap_or","qualname":"<Option<T>>::unwrap_or","value":"fn (self, def: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the contained value or a default.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1473487,"byte_end":1473496,"line_start":365,"line_end":365,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1473501,"byte_end":1473546,"line_start":366,"line_end":366,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4454},"span":{"file_name":"src/libcore/option.rs","byte_start":1474011,"byte_end":1474025,"line_start":385,"line_end":385,"column_start":12,"column_end":26},"name":"unwrap_or_else","qualname":"<Option<T>>::unwrap_or_else","value":"fn <F> (self, f: F) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the contained value or computes it from a closure.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1473940,"byte_end":1473949,"line_start":383,"line_end":383,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1473954,"byte_end":1473999,"line_start":384,"line_end":384,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4456},"span":{"file_name":"src/libcore/option.rs","byte_start":1475054,"byte_end":1475057,"line_start":414,"line_end":414,"column_start":12,"column_end":15},"name":"map","qualname":"<Option<T>>::map","value":"fn <U, F> (self, f: F) -> Option<U>","parent":null,"children":[],"decl_id":null,"docs":" Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1474983,"byte_end":1474992,"line_start":412,"line_end":412,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1474997,"byte_end":1475042,"line_start":413,"line_end":413,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4459},"span":{"file_name":"src/libcore/option.rs","byte_start":1475624,"byte_end":1475630,"line_start":435,"line_end":435,"column_start":12,"column_end":18},"name":"map_or","qualname":"<Option<T>>::map_or","value":"fn <U, F> (self, default: U, f: F) -> U","parent":null,"children":[],"decl_id":null,"docs":" Applies a function to the contained value (if any),\n or returns the provided default (if not).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1475553,"byte_end":1475562,"line_start":433,"line_end":433,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1475567,"byte_end":1475612,"line_start":434,"line_end":434,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4462},"span":{"file_name":"src/libcore/option.rs","byte_start":1476238,"byte_end":1476249,"line_start":458,"line_end":458,"column_start":12,"column_end":23},"name":"map_or_else","qualname":"<Option<T>>::map_or_else","value":"fn <U, D, F> (self, default: D, f: F) -> U","parent":null,"children":[],"decl_id":null,"docs":" Applies a function to the contained value (if any),\n or computes a default (if not).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1476167,"byte_end":1476176,"line_start":456,"line_end":456,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1476181,"byte_end":1476226,"line_start":457,"line_end":457,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4466},"span":{"file_name":"src/libcore/option.rs","byte_start":1477351,"byte_end":1477356,"line_start":490,"line_end":490,"column_start":12,"column_end":17},"name":"ok_or","qualname":"<Option<T>>::ok_or","value":"fn <E> (self, err: E) -> Result<T, E>","parent":null,"children":[],"decl_id":null,"docs":" Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to\n [`Ok(v)`] and [`None`] to [`Err(err)`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1477280,"byte_end":1477289,"line_start":488,"line_end":488,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1477294,"byte_end":1477339,"line_start":489,"line_end":489,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4468},"span":{"file_name":"src/libcore/option.rs","byte_start":1478198,"byte_end":1478208,"line_start":517,"line_end":517,"column_start":12,"column_end":22},"name":"ok_or_else","qualname":"<Option<T>>::ok_or_else","value":"fn <E, F> (self, err: F) -> Result<T, E>","parent":null,"children":[],"decl_id":null,"docs":" Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to\n [`Ok(v)`] and [`None`] to [`Err(err())`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1478127,"byte_end":1478136,"line_start":515,"line_end":515,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1478141,"byte_end":1478186,"line_start":516,"line_end":516,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4471},"span":{"file_name":"src/libcore/option.rs","byte_start":1478903,"byte_end":1478907,"line_start":541,"line_end":541,"column_start":12,"column_end":16},"name":"iter","qualname":"<Option<T>>::iter","value":"fn (&self) -> Iter<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over the possibly contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1478832,"byte_end":1478841,"line_start":539,"line_end":539,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1478846,"byte_end":1478891,"line_start":540,"line_end":540,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4472},"span":{"file_name":"src/libcore/option.rs","byte_start":1479453,"byte_end":1479461,"line_start":562,"line_end":562,"column_start":12,"column_end":20},"name":"iter_mut","qualname":"<Option<T>>::iter_mut","value":"fn (&mut self) -> IterMut<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable iterator over the possibly contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1479382,"byte_end":1479391,"line_start":560,"line_end":560,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1479396,"byte_end":1479441,"line_start":561,"line_end":561,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4473},"span":{"file_name":"src/libcore/option.rs","byte_start":1480445,"byte_end":1480448,"line_start":595,"line_end":595,"column_start":12,"column_end":15},"name":"and","qualname":"<Option<T>>::and","value":"fn <U> (self, optb: Option<U>) -> Option<U>","parent":null,"children":[],"decl_id":null,"docs":" Returns [`None`] if the option is [`None`], otherwise returns `optb`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1480374,"byte_end":1480383,"line_start":593,"line_end":593,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1480388,"byte_end":1480433,"line_start":594,"line_end":594,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4475},"span":{"file_name":"src/libcore/option.rs","byte_start":1481302,"byte_end":1481310,"line_start":622,"line_end":622,"column_start":12,"column_end":20},"name":"and_then","qualname":"<Option<T>>::and_then","value":"fn <U, F> (self, f: F) -> Option<U>","parent":null,"children":[],"decl_id":null,"docs":" Returns [`None`] if the option is [`None`], otherwise calls `f` with the\n wrapped value and returns the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1481231,"byte_end":1481240,"line_start":620,"line_end":620,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1481245,"byte_end":1481290,"line_start":621,"line_end":621,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4478},"span":{"file_name":"src/libcore/option.rs","byte_start":1482328,"byte_end":1482334,"line_start":653,"line_end":653,"column_start":12,"column_end":18},"name":"filter","qualname":"<Option<T>>::filter","value":"fn <P> (self, predicate: P) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Returns `None` if the option is `None`, otherwise calls `predicate`\n with the wrapped value and returns:","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1482248,"byte_end":1482257,"line_start":651,"line_end":651,"column_start":5,"column_end":14}},{"value":"stable(feature = \"option_filter\", since = \"1.27.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1482262,"byte_end":1482316,"line_start":652,"line_end":652,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":4480},"span":{"file_name":"src/libcore/option.rs","byte_start":1483357,"byte_end":1483359,"line_start":691,"line_end":691,"column_start":12,"column_end":14},"name":"or","qualname":"<Option<T>>::or","value":"fn (self, optb: Option<T>) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Returns the option if it contains a value, otherwise returns `optb`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1483286,"byte_end":1483295,"line_start":689,"line_end":689,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1483300,"byte_end":1483345,"line_start":690,"line_end":690,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4481},"span":{"file_name":"src/libcore/option.rs","byte_start":1484039,"byte_end":1484046,"line_start":713,"line_end":713,"column_start":12,"column_end":19},"name":"or_else","qualname":"<Option<T>>::or_else","value":"fn <F> (self, f: F) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Returns the option if it contains a value, otherwise calls `f` and\n returns the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1483968,"byte_end":1483977,"line_start":711,"line_end":711,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1483982,"byte_end":1484027,"line_start":712,"line_end":712,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4483},"span":{"file_name":"src/libcore/option.rs","byte_start":1484915,"byte_end":1484918,"line_start":746,"line_end":746,"column_start":12,"column_end":15},"name":"xor","qualname":"<Option<T>>::xor","value":"fn (self, optb: Option<T>) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Returns [`Some`] if exactly one of `self`, `optb` is [`Some`], otherwise returns `None`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1484838,"byte_end":1484847,"line_start":744,"line_end":744,"column_start":5,"column_end":14}},{"value":"stable(feature = \"option_xor\", since = \"1.37.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1484852,"byte_end":1484903,"line_start":745,"line_end":745,"column_start":5,"column_end":56}}]},{"kind":"Method","id":{"krate":0,"index":4484},"span":{"file_name":"src/libcore/option.rs","byte_start":1485838,"byte_end":1485851,"line_start":779,"line_end":779,"column_start":12,"column_end":25},"name":"get_or_insert","qualname":"<Option<T>>::get_or_insert","value":"fn (&mut self, v: T) -> &mut T","parent":null,"children":[],"decl_id":null,"docs":" Inserts `v` into the option if it is [`None`], then\n returns a mutable reference to the contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1485759,"byte_end":1485768,"line_start":777,"line_end":777,"column_start":5,"column_end":14}},{"value":"stable(feature = \"option_entry\", since = \"1.20.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1485773,"byte_end":1485826,"line_start":778,"line_end":778,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":4485},"span":{"file_name":"src/libcore/option.rs","byte_start":1486642,"byte_end":1486660,"line_start":812,"line_end":812,"column_start":12,"column_end":30},"name":"get_or_insert_with","qualname":"<Option<T>>::get_or_insert_with","value":"fn <F> (&mut self, f: F) -> &mut T","parent":null,"children":[],"decl_id":null,"docs":" Inserts a value computed from `f` into the option if it is [`None`], then\n returns a mutable reference to the contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1486563,"byte_end":1486572,"line_start":810,"line_end":810,"column_start":5,"column_end":14}},{"value":"stable(feature = \"option_entry\", since = \"1.20.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1486577,"byte_end":1486630,"line_start":811,"line_end":811,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":4487},"span":{"file_name":"src/libcore/option.rs","byte_start":1487602,"byte_end":1487606,"line_start":847,"line_end":847,"column_start":12,"column_end":16},"name":"take","qualname":"<Option<T>>::take","value":"fn (&mut self) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Takes the value out of the option, leaving a [`None`] in its place.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1487531,"byte_end":1487540,"line_start":845,"line_end":845,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1487545,"byte_end":1487590,"line_start":846,"line_end":846,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4488},"span":{"file_name":"src/libcore/option.rs","byte_start":1488313,"byte_end":1488320,"line_start":872,"line_end":872,"column_start":12,"column_end":19},"name":"replace","qualname":"<Option<T>>::replace","value":"fn (&mut self, value: T) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Replaces the actual value in the option by the value given in parameter,\n returning the old value if present,\n leaving a [`Some`] in its place without deinitializing either one.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1488232,"byte_end":1488241,"line_start":870,"line_end":870,"column_start":5,"column_end":14}},{"value":"stable(feature = \"option_replace\", since = \"1.31.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1488246,"byte_end":1488301,"line_start":871,"line_end":871,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":4491},"span":{"file_name":"src/libcore/option.rs","byte_start":1488812,"byte_end":1488818,"line_start":891,"line_end":891,"column_start":12,"column_end":18},"name":"copied","qualname":"<Option<&'_ T>>::copied","value":"fn (self) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Maps an `Option<&T>` to an `Option<T>` by copying the contents of the\n option.","sig":null,"attributes":[{"value":"stable(feature = \"copied\", since = \"1.35.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1488753,"byte_end":1488800,"line_start":890,"line_end":890,"column_start":5,"column_end":52}}]},{"kind":"Method","id":{"krate":0,"index":4495},"span":{"file_name":"src/libcore/option.rs","byte_start":1489300,"byte_end":1489306,"line_start":910,"line_end":910,"column_start":12,"column_end":18},"name":"copied","qualname":"<Option<&'_ mut T>>::copied","value":"fn (self) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Maps an `Option<&mut T>` to an `Option<T>` by copying the contents of the\n option.","sig":null,"attributes":[{"value":"stable(feature = \"copied\", since = \"1.35.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1489241,"byte_end":1489288,"line_start":909,"line_end":909,"column_start":5,"column_end":52}}]},{"kind":"Method","id":{"krate":0,"index":4499},"span":{"file_name":"src/libcore/option.rs","byte_start":1489771,"byte_end":1489777,"line_start":929,"line_end":929,"column_start":12,"column_end":18},"name":"cloned","qualname":"<Option<&'_ T>>::cloned","value":"fn (self) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Maps an `Option<&T>` to an `Option<T>` by cloning the contents of the\n option.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1489714,"byte_end":1489759,"line_start":928,"line_end":928,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4503},"span":{"file_name":"src/libcore/option.rs","byte_start":1490282,"byte_end":1490288,"line_start":948,"line_end":948,"column_start":12,"column_end":18},"name":"cloned","qualname":"<Option<&'_ mut T>>::cloned","value":"fn (self) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Maps an `Option<&mut T>` to an `Option<T>` by cloning the contents of the\n option.","sig":null,"attributes":[{"value":"stable(since = \"1.26.0\", feature = \"option_ref_mut_cloned\")","span":{"file_name":"src/libcore/option.rs","byte_start":1490208,"byte_end":1490270,"line_start":947,"line_end":947,"column_start":5,"column_end":67}}]},{"kind":"Method","id":{"krate":0,"index":4507},"span":{"file_name":"src/libcore/option.rs","byte_start":1491568,"byte_end":1491585,"line_start":984,"line_end":984,"column_start":12,"column_end":29},"name":"unwrap_or_default","qualname":"<Option<T>>::unwrap_or_default","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the contained value or a default","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1491497,"byte_end":1491506,"line_start":982,"line_end":982,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1491511,"byte_end":1491556,"line_start":983,"line_end":983,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4510},"span":{"file_name":"src/libcore/option.rs","byte_start":1492047,"byte_end":1492052,"line_start":998,"line_end":998,"column_start":12,"column_end":17},"name":"deref","qualname":"<Option<T>>::deref","value":"fn (&self) -> Option<&T::Target>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `&Option<T>` to `Option<&T::Target>`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4515},"span":{"file_name":"src/libcore/option.rs","byte_start":1492759,"byte_end":1492768,"line_start":1021,"line_end":1021,"column_start":12,"column_end":21},"name":"transpose","qualname":"<Option<Result<T, E>>>::transpose","value":"fn (self) -> Result<Option<T>, E>","parent":null,"children":[],"decl_id":null,"docs":" Transposes an `Option` of a `Result` into a `Result` of an `Option`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1492676,"byte_end":1492685,"line_start":1019,"line_end":1019,"column_start":5,"column_end":14}},{"value":"stable(feature = \"transpose_result\", since = \"1.33.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1492690,"byte_end":1492747,"line_start":1020,"line_end":1020,"column_start":5,"column_end":62}}]},{"kind":"Struct","id":{"krate":0,"index":32889},"span":{"file_name":"src/libcore/option.rs","byte_start":1496786,"byte_end":1496790,"line_start":1180,"line_end":1180,"column_start":12,"column_end":16},"name":"Iter","qualname":"::option::Iter","value":"Iter {  }","parent":null,"children":[{"krate":0,"index":32892}],"decl_id":null,"docs":" An iterator over a reference to the [`Some`] variant of an [`Option`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1496712,"byte_end":1496757,"line_start":1178,"line_end":1178,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":32897},"span":{"file_name":"src/libcore/option.rs","byte_start":1498200,"byte_end":1498207,"line_start":1226,"line_end":1226,"column_start":12,"column_end":19},"name":"IterMut","qualname":"::option::IterMut","value":"IterMut {  }","parent":null,"children":[{"krate":0,"index":32900}],"decl_id":null,"docs":" An iterator over a mutable reference to the [`Some`] variant of an [`Option`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1498126,"byte_end":1498171,"line_start":1224,"line_end":1224,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":32905},"span":{"file_name":"src/libcore/option.rs","byte_start":1499469,"byte_end":1499477,"line_start":1263,"line_end":1263,"column_start":12,"column_end":20},"name":"IntoIter","qualname":"::option::IntoIter","value":"IntoIter {  }","parent":null,"children":[{"krate":0,"index":32907}],"decl_id":null,"docs":" An iterator over the value in [`Some`] variant of an [`Option`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1499412,"byte_end":1499457,"line_start":1262,"line_end":1262,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":32914},"span":{"file_name":"src/libcore/option.rs","byte_start":1504398,"byte_end":1504407,"line_start":1411,"line_end":1411,"column_start":12,"column_end":21},"name":"NoneError","qualname":"::option::NoneError","value":"","parent":null,"children":[],"decl_id":null,"docs":" The error type that results from applying the try operator (`?`) to a `None` value. If you wish\n to allow `x?` (where `x` is an `Option<T>`) to be converted into your error type, you can\n implement `impl From<NoneError>` for `YourErrorType`. In that case, `x?` within a function that\n returns `Result<_, YourErrorType>` will translate a `None` value into an `Err` result.\n","sig":null,"attributes":[{"value":"unstable(feature = \"try_trait\", issue = \"42327\")","span":{"file_name":"src/libcore/option.rs","byte_start":1504267,"byte_end":1504318,"line_start":1409,"line_end":1409,"column_start":1,"column_end":52}},{"value":"structural_match","span":{"file_name":"src/libcore/option.rs","byte_start":1504387,"byte_end":1504408,"line_start":1411,"line_end":1411,"column_start":1,"column_end":22}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/option.rs","byte_start":1504387,"byte_end":1504408,"line_start":1411,"line_end":1411,"column_start":1,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":4639},"span":{"file_name":"src/libcore/option.rs","byte_start":1505642,"byte_end":1505649,"line_start":1459,"line_end":1459,"column_start":12,"column_end":19},"name":"flatten","qualname":"<Option<Option<T>>>::flatten","value":"fn (self) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `Option<Option<T>>` to `Option<T>`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1505557,"byte_end":1505566,"line_start":1457,"line_end":1457,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"option_flattening\", issue = \"60258\")","span":{"file_name":"src/libcore/option.rs","byte_start":1505571,"byte_end":1505630,"line_start":1458,"line_end":1458,"column_start":5,"column_end":64}}]},{"kind":"Mod","id":{"krate":0,"index":4640},"span":{"file_name":"src/libcore/raw.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"raw","qualname":"::raw","value":"src/libcore/raw.rs","parent":null,"children":[{"krate":0,"index":32932},{"krate":0,"index":32937},{"krate":0,"index":32935}],"decl_id":null,"docs":" Contains struct definitions for the layout of compiler built-in types.","sig":null,"attributes":[{"value":"allow(missing_docs)","span":{"file_name":"src/libcore/raw.rs","byte_start":1505721,"byte_end":1505744,"line_start":1,"line_end":1,"column_start":1,"column_end":24}},{"value":"unstable(feature = \"raw\", issue = \"27751\")","span":{"file_name":"src/libcore/raw.rs","byte_start":1505745,"byte_end":1505791,"line_start":2,"line_end":2,"column_start":1,"column_end":47}}]},{"kind":"Struct","id":{"krate":0,"index":32932},"span":{"file_name":"src/libcore/raw.rs","byte_start":1508379,"byte_end":1508390,"line_start":82,"line_end":82,"column_start":12,"column_end":23},"name":"TraitObject","qualname":"::raw::TraitObject","value":"TraitObject { data, vtable }","parent":null,"children":[{"krate":0,"index":32933},{"krate":0,"index":32934}],"decl_id":null,"docs":" The representation of a trait object like `&SomeTrait`.","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"src/libcore/raw.rs","byte_start":1508294,"byte_end":1508304,"line_start":79,"line_end":79,"column_start":1,"column_end":11}},{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/raw.rs","byte_start":1508328,"byte_end":1508367,"line_start":81,"line_end":81,"column_start":1,"column_end":40}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/raw.rs","byte_start":1508368,"byte_end":1508442,"line_start":82,"line_end":85,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":32933},"span":{"file_name":"src/libcore/raw.rs","byte_start":1508401,"byte_end":1508405,"line_start":83,"line_end":83,"column_start":9,"column_end":13},"name":"data","qualname":"::raw::TraitObject::data","value":"*mut ()","parent":{"krate":0,"index":32932},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":32934},"span":{"file_name":"src/libcore/raw.rs","byte_start":1508424,"byte_end":1508430,"line_start":84,"line_end":84,"column_start":9,"column_end":15},"name":"vtable","qualname":"::raw::TraitObject::vtable","value":"*mut ()","parent":{"krate":0,"index":32932},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4641},"span":{"file_name":"src/libcore/result.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"result","qualname":"::result","value":"src/libcore/result.rs","parent":null,"children":[{"krate":0,"index":4642},{"krate":0,"index":4643},{"krate":0,"index":4647},{"krate":0,"index":32938},{"krate":0,"index":32977},{"krate":0,"index":32972},{"krate":0,"index":32964},{"krate":0,"index":32960},{"krate":0,"index":32956},{"krate":0,"index":32952},{"krate":0,"index":32947},{"krate":0,"index":4650},{"krate":0,"index":4684},{"krate":0,"index":4689},{"krate":0,"index":4694},{"krate":0,"index":4698},{"krate":0,"index":4703},{"krate":0,"index":4708},{"krate":0,"index":4714},{"krate":0,"index":4718},{"krate":0,"index":4720},{"krate":0,"index":4725},{"krate":0,"index":4731},{"krate":0,"index":4738},{"krate":0,"index":32980},{"krate":0,"index":32984},{"krate":0,"index":4745},{"krate":0,"index":4751},{"krate":0,"index":4755},{"krate":0,"index":4757},{"krate":0,"index":4759},{"krate":0,"index":4761},{"krate":0,"index":32988},{"krate":0,"index":32992},{"krate":0,"index":4764},{"krate":0,"index":4770},{"krate":0,"index":4774},{"krate":0,"index":4776},{"krate":0,"index":4778},{"krate":0,"index":32996},{"krate":0,"index":33002},{"krate":0,"index":32999},{"krate":0,"index":4780},{"krate":0,"index":4785},{"krate":0,"index":4788},{"krate":0,"index":4790},{"krate":0,"index":4792},{"krate":0,"index":4794},{"krate":0,"index":4812}],"decl_id":null,"docs":" Error handling with the `Result` type.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1515843,"byte_end":1515889,"line_start":231,"line_end":231,"column_start":1,"column_end":47}}]},{"kind":"TupleVariant","id":{"krate":0,"index":32941},"span":{"file_name":"src/libcore/result.rs","byte_start":1516547,"byte_end":1516549,"line_start":249,"line_end":249,"column_start":5,"column_end":7},"name":"Ok","qualname":"::result::Result::Ok","value":"Result::Ok(T)","parent":{"krate":0,"index":32938},"children":[],"decl_id":null,"docs":" Contains the success value\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1516497,"byte_end":1516542,"line_start":248,"line_end":248,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":32944},"span":{"file_name":"src/libcore/result.rs","byte_start":1516688,"byte_end":1516691,"line_start":253,"line_end":253,"column_start":5,"column_end":8},"name":"Err","qualname":"::result::Result::Err","value":"Result::Err(E)","parent":{"krate":0,"index":32938},"children":[],"decl_id":null,"docs":" Contains the error value\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1516638,"byte_end":1516683,"line_start":252,"line_end":252,"column_start":5,"column_end":50}}]},{"kind":"Enum","id":{"krate":0,"index":32938},"span":{"file_name":"src/libcore/result.rs","byte_start":1516443,"byte_end":1516449,"line_start":246,"line_end":246,"column_start":10,"column_end":16},"name":"Result","qualname":"::result::Result","value":"Result::{Ok, Err}","parent":null,"children":[{"krate":0,"index":32941},{"krate":0,"index":32944}],"decl_id":null,"docs":" `Result` is a type that represents either success ([`Ok`]) or failure ([`Err`]).","sig":null,"attributes":[{"value":"must_use = \"this `Result` may be an `Err` variant, which should be handled\"","span":{"file_name":"src/libcore/result.rs","byte_start":1516309,"byte_end":1516387,"line_start":244,"line_end":244,"column_start":1,"column_end":79}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1516388,"byte_end":1516433,"line_start":245,"line_end":245,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/result.rs","byte_start":1516434,"byte_end":1516743,"line_start":246,"line_end":254,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/result.rs","byte_start":1516434,"byte_end":1516743,"line_start":246,"line_end":254,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":4653},"span":{"file_name":"src/libcore/result.rs","byte_start":1517612,"byte_end":1517617,"line_start":283,"line_end":283,"column_start":12,"column_end":17},"name":"is_ok","qualname":"<Result<T, E>>::is_ok","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the result is [`Ok`].","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/result.rs","byte_start":1517525,"byte_end":1517536,"line_start":280,"line_end":280,"column_start":5,"column_end":16}},{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1517541,"byte_end":1517550,"line_start":281,"line_end":281,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1517555,"byte_end":1517600,"line_start":282,"line_end":282,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4654},"span":{"file_name":"src/libcore/result.rs","byte_start":1518201,"byte_end":1518207,"line_start":308,"line_end":308,"column_start":12,"column_end":18},"name":"is_err","qualname":"<Result<T, E>>::is_err","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the result is [`Err`].","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/result.rs","byte_start":1518114,"byte_end":1518125,"line_start":305,"line_end":305,"column_start":5,"column_end":16}},{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1518130,"byte_end":1518139,"line_start":306,"line_end":306,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1518144,"byte_end":1518189,"line_start":307,"line_end":307,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4655},"span":{"file_name":"src/libcore/result.rs","byte_start":1519018,"byte_end":1519020,"line_start":336,"line_end":336,"column_start":12,"column_end":14},"name":"ok","qualname":"<Result<T, E>>::ok","value":"fn (self) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `Result<T, E>` to [`Option<T>`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1518947,"byte_end":1518956,"line_start":334,"line_end":334,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1518961,"byte_end":1519006,"line_start":335,"line_end":335,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4656},"span":{"file_name":"src/libcore/result.rs","byte_start":1519737,"byte_end":1519740,"line_start":363,"line_end":363,"column_start":12,"column_end":15},"name":"err","qualname":"<Result<T, E>>::err","value":"fn (self) -> Option<E>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `Result<T, E>` to [`Option<E>`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1519666,"byte_end":1519675,"line_start":361,"line_end":361,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1519680,"byte_end":1519725,"line_start":362,"line_end":362,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4657},"span":{"file_name":"src/libcore/result.rs","byte_start":1520589,"byte_end":1520595,"line_start":392,"line_end":392,"column_start":12,"column_end":18},"name":"as_ref","qualname":"<Result<T, E>>::as_ref","value":"fn (&self) -> Result<&T, &E>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `&Result<T, E>` to `Result<&T, &E>`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1520518,"byte_end":1520527,"line_start":390,"line_end":390,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1520532,"byte_end":1520577,"line_start":391,"line_end":391,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4658},"span":{"file_name":"src/libcore/result.rs","byte_start":1521362,"byte_end":1521368,"line_start":423,"line_end":423,"column_start":12,"column_end":18},"name":"as_mut","qualname":"<Result<T, E>>::as_mut","value":"fn (&mut self) -> Result<&mut T, &mut E>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `&mut Result<T, E>` to `Result<&mut T, &mut E>`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1521291,"byte_end":1521300,"line_start":421,"line_end":421,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1521305,"byte_end":1521350,"line_start":422,"line_end":422,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4659},"span":{"file_name":"src/libcore/result.rs","byte_start":1522481,"byte_end":1522484,"line_start":458,"line_end":458,"column_start":12,"column_end":15},"name":"map","qualname":"<Result<T, E>>::map","value":"fn <U, F> (self, op: F) -> Result<U, E>","parent":null,"children":[],"decl_id":null,"docs":" Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a\n contained [`Ok`] value, leaving an [`Err`] value untouched.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1522410,"byte_end":1522419,"line_start":456,"line_end":456,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1522424,"byte_end":1522469,"line_start":457,"line_end":457,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4662},"span":{"file_name":"src/libcore/result.rs","byte_start":1523467,"byte_end":1523478,"line_start":491,"line_end":491,"column_start":12,"column_end":23},"name":"map_or_else","qualname":"<Result<T, E>>::map_or_else","value":"fn <U, M, F> (self, fallback: F, map: M) -> U","parent":null,"children":[],"decl_id":null,"docs":" Maps a `Result<T, E>` to `U` by applying a function to a\n contained [`Ok`] value, or a fallback function to a\n contained [`Err`] value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1523381,"byte_end":1523390,"line_start":489,"line_end":489,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"result_map_or_else\", issue = \"53268\")","span":{"file_name":"src/libcore/result.rs","byte_start":1523395,"byte_end":1523455,"line_start":490,"line_end":490,"column_start":5,"column_end":65}}]},{"kind":"Method","id":{"krate":0,"index":4666},"span":{"file_name":"src/libcore/result.rs","byte_start":1524422,"byte_end":1524429,"line_start":519,"line_end":519,"column_start":12,"column_end":19},"name":"map_err","qualname":"<Result<T, E>>::map_err","value":"fn <F, O> (self, op: O) -> Result<T, F>","parent":null,"children":[],"decl_id":null,"docs":" Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n contained [`Err`] value, leaving an [`Ok`] value untouched.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1524351,"byte_end":1524360,"line_start":517,"line_end":517,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1524365,"byte_end":1524410,"line_start":518,"line_end":518,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4669},"span":{"file_name":"src/libcore/result.rs","byte_start":1525280,"byte_end":1525284,"line_start":547,"line_end":547,"column_start":12,"column_end":16},"name":"iter","qualname":"<Result<T, E>>::iter","value":"fn (&self) -> Iter<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over the possibly contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1525209,"byte_end":1525218,"line_start":545,"line_end":545,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1525223,"byte_end":1525268,"line_start":546,"line_end":546,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4670},"span":{"file_name":"src/libcore/result.rs","byte_start":1525977,"byte_end":1525985,"line_start":572,"line_end":572,"column_start":12,"column_end":20},"name":"iter_mut","qualname":"<Result<T, E>>::iter_mut","value":"fn (&mut self) -> IterMut<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable iterator over the possibly contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1525906,"byte_end":1525915,"line_start":570,"line_end":570,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1525920,"byte_end":1525965,"line_start":571,"line_end":571,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4671},"span":{"file_name":"src/libcore/result.rs","byte_start":1527277,"byte_end":1527280,"line_start":608,"line_end":608,"column_start":12,"column_end":15},"name":"and","qualname":"<Result<T, E>>::and","value":"fn <U> (self, res: Result<U, E>) -> Result<U, E>","parent":null,"children":[],"decl_id":null,"docs":" Returns `res` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1527206,"byte_end":1527215,"line_start":606,"line_end":606,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1527220,"byte_end":1527265,"line_start":607,"line_end":607,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4673},"span":{"file_name":"src/libcore/result.rs","byte_start":1528223,"byte_end":1528231,"line_start":637,"line_end":637,"column_start":12,"column_end":20},"name":"and_then","qualname":"<Result<T, E>>::and_then","value":"fn <U, F> (self, op: F) -> Result<U, E>","parent":null,"children":[],"decl_id":null,"docs":" Calls `op` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1528152,"byte_end":1528161,"line_start":635,"line_end":635,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1528166,"byte_end":1528211,"line_start":636,"line_end":636,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4676},"span":{"file_name":"src/libcore/result.rs","byte_start":1529543,"byte_end":1529545,"line_start":677,"line_end":677,"column_start":12,"column_end":14},"name":"or","qualname":"<Result<T, E>>::or","value":"fn <F> (self, res: Result<T, F>) -> Result<T, F>","parent":null,"children":[],"decl_id":null,"docs":" Returns `res` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1529472,"byte_end":1529481,"line_start":675,"line_end":675,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1529486,"byte_end":1529531,"line_start":676,"line_end":676,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4678},"span":{"file_name":"src/libcore/result.rs","byte_start":1530477,"byte_end":1530484,"line_start":706,"line_end":706,"column_start":12,"column_end":19},"name":"or_else","qualname":"<Result<T, E>>::or_else","value":"fn <F, O> (self, op: O) -> Result<T, F>","parent":null,"children":[],"decl_id":null,"docs":" Calls `op` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1530406,"byte_end":1530415,"line_start":704,"line_end":704,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1530420,"byte_end":1530465,"line_start":705,"line_end":705,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4681},"span":{"file_name":"src/libcore/result.rs","byte_start":1531467,"byte_end":1531476,"line_start":738,"line_end":738,"column_start":12,"column_end":21},"name":"unwrap_or","qualname":"<Result<T, E>>::unwrap_or","value":"fn (self, optb: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Unwraps a result, yielding the content of an [`Ok`].\n Else, it returns `optb`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1531396,"byte_end":1531405,"line_start":736,"line_end":736,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1531410,"byte_end":1531455,"line_start":737,"line_end":737,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4682},"span":{"file_name":"src/libcore/result.rs","byte_start":1532144,"byte_end":1532158,"line_start":763,"line_end":763,"column_start":12,"column_end":26},"name":"unwrap_or_else","qualname":"<Result<T, E>>::unwrap_or_else","value":"fn <F> (self, op: F) -> T","parent":null,"children":[],"decl_id":null,"docs":" Unwraps a result, yielding the content of an [`Ok`].\n If the value is an [`Err`] then it calls `op` with its value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1532073,"byte_end":1532082,"line_start":761,"line_end":761,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1532087,"byte_end":1532132,"line_start":762,"line_end":762,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4687},"span":{"file_name":"src/libcore/result.rs","byte_start":1533028,"byte_end":1533034,"line_start":797,"line_end":797,"column_start":12,"column_end":18},"name":"unwrap","qualname":"<Result<T, E>>::unwrap","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Unwraps a result, yielding the content of an [`Ok`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1532957,"byte_end":1532966,"line_start":795,"line_end":795,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1532971,"byte_end":1533016,"line_start":796,"line_end":796,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4688},"span":{"file_name":"src/libcore/result.rs","byte_start":1533857,"byte_end":1533863,"line_start":824,"line_end":824,"column_start":12,"column_end":18},"name":"expect","qualname":"<Result<T, E>>::expect","value":"fn (self, msg: &str) -> T","parent":null,"children":[],"decl_id":null,"docs":" Unwraps a result, yielding the content of an [`Ok`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1533778,"byte_end":1533787,"line_start":822,"line_end":822,"column_start":5,"column_end":14}},{"value":"stable(feature = \"result_expect\", since = \"1.4.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1533792,"byte_end":1533845,"line_start":823,"line_end":823,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":4692},"span":{"file_name":"src/libcore/result.rs","byte_start":1534730,"byte_end":1534740,"line_start":857,"line_end":857,"column_start":12,"column_end":22},"name":"unwrap_err","qualname":"<Result<T, E>>::unwrap_err","value":"fn (self) -> E","parent":null,"children":[],"decl_id":null,"docs":" Unwraps a result, yielding the content of an [`Err`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1534659,"byte_end":1534668,"line_start":855,"line_end":855,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1534673,"byte_end":1534718,"line_start":856,"line_end":856,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4693},"span":{"file_name":"src/libcore/result.rs","byte_start":1535549,"byte_end":1535559,"line_start":884,"line_end":884,"column_start":12,"column_end":22},"name":"expect_err","qualname":"<Result<T, E>>::expect_err","value":"fn (self, msg: &str) -> E","parent":null,"children":[],"decl_id":null,"docs":" Unwraps a result, yielding the content of an [`Err`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1535465,"byte_end":1535474,"line_start":882,"line_end":882,"column_start":5,"column_end":14}},{"value":"stable(feature = \"result_expect_err\", since = \"1.17.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1535479,"byte_end":1535537,"line_start":883,"line_end":883,"column_start":5,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":4697},"span":{"file_name":"src/libcore/result.rs","byte_start":1536877,"byte_end":1536894,"line_start":922,"line_end":922,"column_start":12,"column_end":29},"name":"unwrap_or_default","qualname":"<Result<T, E>>::unwrap_or_default","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the contained value or a default","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1536786,"byte_end":1536795,"line_start":920,"line_end":920,"column_start":5,"column_end":14}},{"value":"stable(feature = \"result_unwrap_or_default\", since = \"1.16.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1536800,"byte_end":1536865,"line_start":921,"line_end":921,"column_start":5,"column_end":70}}]},{"kind":"Method","id":{"krate":0,"index":4701},"span":{"file_name":"src/libcore/result.rs","byte_start":1537391,"byte_end":1537399,"line_start":937,"line_end":937,"column_start":12,"column_end":20},"name":"deref_ok","qualname":"<Result<T, E>>::deref_ok","value":"fn (&self) -> Result<&T::Target, &E>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `&Result<T, E>` to `Result<&T::Target, &E>`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4706},"span":{"file_name":"src/libcore/result.rs","byte_start":1537863,"byte_end":1537872,"line_start":949,"line_end":949,"column_start":12,"column_end":21},"name":"deref_err","qualname":"<Result<T, E>>::deref_err","value":"fn (&self) -> Result<&T, &E::Target>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `&Result<T, E>` to `Result<&T, &E::Target>`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4711},"span":{"file_name":"src/libcore/result.rs","byte_start":1538374,"byte_end":1538379,"line_start":962,"line_end":962,"column_start":12,"column_end":17},"name":"deref","qualname":"<Result<T, E>>::deref","value":"fn (&self) -> Result<&T::Target, &E::Target>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `&Result<T, E>` to `Result<&T::Target, &E::Target>`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4717},"span":{"file_name":"src/libcore/result.rs","byte_start":1539125,"byte_end":1539134,"line_start":986,"line_end":986,"column_start":12,"column_end":21},"name":"transpose","qualname":"<Result<Option<T>, E>>::transpose","value":"fn (self) -> Option<Result<T, E>>","parent":null,"children":[],"decl_id":null,"docs":" Transposes a `Result` of an `Option` into an `Option` of a `Result`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1539042,"byte_end":1539051,"line_start":984,"line_end":984,"column_start":5,"column_end":14}},{"value":"stable(feature = \"transpose_result\", since = \"1.33.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1539056,"byte_end":1539113,"line_start":985,"line_end":985,"column_start":5,"column_end":62}}]},{"kind":"Struct","id":{"krate":0,"index":32980},"span":{"file_name":"src/libcore/result.rs","byte_start":1542013,"byte_end":1542017,"line_start":1090,"line_end":1090,"column_start":12,"column_end":16},"name":"Iter","qualname":"::result::Iter","value":"Iter {  }","parent":null,"children":[{"krate":0,"index":32983}],"decl_id":null,"docs":" An iterator over a reference to the [`Ok`] variant of a [`Result`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1541956,"byte_end":1542001,"line_start":1089,"line_end":1089,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":32988},"span":{"file_name":"src/libcore/result.rs","byte_start":1543336,"byte_end":1543343,"line_start":1135,"line_end":1135,"column_start":12,"column_end":19},"name":"IterMut","qualname":"::result::IterMut","value":"IterMut {  }","parent":null,"children":[{"krate":0,"index":32991}],"decl_id":null,"docs":" An iterator over a mutable reference to the [`Ok`] variant of a [`Result`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1543279,"byte_end":1543324,"line_start":1134,"line_end":1134,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":32996},"span":{"file_name":"src/libcore/result.rs","byte_start":1544766,"byte_end":1544774,"line_start":1178,"line_end":1178,"column_start":12,"column_end":20},"name":"IntoIter","qualname":"::result::IntoIter","value":"IntoIter {  }","parent":null,"children":[{"krate":0,"index":32998}],"decl_id":null,"docs":" An iterator over the value in a [`Ok`] variant of a [`Result`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1544709,"byte_end":1544754,"line_start":1177,"line_end":1177,"column_start":1,"column_end":46}}]},{"kind":"Mod","id":{"krate":0,"index":4820},"span":{"file_name":"src/libcore/ffi.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"ffi","qualname":"::ffi","value":"src/libcore/ffi.rs","parent":null,"children":[{"krate":0,"index":4821},{"krate":0,"index":4822},{"krate":0,"index":4823},{"krate":0,"index":4826},{"krate":0,"index":4831},{"krate":0,"index":33005},{"krate":0,"index":33012},{"krate":0,"index":33015},{"krate":0,"index":33020},{"krate":0,"index":4833},{"krate":0,"index":4837},{"krate":0,"index":4842},{"krate":0,"index":4846},{"krate":0,"index":4848},{"krate":0,"index":33024},{"krate":0,"index":33025},{"krate":0,"index":33026},{"krate":0,"index":33027},{"krate":0,"index":33028},{"krate":0,"index":33029},{"krate":0,"index":33030},{"krate":0,"index":33031},{"krate":0,"index":33032},{"krate":0,"index":33033},{"krate":0,"index":33034},{"krate":0,"index":4849},{"krate":0,"index":4851},{"krate":0,"index":4853},{"krate":0,"index":4861},{"krate":0,"index":4864},{"krate":0,"index":4867}],"decl_id":null,"docs":" Utilities related to FFI bindings.\n","sig":null,"attributes":[{"value":"stable(feature = \"\", since = \"1.30.0\")","span":{"file_name":"src/libcore/ffi.rs","byte_start":1549020,"byte_end":1549062,"line_start":1,"line_end":1,"column_start":1,"column_end":43}},{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/ffi.rs","byte_start":1549064,"byte_end":1549095,"line_start":3,"line_end":3,"column_start":1,"column_end":32}}]},{"kind":"TupleVariant","id":{"krate":0,"index":4827},"span":{"file_name":"src/libcore/ffi.rs","byte_start":1550561,"byte_end":1550571,"line_start":36,"line_end":36,"column_start":20,"column_end":30},"name":"__variant1","qualname":"::ffi::c_void::__variant1","value":"c_void::__variant1","parent":{"krate":0,"index":4826},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"c_void_variant\",\n           reason = \"temporary implementation detail\",\n           issue = \"0\")","span":{"file_name":"src/libcore/ffi.rs","byte_start":1550430,"byte_end":1550541,"line_start":34,"line_end":35,"column_start":5,"column_end":29}}]},{"kind":"TupleVariant","id":{"krate":0,"index":4829},"span":{"file_name":"src/libcore/ffi.rs","byte_start":1550708,"byte_end":1550718,"line_start":39,"line_end":39,"column_start":20,"column_end":30},"name":"__variant2","qualname":"::ffi::c_void::__variant2","value":"c_void::__variant2","parent":{"krate":0,"index":4826},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"c_void_variant\",\n           reason = \"temporary implementation detail\",\n           issue = \"0\")","span":{"file_name":"src/libcore/ffi.rs","byte_start":1550577,"byte_end":1550688,"line_start":37,"line_end":38,"column_start":5,"column_end":29}}]},{"kind":"Enum","id":{"krate":0,"index":4826},"span":{"file_name":"src/libcore/ffi.rs","byte_start":1550417,"byte_end":1550423,"line_start":33,"line_end":33,"column_start":10,"column_end":16},"name":"c_void","qualname":"::ffi::c_void","value":"c_void::{__variant1, __variant2}","parent":null,"children":[{"krate":0,"index":4827},{"krate":0,"index":4829}],"decl_id":null,"docs":" Equivalent to C's `void` type when used as a [pointer].","sig":null,"attributes":[{"value":"repr(u8)","span":{"file_name":"src/libcore/ffi.rs","byte_start":1550349,"byte_end":1550360,"line_start":31,"line_end":31,"column_start":1,"column_end":12}},{"value":"stable(feature = \"raw_os\", since = \"1.1.0\")","span":{"file_name":"src/libcore/ffi.rs","byte_start":1550361,"byte_end":1550407,"line_start":32,"line_end":32,"column_start":1,"column_end":47}}]},{"kind":"Struct","id":{"krate":0,"index":33005},"span":{"file_name":"src/libcore/ffi.rs","byte_start":1553707,"byte_end":1553717,"line_start":129,"line_end":129,"column_start":12,"column_end":22},"name":"VaListImpl","qualname":"::ffi::VaListImpl","value":"VaListImpl {  }","parent":null,"children":[{"krate":0,"index":33007},{"krate":0,"index":33008},{"krate":0,"index":33009},{"krate":0,"index":33010},{"krate":0,"index":33011}],"decl_id":null,"docs":" x86_64 ABI implementation of a `va_list`.\n","sig":null,"attributes":[{"value":"cfg(all(target_arch = \"x86_64\", not(windows)))","span":{"file_name":"src/libcore/ffi.rs","byte_start":1553407,"byte_end":1553456,"line_start":121,"line_end":121,"column_start":1,"column_end":50}},{"value":"repr(C)","span":{"file_name":"src/libcore/ffi.rs","byte_start":1553457,"byte_end":1553467,"line_start":122,"line_end":122,"column_start":1,"column_end":11}},{"value":"unstable(feature = \"c_variadic\",\n           reason =\n               \"the `c_variadic` feature has not been properly tested on \\\n                     all supported platforms\",\n           issue = \"44930\")","span":{"file_name":"src/libcore/ffi.rs","byte_start":1553485,"byte_end":1553675,"line_start":124,"line_end":127,"column_start":1,"column_end":29}},{"value":"lang = \"va_list\"","span":{"file_name":"src/libcore/ffi.rs","byte_start":1553676,"byte_end":1553695,"line_start":128,"line_end":128,"column_start":1,"column_end":20}}]},{"kind":"Struct","id":{"krate":0,"index":33015},"span":{"file_name":"src/libcore/ffi.rs","byte_start":1555493,"byte_end":1555499,"line_start":176,"line_end":176,"column_start":12,"column_end":18},"name":"VaList","qualname":"::ffi::VaList","value":"VaList {  }","parent":null,"children":[{"krate":0,"index":33018},{"krate":0,"index":33019}],"decl_id":null,"docs":" A wrapper for a `va_list`\n","sig":null,"attributes":[{"value":"repr(transparent)","span":{"file_name":"src/libcore/ffi.rs","byte_start":1555253,"byte_end":1555273,"line_start":170,"line_end":170,"column_start":1,"column_end":21}},{"value":"unstable(feature = \"c_variadic\",\n           reason =\n               \"the `c_variadic` feature has not been properly tested on \\\n                     all supported platforms\",\n           issue = \"44930\")","span":{"file_name":"src/libcore/ffi.rs","byte_start":1555291,"byte_end":1555481,"line_start":172,"line_end":175,"column_start":1,"column_end":29}}]},{"kind":"Method","id":{"krate":0,"index":4835},"span":{"file_name":"src/libcore/ffi.rs","byte_start":1557389,"byte_end":1557399,"line_start":222,"line_end":222,"column_start":12,"column_end":22},"name":"as_va_list","qualname":"<VaListImpl>::as_va_list","value":"fn <'a> (&'a mut self) -> VaList<'a, 'f>","parent":null,"children":[],"decl_id":null,"docs":" Convert a `VaListImpl` into a `VaList` that is binary-compatible with C's `va_list`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ffi.rs","byte_start":1557368,"byte_end":1557377,"line_start":221,"line_end":221,"column_start":5,"column_end":14}}]},{"kind":"Trait","id":{"krate":0,"index":4847},"span":{"file_name":"src/libcore/ffi.rs","byte_start":1559167,"byte_end":1559176,"line_start":271,"line_end":271,"column_start":15,"column_end":24},"name":"VaArgSafe","qualname":"::ffi::sealed_trait::VaArgSafe","value":"VaArgSafe","parent":null,"children":[],"decl_id":null,"docs":" Trait which whitelists the allowed types to be used with [VaList::arg]","sig":null,"attributes":[{"value":"unstable(feature = \"c_variadic\",\n           reason =\n               \"the `c_variadic` feature has not been properly tested on \\\n                         all supported platforms\",\n           issue = \"44930\")","span":{"file_name":"src/libcore/ffi.rs","byte_start":1558950,"byte_end":1559152,"line_start":267,"line_end":270,"column_start":5,"column_end":33}}]},{"kind":"Method","id":{"krate":0,"index":4855},"span":{"file_name":"src/libcore/ffi.rs","byte_start":1560452,"byte_end":1560455,"line_start":309,"line_end":309,"column_start":19,"column_end":22},"name":"arg","qualname":"<VaListImpl>::arg","value":"fn <T> (&mut self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Advance to the next arg.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ffi.rs","byte_start":1560424,"byte_end":1560433,"line_start":308,"line_end":308,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":4857},"span":{"file_name":"src/libcore/ffi.rs","byte_start":1560602,"byte_end":1560611,"line_start":314,"line_end":314,"column_start":19,"column_end":28},"name":"with_copy","qualname":"<VaListImpl>::with_copy","value":"fn <F, R> (&self, f: F) -> R","parent":null,"children":[],"decl_id":null,"docs":" Copies the `va_list` at the current location.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4873},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"slice","qualname":"::slice","value":"src/libcore/slice/mod.rs","parent":null,"children":[{"krate":0,"index":4874},{"krate":0,"index":4879},{"krate":0,"index":4880},{"krate":0,"index":4881},{"krate":0,"index":4885},{"krate":0,"index":4886},{"krate":0,"index":4887},{"krate":0,"index":4891},{"krate":0,"index":4892},{"krate":0,"index":4895},{"krate":0,"index":4896},{"krate":0,"index":4899},{"krate":0,"index":4900},{"krate":0,"index":4901},{"krate":0,"index":4907},{"krate":0,"index":4924},{"krate":0,"index":4942},{"krate":0,"index":5021},{"krate":0,"index":5139},{"krate":0,"index":5146},{"krate":0,"index":5151},{"krate":0,"index":5155},{"krate":0,"index":5156},{"krate":0,"index":5157},{"krate":0,"index":5158},{"krate":0,"index":5168},{"krate":0,"index":5177},{"krate":0,"index":5186},{"krate":0,"index":5195},{"krate":0,"index":5204},{"krate":0,"index":5213},{"krate":0,"index":5222},{"krate":0,"index":5231},{"krate":0,"index":5240},{"krate":0,"index":5243},{"krate":0,"index":5246},{"krate":0,"index":5252},{"krate":0,"index":5258},{"krate":0,"index":5260},{"krate":0,"index":5261},{"krate":0,"index":5262},{"krate":0,"index":5263},{"krate":0,"index":5269},{"krate":0,"index":5272},{"krate":0,"index":5274},{"krate":0,"index":5276},{"krate":0,"index":33037},{"krate":0,"index":33038},{"krate":0,"index":33039},{"krate":0,"index":33040},{"krate":0,"index":33046},{"krate":0,"index":33050},{"krate":0,"index":33078},{"krate":0,"index":33090},{"krate":0,"index":33092},{"krate":0,"index":5280},{"krate":0,"index":5283},{"krate":0,"index":5286},{"krate":0,"index":5292},{"krate":0,"index":5295},{"krate":0,"index":5297},{"krate":0,"index":5299},{"krate":0,"index":33094},{"krate":0,"index":33095},{"krate":0,"index":33096},{"krate":0,"index":33097},{"krate":0,"index":33103},{"krate":0,"index":33107},{"krate":0,"index":33131},{"krate":0,"index":33143},{"krate":0,"index":33145},{"krate":0,"index":5304},{"krate":0,"index":5306},{"krate":0,"index":5313},{"krate":0,"index":5317},{"krate":0,"index":5321},{"krate":0,"index":5329},{"krate":0,"index":5335},{"krate":0,"index":5340},{"krate":0,"index":5343},{"krate":0,"index":5350},{"krate":0,"index":5354},{"krate":0,"index":5359},{"krate":0,"index":5367},{"krate":0,"index":5373},{"krate":0,"index":33147},{"krate":0,"index":33152},{"krate":0,"index":5376},{"krate":0,"index":5380},{"krate":0,"index":5387},{"krate":0,"index":5392},{"krate":0,"index":5397},{"krate":0,"index":5400},{"krate":0,"index":5405},{"krate":0,"index":5409},{"krate":0,"index":5414},{"krate":0,"index":5421},{"krate":0,"index":5426},{"krate":0,"index":33157},{"krate":0,"index":33161},{"krate":0,"index":5429},{"krate":0,"index":5436},{"krate":0,"index":5441},{"krate":0,"index":5445},{"krate":0,"index":5450},{"krate":0,"index":5454},{"krate":0,"index":5459},{"krate":0,"index":5463},{"krate":0,"index":5468},{"krate":0,"index":5472},{"krate":0,"index":33164},{"krate":0,"index":33171},{"krate":0,"index":33175},{"krate":0,"index":33182},{"krate":0,"index":33186},{"krate":0,"index":33193},{"krate":0,"index":33197},{"krate":0,"index":33204},{"krate":0,"index":33208},{"krate":0,"index":33213},{"krate":0,"index":5473},{"krate":0,"index":5476},{"krate":0,"index":5485},{"krate":0,"index":5490},{"krate":0,"index":5492},{"krate":0,"index":5494},{"krate":0,"index":5496},{"krate":0,"index":33217},{"krate":0,"index":33222},{"krate":0,"index":5501},{"krate":0,"index":5504},{"krate":0,"index":5513},{"krate":0,"index":5518},{"krate":0,"index":5520},{"krate":0,"index":5522},{"krate":0,"index":5524},{"krate":0,"index":33226},{"krate":0,"index":33231},{"krate":0,"index":5529},{"krate":0,"index":5538},{"krate":0,"index":5542},{"krate":0,"index":5544},{"krate":0,"index":5546},{"krate":0,"index":5548},{"krate":0,"index":33235},{"krate":0,"index":33241},{"krate":0,"index":5553},{"krate":0,"index":5557},{"krate":0,"index":5560},{"krate":0,"index":5569},{"krate":0,"index":5573},{"krate":0,"index":5576},{"krate":0,"index":5578},{"krate":0,"index":5580},{"krate":0,"index":33245},{"krate":0,"index":33251},{"krate":0,"index":5585},{"krate":0,"index":5589},{"krate":0,"index":5598},{"krate":0,"index":5602},{"krate":0,"index":5605},{"krate":0,"index":5607},{"krate":0,"index":5609},{"krate":0,"index":33255},{"krate":0,"index":33260},{"krate":0,"index":5614},{"krate":0,"index":5617},{"krate":0,"index":5626},{"krate":0,"index":5631},{"krate":0,"index":5633},{"krate":0,"index":5635},{"krate":0,"index":5637},{"krate":0,"index":33264},{"krate":0,"index":33269},{"krate":0,"index":5642},{"krate":0,"index":5651},{"krate":0,"index":5656},{"krate":0,"index":5658},{"krate":0,"index":5660},{"krate":0,"index":5662},{"krate":0,"index":33273},{"krate":0,"index":33279},{"krate":0,"index":5667},{"krate":0,"index":5671},{"krate":0,"index":5675},{"krate":0,"index":5684},{"krate":0,"index":5689},{"krate":0,"index":5693},{"krate":0,"index":5695},{"krate":0,"index":5697},{"krate":0,"index":33283},{"krate":0,"index":33289},{"krate":0,"index":5702},{"krate":0,"index":5706},{"krate":0,"index":5715},{"krate":0,"index":5720},{"krate":0,"index":5723},{"krate":0,"index":5725},{"krate":0,"index":5727},{"krate":0,"index":5732},{"krate":0,"index":5735},{"krate":0,"index":5738},{"krate":0,"index":5740},{"krate":0,"index":5742},{"krate":0,"index":5745},{"krate":0,"index":5747},{"krate":0,"index":5752},{"krate":0,"index":5754},{"krate":0,"index":5757},{"krate":0,"index":5760},{"krate":0,"index":5764},{"krate":0,"index":5768},{"krate":0,"index":5771},{"krate":0,"index":5774},{"krate":0,"index":5777},{"krate":0,"index":5780},{"krate":0,"index":5783},{"krate":0,"index":5786},{"krate":0,"index":5788},{"krate":0,"index":5789},{"krate":0,"index":33293},{"krate":0,"index":33294},{"krate":0,"index":33295},{"krate":0,"index":33296},{"krate":0,"index":33297},{"krate":0,"index":33298},{"krate":0,"index":33299},{"krate":0,"index":33300},{"krate":0,"index":33301},{"krate":0,"index":33302},{"krate":0,"index":33303},{"krate":0,"index":33304},{"krate":0,"index":33305},{"krate":0,"index":33306},{"krate":0,"index":5790},{"krate":0,"index":5795},{"krate":0,"index":5800},{"krate":0,"index":5802},{"krate":0,"index":5806},{"krate":0,"index":5808}],"decl_id":null,"docs":" Slice management and manipulation.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1563015,"byte_end":1563061,"line_start":9,"line_end":9,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":4907},"span":{"file_name":"src/libcore/slice/memchr.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"memchr","qualname":"::slice::memchr","value":"src/libcore/slice/memchr.rs","parent":null,"children":[{"krate":0,"index":4908},{"krate":0,"index":4909},{"krate":0,"index":4910},{"krate":0,"index":4911},{"krate":0,"index":4912},{"krate":0,"index":4913},{"krate":0,"index":4914},{"krate":0,"index":4915},{"krate":0,"index":4916},{"krate":0,"index":4920}],"decl_id":null,"docs":" Pure rust memchr implementation, taken from rust-memchr\n","sig":null,"attributes":[{"value":"unstable(feature = \"slice_internals\",\n           issue = \"0\",\n           reason =\n               \"exposed from core to be reused in std; use the memchr crate\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1563980,"byte_end":1564116,"line_start":40,"line_end":41,"column_start":1,"column_end":84}}]},{"kind":"Function","id":{"krate":0,"index":4916},"span":{"file_name":"src/libcore/slice/memchr.rs","byte_start":1743640,"byte_end":1743646,"line_start":39,"line_end":39,"column_start":8,"column_end":14},"name":"memchr","qualname":"::slice::memchr::memchr","value":"fn (x: u8, text: &[u8]) -> Option<usize>","parent":null,"children":[],"decl_id":null,"docs":" Returns the first index matching the byte `x` in `text`.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4920},"span":{"file_name":"src/libcore/slice/memchr.rs","byte_start":1745186,"byte_end":1745193,"line_start":84,"line_end":84,"column_start":8,"column_end":15},"name":"memrchr","qualname":"::slice::memchr::memrchr","value":"fn (x: u8, text: &[u8]) -> Option<usize>","parent":null,"children":[],"decl_id":null,"docs":" Returns the last index matching the byte `x` in `text`.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4939},"span":{"file_name":"src/libcore/slice/rotate.rs","byte_start":1748959,"byte_end":1748969,"line_start":55,"line_end":55,"column_start":15,"column_end":25},"name":"ptr_rotate","qualname":"::slice::rotate::ptr_rotate","value":"fn <T> (mut left: usize, mid: *mut T, mut right: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Rotates the range `[mid-left, mid+right)` such that the element at `mid`\n becomes the first element. Equivalently, rotates the range `left`\n elements to the left or `right` elements to the right.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4969},"span":{"file_name":"src/libcore/slice/sort.rs","byte_start":1755116,"byte_end":1755124,"line_start":146,"line_end":146,"column_start":8,"column_end":16},"name":"heapsort","qualname":"::slice::sort::heapsort","value":"fn <T, F> (v: &mut [T], is_less: &mut F) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Sorts `v` using heapsort, which guarantees `O(n log n)` worst-case.\n","sig":null,"attributes":[{"value":"cold","span":{"file_name":"src/libcore/slice/sort.rs","byte_start":1755101,"byte_end":1755108,"line_start":145,"line_end":145,"column_start":1,"column_end":8}}]},{"kind":"Function","id":{"krate":0,"index":5006},"span":{"file_name":"src/libcore/slice/sort.rs","byte_start":1774670,"byte_end":1774679,"line_start":681,"line_end":681,"column_start":8,"column_end":17},"name":"quicksort","qualname":"::slice::sort::quicksort","value":"fn <T, F> (v: &mut [T], mut is_less: F) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Sorts `v` using pattern-defeating quicksort, which is `O(n log n)` worst-case.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5014},"span":{"file_name":"src/libcore/slice/sort.rs","byte_start":1777018,"byte_end":1777036,"line_start":750,"line_end":750,"column_start":8,"column_end":26},"name":"partition_at_index","qualname":"::slice::sort::partition_at_index","value":"fn <T, F> (v: &mut [T], index: usize, mut is_less: F) -> (&mut [T], &mut T, &mut [T])","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5023},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1564603,"byte_end":1564606,"line_start":66,"line_end":66,"column_start":18,"column_end":21},"name":"len","qualname":"<[T]>::len","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the number of elements in the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1564469,"byte_end":1564514,"line_start":63,"line_end":63,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1564519,"byte_end":1564528,"line_start":64,"line_end":64,"column_start":5,"column_end":14}},{"value":"rustc_const_unstable(feature = \"const_slice_len\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1564533,"byte_end":1564585,"line_start":65,"line_end":65,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":5024},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1565022,"byte_end":1565030,"line_start":83,"line_end":83,"column_start":18,"column_end":26},"name":"is_empty","qualname":"<[T]>::is_empty","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the slice has a length of 0.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1564888,"byte_end":1564933,"line_start":80,"line_end":80,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1564938,"byte_end":1564947,"line_start":81,"line_end":81,"column_start":5,"column_end":14}},{"value":"rustc_const_unstable(feature = \"const_slice_len\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1564952,"byte_end":1565004,"line_start":82,"line_end":82,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":5025},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1565433,"byte_end":1565438,"line_start":100,"line_end":100,"column_start":12,"column_end":17},"name":"first","qualname":"<[T]>::first","value":"fn (&self) -> Option<&T>","parent":null,"children":[],"decl_id":null,"docs":" Returns the first element of the slice, or `None` if it is empty.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1565362,"byte_end":1565407,"line_start":98,"line_end":98,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1565412,"byte_end":1565421,"line_start":99,"line_end":99,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5026},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1565872,"byte_end":1565881,"line_start":118,"line_end":118,"column_start":12,"column_end":21},"name":"first_mut","qualname":"<[T]>::first_mut","value":"fn (&mut self) -> Option<&mut T>","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable pointer to the first element of the slice, or `None` if it is empty.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1565801,"byte_end":1565846,"line_start":116,"line_end":116,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1565851,"byte_end":1565860,"line_start":117,"line_end":117,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5027},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1566367,"byte_end":1566378,"line_start":136,"line_end":136,"column_start":12,"column_end":23},"name":"split_first","qualname":"<[T]>::split_first","value":"fn (&self) -> Option<(&T, &[T])>","parent":null,"children":[],"decl_id":null,"docs":" Returns the first and all the rest of the elements of the slice, or `None` if it is empty.","sig":null,"attributes":[{"value":"stable(feature = \"slice_splits\", since = \"1.5.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1566289,"byte_end":1566341,"line_start":134,"line_end":134,"column_start":5,"column_end":57}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1566346,"byte_end":1566355,"line_start":135,"line_end":135,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5028},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1566961,"byte_end":1566976,"line_start":156,"line_end":156,"column_start":12,"column_end":27},"name":"split_first_mut","qualname":"<[T]>::split_first_mut","value":"fn (&mut self) -> Option<(&mut T, &mut [T])>","parent":null,"children":[],"decl_id":null,"docs":" Returns the first and all the rest of the elements of the slice, or `None` if it is empty.","sig":null,"attributes":[{"value":"stable(feature = \"slice_splits\", since = \"1.5.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1566883,"byte_end":1566935,"line_start":154,"line_end":154,"column_start":5,"column_end":57}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1566940,"byte_end":1566949,"line_start":155,"line_end":155,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5029},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1567590,"byte_end":1567600,"line_start":177,"line_end":177,"column_start":12,"column_end":22},"name":"split_last","qualname":"<[T]>::split_last","value":"fn (&self) -> Option<(&T, &[T])>","parent":null,"children":[],"decl_id":null,"docs":" Returns the last and all the rest of the elements of the slice, or `None` if it is empty.","sig":null,"attributes":[{"value":"stable(feature = \"slice_splits\", since = \"1.5.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1567512,"byte_end":1567564,"line_start":175,"line_end":175,"column_start":5,"column_end":57}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1567569,"byte_end":1567578,"line_start":176,"line_end":176,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5030},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1568216,"byte_end":1568230,"line_start":198,"line_end":198,"column_start":12,"column_end":26},"name":"split_last_mut","qualname":"<[T]>::split_last_mut","value":"fn (&mut self) -> Option<(&mut T, &mut [T])>","parent":null,"children":[],"decl_id":null,"docs":" Returns the last and all the rest of the elements of the slice, or `None` if it is empty.","sig":null,"attributes":[{"value":"stable(feature = \"slice_splits\", since = \"1.5.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1568138,"byte_end":1568190,"line_start":196,"line_end":196,"column_start":5,"column_end":57}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1568195,"byte_end":1568204,"line_start":197,"line_end":197,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5031},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1568806,"byte_end":1568810,"line_start":220,"line_end":220,"column_start":12,"column_end":16},"name":"last","qualname":"<[T]>::last","value":"fn (&self) -> Option<&T>","parent":null,"children":[],"decl_id":null,"docs":" Returns the last element of the slice, or `None` if it is empty.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1568735,"byte_end":1568780,"line_start":218,"line_end":218,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1568785,"byte_end":1568794,"line_start":219,"line_end":219,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5032},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1569271,"byte_end":1569279,"line_start":239,"line_end":239,"column_start":12,"column_end":20},"name":"last_mut","qualname":"<[T]>::last_mut","value":"fn (&mut self) -> Option<&mut T>","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable pointer to the last item in the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1569200,"byte_end":1569245,"line_start":237,"line_end":237,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1569250,"byte_end":1569259,"line_start":238,"line_end":238,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5033},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1570073,"byte_end":1570076,"line_start":263,"line_end":263,"column_start":12,"column_end":15},"name":"get","qualname":"<[T]>::get","value":"fn <I> (&self, index: I) -> Option<&I::Output>","parent":null,"children":[],"decl_id":null,"docs":" Returns a reference to an element or subslice depending on the type of\n index.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1570002,"byte_end":1570047,"line_start":261,"line_end":261,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1570052,"byte_end":1570061,"line_start":262,"line_end":262,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5035},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1570670,"byte_end":1570677,"line_start":286,"line_end":286,"column_start":12,"column_end":19},"name":"get_mut","qualname":"<[T]>::get_mut","value":"fn <I> (&mut self, index: I) -> Option<&mut I::Output>","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable reference to an element or subslice depending on the\n type of index (see [`get`]) or `None` if the index is out of bounds.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1570599,"byte_end":1570644,"line_start":284,"line_end":284,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1570649,"byte_end":1570658,"line_start":285,"line_end":285,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5037},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1571299,"byte_end":1571312,"line_start":311,"line_end":311,"column_start":19,"column_end":32},"name":"get_unchecked","qualname":"<[T]>::get_unchecked","value":"fn <I> (&self, index: I) -> &I::Output","parent":null,"children":[],"decl_id":null,"docs":" Returns a reference to an element or subslice, without doing bounds\n checking.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1571221,"byte_end":1571266,"line_start":309,"line_end":309,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1571271,"byte_end":1571280,"line_start":310,"line_end":310,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5039},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1572007,"byte_end":1572024,"line_start":338,"line_end":338,"column_start":19,"column_end":36},"name":"get_unchecked_mut","qualname":"<[T]>::get_unchecked_mut","value":"fn <I> (&mut self, index: I) -> &mut I::Output","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable reference to an element or subslice, without doing\n bounds checking.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1571929,"byte_end":1571974,"line_start":336,"line_end":336,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1571979,"byte_end":1571988,"line_start":337,"line_end":337,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5041},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1573205,"byte_end":1573211,"line_start":372,"line_end":372,"column_start":18,"column_end":24},"name":"as_ptr","qualname":"<[T]>::as_ptr","value":"fn (&self) -> *const T","parent":null,"children":[],"decl_id":null,"docs":" Returns a raw pointer to the slice's buffer.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1573128,"byte_end":1573173,"line_start":370,"line_end":370,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1573178,"byte_end":1573187,"line_start":371,"line_end":371,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5042},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1574013,"byte_end":1574023,"line_start":399,"line_end":399,"column_start":12,"column_end":22},"name":"as_mut_ptr","qualname":"<[T]>::as_mut_ptr","value":"fn (&mut self) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Returns an unsafe mutable pointer to the slice's buffer.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1573942,"byte_end":1573987,"line_start":397,"line_end":397,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1573992,"byte_end":1574001,"line_start":398,"line_end":398,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5043},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1574580,"byte_end":1574584,"line_start":423,"line_end":423,"column_start":12,"column_end":16},"name":"swap","qualname":"<[T]>::swap","value":"fn (&mut self, a: usize, b: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Swaps two elements in the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1574509,"byte_end":1574554,"line_start":421,"line_end":421,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1574559,"byte_end":1574568,"line_start":422,"line_end":422,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5044},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1575190,"byte_end":1575197,"line_start":444,"line_end":444,"column_start":12,"column_end":19},"name":"reverse","qualname":"<[T]>::reverse","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Reverses the order of elements in the slice, in place.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1575119,"byte_end":1575164,"line_start":442,"line_end":442,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1575169,"byte_end":1575178,"line_start":443,"line_end":443,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5045},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1578443,"byte_end":1578447,"line_start":522,"line_end":522,"column_start":12,"column_end":16},"name":"iter","qualname":"<[T]>::iter","value":"fn (&self) -> Iter<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1578372,"byte_end":1578417,"line_start":520,"line_end":520,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1578422,"byte_end":1578431,"line_start":521,"line_end":521,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5046},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1579229,"byte_end":1579237,"line_start":554,"line_end":554,"column_start":12,"column_end":20},"name":"iter_mut","qualname":"<[T]>::iter_mut","value":"fn (&mut self) -> IterMut<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator that allows modifying each value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1579158,"byte_end":1579203,"line_start":552,"line_end":552,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1579208,"byte_end":1579217,"line_start":553,"line_end":553,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5047},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1580566,"byte_end":1580573,"line_start":601,"line_end":601,"column_start":12,"column_end":19},"name":"windows","qualname":"<[T]>::windows","value":"fn (&self, size: usize) -> Windows<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over all contiguous windows of length\n `size`. The windows overlap. If the slice is shorter than\n `size`, the iterator returns no values.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1580495,"byte_end":1580540,"line_start":599,"line_end":599,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1580545,"byte_end":1580554,"line_start":600,"line_end":600,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5048},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1581805,"byte_end":1581811,"line_start":635,"line_end":635,"column_start":12,"column_end":18},"name":"chunks","qualname":"<[T]>::chunks","value":"fn (&self, chunk_size: usize) -> Chunks<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n beginning of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1581734,"byte_end":1581779,"line_start":633,"line_end":633,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1581784,"byte_end":1581793,"line_start":634,"line_end":634,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5049},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1583081,"byte_end":1583091,"line_start":673,"line_end":673,"column_start":12,"column_end":22},"name":"chunks_mut","qualname":"<[T]>::chunks_mut","value":"fn (&mut self, chunk_size: usize) -> ChunksMut<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n beginning of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1583010,"byte_end":1583055,"line_start":671,"line_end":671,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1583060,"byte_end":1583069,"line_start":672,"line_end":672,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5050},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1584580,"byte_end":1584592,"line_start":710,"line_end":710,"column_start":12,"column_end":24},"name":"chunks_exact","qualname":"<[T]>::chunks_exact","value":"fn (&self, chunk_size: usize) -> ChunksExact<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n beginning of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"chunks_exact\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1584501,"byte_end":1584554,"line_start":708,"line_end":708,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1584559,"byte_end":1584568,"line_start":709,"line_end":709,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5051},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1586270,"byte_end":1586286,"line_start":755,"line_end":755,"column_start":12,"column_end":28},"name":"chunks_exact_mut","qualname":"<[T]>::chunks_exact_mut","value":"fn (&mut self, chunk_size: usize) -> ChunksExactMut<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n beginning of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"chunks_exact\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1586191,"byte_end":1586244,"line_start":753,"line_end":753,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1586249,"byte_end":1586258,"line_start":754,"line_end":754,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5052},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1587682,"byte_end":1587689,"line_start":792,"line_end":792,"column_start":12,"column_end":19},"name":"rchunks","qualname":"<[T]>::rchunks","value":"fn (&self, chunk_size: usize) -> RChunks<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rchunks\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1587608,"byte_end":1587656,"line_start":790,"line_end":790,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1587661,"byte_end":1587670,"line_start":791,"line_end":791,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5053},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1588952,"byte_end":1588963,"line_start":830,"line_end":830,"column_start":12,"column_end":23},"name":"rchunks_mut","qualname":"<[T]>::rchunks_mut","value":"fn (&mut self, chunk_size: usize) -> RChunksMut<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rchunks\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1588878,"byte_end":1588926,"line_start":828,"line_end":828,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1588931,"byte_end":1588940,"line_start":829,"line_end":829,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5054},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1590493,"byte_end":1590506,"line_start":869,"line_end":869,"column_start":12,"column_end":25},"name":"rchunks_exact","qualname":"<[T]>::rchunks_exact","value":"fn (&self, chunk_size: usize) -> RChunksExact<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n end of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rchunks\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1590419,"byte_end":1590467,"line_start":867,"line_end":867,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1590472,"byte_end":1590481,"line_start":868,"line_end":868,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5055},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1592176,"byte_end":1592193,"line_start":914,"line_end":914,"column_start":12,"column_end":29},"name":"rchunks_exact_mut","qualname":"<[T]>::rchunks_exact_mut","value":"fn (&mut self, chunk_size: usize) -> RChunksExactMut<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rchunks\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1592102,"byte_end":1592150,"line_start":912,"line_end":912,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1592155,"byte_end":1592164,"line_start":913,"line_end":913,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5056},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1593405,"byte_end":1593413,"line_start":956,"line_end":956,"column_start":12,"column_end":20},"name":"split_at","qualname":"<[T]>::split_at","value":"fn (&self, mid: usize) -> (&[T], &[T])","parent":null,"children":[],"decl_id":null,"docs":" Divides one slice into two at an index.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1593334,"byte_end":1593379,"line_start":954,"line_end":954,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1593384,"byte_end":1593393,"line_start":955,"line_end":955,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5057},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1594304,"byte_end":1594316,"line_start":986,"line_end":986,"column_start":12,"column_end":24},"name":"split_at_mut","qualname":"<[T]>::split_at_mut","value":"fn (&mut self, mid: usize) -> (&mut [T], &mut [T])","parent":null,"children":[],"decl_id":null,"docs":" Divides one mutable slice into two at an index.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1594233,"byte_end":1594278,"line_start":984,"line_end":984,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1594283,"byte_end":1594292,"line_start":985,"line_end":985,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5058},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1596088,"byte_end":1596093,"line_start":1040,"line_end":1040,"column_start":12,"column_end":17},"name":"split","qualname":"<[T]>::split","value":"fn <F> (&self, pred: F) -> Split<'_, T, F>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over subslices separated by elements that match\n `pred`. The matched element is not contained in the subslices.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1596017,"byte_end":1596062,"line_start":1038,"line_end":1038,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1596067,"byte_end":1596076,"line_start":1039,"line_end":1039,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5060},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1596754,"byte_end":1596763,"line_start":1065,"line_end":1065,"column_start":12,"column_end":21},"name":"split_mut","qualname":"<[T]>::split_mut","value":"fn <F> (&mut self, pred: F) -> SplitMut<'_, T, F>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over mutable subslices separated by elements that\n match `pred`. The matched element is not contained in the subslices.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1596683,"byte_end":1596728,"line_start":1063,"line_end":1063,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1596733,"byte_end":1596742,"line_start":1064,"line_end":1064,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5062},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1598021,"byte_end":1598027,"line_start":1100,"line_end":1100,"column_start":12,"column_end":18},"name":"rsplit","qualname":"<[T]>::rsplit","value":"fn <F> (&self, pred: F) -> RSplit<'_, T, F>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over subslices separated by elements that match\n `pred`, starting at the end of the slice and working backwards.\n The matched element is not contained in the subslices.","sig":null,"attributes":[{"value":"stable(feature = \"slice_rsplit\", since = \"1.27.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1597942,"byte_end":1597995,"line_start":1098,"line_end":1098,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1598000,"byte_end":1598009,"line_start":1099,"line_end":1099,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5064},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1598784,"byte_end":1598794,"line_start":1125,"line_end":1125,"column_start":12,"column_end":22},"name":"rsplit_mut","qualname":"<[T]>::rsplit_mut","value":"fn <F> (&mut self, pred: F) -> RSplitMut<'_, T, F>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over mutable subslices separated by elements that\n match `pred`, starting at the end of the slice and working\n backwards. The matched element is not contained in the subslices.","sig":null,"attributes":[{"value":"stable(feature = \"slice_rsplit\", since = \"1.27.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1598705,"byte_end":1598758,"line_start":1123,"line_end":1123,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1598763,"byte_end":1598772,"line_start":1124,"line_end":1124,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5066},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1599634,"byte_end":1599640,"line_start":1152,"line_end":1152,"column_start":12,"column_end":18},"name":"splitn","qualname":"<[T]>::splitn","value":"fn <F> (&self, n: usize, pred: F) -> SplitN<'_, T, F>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over subslices separated by elements that match\n `pred`, limited to returning at most `n` items. The matched element is\n not contained in the subslices.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1599563,"byte_end":1599608,"line_start":1150,"line_end":1150,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1599613,"byte_end":1599622,"line_start":1151,"line_end":1151,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5068},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1600505,"byte_end":1600515,"line_start":1182,"line_end":1182,"column_start":12,"column_end":22},"name":"splitn_mut","qualname":"<[T]>::splitn_mut","value":"fn <F> (&mut self, n: usize, pred: F) -> SplitNMut<'_, T, F>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over subslices separated by elements that match\n `pred`, limited to returning at most `n` items. The matched element is\n not contained in the subslices.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1600434,"byte_end":1600479,"line_start":1180,"line_end":1180,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1600484,"byte_end":1600493,"line_start":1181,"line_end":1181,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5070},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1601552,"byte_end":1601559,"line_start":1215,"line_end":1215,"column_start":12,"column_end":19},"name":"rsplitn","qualname":"<[T]>::rsplitn","value":"fn <F> (&self, n: usize, pred: F) -> RSplitN<'_, T, F>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over subslices separated by elements that match\n `pred` limited to returning at most `n` items. This starts at the end of\n the slice and works backwards. The matched element is not contained in\n the subslices.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1601481,"byte_end":1601526,"line_start":1213,"line_end":1213,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1601531,"byte_end":1601540,"line_start":1214,"line_end":1214,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5072},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1602492,"byte_end":1602503,"line_start":1246,"line_end":1246,"column_start":12,"column_end":23},"name":"rsplitn_mut","qualname":"<[T]>::rsplitn_mut","value":"fn <F> (&mut self, n: usize, pred: F) -> RSplitNMut<'_, T, F>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over subslices separated by elements that match\n `pred` limited to returning at most `n` items. This starts at the end of\n the slice and works backwards. The matched element is not contained in\n the subslices.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1602421,"byte_end":1602466,"line_start":1244,"line_end":1244,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1602471,"byte_end":1602480,"line_start":1245,"line_end":1245,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5074},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1603056,"byte_end":1603064,"line_start":1267,"line_end":1267,"column_start":12,"column_end":20},"name":"contains","qualname":"<[T]>::contains","value":"fn (&self, x: &T) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the slice contains an element with the given value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1602999,"byte_end":1603044,"line_start":1266,"line_end":1266,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5075},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1603769,"byte_end":1603780,"line_start":1294,"line_end":1294,"column_start":12,"column_end":23},"name":"starts_with","qualname":"<[T]>::starts_with","value":"fn (&self, needle: &[T]) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `needle` is a prefix of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1603712,"byte_end":1603757,"line_start":1293,"line_end":1293,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5076},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1604527,"byte_end":1604536,"line_start":1322,"line_end":1322,"column_start":12,"column_end":21},"name":"ends_with","qualname":"<[T]>::ends_with","value":"fn (&self, needle: &[T]) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `needle` is a suffix of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1604470,"byte_end":1604515,"line_start":1321,"line_end":1321,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5077},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1605792,"byte_end":1605805,"line_start":1353,"line_end":1353,"column_start":12,"column_end":25},"name":"binary_search","qualname":"<[T]>::binary_search","value":"fn (&self, x: &T) -> Result<usize, usize>","parent":null,"children":[],"decl_id":null,"docs":" Binary searches this sorted slice for a given element.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1605735,"byte_end":1605780,"line_start":1352,"line_end":1352,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5079},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1607482,"byte_end":1607498,"line_start":1393,"line_end":1393,"column_start":12,"column_end":28},"name":"binary_search_by","qualname":"<[T]>::binary_search_by","value":"fn <'a, F> (&'a self, mut f: F) -> Result<usize, usize>","parent":null,"children":[],"decl_id":null,"docs":" Binary searches this sorted slice with a comparator function.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1607411,"byte_end":1607456,"line_start":1391,"line_end":1391,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1607461,"byte_end":1607470,"line_start":1392,"line_end":1392,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5082},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1609953,"byte_end":1609973,"line_start":1451,"line_end":1451,"column_start":12,"column_end":32},"name":"binary_search_by_key","qualname":"<[T]>::binary_search_by_key","value":"fn <'a, B, F> (&'a self, b: &B, mut f: F) -> Result<usize, usize>","parent":null,"children":[],"decl_id":null,"docs":" Binary searches this sorted slice with a key extraction function.","sig":null,"attributes":[{"value":"stable(feature = \"slice_binary_search_by_key\", since = \"1.10.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1609860,"byte_end":1609927,"line_start":1449,"line_end":1449,"column_start":5,"column_end":72}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1609932,"byte_end":1609941,"line_start":1450,"line_end":1450,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5087},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1611319,"byte_end":1611332,"line_start":1486,"line_end":1486,"column_start":12,"column_end":25},"name":"sort_unstable","qualname":"<[T]>::sort_unstable","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Sorts the slice, but may not preserve the order of equal elements.","sig":null,"attributes":[{"value":"stable(feature = \"sort_unstable\", since = \"1.20.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1611239,"byte_end":1611293,"line_start":1484,"line_end":1484,"column_start":5,"column_end":59}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1611298,"byte_end":1611307,"line_start":1485,"line_end":1485,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5089},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1613573,"byte_end":1613589,"line_start":1540,"line_end":1540,"column_start":12,"column_end":28},"name":"sort_unstable_by","qualname":"<[T]>::sort_unstable_by","value":"fn <F> (&mut self, mut compare: F) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Sorts the slice with a comparator function, but may not preserve the order of equal\n elements.","sig":null,"attributes":[{"value":"stable(feature = \"sort_unstable\", since = \"1.20.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1613493,"byte_end":1613547,"line_start":1538,"line_end":1538,"column_start":5,"column_end":59}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1613552,"byte_end":1613561,"line_start":1539,"line_end":1539,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5092},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1615095,"byte_end":1615115,"line_start":1577,"line_end":1577,"column_start":12,"column_end":32},"name":"sort_unstable_by_key","qualname":"<[T]>::sort_unstable_by_key","value":"fn <K, F> (&mut self, mut f: F) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Sorts the slice with a key extraction function, but may not preserve the order of equal\n elements.","sig":null,"attributes":[{"value":"stable(feature = \"sort_unstable\", since = \"1.20.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1615015,"byte_end":1615069,"line_start":1575,"line_end":1575,"column_start":5,"column_end":59}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1615074,"byte_end":1615083,"line_start":1576,"line_end":1576,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5096},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1616959,"byte_end":1616977,"line_start":1623,"line_end":1623,"column_start":12,"column_end":30},"name":"partition_at_index","qualname":"<[T]>::partition_at_index","value":"fn (&mut self, index: usize) -> (&mut [T], &mut T, &mut [T])","parent":null,"children":[],"decl_id":null,"docs":" Reorder the slice such that the element at `index` is at its final sorted position.","sig":null,"attributes":[{"value":"unstable(feature = \"slice_partition_at_index\", issue = \"55300\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1616867,"byte_end":1616933,"line_start":1621,"line_end":1621,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1616938,"byte_end":1616947,"line_start":1622,"line_end":1622,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5098},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1619057,"byte_end":1619078,"line_start":1672,"line_end":1672,"column_start":12,"column_end":33},"name":"partition_at_index_by","qualname":"<[T]>::partition_at_index_by","value":"fn <F> (&mut self, index: usize, mut compare: F) -> (&mut [T], &mut T, &mut [T])","parent":null,"children":[],"decl_id":null,"docs":" Reorder the slice with a comparator function such that the element at `index` is at its\n final sorted position.","sig":null,"attributes":[{"value":"unstable(feature = \"slice_partition_at_index\", issue = \"55300\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1618965,"byte_end":1619031,"line_start":1670,"line_end":1670,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1619036,"byte_end":1619045,"line_start":1671,"line_end":1671,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5101},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1621271,"byte_end":1621296,"line_start":1722,"line_end":1722,"column_start":12,"column_end":37},"name":"partition_at_index_by_key","qualname":"<[T]>::partition_at_index_by_key","value":"fn <K, F> (&mut self, index: usize, mut f: F) -> (&mut [T], &mut T, &mut [T])","parent":null,"children":[],"decl_id":null,"docs":" Reorder the slice with a key extraction function such that the element at `index` is at its\n final sorted position.","sig":null,"attributes":[{"value":"unstable(feature = \"slice_partition_at_index\", issue = \"55300\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1621179,"byte_end":1621245,"line_start":1720,"line_end":1720,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1621250,"byte_end":1621259,"line_start":1721,"line_end":1721,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5105},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1622367,"byte_end":1622382,"line_start":1752,"line_end":1752,"column_start":12,"column_end":27},"name":"partition_dedup","qualname":"<[T]>::partition_dedup","value":"fn (&mut self) -> (&mut [T], &mut [T])","parent":null,"children":[],"decl_id":null,"docs":" Moves all consecutive repeated elements to the end of the slice according to the\n [`PartialEq`] trait implementation.","sig":null,"attributes":[{"value":"unstable(feature = \"slice_partition_dedup\", issue = \"54279\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1622278,"byte_end":1622341,"line_start":1750,"line_end":1750,"column_start":5,"column_end":68}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1622346,"byte_end":1622355,"line_start":1751,"line_end":1751,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5107},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1623701,"byte_end":1623719,"line_start":1785,"line_end":1785,"column_start":12,"column_end":30},"name":"partition_dedup_by","qualname":"<[T]>::partition_dedup_by","value":"fn <F> (&mut self, mut same_bucket: F) -> (&mut [T], &mut [T])","parent":null,"children":[],"decl_id":null,"docs":" Moves all but the first of consecutive elements to the end of the slice satisfying\n a given equality relation.","sig":null,"attributes":[{"value":"unstable(feature = \"slice_partition_dedup\", issue = \"54279\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1623612,"byte_end":1623675,"line_start":1783,"line_end":1783,"column_start":5,"column_end":68}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1623680,"byte_end":1623689,"line_start":1784,"line_end":1784,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5109},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1627796,"byte_end":1627818,"line_start":1895,"line_end":1895,"column_start":12,"column_end":34},"name":"partition_dedup_by_key","qualname":"<[T]>::partition_dedup_by_key","value":"fn <K, F> (&mut self, mut key: F) -> (&mut [T], &mut [T])","parent":null,"children":[],"decl_id":null,"docs":" Moves all but the first of consecutive elements to the end of the slice that resolve\n to the same key.","sig":null,"attributes":[{"value":"unstable(feature = \"slice_partition_dedup\", issue = \"54279\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1627707,"byte_end":1627770,"line_start":1893,"line_end":1893,"column_start":5,"column_end":68}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1627775,"byte_end":1627784,"line_start":1894,"line_end":1894,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5113},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1629058,"byte_end":1629069,"line_start":1933,"line_end":1933,"column_start":12,"column_end":23},"name":"rotate_left","qualname":"<[T]>::rotate_left","value":"fn (&mut self, mid: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Rotates the slice in-place such that the first `mid` elements of the\n slice move to the end while the last `self.len() - mid` elements move to\n the front. After calling `rotate_left`, the element previously at index\n `mid` will become the first element in the slice.","sig":null,"attributes":[{"value":"stable(feature = \"slice_rotate\", since = \"1.26.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1628993,"byte_end":1629046,"line_start":1932,"line_end":1932,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":5114},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1630346,"byte_end":1630358,"line_start":1974,"line_end":1974,"column_start":12,"column_end":24},"name":"rotate_right","qualname":"<[T]>::rotate_right","value":"fn (&mut self, k: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Rotates the slice in-place such that the first `self.len() - k`\n elements of the slice move to the end while the last `k` elements move\n to the front. After calling `rotate_right`, the element previously at\n index `self.len() - k` will become the first element in the slice.","sig":null,"attributes":[{"value":"stable(feature = \"slice_rotate\", since = \"1.26.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1630281,"byte_end":1630334,"line_start":1973,"line_end":1973,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":5115},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1632392,"byte_end":1632408,"line_start":2040,"line_end":2040,"column_start":12,"column_end":28},"name":"clone_from_slice","qualname":"<[T]>::clone_from_slice","value":"fn (&mut self, src: &[T]) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies the elements from `src` into `self`.","sig":null,"attributes":[{"value":"stable(feature = \"clone_from_slice\", since = \"1.7.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1632324,"byte_end":1632380,"line_start":2039,"line_end":2039,"column_start":5,"column_end":61}}]},{"kind":"Method","id":{"krate":0,"index":5116},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1634712,"byte_end":1634727,"line_start":2109,"line_end":2109,"column_start":12,"column_end":27},"name":"copy_from_slice","qualname":"<[T]>::copy_from_slice","value":"fn (&mut self, src: &[T]) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies all elements from `src` into `self`, using a memcpy.","sig":null,"attributes":[{"value":"stable(feature = \"copy_from_slice\", since = \"1.9.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1634645,"byte_end":1634700,"line_start":2108,"line_end":2108,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":5117},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1635900,"byte_end":1635911,"line_start":2143,"line_end":2143,"column_start":12,"column_end":23},"name":"copy_within","qualname":"<[T]>::copy_within","value":"fn <R> (&mut self, src: R, dest: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies elements from one part of the slice to another part of itself,\n using a memmove.","sig":null,"attributes":[{"value":"stable(feature = \"copy_within\", since = \"1.37.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1635836,"byte_end":1635888,"line_start":2142,"line_end":2142,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":5121},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1638495,"byte_end":1638510,"line_start":2222,"line_end":2222,"column_start":12,"column_end":27},"name":"swap_with_slice","qualname":"<[T]>::swap_with_slice","value":"fn (&mut self, other: &mut [T]) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Swaps all elements in `self` with those in `other`.","sig":null,"attributes":[{"value":"stable(feature = \"swap_with_slice\", since = \"1.27.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1638427,"byte_end":1638483,"line_start":2221,"line_end":2221,"column_start":5,"column_end":61}}]},{"kind":"Method","id":{"krate":0,"index":5126},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1642792,"byte_end":1642800,"line_start":2322,"line_end":2322,"column_start":19,"column_end":27},"name":"align_to","qualname":"<[T]>::align_to","value":"fn <U> (&self) -> (&[T], &[U], &[T])","parent":null,"children":[],"decl_id":null,"docs":" Transmute the slice to a slice of another type, ensuring alignment of the types is\n maintained.","sig":null,"attributes":[{"value":"stable(feature = \"slice_align_to\", since = \"1.30.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1642718,"byte_end":1642773,"line_start":2321,"line_end":2321,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":5128},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1645188,"byte_end":1645200,"line_start":2375,"line_end":2375,"column_start":19,"column_end":31},"name":"align_to_mut","qualname":"<[T]>::align_to_mut","value":"fn <U> (&mut self) -> (&mut [T], &mut [U], &mut [T])","parent":null,"children":[],"decl_id":null,"docs":" Transmute the slice to a slice of another type, ensuring alignment of the types is\n maintained.","sig":null,"attributes":[{"value":"stable(feature = \"slice_align_to\", since = \"1.30.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1645114,"byte_end":1645169,"line_start":2374,"line_end":2374,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":5130},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1647148,"byte_end":1647157,"line_start":2422,"line_end":2422,"column_start":12,"column_end":21},"name":"is_sorted","qualname":"<[T]>::is_sorted","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the elements of this slice are sorted.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1647051,"byte_end":1647060,"line_start":2420,"line_end":2420,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1647065,"byte_end":1647136,"line_start":2421,"line_end":2421,"column_start":5,"column_end":76}}]},{"kind":"Method","id":{"krate":0,"index":5132},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1647761,"byte_end":1647773,"line_start":2437,"line_end":2437,"column_start":12,"column_end":24},"name":"is_sorted_by","qualname":"<[T]>::is_sorted_by","value":"fn <F> (&self, mut compare: F) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the elements of this slice are sorted using the given comparator function.","sig":null,"attributes":[{"value":"unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1647678,"byte_end":1647749,"line_start":2436,"line_end":2436,"column_start":5,"column_end":76}}]},{"kind":"Method","id":{"krate":0,"index":5135},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1648662,"byte_end":1648678,"line_start":2462,"line_end":2462,"column_start":12,"column_end":28},"name":"is_sorted_by_key","qualname":"<[T]>::is_sorted_by_key","value":"fn <F, K> (&self, mut f: F) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the elements of this slice are sorted using the given key extraction function.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1648565,"byte_end":1648574,"line_start":2460,"line_end":2460,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1648579,"byte_end":1648650,"line_start":2461,"line_end":2461,"column_start":5,"column_end":76}}]},{"kind":"Method","id":{"krate":0,"index":5140},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1649061,"byte_end":1649069,"line_start":2477,"line_end":2477,"column_start":12,"column_end":20},"name":"is_ascii","qualname":"<[u8]>::is_ascii","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if all bytes in this slice are within the ASCII range.\n","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1648967,"byte_end":1649035,"line_start":2475,"line_end":2475,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1649040,"byte_end":1649049,"line_start":2476,"line_end":2476,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5142},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1649432,"byte_end":1649452,"line_start":2487,"line_end":2487,"column_start":12,"column_end":32},"name":"eq_ignore_ascii_case","qualname":"<[u8]>::eq_ignore_ascii_case","value":"fn (&self, other: &[u8]) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks that two slices are an ASCII case-insensitive match.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1649338,"byte_end":1649406,"line_start":2485,"line_end":2485,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1649411,"byte_end":1649420,"line_start":2486,"line_end":2486,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5144},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1650106,"byte_end":1650126,"line_start":2505,"line_end":2505,"column_start":12,"column_end":32},"name":"make_ascii_uppercase","qualname":"<[u8]>::make_ascii_uppercase","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Converts this slice to its ASCII upper case equivalent in-place.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1650012,"byte_end":1650080,"line_start":2503,"line_end":2503,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1650085,"byte_end":1650094,"line_start":2504,"line_end":2504,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5145},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1650696,"byte_end":1650716,"line_start":2522,"line_end":2522,"column_start":12,"column_end":32},"name":"make_ascii_lowercase","qualname":"<[u8]>::make_ascii_lowercase","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Converts this slice to its ASCII lower case equivalent in-place.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1650602,"byte_end":1650670,"line_start":2520,"line_end":2520,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1650675,"byte_end":1650684,"line_start":2521,"line_end":2521,"column_start":5,"column_end":14}}]},{"kind":"Trait","id":{"krate":0,"index":5160},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1651835,"byte_end":1651841,"line_start":2573,"line_end":2573,"column_start":15,"column_end":21},"name":"Sealed","qualname":"::slice::private_slice_index::Sealed","value":"Sealed","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"stable(feature = \"slice_get_slice\", since = \"1.28.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1651764,"byte_end":1651820,"line_start":2572,"line_end":2572,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":5168},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1653207,"byte_end":1653217,"line_start":2606,"line_end":2606,"column_start":11,"column_end":21},"name":"SliceIndex","qualname":"::slice::SliceIndex","value":"SliceIndex<T: ?Sized>: private_slice_index::Sealed","parent":null,"children":[{"krate":0,"index":5170},{"krate":0,"index":5171},{"krate":0,"index":5172},{"krate":0,"index":5173},{"krate":0,"index":5174},{"krate":0,"index":5175},{"krate":0,"index":5176}],"decl_id":null,"docs":" A helper trait used for indexing operations.\n","sig":null,"attributes":[{"value":"stable(feature = \"slice_get_slice\", since = \"1.28.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1652623,"byte_end":1652679,"line_start":2592,"line_end":2592,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(on(T = \"str\",\n                            label = \"string indices are ranges of `usize`\"),\n                         on(all(any(T = \"str\",\n                                    T = \"&str\",\n                                    T = \"std::string::String\"),\n                                _Self = \"{integer}\"),\n                            note =\n                                \"you can use `.chars().nth()` or `.bytes().nth()`\nsee chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"),\n                         message =\n                             \"the type `{T}` cannot be indexed by `{Self}`\",\n                         label =\n                             \"slice indices are of type `usize` or ranges of `usize`\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1652680,"byte_end":1653196,"line_start":2593,"line_end":2605,"column_start":1,"column_end":3}}]},{"kind":"Type","id":{"krate":0,"index":5170},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1653375,"byte_end":1653381,"line_start":2609,"line_end":2609,"column_start":10,"column_end":16},"name":"Output","qualname":"::slice::SliceIndex::Output","value":"type Output: ?Sized;","parent":{"krate":0,"index":5168},"children":[],"decl_id":null,"docs":" The output type returned by methods.\n","sig":null,"attributes":[{"value":"stable(feature = \"slice_get_slice\", since = \"1.28.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1653309,"byte_end":1653365,"line_start":2608,"line_end":2608,"column_start":5,"column_end":61}}]},{"kind":"Method","id":{"krate":0,"index":5171},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1653550,"byte_end":1653553,"line_start":2614,"line_end":2614,"column_start":8,"column_end":11},"name":"get","qualname":"::slice::SliceIndex::get","value":"fn (self, slice: &T) -> Option<&Self::Output>","parent":{"krate":0,"index":5168},"children":[],"decl_id":null,"docs":" Returns a shared reference to the output at this location, if in\n bounds.\n","sig":null,"attributes":[{"value":"unstable(feature = \"slice_index_methods\", issue = \"0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1653485,"byte_end":1653542,"line_start":2613,"line_end":2613,"column_start":5,"column_end":62}}]},{"kind":"Method","id":{"krate":0,"index":5172},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1653757,"byte_end":1653764,"line_start":2619,"line_end":2619,"column_start":8,"column_end":15},"name":"get_mut","qualname":"::slice::SliceIndex::get_mut","value":"fn (self, slice: &mut T) -> Option<&mut Self::Output>","parent":{"krate":0,"index":5168},"children":[],"decl_id":null,"docs":" Returns a mutable reference to the output at this location, if in\n bounds.\n","sig":null,"attributes":[{"value":"unstable(feature = \"slice_index_methods\", issue = \"0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1653692,"byte_end":1653749,"line_start":2618,"line_end":2618,"column_start":5,"column_end":62}}]},{"kind":"Method","id":{"krate":0,"index":5173},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1654008,"byte_end":1654021,"line_start":2624,"line_end":2624,"column_start":15,"column_end":28},"name":"get_unchecked","qualname":"::slice::SliceIndex::get_unchecked","value":"fn (self, slice: &T) -> &Self::Output","parent":{"krate":0,"index":5168},"children":[],"decl_id":null,"docs":" Returns a shared reference to the output at this location, without\n performing any bounds checking.\n","sig":null,"attributes":[{"value":"unstable(feature = \"slice_index_methods\", issue = \"0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1653936,"byte_end":1653993,"line_start":2623,"line_end":2623,"column_start":5,"column_end":62}}]},{"kind":"Method","id":{"krate":0,"index":5174},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1654250,"byte_end":1654267,"line_start":2629,"line_end":2629,"column_start":15,"column_end":32},"name":"get_unchecked_mut","qualname":"::slice::SliceIndex::get_unchecked_mut","value":"fn (self, slice: &mut T) -> &mut Self::Output","parent":{"krate":0,"index":5168},"children":[],"decl_id":null,"docs":" Returns a mutable reference to the output at this location, without\n performing any bounds checking.\n","sig":null,"attributes":[{"value":"unstable(feature = \"slice_index_methods\", issue = \"0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1654178,"byte_end":1654235,"line_start":2628,"line_end":2628,"column_start":5,"column_end":62}}]},{"kind":"Method","id":{"krate":0,"index":5175},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1654484,"byte_end":1654489,"line_start":2634,"line_end":2634,"column_start":8,"column_end":13},"name":"index","qualname":"::slice::SliceIndex::index","value":"fn (self, slice: &T) -> &Self::Output","parent":{"krate":0,"index":5168},"children":[],"decl_id":null,"docs":" Returns a shared reference to the output at this location, panicking\n if out of bounds.\n","sig":null,"attributes":[{"value":"unstable(feature = \"slice_index_methods\", issue = \"0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1654419,"byte_end":1654476,"line_start":2633,"line_end":2633,"column_start":5,"column_end":62}}]},{"kind":"Method","id":{"krate":0,"index":5176},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1654699,"byte_end":1654708,"line_start":2639,"line_end":2639,"column_start":8,"column_end":17},"name":"index_mut","qualname":"::slice::SliceIndex::index_mut","value":"fn (self, slice: &mut T) -> &mut Self::Output","parent":{"krate":0,"index":5168},"children":[],"decl_id":null,"docs":" Returns a mutable reference to the output at this location, panicking\n if out of bounds.\n","sig":null,"attributes":[{"value":"unstable(feature = \"slice_index_methods\", issue = \"0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1654634,"byte_end":1654691,"line_start":2638,"line_end":2638,"column_start":5,"column_end":62}}]},{"kind":"Struct","id":{"krate":0,"index":5263},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1675887,"byte_end":1675891,"line_start":3318,"line_end":3318,"column_start":12,"column_end":16},"name":"Iter","qualname":"::slice::Iter","value":"Iter {  }","parent":null,"children":[{"krate":0,"index":5266},{"krate":0,"index":5267},{"krate":0,"index":5268}],"decl_id":null,"docs":" Immutable slice iterator","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1675830,"byte_end":1675875,"line_start":3317,"line_end":3317,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":5279},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1677577,"byte_end":1677585,"line_start":3366,"line_end":3366,"column_start":12,"column_end":20},"name":"as_slice","qualname":"<Iter>::as_slice","value":"fn (&self) -> &'a [T]","parent":null,"children":[],"decl_id":null,"docs":" Views the underlying data as a subslice of the original data.","sig":null,"attributes":[{"value":"stable(feature = \"iter_to_slice\", since = \"1.4.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1677512,"byte_end":1677565,"line_start":3365,"line_end":3365,"column_start":5,"column_end":58}}]},{"kind":"Struct","id":{"krate":0,"index":5286},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1679027,"byte_end":1679034,"line_start":3420,"line_end":3420,"column_start":12,"column_end":19},"name":"IterMut","qualname":"::slice::IterMut","value":"IterMut {  }","parent":null,"children":[{"krate":0,"index":5289},{"krate":0,"index":5290},{"krate":0,"index":5291}],"decl_id":null,"docs":" Mutable slice iterator.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1678970,"byte_end":1679015,"line_start":3419,"line_end":3419,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":5302},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1681028,"byte_end":1681038,"line_start":3477,"line_end":3477,"column_start":12,"column_end":22},"name":"into_slice","qualname":"<IterMut>::into_slice","value":"fn (self) -> &'a mut [T]","parent":null,"children":[],"decl_id":null,"docs":" Views the underlying data as a subslice of the original data.","sig":null,"attributes":[{"value":"stable(feature = \"iter_to_slice\", since = \"1.4.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1680963,"byte_end":1681016,"line_start":3476,"line_end":3476,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":5303},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1682061,"byte_end":1682069,"line_start":3505,"line_end":3505,"column_start":12,"column_end":20},"name":"as_slice","qualname":"<IterMut>::as_slice","value":"fn (&self) -> &[T]","parent":null,"children":[],"decl_id":null,"docs":" Views the underlying data as a subslice of the original data.","sig":null,"attributes":[{"value":"unstable(feature = \"slice_iter_mut_as_slice\",\n           reason = \"recently added\",\n           issue = \"58957\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1681957,"byte_end":1682049,"line_start":3504,"line_end":3504,"column_start":5,"column_end":97}}]},{"kind":"Method","id":{"krate":0,"index":5305},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1682471,"byte_end":1682477,"line_start":3518,"line_end":3518,"column_start":8,"column_end":14},"name":"finish","qualname":"::slice::SplitIter::finish","value":"fn (&mut self) -> Option<Self::Item>","parent":{"krate":0,"index":5304},"children":[],"decl_id":null,"docs":" Marks the underlying iterator as complete, extracting the remaining\n portion of the slice.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":5306},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1682838,"byte_end":1682843,"line_start":3529,"line_end":3529,"column_start":12,"column_end":17},"name":"Split","qualname":"::slice::Split","value":"Split {  }","parent":null,"children":[{"krate":0,"index":5310},{"krate":0,"index":5311},{"krate":0,"index":5312}],"decl_id":null,"docs":" An iterator over subslices separated by elements that match a predicate\n function.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1682781,"byte_end":1682826,"line_start":3528,"line_end":3528,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":5343},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1685521,"byte_end":1685529,"line_start":3620,"line_end":3620,"column_start":12,"column_end":20},"name":"SplitMut","qualname":"::slice::SplitMut","value":"SplitMut {  }","parent":null,"children":[{"krate":0,"index":5347},{"krate":0,"index":5348},{"krate":0,"index":5349}],"decl_id":null,"docs":" An iterator over the subslices of the vector which are separated\n by elements that match `pred`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1685464,"byte_end":1685509,"line_start":3619,"line_end":3619,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":33147},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1688644,"byte_end":1688650,"line_start":3719,"line_end":3719,"column_start":12,"column_end":18},"name":"RSplit","qualname":"::slice::RSplit","value":"RSplit {  }","parent":null,"children":[{"krate":0,"index":33151}],"decl_id":null,"docs":" An iterator over subslices separated by elements that match a predicate\n function, starting from the end of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"slice_rsplit\", since = \"1.27.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1688499,"byte_end":1688552,"line_start":3717,"line_end":3717,"column_start":1,"column_end":54}}]},{"kind":"Struct","id":{"krate":0,"index":5400},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1690426,"byte_end":1690435,"line_start":3775,"line_end":3775,"column_start":12,"column_end":21},"name":"RSplitMut","qualname":"::slice::RSplitMut","value":"RSplitMut {  }","parent":null,"children":[{"krate":0,"index":5404}],"decl_id":null,"docs":" An iterator over the subslices of the vector which are separated\n by elements that match `pred`, starting from the end of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"slice_rsplit\", since = \"1.27.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1690361,"byte_end":1690414,"line_start":3774,"line_end":3774,"column_start":1,"column_end":54}}]},{"kind":"Struct","id":{"krate":0,"index":5436},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1692954,"byte_end":1692960,"line_start":3861,"line_end":3861,"column_start":12,"column_end":18},"name":"SplitN","qualname":"::slice::SplitN","value":"SplitN {  }","parent":null,"children":[{"krate":0,"index":5440}],"decl_id":null,"docs":" An iterator over subslices separated by elements that match a predicate\n function, limited to a given number of splits.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1692897,"byte_end":1692942,"line_start":3860,"line_end":3860,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":5445},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1693763,"byte_end":1693770,"line_start":3883,"line_end":3883,"column_start":12,"column_end":19},"name":"RSplitN","qualname":"::slice::RSplitN","value":"RSplitN {  }","parent":null,"children":[{"krate":0,"index":5449}],"decl_id":null,"docs":" An iterator over subslices separated by elements that match a\n predicate function, limited to a given number of splits, starting\n from the end of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1693706,"byte_end":1693751,"line_start":3882,"line_end":3882,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":5454},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1694545,"byte_end":1694554,"line_start":3904,"line_end":3904,"column_start":12,"column_end":21},"name":"SplitNMut","qualname":"::slice::SplitNMut","value":"SplitNMut {  }","parent":null,"children":[{"krate":0,"index":5458}],"decl_id":null,"docs":" An iterator over subslices separated by elements that match a predicate\n function, limited to a given number of splits.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1694488,"byte_end":1694533,"line_start":3903,"line_end":3903,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":5463},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1695378,"byte_end":1695388,"line_start":3926,"line_end":3926,"column_start":12,"column_end":22},"name":"RSplitNMut","qualname":"::slice::RSplitNMut","value":"RSplitNMut {  }","parent":null,"children":[{"krate":0,"index":5467}],"decl_id":null,"docs":" An iterator over subslices separated by elements that match a\n predicate function, limited to a given number of splits, starting\n from the end of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1695321,"byte_end":1695366,"line_start":3925,"line_end":3925,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":33208},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1697015,"byte_end":1697022,"line_start":3977,"line_end":3977,"column_start":12,"column_end":19},"name":"Windows","qualname":"::slice::Windows","value":"Windows {  }","parent":null,"children":[{"krate":0,"index":33211},{"krate":0,"index":33212}],"decl_id":null,"docs":" An iterator over overlapping subslices of length `size`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1696958,"byte_end":1697003,"line_start":3976,"line_end":3976,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":33217},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1700391,"byte_end":1700397,"line_start":4103,"line_end":4103,"column_start":12,"column_end":18},"name":"Chunks","qualname":"::slice::Chunks","value":"Chunks {  }","parent":null,"children":[{"krate":0,"index":33220},{"krate":0,"index":33221}],"decl_id":null,"docs":" An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n time), starting at the beginning of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1700334,"byte_end":1700379,"line_start":4102,"line_end":4102,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":33226},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1704681,"byte_end":1704690,"line_start":4248,"line_end":4248,"column_start":12,"column_end":21},"name":"ChunksMut","qualname":"::slice::ChunksMut","value":"ChunksMut {  }","parent":null,"children":[{"krate":0,"index":33229},{"krate":0,"index":33230}],"decl_id":null,"docs":" An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n elements at a time), starting at the beginning of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1704624,"byte_end":1704669,"line_start":4247,"line_end":4247,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":33235},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1708624,"byte_end":1708635,"line_start":4371,"line_end":4371,"column_start":12,"column_end":23},"name":"ChunksExact","qualname":"::slice::ChunksExact","value":"ChunksExact {  }","parent":null,"children":[{"krate":0,"index":33238},{"krate":0,"index":33239},{"krate":0,"index":33240}],"decl_id":null,"docs":" An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n time), starting at the beginning of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"chunks_exact\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1708559,"byte_end":1708612,"line_start":4370,"line_end":4370,"column_start":1,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":5556},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1708983,"byte_end":1708992,"line_start":4382,"line_end":4382,"column_start":12,"column_end":21},"name":"remainder","qualname":"<ChunksExact>::remainder","value":"fn (&self) -> &'a [T]","parent":null,"children":[],"decl_id":null,"docs":" Returns the remainder of the original slice that is not going to be\n returned by the iterator. The returned slice has at most `chunk_size-1`\n elements.\n","sig":null,"attributes":[{"value":"stable(feature = \"chunks_exact\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1708918,"byte_end":1708971,"line_start":4381,"line_end":4381,"column_start":5,"column_end":58}}]},{"kind":"Struct","id":{"krate":0,"index":33245},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1712281,"byte_end":1712295,"line_start":4495,"line_end":4495,"column_start":12,"column_end":26},"name":"ChunksExactMut","qualname":"::slice::ChunksExactMut","value":"ChunksExactMut {  }","parent":null,"children":[{"krate":0,"index":33248},{"krate":0,"index":33249},{"krate":0,"index":33250}],"decl_id":null,"docs":" An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n elements at a time), starting at the beginning of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"chunks_exact\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1712216,"byte_end":1712269,"line_start":4494,"line_end":4494,"column_start":1,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":5588},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1712654,"byte_end":1712668,"line_start":4506,"line_end":4506,"column_start":12,"column_end":26},"name":"into_remainder","qualname":"<ChunksExactMut>::into_remainder","value":"fn (self) -> &'a mut [T]","parent":null,"children":[],"decl_id":null,"docs":" Returns the remainder of the original slice that is not going to be\n returned by the iterator. The returned slice has at most `chunk_size-1`\n elements.\n","sig":null,"attributes":[{"value":"stable(feature = \"chunks_exact\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1712589,"byte_end":1712642,"line_start":4505,"line_end":4505,"column_start":5,"column_end":58}}]},{"kind":"Struct","id":{"krate":0,"index":33255},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1715698,"byte_end":1715705,"line_start":4609,"line_end":4609,"column_start":12,"column_end":19},"name":"RChunks","qualname":"::slice::RChunks","value":"RChunks {  }","parent":null,"children":[{"krate":0,"index":33258},{"krate":0,"index":33259}],"decl_id":null,"docs":" An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n time), starting at the end of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rchunks\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1715638,"byte_end":1715686,"line_start":4608,"line_end":4608,"column_start":1,"column_end":49}}]},{"kind":"Struct","id":{"krate":0,"index":33264},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1720143,"byte_end":1720153,"line_start":4757,"line_end":4757,"column_start":12,"column_end":22},"name":"RChunksMut","qualname":"::slice::RChunksMut","value":"RChunksMut {  }","parent":null,"children":[{"krate":0,"index":33267},{"krate":0,"index":33268}],"decl_id":null,"docs":" An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n elements at a time), starting at the end of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rchunks\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1720083,"byte_end":1720131,"line_start":4756,"line_end":4756,"column_start":1,"column_end":49}}]},{"kind":"Struct","id":{"krate":0,"index":33273},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1724870,"byte_end":1724882,"line_start":4902,"line_end":4902,"column_start":12,"column_end":24},"name":"RChunksExact","qualname":"::slice::RChunksExact","value":"RChunksExact {  }","parent":null,"children":[{"krate":0,"index":33276},{"krate":0,"index":33277},{"krate":0,"index":33278}],"decl_id":null,"docs":" An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n time), starting at the end of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rchunks\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1724810,"byte_end":1724858,"line_start":4901,"line_end":4901,"column_start":1,"column_end":49}}]},{"kind":"Method","id":{"krate":0,"index":5670},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1725226,"byte_end":1725235,"line_start":4913,"line_end":4913,"column_start":12,"column_end":21},"name":"remainder","qualname":"<RChunksExact>::remainder","value":"fn (&self) -> &'a [T]","parent":null,"children":[],"decl_id":null,"docs":" Returns the remainder of the original slice that is not going to be\n returned by the iterator. The returned slice has at most `chunk_size-1`\n elements.\n","sig":null,"attributes":[{"value":"stable(feature = \"rchunks\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1725166,"byte_end":1725214,"line_start":4912,"line_end":4912,"column_start":5,"column_end":53}}]},{"kind":"Struct","id":{"krate":0,"index":33283},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1729174,"byte_end":1729189,"line_start":5045,"line_end":5045,"column_start":12,"column_end":27},"name":"RChunksExactMut","qualname":"::slice::RChunksExactMut","value":"RChunksExactMut {  }","parent":null,"children":[{"krate":0,"index":33286},{"krate":0,"index":33287},{"krate":0,"index":33288}],"decl_id":null,"docs":" An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n elements at a time), starting at the end of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rchunks\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1729114,"byte_end":1729162,"line_start":5044,"line_end":5044,"column_start":1,"column_end":49}}]},{"kind":"Method","id":{"krate":0,"index":5705},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1729544,"byte_end":1729558,"line_start":5056,"line_end":5056,"column_start":12,"column_end":26},"name":"into_remainder","qualname":"<RChunksExactMut>::into_remainder","value":"fn (self) -> &'a mut [T]","parent":null,"children":[],"decl_id":null,"docs":" Returns the remainder of the original slice that is not going to be\n returned by the iterator. The returned slice has at most `chunk_size-1`\n elements.\n","sig":null,"attributes":[{"value":"stable(feature = \"rchunks\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1729484,"byte_end":1729532,"line_start":5055,"line_end":5055,"column_start":5,"column_end":53}}]},{"kind":"Function","id":{"krate":0,"index":5732},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1734524,"byte_end":1734538,"line_start":5215,"line_end":5215,"column_start":15,"column_end":29},"name":"from_raw_parts","qualname":"::slice::from_raw_parts","value":"fn <'a, T> (data: *const T, len: usize) -> &'a [T]","parent":null,"children":[],"decl_id":null,"docs":" Forms a slice from a pointer and a length.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1734454,"byte_end":1734463,"line_start":5213,"line_end":5213,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1734464,"byte_end":1734509,"line_start":5214,"line_end":5214,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":5735},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1735565,"byte_end":1735583,"line_start":5236,"line_end":5236,"column_start":15,"column_end":33},"name":"from_raw_parts_mut","qualname":"::slice::from_raw_parts_mut","value":"fn <'a, T> (data: *mut T, len: usize) -> &'a mut [T]","parent":null,"children":[],"decl_id":null,"docs":" Performs the same functionality as [`from_raw_parts`], except that a\n mutable slice is returned.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1735495,"byte_end":1735504,"line_start":5234,"line_end":5234,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1735505,"byte_end":1735550,"line_start":5235,"line_end":5235,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":5738},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1736078,"byte_end":1736086,"line_start":5245,"line_end":5245,"column_start":8,"column_end":16},"name":"from_ref","qualname":"::slice::from_ref","value":"fn <T> (s: &T) -> &[T]","parent":null,"children":[],"decl_id":null,"docs":" Converts a reference to T into a slice of length 1 (without copying).\n","sig":null,"attributes":[{"value":"stable(feature = \"from_ref\", since = \"1.28.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1736021,"byte_end":1736070,"line_start":5244,"line_end":5244,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":5740},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1736289,"byte_end":1736297,"line_start":5253,"line_end":5253,"column_start":8,"column_end":16},"name":"from_mut","qualname":"::slice::from_mut","value":"fn <T> (s: &mut T) -> &mut [T]","parent":null,"children":[],"decl_id":null,"docs":" Converts a reference to T into a slice of length 1 (without copying).\n","sig":null,"attributes":[{"value":"stable(feature = \"from_ref\", since = \"1.28.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1736232,"byte_end":1736281,"line_start":5252,"line_end":5252,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":5742},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1736577,"byte_end":1736585,"line_start":5262,"line_end":5262,"column_start":8,"column_end":16},"name":"heapsort","qualname":"::slice::heapsort","value":"fn <T, F> (v: &mut [T], mut is_less: F) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"sort_internals\",\n           reason = \"internal to sort module\",\n           issue = \"0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1736466,"byte_end":1736554,"line_start":5260,"line_end":5260,"column_start":1,"column_end":89}}]},{"kind":"Method","id":{"krate":0,"index":5762},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1737990,"byte_end":1737995,"line_start":5316,"line_end":5316,"column_start":8,"column_end":13},"name":"equal","qualname":"::slice::SlicePartialEq::equal","value":"fn (&self, other: &[B]) -> bool","parent":{"krate":0,"index":5760},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5763},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1738033,"byte_end":1738042,"line_start":5318,"line_end":5318,"column_start":8,"column_end":17},"name":"not_equal","qualname":"::slice::SlicePartialEq::not_equal","value":"fn (&self, other: &[B]) -> bool","parent":{"krate":0,"index":5760},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5773},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1739102,"byte_end":1739117,"line_start":5362,"line_end":5362,"column_start":8,"column_end":23},"name":"partial_compare","qualname":"::slice::SlicePartialOrd::partial_compare","value":"fn (&self, other: &[B]) -> Option<Ordering>","parent":{"krate":0,"index":5771},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5782},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1740032,"byte_end":1740039,"line_start":5398,"line_end":5398,"column_start":8,"column_end":15},"name":"compare","qualname":"::slice::SliceOrd::compare","value":"fn (&self, other: &[B]) -> Ordering","parent":{"krate":0,"index":5780},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5801},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1742047,"byte_end":1742061,"line_start":5475,"line_end":5475,"column_start":8,"column_end":22},"name":"slice_contains","qualname":"::slice::SliceContains::slice_contains","value":"fn (&self, x: &[Self]) -> bool","parent":{"krate":0,"index":5800},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5810},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"str","qualname":"::str","value":"src/libcore/str/mod.rs","parent":null,"children":[{"krate":0,"index":5811},{"krate":0,"index":5812},{"krate":0,"index":5816},{"krate":0,"index":5817},{"krate":0,"index":5820},{"krate":0,"index":5827},{"krate":0,"index":5831},{"krate":0,"index":5835},{"krate":0,"index":5836},{"krate":0,"index":5837},{"krate":0,"index":5838},{"krate":0,"index":5995},{"krate":0,"index":6022},{"krate":0,"index":6025},{"krate":0,"index":33474},{"krate":0,"index":33483},{"krate":0,"index":33481},{"krate":0,"index":33478},{"krate":0,"index":33476},{"krate":0,"index":6028},{"krate":0,"index":33485},{"krate":0,"index":33497},{"krate":0,"index":33495},{"krate":0,"index":33492},{"krate":0,"index":33490},{"krate":0,"index":33488},{"krate":0,"index":6030},{"krate":0,"index":6034},{"krate":0,"index":6035},{"krate":0,"index":6036},{"krate":0,"index":6037},{"krate":0,"index":6038},{"krate":0,"index":33498},{"krate":0,"index":33504},{"krate":0,"index":33501},{"krate":0,"index":6040},{"krate":0,"index":6041},{"krate":0,"index":6042},{"krate":0,"index":6043},{"krate":0,"index":6044},{"krate":0,"index":6047},{"krate":0,"index":6050},{"krate":0,"index":6058},{"krate":0,"index":6062},{"krate":0,"index":6063},{"krate":0,"index":33507},{"krate":0,"index":33514},{"krate":0,"index":33511},{"krate":0,"index":6066},{"krate":0,"index":6073},{"krate":0,"index":6077},{"krate":0,"index":6078},{"krate":0,"index":33517},{"krate":0,"index":33524},{"krate":0,"index":33521},{"krate":0,"index":6081},{"krate":0,"index":6098},{"krate":0,"index":6103},{"krate":0,"index":6106},{"krate":0,"index":6107},{"krate":0,"index":6108},{"krate":0,"index":6111},{"krate":0,"index":6112},{"krate":0,"index":33527},{"krate":0,"index":6113},{"krate":0,"index":6121},{"krate":0,"index":6125},{"krate":0,"index":33531},{"krate":0,"index":33536},{"krate":0,"index":33540},{"krate":0,"index":33545},{"krate":0,"index":33549},{"krate":0,"index":33554},{"krate":0,"index":33558},{"krate":0,"index":33563},{"krate":0,"index":33567},{"krate":0,"index":33570},{"krate":0,"index":33573},{"krate":0,"index":33577},{"krate":0,"index":33581},{"krate":0,"index":33586},{"krate":0,"index":33590},{"krate":0,"index":33595},{"krate":0,"index":33599},{"krate":0,"index":33604},{"krate":0,"index":33608},{"krate":0,"index":33613},{"krate":0,"index":33617},{"krate":0,"index":33620},{"krate":0,"index":33623},{"krate":0,"index":33627},{"krate":0,"index":33631},{"krate":0,"index":6131},{"krate":0,"index":6136},{"krate":0,"index":6140},{"krate":0,"index":33635},{"krate":0,"index":33640},{"krate":0,"index":33644},{"krate":0,"index":33649},{"krate":0,"index":33653},{"krate":0,"index":33658},{"krate":0,"index":33662},{"krate":0,"index":33667},{"krate":0,"index":33671},{"krate":0,"index":33674},{"krate":0,"index":33677},{"krate":0,"index":6145},{"krate":0,"index":6150},{"krate":0,"index":6154},{"krate":0,"index":33681},{"krate":0,"index":33686},{"krate":0,"index":33690},{"krate":0,"index":33695},{"krate":0,"index":33699},{"krate":0,"index":33704},{"krate":0,"index":33708},{"krate":0,"index":33713},{"krate":0,"index":33717},{"krate":0,"index":33720},{"krate":0,"index":33723},{"krate":0,"index":33727},{"krate":0,"index":33731},{"krate":0,"index":6161},{"krate":0,"index":6166},{"krate":0,"index":6170},{"krate":0,"index":33735},{"krate":0,"index":33740},{"krate":0,"index":33744},{"krate":0,"index":33749},{"krate":0,"index":33753},{"krate":0,"index":33758},{"krate":0,"index":33762},{"krate":0,"index":33767},{"krate":0,"index":33771},{"krate":0,"index":33774},{"krate":0,"index":33777},{"krate":0,"index":33781},{"krate":0,"index":33785},{"krate":0,"index":33792},{"krate":0,"index":33789},{"krate":0,"index":6177},{"krate":0,"index":6182},{"krate":0,"index":6185},{"krate":0,"index":33795},{"krate":0,"index":33802},{"krate":0,"index":33799},{"krate":0,"index":33815},{"krate":0,"index":33817},{"krate":0,"index":33805},{"krate":0,"index":33808},{"krate":0,"index":33811},{"krate":0,"index":6186},{"krate":0,"index":6191},{"krate":0,"index":6194},{"krate":0,"index":6195},{"krate":0,"index":6196},{"krate":0,"index":6197},{"krate":0,"index":6200},{"krate":0,"index":6202},{"krate":0,"index":6203},{"krate":0,"index":6204},{"krate":0,"index":6205},{"krate":0,"index":6278},{"krate":0,"index":6279},{"krate":0,"index":6281},{"krate":0,"index":33840},{"krate":0,"index":33842},{"krate":0,"index":33819},{"krate":0,"index":33821},{"krate":0,"index":33823},{"krate":0,"index":33844},{"krate":0,"index":33846},{"krate":0,"index":33826},{"krate":0,"index":33828},{"krate":0,"index":33830},{"krate":0,"index":33848},{"krate":0,"index":33850},{"krate":0,"index":33833},{"krate":0,"index":33835},{"krate":0,"index":33837},{"krate":0,"index":6394},{"krate":0,"index":6396},{"krate":0,"index":6398},{"krate":0,"index":33852},{"krate":0,"index":33858},{"krate":0,"index":33855},{"krate":0,"index":33861},{"krate":0,"index":33867},{"krate":0,"index":33864},{"krate":0,"index":33920},{"krate":0,"index":33922},{"krate":0,"index":33870},{"krate":0,"index":33872},{"krate":0,"index":33874},{"krate":0,"index":33924},{"krate":0,"index":33926},{"krate":0,"index":33877},{"krate":0,"index":33879},{"krate":0,"index":33881},{"krate":0,"index":33928},{"krate":0,"index":33930},{"krate":0,"index":33884},{"krate":0,"index":33888},{"krate":0,"index":33892},{"krate":0,"index":33932},{"krate":0,"index":33934},{"krate":0,"index":33897},{"krate":0,"index":33901},{"krate":0,"index":33905},{"krate":0,"index":33936},{"krate":0,"index":33938},{"krate":0,"index":33910},{"krate":0,"index":33913},{"krate":0,"index":33916},{"krate":0,"index":6400},{"krate":0,"index":6405},{"krate":0,"index":6408},{"krate":0,"index":6409},{"krate":0,"index":6414},{"krate":0,"index":6417},{"krate":0,"index":33940},{"krate":0,"index":33944},{"krate":0,"index":6418},{"krate":0,"index":6420},{"krate":0,"index":6428},{"krate":0,"index":33947},{"krate":0,"index":33953},{"krate":0,"index":33950},{"krate":0,"index":33956},{"krate":0,"index":33962},{"krate":0,"index":33959},{"krate":0,"index":33965},{"krate":0,"index":33971},{"krate":0,"index":33968},{"krate":0,"index":6429},{"krate":0,"index":33974},{"krate":0,"index":33978},{"krate":0,"index":33990},{"krate":0,"index":33992},{"krate":0,"index":33996},{"krate":0,"index":34008},{"krate":0,"index":34010},{"krate":0,"index":34014},{"krate":0,"index":34026}],"decl_id":null,"docs":" String manipulation.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1778564,"byte_end":1778610,"line_start":7,"line_end":7,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":5838},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"pattern","qualname":"::str::pattern","value":"src/libcore/str/pattern.rs","parent":null,"children":[{"krate":0,"index":5839},{"krate":0,"index":5840},{"krate":0,"index":5841},{"krate":0,"index":5842},{"krate":0,"index":5843},{"krate":0,"index":33307},{"krate":0,"index":33327},{"krate":0,"index":33325},{"krate":0,"index":33323},{"krate":0,"index":33320},{"krate":0,"index":33318},{"krate":0,"index":5850},{"krate":0,"index":5856},{"krate":0,"index":5861},{"krate":0,"index":33328},{"krate":0,"index":33340},{"krate":0,"index":33337},{"krate":0,"index":5863},{"krate":0,"index":5868},{"krate":0,"index":5872},{"krate":0,"index":5874},{"krate":0,"index":5883},{"krate":0,"index":5885},{"krate":0,"index":5888},{"krate":0,"index":5891},{"krate":0,"index":33343},{"krate":0,"index":33353},{"krate":0,"index":33349},{"krate":0,"index":5895},{"krate":0,"index":5900},{"krate":0,"index":5905},{"krate":0,"index":5909},{"krate":0,"index":5912},{"krate":0,"index":5913},{"krate":0,"index":33357},{"krate":0,"index":33366},{"krate":0,"index":33362},{"krate":0,"index":5914},{"krate":0,"index":5917},{"krate":0,"index":5920},{"krate":0,"index":5923},{"krate":0,"index":33382},{"krate":0,"index":33387},{"krate":0,"index":5926},{"krate":0,"index":5929},{"krate":0,"index":5932},{"krate":0,"index":5935},{"krate":0,"index":5938},{"krate":0,"index":5941},{"krate":0,"index":5945},{"krate":0,"index":33413},{"krate":0,"index":33423},{"krate":0,"index":33419},{"krate":0,"index":33427},{"krate":0,"index":33436},{"krate":0,"index":33434},{"krate":0,"index":33438},{"krate":0,"index":33445},{"krate":0,"index":33443},{"krate":0,"index":5952},{"krate":0,"index":5956},{"krate":0,"index":5962},{"krate":0,"index":33447},{"krate":0,"index":33458},{"krate":0,"index":33456},{"krate":0,"index":5967},{"krate":0,"index":5978},{"krate":0,"index":5983},{"krate":0,"index":5984},{"krate":0,"index":5989},{"krate":0,"index":5990}],"decl_id":null,"docs":" The string Pattern API.","sig":null,"attributes":[{"value":"unstable(feature = \"pattern\",\n           reason = \"API not fully fleshed out and ready to be stabilized\",\n           issue = \"27721\")","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1919693,"byte_end":1919832,"line_start":6,"line_end":8,"column_start":1,"column_end":30}}]},{"kind":"Trait","id":{"krate":0,"index":5843},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1920362,"byte_end":1920369,"line_start":28,"line_end":28,"column_start":11,"column_end":18},"name":"Pattern","qualname":"::str::pattern::Pattern","value":"Pattern<'a>: Sized","parent":null,"children":[{"krate":0,"index":5845},{"krate":0,"index":5846},{"krate":0,"index":5847},{"krate":0,"index":5848},{"krate":0,"index":5849}],"decl_id":null,"docs":" A string pattern.","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":5845},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1920437,"byte_end":1920445,"line_start":30,"line_end":30,"column_start":10,"column_end":18},"name":"Searcher","qualname":"::str::pattern::Pattern::Searcher","value":"type Searcher: Searcher<'a>;","parent":{"krate":0,"index":5843},"children":[],"decl_id":null,"docs":" Associated searcher for this pattern\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5846},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1920565,"byte_end":1920578,"line_start":34,"line_end":34,"column_start":8,"column_end":21},"name":"into_searcher","qualname":"::str::pattern::Pattern::into_searcher","value":"fn (self, haystack: &'a str) -> Self::Searcher","parent":{"krate":0,"index":5843},"children":[],"decl_id":null,"docs":" Constructs the associated searcher from\n `self` and the `haystack` to search in.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5847},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1920713,"byte_end":1920728,"line_start":38,"line_end":38,"column_start":8,"column_end":23},"name":"is_contained_in","qualname":"::str::pattern::Pattern::is_contained_in","value":"fn (self, haystack: &'a str) -> bool","parent":{"krate":0,"index":5843},"children":[],"decl_id":null,"docs":" Checks whether the pattern matches anywhere in the haystack\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1920696,"byte_end":1920705,"line_start":37,"line_end":37,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5848},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1920924,"byte_end":1920936,"line_start":44,"line_end":44,"column_start":8,"column_end":20},"name":"is_prefix_of","qualname":"::str::pattern::Pattern::is_prefix_of","value":"fn (self, haystack: &'a str) -> bool","parent":{"krate":0,"index":5843},"children":[],"decl_id":null,"docs":" Checks whether the pattern matches at the front of the haystack\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1920907,"byte_end":1920916,"line_start":43,"line_end":43,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5849},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1921202,"byte_end":1921214,"line_start":53,"line_end":53,"column_start":8,"column_end":20},"name":"is_suffix_of","qualname":"::str::pattern::Pattern::is_suffix_of","value":"fn (self, haystack: &'a str) -> bool","parent":{"krate":0,"index":5843},"children":[],"decl_id":null,"docs":" Checks whether the pattern matches at the back of the haystack\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1921185,"byte_end":1921194,"line_start":52,"line_end":52,"column_start":5,"column_end":14}}]},{"kind":"TupleVariant","id":{"krate":0,"index":33308},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1921722,"byte_end":1921727,"line_start":70,"line_end":70,"column_start":5,"column_end":10},"name":"Match","qualname":"::str::pattern::SearchStep::Match","value":"SearchStep::Match(usize, usize)","parent":{"krate":0,"index":33307},"children":[],"decl_id":null,"docs":" Expresses that a match of the pattern has been found at\n `haystack[a..b]`.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":33312},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1922002,"byte_end":1922008,"line_start":76,"line_end":76,"column_start":5,"column_end":11},"name":"Reject","qualname":"::str::pattern::SearchStep::Reject","value":"SearchStep::Reject(usize, usize)","parent":{"krate":0,"index":33307},"children":[],"decl_id":null,"docs":" Expresses that `haystack[a..b]` has been rejected as a possible match\n of the pattern.","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":33316},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1922126,"byte_end":1922130,"line_start":79,"line_end":79,"column_start":5,"column_end":9},"name":"Done","qualname":"::str::pattern::SearchStep::Done","value":"SearchStep::Done","parent":{"krate":0,"index":33307},"children":[],"decl_id":null,"docs":" Expresses that every byte of the haystack has been visited, ending\n the iteration.\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":33307},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1921615,"byte_end":1921625,"line_start":67,"line_end":67,"column_start":10,"column_end":20},"name":"SearchStep","qualname":"::str::pattern::SearchStep","value":"SearchStep::{Match, Reject, Done}","parent":null,"children":[{"krate":0,"index":33308},{"krate":0,"index":33312},{"krate":0,"index":33316}],"decl_id":null,"docs":" Result of calling `Searcher::next()` or `ReverseSearcher::next_back()`.\n","sig":null,"attributes":[{"value":"structural_match","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1921606,"byte_end":1922132,"line_start":67,"line_end":80,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1921606,"byte_end":1922132,"line_start":67,"line_end":80,"column_start":1,"column_end":2}}]},{"kind":"Trait","id":{"krate":0,"index":5850},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1922673,"byte_end":1922681,"line_start":94,"line_end":94,"column_start":18,"column_end":26},"name":"Searcher","qualname":"::str::pattern::Searcher","value":"Searcher<'a>","parent":null,"children":[{"krate":0,"index":5852},{"krate":0,"index":5853},{"krate":0,"index":5854},{"krate":0,"index":5855}],"decl_id":null,"docs":" A searcher for a string pattern.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5852},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1922805,"byte_end":1922813,"line_start":98,"line_end":98,"column_start":8,"column_end":16},"name":"haystack","qualname":"::str::pattern::Searcher::haystack","value":"fn (&self) -> &'a str","parent":{"krate":0,"index":5850},"children":[],"decl_id":null,"docs":" Getter for the underlying string to be searched in","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5853},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1923762,"byte_end":1923766,"line_start":118,"line_end":118,"column_start":8,"column_end":12},"name":"next","qualname":"::str::pattern::Searcher::next","value":"fn (&mut self) -> SearchStep","parent":{"krate":0,"index":5850},"children":[],"decl_id":null,"docs":" Performs the next search step starting from the front.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5854},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1924163,"byte_end":1924173,"line_start":127,"line_end":127,"column_start":8,"column_end":18},"name":"next_match","qualname":"::str::pattern::Searcher::next_match","value":"fn (&mut self) -> Option<(usize, usize)>","parent":{"krate":0,"index":5850},"children":[],"decl_id":null,"docs":" Finds the next `Match` result. See `next()`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1924146,"byte_end":1924155,"line_start":126,"line_end":126,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5855},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1924651,"byte_end":1924662,"line_start":142,"line_end":142,"column_start":8,"column_end":19},"name":"next_reject","qualname":"::str::pattern::Searcher::next_reject","value":"fn (&mut self) -> Option<(usize, usize)>","parent":{"krate":0,"index":5850},"children":[],"decl_id":null,"docs":" Finds the next `Reject` result. See `next()` and `next_match()`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1924634,"byte_end":1924643,"line_start":141,"line_end":141,"column_start":5,"column_end":14}}]},{"kind":"Trait","id":{"krate":0,"index":5856},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1925497,"byte_end":1925512,"line_start":167,"line_end":167,"column_start":18,"column_end":33},"name":"ReverseSearcher","qualname":"::str::pattern::ReverseSearcher","value":"ReverseSearcher<'a>: Searcher<'a>","parent":null,"children":[{"krate":0,"index":5858},{"krate":0,"index":5859},{"krate":0,"index":5860}],"decl_id":null,"docs":" A reverse searcher for a string pattern.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5858},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1926460,"byte_end":1926469,"line_start":186,"line_end":186,"column_start":8,"column_end":17},"name":"next_back","qualname":"::str::pattern::ReverseSearcher::next_back","value":"fn (&mut self) -> SearchStep","parent":{"krate":0,"index":5856},"children":[],"decl_id":null,"docs":" Performs the next search step starting from the back.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5859},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1926575,"byte_end":1926590,"line_start":190,"line_end":190,"column_start":8,"column_end":23},"name":"next_match_back","qualname":"::str::pattern::ReverseSearcher::next_match_back","value":"fn (&mut self) -> Option<(usize, usize)>","parent":{"krate":0,"index":5856},"children":[],"decl_id":null,"docs":" Finds the next `Match` result. See `next_back()`\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1926558,"byte_end":1926567,"line_start":189,"line_end":189,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":5860},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1926935,"byte_end":1926951,"line_start":202,"line_end":202,"column_start":8,"column_end":24},"name":"next_reject_back","qualname":"::str::pattern::ReverseSearcher::next_reject_back","value":"fn (&mut self) -> Option<(usize, usize)>","parent":{"krate":0,"index":5856},"children":[],"decl_id":null,"docs":" Finds the next `Reject` result. See `next_back()`\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1926918,"byte_end":1926927,"line_start":201,"line_end":201,"column_start":5,"column_end":14}}]},{"kind":"Trait","id":{"krate":0,"index":5861},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1928089,"byte_end":1928108,"line_start":234,"line_end":234,"column_start":11,"column_end":30},"name":"DoubleEndedSearcher","qualname":"::str::pattern::DoubleEndedSearcher","value":"DoubleEndedSearcher<'a>: ReverseSearcher<'a>","parent":null,"children":[],"decl_id":null,"docs":" A marker trait to express that a `ReverseSearcher`\n can be used for a `DoubleEndedIterator` implementation.","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":33328},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1928407,"byte_end":1928419,"line_start":243,"line_end":243,"column_start":12,"column_end":24},"name":"CharSearcher","qualname":"::str::pattern::CharSearcher","value":"CharSearcher {  }","parent":null,"children":[{"krate":0,"index":33330},{"krate":0,"index":33331},{"krate":0,"index":33332},{"krate":0,"index":33333},{"krate":0,"index":33334},{"krate":0,"index":33335}],"decl_id":null,"docs":" Associated type for `<char as Pattern<'a>>::Searcher`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5884},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1938157,"byte_end":1938164,"line_start":475,"line_end":475,"column_start":8,"column_end":15},"name":"matches","qualname":"::str::pattern::MultiCharEq::matches","value":"fn (&mut self, c: char) -> bool","parent":{"krate":0,"index":5883},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":33357},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1942596,"byte_end":1942613,"line_start":632,"line_end":632,"column_start":12,"column_end":29},"name":"CharSliceSearcher","qualname":"::str::pattern::CharSliceSearcher","value":"","parent":null,"children":[],"decl_id":null,"docs":" Associated type for `<&[char] as Pattern<'a>>::Searcher`.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":33382},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1943441,"byte_end":1943462,"line_start":655,"line_end":655,"column_start":12,"column_end":33},"name":"CharPredicateSearcher","qualname":"::str::pattern::CharPredicateSearcher","value":"","parent":null,"children":[],"decl_id":null,"docs":" Associated type for `<F as Pattern<'a>>::Searcher`.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":33413},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1946166,"byte_end":1946177,"line_start":736,"line_end":736,"column_start":12,"column_end":23},"name":"StrSearcher","qualname":"::str::pattern::StrSearcher","value":"StrSearcher {  }","parent":null,"children":[{"krate":0,"index":33416},{"krate":0,"index":33417},{"krate":0,"index":33418}],"decl_id":null,"docs":" Associated type for `<&str as Pattern<'a>>::Searcher`.\n","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":5979},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1971559,"byte_end":1971565,"line_start":1370,"line_end":1370,"column_start":10,"column_end":16},"name":"Output","qualname":"::str::pattern::TwoWayStrategy::Output","value":"type Output;","parent":{"krate":0,"index":5978},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5980},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1971574,"byte_end":1971590,"line_start":1371,"line_end":1371,"column_start":8,"column_end":24},"name":"use_early_reject","qualname":"::str::pattern::TwoWayStrategy::use_early_reject","value":"fn () -> bool","parent":{"krate":0,"index":5978},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5981},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1971609,"byte_end":1971618,"line_start":1372,"line_end":1372,"column_start":8,"column_end":17},"name":"rejecting","qualname":"::str::pattern::TwoWayStrategy::rejecting","value":"fn (a: usize, b: usize) -> Self::Output","parent":{"krate":0,"index":5978},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5982},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1971663,"byte_end":1971671,"line_start":1373,"line_end":1373,"column_start":8,"column_end":16},"name":"matching","qualname":"::str::pattern::TwoWayStrategy::matching","value":"fn (a: usize, b: usize) -> Self::Output","parent":{"krate":0,"index":5978},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5995},"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"lossy","qualname":"::str::lossy","value":"src/libcore/str/lossy.rs","parent":null,"children":[{"krate":0,"index":5996},{"krate":0,"index":5997},{"krate":0,"index":5998},{"krate":0,"index":6001},{"krate":0,"index":6002},{"krate":0,"index":6004},{"krate":0,"index":6008},{"krate":0,"index":33460},{"krate":0,"index":33470},{"krate":0,"index":33467},{"krate":0,"index":33464},{"krate":0,"index":6011},{"krate":0,"index":6018},{"krate":0,"index":6020}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"str_internals\", issue = \"0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1779024,"byte_end":1779075,"line_start":23,"line_end":23,"column_start":1,"column_end":52}},{"value":"allow(missing_docs)","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1779076,"byte_end":1779098,"line_start":24,"line_end":24,"column_start":1,"column_end":23}}]},{"kind":"Struct","id":{"krate":0,"index":6002},"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1972638,"byte_end":1972647,"line_start":8,"line_end":8,"column_start":12,"column_end":21},"name":"Utf8Lossy","qualname":"::str::lossy::Utf8Lossy","value":"Utf8Lossy {  }","parent":null,"children":[{"krate":0,"index":6003}],"decl_id":null,"docs":" Lossy UTF-8 string.\n","sig":null,"attributes":[{"value":"unstable(feature = \"str_internals\", issue = \"0\")","span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1972575,"byte_end":1972626,"line_start":7,"line_end":7,"column_start":1,"column_end":52}}]},{"kind":"Method","id":{"krate":0,"index":6005},"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1972697,"byte_end":1972705,"line_start":13,"line_end":13,"column_start":12,"column_end":20},"name":"from_str","qualname":"<Utf8Lossy>::from_str","value":"fn (s: &str) -> &Utf8Lossy","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6006},"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1972793,"byte_end":1972803,"line_start":17,"line_end":17,"column_start":12,"column_end":22},"name":"from_bytes","qualname":"<Utf8Lossy>::from_bytes","value":"fn (bytes: &[u8]) -> &Utf8Lossy","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6007},"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1972893,"byte_end":1972899,"line_start":21,"line_end":21,"column_start":12,"column_end":18},"name":"chunks","qualname":"<Utf8Lossy>::chunks","value":"fn (&self) -> Utf8LossyChunksIter<'_>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":6008},"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1973138,"byte_end":1973157,"line_start":30,"line_end":30,"column_start":12,"column_end":31},"name":"Utf8LossyChunksIter","qualname":"::str::lossy::Utf8LossyChunksIter","value":"Utf8LossyChunksIter {  }","parent":null,"children":[{"krate":0,"index":6010}],"decl_id":null,"docs":" Iterator over lossy UTF-8 string\n","sig":null,"attributes":[{"value":"unstable(feature = \"str_internals\", issue = \"0\")","span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1973035,"byte_end":1973086,"line_start":28,"line_end":28,"column_start":1,"column_end":52}},{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1973087,"byte_end":1973126,"line_start":29,"line_end":29,"column_start":1,"column_end":40}}]},{"kind":"Struct","id":{"krate":0,"index":33460},"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1973284,"byte_end":1973298,"line_start":36,"line_end":36,"column_start":12,"column_end":26},"name":"Utf8LossyChunk","qualname":"::str::lossy::Utf8LossyChunk","value":"Utf8LossyChunk { valid, broken }","parent":null,"children":[{"krate":0,"index":33462},{"krate":0,"index":33463}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"str_internals\", issue = \"0\")","span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1973189,"byte_end":1973240,"line_start":34,"line_end":34,"column_start":1,"column_end":52}},{"value":"structural_match","span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1973273,"byte_end":1973522,"line_start":36,"line_end":43,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":33462},"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1973395,"byte_end":1973400,"line_start":39,"line_end":39,"column_start":9,"column_end":14},"name":"valid","qualname":"::str::lossy::Utf8LossyChunk::valid","value":"&'a str","parent":{"krate":0,"index":33460},"children":[],"decl_id":null,"docs":" Sequence of valid chars.\n Can be empty between broken UTF-8 chars.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":33463},"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1973503,"byte_end":1973509,"line_start":42,"line_end":42,"column_start":9,"column_end":15},"name":"broken","qualname":"::str::lossy::Utf8LossyChunk::broken","value":"&'a [u8]","parent":{"krate":0,"index":33460},"children":[],"decl_id":null,"docs":" Single broken char, empty if none.\n Empty iff iterator item is last.\n","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":6022},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1780644,"byte_end":1780651,"line_start":74,"line_end":74,"column_start":11,"column_end":18},"name":"FromStr","qualname":"::str::FromStr","value":"FromStr: Sized","parent":null,"children":[{"krate":0,"index":6023},{"krate":0,"index":6024}],"decl_id":null,"docs":" Parse a value from a string","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1780588,"byte_end":1780633,"line_start":73,"line_end":73,"column_start":1,"column_end":46}}]},{"kind":"Type","id":{"krate":0,"index":6023},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1780785,"byte_end":1780788,"line_start":77,"line_end":77,"column_start":10,"column_end":13},"name":"Err","qualname":"::str::FromStr::Err","value":"type Err;","parent":{"krate":0,"index":6022},"children":[],"decl_id":null,"docs":" The associated error which can be returned from parsing.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1780730,"byte_end":1780775,"line_start":76,"line_end":76,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":6024},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1781618,"byte_end":1781626,"line_start":103,"line_end":103,"column_start":8,"column_end":16},"name":"from_str","qualname":"::str::FromStr::from_str","value":"fn (s: &str) -> Result<Self, Self::Err>","parent":{"krate":0,"index":6022},"children":[],"decl_id":null,"docs":" Parses a string `s` to return a value of this type.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1781565,"byte_end":1781610,"line_start":102,"line_end":102,"column_start":5,"column_end":50}}]},{"kind":"Struct","id":{"krate":0,"index":33474},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1782955,"byte_end":1782969,"line_start":147,"line_end":147,"column_start":12,"column_end":26},"name":"ParseBoolError","qualname":"::str::ParseBoolError","value":"ParseBoolError {  }","parent":null,"children":[{"krate":0,"index":33475}],"decl_id":null,"docs":" An error returned when parsing a `bool` using [`from_str`] fails","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1782898,"byte_end":1782943,"line_start":146,"line_end":146,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1782944,"byte_end":1782983,"line_start":147,"line_end":147,"column_start":1,"column_end":40}}]},{"kind":"Struct","id":{"krate":0,"index":33485},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1784729,"byte_end":1784738,"line_start":203,"line_end":203,"column_start":12,"column_end":21},"name":"Utf8Error","qualname":"::str::Utf8Error","value":"Utf8Error {  }","parent":null,"children":[{"krate":0,"index":33486},{"krate":0,"index":33487}],"decl_id":null,"docs":" Errors which can occur when attempting to interpret a sequence of [`u8`]\n as a string.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1784672,"byte_end":1784717,"line_start":202,"line_end":202,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1784718,"byte_end":1784793,"line_start":203,"line_end":206,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1784718,"byte_end":1784793,"line_start":203,"line_end":206,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":6031},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1785511,"byte_end":1785522,"line_start":232,"line_end":232,"column_start":12,"column_end":23},"name":"valid_up_to","qualname":"<Utf8Error>::valid_up_to","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the index in the given string up to which valid UTF-8 was\n verified.","sig":null,"attributes":[{"value":"stable(feature = \"utf8_error\", since = \"1.5.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1785449,"byte_end":1785499,"line_start":231,"line_end":231,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":6032},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1786461,"byte_end":1786470,"line_start":250,"line_end":250,"column_start":12,"column_end":21},"name":"error_len","qualname":"<Utf8Error>::error_len","value":"fn (&self) -> Option<usize>","parent":null,"children":[],"decl_id":null,"docs":" Provides more information about the failure:","sig":null,"attributes":[{"value":"stable(feature = \"utf8_error_error_len\", since = \"1.20.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1786388,"byte_end":1786449,"line_start":249,"line_end":249,"column_start":5,"column_end":66}}]},{"kind":"Function","id":{"krate":0,"index":6034},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1789095,"byte_end":1789104,"line_start":337,"line_end":337,"column_start":8,"column_end":17},"name":"from_utf8","qualname":"::str::from_utf8","value":"fn (v: &[u8]) -> Result<&str, Utf8Error>","parent":null,"children":[],"decl_id":null,"docs":" Converts a slice of bytes to a string slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1789042,"byte_end":1789087,"line_start":336,"line_end":336,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":6035},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1790086,"byte_end":1790099,"line_start":375,"line_end":375,"column_start":8,"column_end":21},"name":"from_utf8_mut","qualname":"::str::from_utf8_mut","value":"fn (v: &mut [u8]) -> Result<&mut str, Utf8Error>","parent":null,"children":[],"decl_id":null,"docs":" Converts a mutable slice of bytes to a mutable string slice.","sig":null,"attributes":[{"value":"stable(feature = \"str_mut_extras\", since = \"1.20.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1790023,"byte_end":1790078,"line_start":374,"line_end":374,"column_start":1,"column_end":56}}]},{"kind":"Function","id":{"krate":0,"index":6036},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1791111,"byte_end":1791130,"line_start":413,"line_end":413,"column_start":15,"column_end":34},"name":"from_utf8_unchecked","qualname":"::str::from_utf8_unchecked","value":"fn (v: &[u8]) -> &str","parent":null,"children":[],"decl_id":null,"docs":" Converts a slice of bytes to a string slice without checking\n that the string contains valid UTF-8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1791041,"byte_end":1791050,"line_start":411,"line_end":411,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1791051,"byte_end":1791096,"line_start":412,"line_end":412,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":6037},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1791771,"byte_end":1791794,"line_start":438,"line_end":438,"column_start":15,"column_end":38},"name":"from_utf8_unchecked_mut","qualname":"::str::from_utf8_unchecked_mut","value":"fn (v: &mut [u8]) -> &mut str","parent":null,"children":[],"decl_id":null,"docs":" Converts a slice of bytes to a string slice without checking\n that the string contains valid UTF-8; mutable version.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1791691,"byte_end":1791700,"line_start":436,"line_end":436,"column_start":1,"column_end":10}},{"value":"stable(feature = \"str_mut_extras\", since = \"1.20.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1791701,"byte_end":1791756,"line_start":437,"line_end":437,"column_start":1,"column_end":56}}]},{"kind":"Struct","id":{"krate":0,"index":33498},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1792719,"byte_end":1792724,"line_start":469,"line_end":469,"column_start":12,"column_end":17},"name":"Chars","qualname":"::str::Chars","value":"Chars {  }","parent":null,"children":[{"krate":0,"index":33500}],"decl_id":null,"docs":" An iterator over the [`char`]s of a string slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1792662,"byte_end":1792707,"line_start":468,"line_end":468,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":6044},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1793680,"byte_end":1793695,"line_start":500,"line_end":500,"column_start":8,"column_end":23},"name":"next_code_point","qualname":"::str::next_code_point","value":"fn <'a, I> (bytes: &mut I) -> Option<u32>","parent":null,"children":[],"decl_id":null,"docs":" Reads the next code point out of a byte iterator (assuming a\n UTF-8-like encoding).\n","sig":null,"attributes":[{"value":"unstable(feature = \"str_internals\", issue = \"0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1793611,"byte_end":1793662,"line_start":498,"line_end":498,"column_start":1,"column_end":52}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1793663,"byte_end":1793672,"line_start":499,"line_end":499,"column_start":1,"column_end":10}}]},{"kind":"Method","id":{"krate":0,"index":6065},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1797891,"byte_end":1797897,"line_start":639,"line_end":639,"column_start":12,"column_end":18},"name":"as_str","qualname":"<Chars>::as_str","value":"fn (&self) -> &'a str","parent":null,"children":[],"decl_id":null,"docs":" Views the underlying data as a subslice of the original data.","sig":null,"attributes":[{"value":"stable(feature = \"iter_to_slice\", since = \"1.4.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1797812,"byte_end":1797865,"line_start":637,"line_end":637,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1797870,"byte_end":1797879,"line_start":638,"line_end":638,"column_start":5,"column_end":14}}]},{"kind":"Struct","id":{"krate":0,"index":33507},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1798419,"byte_end":1798430,"line_start":655,"line_end":655,"column_start":12,"column_end":23},"name":"CharIndices","qualname":"::str::CharIndices","value":"CharIndices {  }","parent":null,"children":[{"krate":0,"index":33509},{"krate":0,"index":33510}],"decl_id":null,"docs":" An iterator over the [`char`]s of a string slice, and their positions.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1798362,"byte_end":1798407,"line_start":654,"line_end":654,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":6080},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1800062,"byte_end":1800068,"line_start":716,"line_end":716,"column_start":12,"column_end":18},"name":"as_str","qualname":"<CharIndices>::as_str","value":"fn (&self) -> &'a str","parent":null,"children":[],"decl_id":null,"docs":" Views the underlying data as a subslice of the original data.","sig":null,"attributes":[{"value":"stable(feature = \"iter_to_slice\", since = \"1.4.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1799983,"byte_end":1800036,"line_start":714,"line_end":714,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1800041,"byte_end":1800050,"line_start":715,"line_end":715,"column_start":5,"column_end":14}}]},{"kind":"Struct","id":{"krate":0,"index":33517},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1800462,"byte_end":1800467,"line_start":730,"line_end":730,"column_start":12,"column_end":17},"name":"Bytes","qualname":"::str::Bytes","value":"","parent":null,"children":[],"decl_id":null,"docs":" An iterator over the bytes of a string slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1800381,"byte_end":1800426,"line_start":728,"line_end":728,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":33531},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1812255,"byte_end":1812260,"line_start":1117,"line_end":1117,"column_start":16,"column_end":21},"name":"Split","qualname":"::str::Split","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`split`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1805765,"byte_end":1805795,"line_start":917,"line_end":917,"column_start":11,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":33549},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1812417,"byte_end":1812423,"line_start":1122,"line_end":1122,"column_start":16,"column_end":22},"name":"RSplit","qualname":"::str::RSplit","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`rsplit`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1806878,"byte_end":1806908,"line_start":951,"line_end":951,"column_start":11,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":33581},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1812795,"byte_end":1812810,"line_start":1135,"line_end":1135,"column_start":16,"column_end":31},"name":"SplitTerminator","qualname":"::str::SplitTerminator","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`split_terminator`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1805765,"byte_end":1805795,"line_start":917,"line_end":917,"column_start":11,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":33599},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1813000,"byte_end":1813016,"line_start":1140,"line_end":1140,"column_start":16,"column_end":32},"name":"RSplitTerminator","qualname":"::str::RSplitTerminator","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`rsplit_terminator`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1806878,"byte_end":1806908,"line_start":951,"line_end":951,"column_start":11,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":33635},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1814499,"byte_end":1814505,"line_start":1195,"line_end":1195,"column_start":16,"column_end":22},"name":"SplitN","qualname":"::str::SplitN","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`splitn`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1805765,"byte_end":1805795,"line_start":917,"line_end":917,"column_start":11,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":33653},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1814665,"byte_end":1814672,"line_start":1200,"line_end":1200,"column_start":16,"column_end":23},"name":"RSplitN","qualname":"::str::RSplitN","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`rsplitn`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1806878,"byte_end":1806908,"line_start":951,"line_end":951,"column_start":11,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":33681},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1816001,"byte_end":1816013,"line_start":1246,"line_end":1246,"column_start":16,"column_end":28},"name":"MatchIndices","qualname":"::str::MatchIndices","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`match_indices`].","sig":null,"attributes":[{"value":"stable(feature = \"str_match_indices\", since = \"1.5.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1805765,"byte_end":1805795,"line_start":917,"line_end":917,"column_start":11,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":33699},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1816194,"byte_end":1816207,"line_start":1251,"line_end":1251,"column_start":16,"column_end":29},"name":"RMatchIndices","qualname":"::str::RMatchIndices","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`rmatch_indices`].","sig":null,"attributes":[{"value":"stable(feature = \"str_match_indices\", since = \"1.5.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1806878,"byte_end":1806908,"line_start":951,"line_end":951,"column_start":11,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":33735},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1817571,"byte_end":1817578,"line_start":1299,"line_end":1299,"column_start":16,"column_end":23},"name":"Matches","qualname":"::str::Matches","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`matches`].","sig":null,"attributes":[{"value":"stable(feature = \"str_matches\", since = \"1.2.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1805765,"byte_end":1805795,"line_start":917,"line_end":917,"column_start":11,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":33753},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1817741,"byte_end":1817749,"line_start":1304,"line_end":1304,"column_start":16,"column_end":24},"name":"RMatches","qualname":"::str::RMatches","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`rmatches`].","sig":null,"attributes":[{"value":"stable(feature = \"str_matches\", since = \"1.2.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1806878,"byte_end":1806908,"line_start":951,"line_end":951,"column_start":11,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":33785},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1818265,"byte_end":1818270,"line_start":1321,"line_end":1321,"column_start":12,"column_end":17},"name":"Lines","qualname":"::str::Lines","value":"","parent":null,"children":[],"decl_id":null,"docs":" An iterator over the lines of a string, as string slices.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1818184,"byte_end":1818229,"line_start":1319,"line_end":1319,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":33795},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1819184,"byte_end":1819192,"line_start":1356,"line_end":1356,"column_start":12,"column_end":20},"name":"LinesAny","qualname":"::str::LinesAny","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`lines_any`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1819003,"byte_end":1819048,"line_start":1352,"line_end":1352,"column_start":1,"column_end":46}},{"value":"rustc_deprecated(since = \"1.4.0\", reason = \"use lines()/Lines instead now\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1819049,"byte_end":1819127,"line_start":1353,"line_end":1353,"column_start":1,"column_end":79}},{"value":"allow(deprecated)","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1819152,"byte_end":1819172,"line_start":1355,"line_end":1355,"column_start":1,"column_end":21}}]},{"kind":"Function","id":{"krate":0,"index":6202},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1825858,"byte_end":1825873,"line_start":1553,"line_end":1553,"column_start":8,"column_end":23},"name":"utf8_char_width","qualname":"::str::utf8_char_width","value":"fn (b: u8) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Given a first byte, determines how many bytes are in this UTF-8 character.\n","sig":null,"attributes":[{"value":"unstable(feature = \"str_internals\", issue = \"0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1825789,"byte_end":1825840,"line_start":1551,"line_end":1551,"column_start":1,"column_end":52}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1825841,"byte_end":1825850,"line_start":1552,"line_end":1552,"column_start":1,"column_end":10}}]},{"kind":"Method","id":{"krate":0,"index":6282},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1844209,"byte_end":1844212,"line_start":2060,"line_end":2060,"column_start":18,"column_end":21},"name":"len","qualname":"<str>::len","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the length of `self`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1844077,"byte_end":1844122,"line_start":2057,"line_end":2057,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1844127,"byte_end":1844136,"line_start":2058,"line_end":2058,"column_start":5,"column_end":14}},{"value":"rustc_const_unstable(feature = \"const_str_len\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1844141,"byte_end":1844191,"line_start":2059,"line_end":2059,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":6283},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1844673,"byte_end":1844681,"line_start":2080,"line_end":2080,"column_start":18,"column_end":26},"name":"is_empty","qualname":"<str>::is_empty","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `self` has a length of zero bytes.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1844541,"byte_end":1844550,"line_start":2077,"line_end":2077,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1844555,"byte_end":1844600,"line_start":2078,"line_end":2078,"column_start":5,"column_end":50}},{"value":"rustc_const_unstable(feature = \"const_str_len\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1844605,"byte_end":1844655,"line_start":2079,"line_end":2079,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":6284},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1845532,"byte_end":1845548,"line_start":2110,"line_end":2110,"column_start":12,"column_end":28},"name":"is_char_boundary","qualname":"<str>::is_char_boundary","value":"fn (&self, index: usize) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks that `index`-th byte lies at the start and/or end of a\n UTF-8 code point sequence.","sig":null,"attributes":[{"value":"stable(feature = \"is_char_boundary\", since = \"1.9.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1845450,"byte_end":1845506,"line_start":2108,"line_end":2108,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1845511,"byte_end":1845520,"line_start":2109,"line_end":2109,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6285},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1846526,"byte_end":1846534,"line_start":2138,"line_end":2138,"column_start":18,"column_end":26},"name":"as_bytes","qualname":"<str>::as_bytes","value":"fn (&self) -> &[u8]","parent":null,"children":[],"decl_id":null,"docs":" Converts a string slice to a byte slice. To convert the byte slice back\n into a string slice, use the [`str::from_utf8`] function.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1846383,"byte_end":1846428,"line_start":2135,"line_end":2135,"column_start":5,"column_end":50}},{"value":"inline(always)","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1846433,"byte_end":1846450,"line_start":2136,"line_end":2136,"column_start":5,"column_end":22}},{"value":"rustc_const_unstable(feature = \"const_str_as_bytes\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1846455,"byte_end":1846508,"line_start":2137,"line_end":2137,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":6290},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1847637,"byte_end":1847649,"line_start":2181,"line_end":2181,"column_start":19,"column_end":31},"name":"as_bytes_mut","qualname":"<str>::as_bytes_mut","value":"fn (&mut self) -> &mut [u8]","parent":null,"children":[],"decl_id":null,"docs":" Converts a mutable string slice to a mutable byte slice. To convert the\n mutable byte slice back into a mutable string slice, use the\n [`str::from_utf8_mut`] function.","sig":null,"attributes":[{"value":"stable(feature = \"str_mut_extras\", since = \"1.20.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1847541,"byte_end":1847596,"line_start":2179,"line_end":2179,"column_start":5,"column_end":60}},{"value":"inline(always)","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1847601,"byte_end":1847618,"line_start":2180,"line_end":2180,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":6291},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1848434,"byte_end":1848440,"line_start":2207,"line_end":2207,"column_start":18,"column_end":24},"name":"as_ptr","qualname":"<str>::as_ptr","value":"fn (&self) -> *const u8","parent":null,"children":[],"decl_id":null,"docs":" Converts a string slice to a raw pointer.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1848357,"byte_end":1848402,"line_start":2205,"line_end":2205,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1848407,"byte_end":1848416,"line_start":2206,"line_end":2206,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6292},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1849013,"byte_end":1849023,"line_start":2223,"line_end":2223,"column_start":12,"column_end":22},"name":"as_mut_ptr","qualname":"<str>::as_mut_ptr","value":"fn (&mut self) -> *mut u8","parent":null,"children":[],"decl_id":null,"docs":" Converts a mutable string slice to a raw pointer.","sig":null,"attributes":[{"value":"stable(feature = \"str_as_mut_ptr\", since = \"1.36.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1848932,"byte_end":1848987,"line_start":2221,"line_end":2221,"column_start":5,"column_end":60}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1848992,"byte_end":1849001,"line_start":2222,"line_end":2222,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6293},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1849805,"byte_end":1849808,"line_start":2250,"line_end":2250,"column_start":12,"column_end":15},"name":"get","qualname":"<str>::get","value":"fn <I> (&self, i: I) -> Option<&I::Output>","parent":null,"children":[],"decl_id":null,"docs":" Returns a subslice of `str`.","sig":null,"attributes":[{"value":"stable(feature = \"str_checked_slicing\", since = \"1.20.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1849719,"byte_end":1849779,"line_start":2248,"line_end":2248,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1849784,"byte_end":1849793,"line_start":2249,"line_end":2249,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6295},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1850826,"byte_end":1850833,"line_start":2284,"line_end":2284,"column_start":12,"column_end":19},"name":"get_mut","qualname":"<str>::get_mut","value":"fn <I> (&mut self, i: I) -> Option<&mut I::Output>","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable subslice of `str`.","sig":null,"attributes":[{"value":"stable(feature = \"str_checked_slicing\", since = \"1.20.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1850740,"byte_end":1850800,"line_start":2282,"line_end":2282,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1850805,"byte_end":1850814,"line_start":2283,"line_end":2283,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6297},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1851902,"byte_end":1851915,"line_start":2316,"line_end":2316,"column_start":19,"column_end":32},"name":"get_unchecked","qualname":"<str>::get_unchecked","value":"fn <I> (&self, i: I) -> &I::Output","parent":null,"children":[],"decl_id":null,"docs":" Returns a unchecked subslice of `str`.","sig":null,"attributes":[{"value":"stable(feature = \"str_checked_slicing\", since = \"1.20.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1851809,"byte_end":1851869,"line_start":2314,"line_end":2314,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1851874,"byte_end":1851883,"line_start":2315,"line_end":2315,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6299},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1853013,"byte_end":1853030,"line_start":2348,"line_end":2348,"column_start":19,"column_end":36},"name":"get_unchecked_mut","qualname":"<str>::get_unchecked_mut","value":"fn <I> (&mut self, i: I) -> &mut I::Output","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable, unchecked subslice of `str`.","sig":null,"attributes":[{"value":"stable(feature = \"str_checked_slicing\", since = \"1.20.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1852920,"byte_end":1852980,"line_start":2346,"line_end":2346,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1852985,"byte_end":1852994,"line_start":2347,"line_end":2347,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6301},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1854582,"byte_end":1854597,"line_start":2398,"line_end":2398,"column_start":19,"column_end":34},"name":"slice_unchecked","qualname":"<str>::slice_unchecked","value":"fn (&self, begin: usize, end: usize) -> &str","parent":null,"children":[],"decl_id":null,"docs":" Creates a string slice from another string slice, bypassing safety\n checks.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1854410,"byte_end":1854455,"line_start":2395,"line_end":2395,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.29.0\",\n                   reason = \"use `get_unchecked(begin..end)` instead\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1854460,"byte_end":1854549,"line_start":2396,"line_end":2396,"column_start":5,"column_end":94}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1854554,"byte_end":1854563,"line_start":2397,"line_end":2397,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6302},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1855772,"byte_end":1855791,"line_start":2429,"line_end":2429,"column_start":19,"column_end":38},"name":"slice_mut_unchecked","qualname":"<str>::slice_mut_unchecked","value":"fn (&mut self, begin: usize, end: usize) -> &mut str","parent":null,"children":[],"decl_id":null,"docs":" Creates a string slice from another string slice, bypassing safety\n checks.\n This is generally not recommended, use with caution! For a safe\n alternative see [`str`] and [`IndexMut`].","sig":null,"attributes":[{"value":"stable(feature = \"str_slice_mut\", since = \"1.5.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1855588,"byte_end":1855641,"line_start":2426,"line_end":2426,"column_start":5,"column_end":58}},{"value":"rustc_deprecated(since = \"1.29.0\",\n                   reason = \"use `get_unchecked_mut(begin..end)` instead\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1855646,"byte_end":1855739,"line_start":2427,"line_end":2427,"column_start":5,"column_end":98}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1855744,"byte_end":1855753,"line_start":2428,"line_end":2428,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6303},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1856900,"byte_end":1856908,"line_start":2465,"line_end":2465,"column_start":12,"column_end":20},"name":"split_at","qualname":"<str>::split_at","value":"fn (&self, mid: usize) -> (&str, &str)","parent":null,"children":[],"decl_id":null,"docs":" Divide one string slice into two at an index.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1856822,"byte_end":1856831,"line_start":2463,"line_end":2463,"column_start":5,"column_end":14}},{"value":"stable(feature = \"str_split_at\", since = \"1.4.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1856836,"byte_end":1856888,"line_start":2464,"line_end":2464,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":6304},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1858380,"byte_end":1858392,"line_start":2510,"line_end":2510,"column_start":12,"column_end":24},"name":"split_at_mut","qualname":"<str>::split_at_mut","value":"fn (&mut self, mid: usize) -> (&mut str, &mut str)","parent":null,"children":[],"decl_id":null,"docs":" Divide one mutable string slice into two at an index.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1858302,"byte_end":1858311,"line_start":2508,"line_end":2508,"column_start":5,"column_end":14}},{"value":"stable(feature = \"str_split_at\", since = \"1.4.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1858316,"byte_end":1858368,"line_start":2509,"line_end":2509,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":6305},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1860460,"byte_end":1860465,"line_start":2573,"line_end":2573,"column_start":12,"column_end":17},"name":"chars","qualname":"<str>::chars","value":"fn (&self) -> Chars<'_>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over the [`char`]s of a string slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1860389,"byte_end":1860434,"line_start":2571,"line_end":2571,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1860439,"byte_end":1860448,"line_start":2572,"line_end":2572,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6306},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1862348,"byte_end":1862360,"line_start":2628,"line_end":2628,"column_start":12,"column_end":24},"name":"char_indices","qualname":"<str>::char_indices","value":"fn (&self) -> CharIndices<'_>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over the [`char`]s of a string slice, and their\n positions.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1862277,"byte_end":1862322,"line_start":2626,"line_end":2626,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1862327,"byte_end":1862336,"line_start":2627,"line_end":2627,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6307},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1863113,"byte_end":1863118,"line_start":2653,"line_end":2653,"column_start":12,"column_end":17},"name":"bytes","qualname":"<str>::bytes","value":"fn (&self) -> Bytes<'_>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over the bytes of a string slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1863042,"byte_end":1863087,"line_start":2651,"line_end":2651,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1863092,"byte_end":1863101,"line_start":2652,"line_end":2652,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6308},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1864571,"byte_end":1864587,"line_start":2696,"line_end":2696,"column_start":12,"column_end":28},"name":"split_whitespace","qualname":"<str>::split_whitespace","value":"fn (&self) -> SplitWhitespace<'_>","parent":null,"children":[],"decl_id":null,"docs":" Splits a string slice by whitespace.","sig":null,"attributes":[{"value":"stable(feature = \"split_whitespace\", since = \"1.1.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1864489,"byte_end":1864545,"line_start":2694,"line_end":2694,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1864550,"byte_end":1864559,"line_start":2695,"line_end":2695,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6309},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1865966,"byte_end":1865988,"line_start":2737,"line_end":2737,"column_start":12,"column_end":34},"name":"split_ascii_whitespace","qualname":"<str>::split_ascii_whitespace","value":"fn (&self) -> SplitAsciiWhitespace<'_>","parent":null,"children":[],"decl_id":null,"docs":" Splits a string slice by ASCII whitespace.","sig":null,"attributes":[{"value":"stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1865877,"byte_end":1865940,"line_start":2735,"line_end":2735,"column_start":5,"column_end":68}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1865945,"byte_end":1865954,"line_start":2736,"line_end":2736,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6310},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1867355,"byte_end":1867360,"line_start":2784,"line_end":2784,"column_start":12,"column_end":17},"name":"lines","qualname":"<str>::lines","value":"fn (&self) -> Lines<'_>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over the lines of a string, as string slices.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1867284,"byte_end":1867329,"line_start":2782,"line_end":2782,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1867334,"byte_end":1867343,"line_start":2783,"line_end":2783,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6311},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1867675,"byte_end":1867684,"line_start":2793,"line_end":2793,"column_start":12,"column_end":21},"name":"lines_any","qualname":"<str>::lines_any","value":"fn (&self) -> LinesAny<'_>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over the lines of a string.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1867502,"byte_end":1867547,"line_start":2789,"line_end":2789,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.4.0\", reason = \"use lines() instead now\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1867552,"byte_end":1867624,"line_start":2790,"line_end":2790,"column_start":5,"column_end":77}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1867629,"byte_end":1867638,"line_start":2791,"line_end":2791,"column_start":5,"column_end":14}},{"value":"allow(deprecated)","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1867643,"byte_end":1867663,"line_start":2792,"line_end":2792,"column_start":5,"column_end":25}}]},{"kind":"Method","id":{"krate":0,"index":6312},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1868169,"byte_end":1868181,"line_start":2812,"line_end":2812,"column_start":12,"column_end":24},"name":"encode_utf16","qualname":"<str>::encode_utf16","value":"fn (&self) -> EncodeUtf16<'_>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator of `u16` over the string encoded as UTF-16.","sig":null,"attributes":[{"value":"stable(feature = \"encode_utf16\", since = \"1.8.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1868105,"byte_end":1868157,"line_start":2811,"line_end":2811,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":6313},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1868706,"byte_end":1868714,"line_start":2833,"line_end":2833,"column_start":12,"column_end":20},"name":"contains","qualname":"<str>::contains","value":"fn <'a, P> (&'a self, pat: P) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the given pattern matches a sub-slice of\n this string slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1868635,"byte_end":1868680,"line_start":2831,"line_end":2831,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1868685,"byte_end":1868694,"line_start":2832,"line_end":2832,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6316},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1869226,"byte_end":1869237,"line_start":2853,"line_end":2853,"column_start":12,"column_end":23},"name":"starts_with","qualname":"<str>::starts_with","value":"fn <'a, P> (&'a self, pat: P) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the given pattern matches a prefix of this\n string slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1869169,"byte_end":1869214,"line_start":2852,"line_end":2852,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":6319},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1869742,"byte_end":1869751,"line_start":2873,"line_end":2873,"column_start":12,"column_end":21},"name":"ends_with","qualname":"<str>::ends_with","value":"fn <'a, P> (&'a self, pat: P) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the given pattern matches a suffix of this\n string slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1869685,"byte_end":1869730,"line_start":2872,"line_end":2872,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":6322},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1871214,"byte_end":1871218,"line_start":2922,"line_end":2922,"column_start":12,"column_end":16},"name":"find","qualname":"<str>::find","value":"fn <'a, P> (&'a self, pat: P) -> Option<usize>","parent":null,"children":[],"decl_id":null,"docs":" Returns the byte index of the first character of this string slice that\n matches the pattern.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1871143,"byte_end":1871188,"line_start":2920,"line_end":2920,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1871193,"byte_end":1871202,"line_start":2921,"line_end":2921,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6326},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1872447,"byte_end":1872452,"line_start":2966,"line_end":2966,"column_start":12,"column_end":17},"name":"rfind","qualname":"<str>::rfind","value":"fn <'a, P> (&'a self, pat: P) -> Option<usize>","parent":null,"children":[],"decl_id":null,"docs":" Returns the byte index of the last character of this string slice that\n matches the pattern.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1872376,"byte_end":1872421,"line_start":2964,"line_end":2964,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1872426,"byte_end":1872435,"line_start":2965,"line_end":2965,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6330},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1876286,"byte_end":1876291,"line_start":3079,"line_end":3079,"column_start":12,"column_end":17},"name":"split","qualname":"<str>::split","value":"fn <'a, P> (&'a self, pat: P) -> Split<'a, P>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over substrings of this string slice, separated by\n characters matched by a pattern.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1876215,"byte_end":1876260,"line_start":3077,"line_end":3077,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1876265,"byte_end":1876274,"line_start":3078,"line_end":3078,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6333},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1878197,"byte_end":1878203,"line_start":3133,"line_end":3133,"column_start":12,"column_end":18},"name":"rsplit","qualname":"<str>::rsplit","value":"fn <'a, P> (&'a self, pat: P) -> RSplit<'a, P>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over substrings of the given string slice, separated by\n characters matched by a pattern and yielded in reverse order.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1878126,"byte_end":1878171,"line_start":3131,"line_end":3131,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1878176,"byte_end":1878185,"line_start":3132,"line_end":3132,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6336},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1879864,"byte_end":1879880,"line_start":3179,"line_end":3179,"column_start":12,"column_end":28},"name":"split_terminator","qualname":"<str>::split_terminator","value":"fn <'a, P> (&'a self, pat: P) -> SplitTerminator<'a, P>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over substrings of the given string slice, separated by\n characters matched by a pattern.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1879793,"byte_end":1879838,"line_start":3177,"line_end":3177,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1879843,"byte_end":1879852,"line_start":3178,"line_end":3178,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6339},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1881488,"byte_end":1881505,"line_start":3224,"line_end":3224,"column_start":12,"column_end":29},"name":"rsplit_terminator","qualname":"<str>::rsplit_terminator","value":"fn <'a, P> (&'a self, pat: P) -> RSplitTerminator<'a, P>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over substrings of `self`, separated by characters\n matched by a pattern and yielded in reverse order.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1881417,"byte_end":1881462,"line_start":3222,"line_end":3222,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1881467,"byte_end":1881476,"line_start":3223,"line_end":3223,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6342},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1883285,"byte_end":1883291,"line_start":3275,"line_end":3275,"column_start":12,"column_end":18},"name":"splitn","qualname":"<str>::splitn","value":"fn <'a, P> (&'a self, n: usize, pat: P) -> SplitN<'a, P>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over substrings of the given string slice, separated by a\n pattern, restricted to returning at most `n` items.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1883214,"byte_end":1883259,"line_start":3273,"line_end":3273,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1883264,"byte_end":1883273,"line_start":3274,"line_end":3274,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6345},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1885022,"byte_end":1885029,"line_start":3324,"line_end":3324,"column_start":12,"column_end":19},"name":"rsplitn","qualname":"<str>::rsplitn","value":"fn <'a, P> (&'a self, n: usize, pat: P) -> RSplitN<'a, P>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over substrings of this string slice, separated by a\n pattern, starting from the end of the string, restricted to returning\n at most `n` items.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1884951,"byte_end":1884996,"line_start":3322,"line_end":3322,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1885001,"byte_end":1885010,"line_start":3323,"line_end":3323,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6348},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1886415,"byte_end":1886422,"line_start":3362,"line_end":3362,"column_start":12,"column_end":19},"name":"matches","qualname":"<str>::matches","value":"fn <'a, P> (&'a self, pat: P) -> Matches<'a, P>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over the disjoint matches of a pattern within the given string\n slice.","sig":null,"attributes":[{"value":"stable(feature = \"str_matches\", since = \"1.2.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1886338,"byte_end":1886389,"line_start":3360,"line_end":3360,"column_start":5,"column_end":56}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1886394,"byte_end":1886403,"line_start":3361,"line_end":3361,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6351},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1887635,"byte_end":1887643,"line_start":3397,"line_end":3397,"column_start":12,"column_end":20},"name":"rmatches","qualname":"<str>::rmatches","value":"fn <'a, P> (&'a self, pat: P) -> RMatches<'a, P>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over the disjoint matches of a pattern within this string slice,\n yielded in reverse order.","sig":null,"attributes":[{"value":"stable(feature = \"str_matches\", since = \"1.2.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1887558,"byte_end":1887609,"line_start":3395,"line_end":3395,"column_start":5,"column_end":56}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1887614,"byte_end":1887623,"line_start":3396,"line_end":3396,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6354},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1889323,"byte_end":1889336,"line_start":3441,"line_end":3441,"column_start":12,"column_end":25},"name":"match_indices","qualname":"<str>::match_indices","value":"fn <'a, P> (&'a self, pat: P) -> MatchIndices<'a, P>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over the disjoint matches of a pattern within this string\n slice as well as the index that the match starts at.","sig":null,"attributes":[{"value":"stable(feature = \"str_match_indices\", since = \"1.5.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1889240,"byte_end":1889297,"line_start":3439,"line_end":3439,"column_start":5,"column_end":62}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1889302,"byte_end":1889311,"line_start":3440,"line_end":3440,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6357},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1890899,"byte_end":1890913,"line_start":3482,"line_end":3482,"column_start":12,"column_end":26},"name":"rmatch_indices","qualname":"<str>::rmatch_indices","value":"fn <'a, P> (&'a self, pat: P) -> RMatchIndices<'a, P>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over the disjoint matches of a pattern within `self`,\n yielded in reverse order along with the index of the match.","sig":null,"attributes":[{"value":"stable(feature = \"str_match_indices\", since = \"1.5.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1890816,"byte_end":1890873,"line_start":3480,"line_end":3480,"column_start":5,"column_end":62}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1890878,"byte_end":1890887,"line_start":3481,"line_end":3481,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6360},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1891638,"byte_end":1891642,"line_start":3505,"line_end":3505,"column_start":12,"column_end":16},"name":"trim","qualname":"<str>::trim","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":" Returns a string slice with leading and trailing whitespace removed.","sig":null,"attributes":[{"value":"must_use =\n      \"this returns the trimmed string as a slice, \\\n                  without modifying the original\"","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1891466,"byte_end":1891576,"line_start":3502,"line_end":3503,"column_start":5,"column_end":51}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1891581,"byte_end":1891626,"line_start":3504,"line_end":3504,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":6362},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1892884,"byte_end":1892894,"line_start":3542,"line_end":3542,"column_start":12,"column_end":22},"name":"trim_start","qualname":"<str>::trim_start","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":" Returns a string slice with leading whitespace removed.","sig":null,"attributes":[{"value":"must_use =\n      \"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1892698,"byte_end":1892812,"line_start":3539,"line_end":3540,"column_start":5,"column_end":51}},{"value":"stable(feature = \"trim_direction\", since = \"1.30.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1892817,"byte_end":1892872,"line_start":3541,"line_end":3541,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":6364},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1894145,"byte_end":1894153,"line_start":3579,"line_end":3579,"column_start":12,"column_end":20},"name":"trim_end","qualname":"<str>::trim_end","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":" Returns a string slice with trailing whitespace removed.","sig":null,"attributes":[{"value":"must_use =\n      \"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1893959,"byte_end":1894073,"line_start":3576,"line_end":3577,"column_start":5,"column_end":51}},{"value":"stable(feature = \"trim_direction\", since = \"1.30.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1894078,"byte_end":1894133,"line_start":3578,"line_end":3578,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":6366},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1895379,"byte_end":1895388,"line_start":3620,"line_end":3620,"column_start":12,"column_end":21},"name":"trim_left","qualname":"<str>::trim_left","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":" Returns a string slice with leading whitespace removed.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1895183,"byte_end":1895228,"line_start":3614,"line_end":3614,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.33.0\",\n                   reason = \"superseded by `trim_start`\",\n                   suggestion = \"trim_start\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1895233,"byte_end":1895367,"line_start":3615,"line_end":3619,"column_start":5,"column_end":7}}]},{"kind":"Method","id":{"krate":0,"index":6367},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1896592,"byte_end":1896602,"line_start":3661,"line_end":3661,"column_start":12,"column_end":22},"name":"trim_right","qualname":"<str>::trim_right","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":" Returns a string slice with trailing whitespace removed.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1896400,"byte_end":1896445,"line_start":3655,"line_end":3655,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.33.0\",\n                   reason = \"superseded by `trim_end`\",\n                   suggestion = \"trim_end\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1896450,"byte_end":1896580,"line_start":3656,"line_end":3660,"column_start":5,"column_end":7}}]},{"kind":"Method","id":{"krate":0,"index":6368},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1897562,"byte_end":1897574,"line_start":3691,"line_end":3691,"column_start":12,"column_end":24},"name":"trim_matches","qualname":"<str>::trim_matches","value":"fn <'a, P> (&'a self, pat: P) -> &'a str","parent":null,"children":[],"decl_id":null,"docs":" Returns a string slice with all prefixes and suffixes that match a\n pattern repeatedly removed.","sig":null,"attributes":[{"value":"must_use =\n      \"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1897386,"byte_end":1897500,"line_start":3688,"line_end":3689,"column_start":5,"column_end":51}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1897505,"byte_end":1897550,"line_start":3690,"line_end":3690,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":6371},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1899278,"byte_end":1899296,"line_start":3738,"line_end":3738,"column_start":12,"column_end":30},"name":"trim_start_matches","qualname":"<str>::trim_start_matches","value":"fn <'a, P> (&'a self, pat: P) -> &'a str","parent":null,"children":[],"decl_id":null,"docs":" Returns a string slice with all prefixes that match a pattern\n repeatedly removed.","sig":null,"attributes":[{"value":"must_use =\n      \"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1899092,"byte_end":1899206,"line_start":3735,"line_end":3736,"column_start":5,"column_end":51}},{"value":"stable(feature = \"trim_direction\", since = \"1.30.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1899211,"byte_end":1899266,"line_start":3737,"line_end":3737,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":6374},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1900900,"byte_end":1900916,"line_start":3783,"line_end":3783,"column_start":12,"column_end":28},"name":"trim_end_matches","qualname":"<str>::trim_end_matches","value":"fn <'a, P> (&'a self, pat: P) -> &'a str","parent":null,"children":[],"decl_id":null,"docs":" Returns a string slice with all suffixes that match a pattern\n repeatedly removed.","sig":null,"attributes":[{"value":"must_use =\n      \"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1900714,"byte_end":1900828,"line_start":3780,"line_end":3781,"column_start":5,"column_end":51}},{"value":"stable(feature = \"trim_direction\", since = \"1.30.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1900833,"byte_end":1900888,"line_start":3782,"line_end":3782,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":6377},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1902491,"byte_end":1902508,"line_start":3829,"line_end":3829,"column_start":12,"column_end":29},"name":"trim_left_matches","qualname":"<str>::trim_left_matches","value":"fn <'a, P> (&'a self, pat: P) -> &'a str","parent":null,"children":[],"decl_id":null,"docs":" Returns a string slice with all prefixes that match a pattern\n repeatedly removed.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1902279,"byte_end":1902324,"line_start":3823,"line_end":3823,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.33.0\",\n                   reason = \"superseded by `trim_start_matches`\",\n                   suggestion = \"trim_start_matches\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1902329,"byte_end":1902479,"line_start":3824,"line_end":3828,"column_start":5,"column_end":7}}]},{"kind":"Method","id":{"krate":0,"index":6380},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1903957,"byte_end":1903975,"line_start":3871,"line_end":3871,"column_start":12,"column_end":30},"name":"trim_right_matches","qualname":"<str>::trim_right_matches","value":"fn <'a, P> (&'a self, pat: P) -> &'a str","parent":null,"children":[],"decl_id":null,"docs":" Returns a string slice with all suffixes that match a pattern\n repeatedly removed.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1903749,"byte_end":1903794,"line_start":3865,"line_end":3865,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.33.0\",\n                   reason = \"superseded by `trim_end_matches`\",\n                   suggestion = \"trim_end_matches\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1903799,"byte_end":1903945,"line_start":3866,"line_end":3870,"column_start":5,"column_end":7}}]},{"kind":"Method","id":{"krate":0,"index":6383},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1905416,"byte_end":1905421,"line_start":3923,"line_end":3923,"column_start":12,"column_end":17},"name":"parse","qualname":"<str>::parse","value":"fn <F> (&self) -> Result<F, F::Err>","parent":null,"children":[],"decl_id":null,"docs":" Parses this string slice into another type.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1905345,"byte_end":1905354,"line_start":3921,"line_end":3921,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1905359,"byte_end":1905404,"line_start":3922,"line_end":3922,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":6385},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1905899,"byte_end":1905907,"line_start":3940,"line_end":3940,"column_start":12,"column_end":20},"name":"is_ascii","qualname":"<str>::is_ascii","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if all characters in this string are within the ASCII range.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1905805,"byte_end":1905873,"line_start":3938,"line_end":3938,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1905878,"byte_end":1905887,"line_start":3939,"line_end":3939,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6387},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1906691,"byte_end":1906711,"line_start":3961,"line_end":3961,"column_start":12,"column_end":32},"name":"eq_ignore_ascii_case","qualname":"<str>::eq_ignore_ascii_case","value":"fn (&self, other: &str) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks that two strings are an ASCII case-insensitive match.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1906597,"byte_end":1906665,"line_start":3959,"line_end":3959,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1906670,"byte_end":1906679,"line_start":3960,"line_end":3960,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6388},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1907484,"byte_end":1907504,"line_start":3985,"line_end":3985,"column_start":12,"column_end":32},"name":"make_ascii_uppercase","qualname":"<str>::make_ascii_uppercase","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Converts this string to its ASCII upper case equivalent in-place.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1907404,"byte_end":1907472,"line_start":3984,"line_end":3984,"column_start":5,"column_end":73}}]},{"kind":"Method","id":{"krate":0,"index":6389},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1908280,"byte_end":1908300,"line_start":4010,"line_end":4010,"column_start":12,"column_end":32},"name":"make_ascii_lowercase","qualname":"<str>::make_ascii_lowercase","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Converts this string to its ASCII lower case equivalent in-place.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1908200,"byte_end":1908268,"line_start":4009,"line_end":4009,"column_start":5,"column_end":73}}]},{"kind":"Method","id":{"krate":0,"index":6390},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1909311,"byte_end":1909323,"line_start":4052,"line_end":4052,"column_start":12,"column_end":24},"name":"escape_debug","qualname":"<str>::escape_debug","value":"fn (&self) -> EscapeDebug<'_>","parent":null,"children":[],"decl_id":null,"docs":" Return an iterator that escapes each char in `self` with [`char::escape_debug`].","sig":null,"attributes":[{"value":"stable(feature = \"str_escape\", since = \"1.34.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1909248,"byte_end":1909299,"line_start":4051,"line_end":4051,"column_start":5,"column_end":56}}]},{"kind":"Method","id":{"krate":0,"index":6392},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1910470,"byte_end":1910484,"line_start":4097,"line_end":4097,"column_start":12,"column_end":26},"name":"escape_default","qualname":"<str>::escape_default","value":"fn (&self) -> EscapeDefault<'_>","parent":null,"children":[],"decl_id":null,"docs":" Return an iterator that escapes each char in `self` with [`char::escape_default`].","sig":null,"attributes":[{"value":"stable(feature = \"str_escape\", since = \"1.34.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1910407,"byte_end":1910458,"line_start":4096,"line_end":4096,"column_start":5,"column_end":56}}]},{"kind":"Method","id":{"krate":0,"index":6393},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1911448,"byte_end":1911462,"line_start":4135,"line_end":4135,"column_start":12,"column_end":26},"name":"escape_unicode","qualname":"<str>::escape_unicode","value":"fn (&self) -> EscapeUnicode<'_>","parent":null,"children":[],"decl_id":null,"docs":" Return an iterator that escapes each char in `self` with [`char::escape_unicode`].","sig":null,"attributes":[{"value":"stable(feature = \"str_escape\", since = \"1.34.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1911385,"byte_end":1911436,"line_start":4134,"line_end":4134,"column_start":5,"column_end":56}}]},{"kind":"Struct","id":{"krate":0,"index":33852},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1912919,"byte_end":1912934,"line_start":4186,"line_end":4186,"column_start":12,"column_end":27},"name":"SplitWhitespace","qualname":"::str::SplitWhitespace","value":"SplitWhitespace {  }","parent":null,"children":[{"krate":0,"index":33854}],"decl_id":null,"docs":" An iterator over the non-whitespace substrings of a string,\n separated by any amount of whitespace.","sig":null,"attributes":[{"value":"stable(feature = \"split_whitespace\", since = \"1.1.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1912827,"byte_end":1912883,"line_start":4184,"line_end":4184,"column_start":1,"column_end":57}}]},{"kind":"Struct","id":{"krate":0,"index":33861},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1913475,"byte_end":1913495,"line_start":4200,"line_end":4200,"column_start":12,"column_end":32},"name":"SplitAsciiWhitespace","qualname":"::str::SplitAsciiWhitespace","value":"SplitAsciiWhitespace {  }","parent":null,"children":[{"krate":0,"index":33863}],"decl_id":null,"docs":" An iterator over the non-ASCII-whitespace substrings of a string,\n separated by any amount of ASCII whitespace.","sig":null,"attributes":[{"value":"stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1913376,"byte_end":1913439,"line_start":4198,"line_end":4198,"column_start":1,"column_end":64}}]},{"kind":"Struct","id":{"krate":0,"index":33940},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1915976,"byte_end":1915987,"line_start":4294,"line_end":4294,"column_start":12,"column_end":23},"name":"EncodeUtf16","qualname":"::str::EncodeUtf16","value":"EncodeUtf16 {  }","parent":null,"children":[{"krate":0,"index":33942},{"krate":0,"index":33943}],"decl_id":null,"docs":" An iterator of [`u16`] over the string encoded as UTF-16.","sig":null,"attributes":[{"value":"stable(feature = \"encode_utf16\", since = \"1.8.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1915912,"byte_end":1915964,"line_start":4293,"line_end":4293,"column_start":1,"column_end":53}}]},{"kind":"Struct","id":{"krate":0,"index":33947},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1917404,"byte_end":1917415,"line_start":4346,"line_end":4346,"column_start":12,"column_end":23},"name":"EscapeDebug","qualname":"::str::EscapeDebug","value":"EscapeDebug {  }","parent":null,"children":[{"krate":0,"index":33949}],"decl_id":null,"docs":" The return type of [`str::escape_debug`].","sig":null,"attributes":[{"value":"stable(feature = \"str_escape\", since = \"1.34.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1917317,"byte_end":1917368,"line_start":4344,"line_end":4344,"column_start":1,"column_end":52}}]},{"kind":"Struct","id":{"krate":0,"index":33956},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1917794,"byte_end":1917807,"line_start":4358,"line_end":4358,"column_start":12,"column_end":25},"name":"EscapeDefault","qualname":"::str::EscapeDefault","value":"EscapeDefault {  }","parent":null,"children":[{"krate":0,"index":33958}],"decl_id":null,"docs":" The return type of [`str::escape_default`].","sig":null,"attributes":[{"value":"stable(feature = \"str_escape\", since = \"1.34.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1917707,"byte_end":1917758,"line_start":4356,"line_end":4356,"column_start":1,"column_end":52}}]},{"kind":"Struct","id":{"krate":0,"index":33965},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1918107,"byte_end":1918120,"line_start":4367,"line_end":4367,"column_start":12,"column_end":25},"name":"EscapeUnicode","qualname":"::str::EscapeUnicode","value":"EscapeUnicode {  }","parent":null,"children":[{"krate":0,"index":33967}],"decl_id":null,"docs":" The return type of [`str::escape_unicode`].","sig":null,"attributes":[{"value":"stable(feature = \"str_escape\", since = \"1.34.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1918020,"byte_end":1918071,"line_start":4365,"line_end":4365,"column_start":1,"column_end":52}}]},{"kind":"Mod","id":{"krate":0,"index":6430},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"hash","qualname":"::hash","value":"src/libcore/hash/mod.rs","parent":null,"children":[{"krate":0,"index":6431},{"krate":0,"index":6432},{"krate":0,"index":6433},{"krate":0,"index":6434},{"krate":0,"index":6435},{"krate":0,"index":6481},{"krate":0,"index":6486},{"krate":0,"index":6501},{"krate":0,"index":6517},{"krate":0,"index":6520},{"krate":0,"index":6524},{"krate":0,"index":6527},{"krate":0,"index":6531},{"krate":0,"index":6534},{"krate":0,"index":6537},{"krate":0,"index":6540},{"krate":0,"index":6542}],"decl_id":null,"docs":" Generic hashing support.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1980467,"byte_end":1980513,"line_start":82,"line_end":82,"column_start":1,"column_end":47}}]},{"kind":"Struct","id":{"krate":0,"index":34028},"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1999470,"byte_end":1999481,"line_start":21,"line_end":21,"column_start":12,"column_end":23},"name":"SipHasher13","qualname":"::hash::sip::SipHasher13","value":"SipHasher13 {  }","parent":null,"children":[{"krate":0,"index":34029}],"decl_id":null,"docs":" An implementation of SipHash 1-3.","sig":null,"attributes":[{"value":"unstable(feature = \"hashmap_internals\", issue = \"0\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1999230,"byte_end":1999285,"line_start":16,"line_end":16,"column_start":1,"column_end":56}},{"value":"rustc_deprecated(since = \"1.13.0\",\n                   reason =\n                       \"use `std::collections::hash_map::DefaultHasher` instead\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1999286,"byte_end":1999410,"line_start":17,"line_end":18,"column_start":1,"column_end":88}}]},{"kind":"Struct","id":{"krate":0,"index":34044},"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2000685,"byte_end":2000694,"line_start":52,"line_end":52,"column_start":12,"column_end":21},"name":"SipHasher","qualname":"::hash::sip::SipHasher","value":"","parent":null,"children":[],"decl_id":null,"docs":" An implementation of SipHash 2-4.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2000470,"byte_end":2000515,"line_start":48,"line_end":48,"column_start":1,"column_end":46}},{"value":"rustc_deprecated(since = \"1.13.0\",\n                   reason =\n                       \"use `std::collections::hash_map::DefaultHasher` instead\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2000516,"byte_end":2000640,"line_start":49,"line_end":50,"column_start":1,"column_end":88}}]},{"kind":"Method","id":{"krate":0,"index":6444},"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2003551,"byte_end":2003554,"line_start":140,"line_end":140,"column_start":12,"column_end":15},"name":"new","qualname":"<SipHasher>::new","value":"fn () -> SipHasher","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `SipHasher` with the two initial keys set to 0.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2003347,"byte_end":2003356,"line_start":136,"line_end":136,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2003361,"byte_end":2003406,"line_start":137,"line_end":137,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.13.0\",\n                   reason =\n                       \"use `std::collections::hash_map::DefaultHasher` instead\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2003411,"byte_end":2003539,"line_start":138,"line_end":139,"column_start":5,"column_end":92}}]},{"kind":"Method","id":{"krate":0,"index":6445},"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2003893,"byte_end":2003906,"line_start":149,"line_end":149,"column_start":12,"column_end":25},"name":"new_with_keys","qualname":"<SipHasher>::new_with_keys","value":"fn (key0: u64, key1: u64) -> SipHasher","parent":null,"children":[],"decl_id":null,"docs":" Creates a `SipHasher` that is keyed off the provided keys.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2003689,"byte_end":2003698,"line_start":145,"line_end":145,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2003703,"byte_end":2003748,"line_start":146,"line_end":146,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.13.0\",\n                   reason =\n                       \"use `std::collections::hash_map::DefaultHasher` instead\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2003753,"byte_end":2003881,"line_start":147,"line_end":148,"column_start":5,"column_end":92}}]},{"kind":"Method","id":{"krate":0,"index":6447},"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2004359,"byte_end":2004362,"line_start":162,"line_end":162,"column_start":12,"column_end":15},"name":"new","qualname":"<SipHasher13>::new","value":"fn () -> SipHasher13","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `SipHasher13` with the two initial keys set to 0.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2004145,"byte_end":2004154,"line_start":158,"line_end":158,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"hashmap_internals\", issue = \"0\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2004159,"byte_end":2004214,"line_start":159,"line_end":159,"column_start":5,"column_end":60}},{"value":"rustc_deprecated(since = \"1.13.0\",\n                   reason =\n                       \"use `std::collections::hash_map::DefaultHasher` instead\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2004219,"byte_end":2004347,"line_start":160,"line_end":161,"column_start":5,"column_end":92}}]},{"kind":"Method","id":{"krate":0,"index":6448},"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2004717,"byte_end":2004730,"line_start":171,"line_end":171,"column_start":12,"column_end":25},"name":"new_with_keys","qualname":"<SipHasher13>::new_with_keys","value":"fn (key0: u64, key1: u64) -> SipHasher13","parent":null,"children":[],"decl_id":null,"docs":" Creates a `SipHasher13` that is keyed off the provided keys.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2004503,"byte_end":2004512,"line_start":167,"line_end":167,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"hashmap_internals\", issue = \"0\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2004517,"byte_end":2004572,"line_start":168,"line_end":168,"column_start":5,"column_end":60}},{"value":"rustc_deprecated(since = \"1.13.0\",\n                   reason =\n                       \"use `std::collections::hash_map::DefaultHasher` instead\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2004577,"byte_end":2004705,"line_start":169,"line_end":170,"column_start":5,"column_end":92}}]},{"kind":"Method","id":{"krate":0,"index":6473},"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2009887,"byte_end":2009895,"line_start":365,"line_end":365,"column_start":8,"column_end":16},"name":"c_rounds","qualname":"::hash::sip::Sip::c_rounds","value":"fn (_: &mut State) -> ()","parent":{"krate":0,"index":6472},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6474},"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2009919,"byte_end":2009927,"line_start":366,"line_end":366,"column_start":8,"column_end":16},"name":"d_rounds","qualname":"::hash::sip::Sip::d_rounds","value":"fn (_: &mut State) -> ()","parent":{"krate":0,"index":6472},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":6481},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1982434,"byte_end":1982438,"line_start":158,"line_end":158,"column_start":11,"column_end":15},"name":"Hash","qualname":"::hash::Hash","value":"Hash","parent":null,"children":[{"krate":0,"index":6482},{"krate":0,"index":6484}],"decl_id":null,"docs":" A hashable type.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1982378,"byte_end":1982423,"line_start":157,"line_end":157,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":6482},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1982888,"byte_end":1982892,"line_start":174,"line_end":174,"column_start":8,"column_end":12},"name":"hash","qualname":"::hash::Hash::hash","value":"fn <H> (&self, state: &mut H) -> ()","parent":{"krate":0,"index":6481},"children":[],"decl_id":null,"docs":" Feeds this value into the given [`Hasher`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1982835,"byte_end":1982880,"line_start":173,"line_end":173,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":6484},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1983449,"byte_end":1983459,"line_start":192,"line_end":192,"column_start":8,"column_end":18},"name":"hash_slice","qualname":"::hash::Hash::hash_slice","value":"fn <H> (data: &[Self], state: &mut H) -> ()","parent":{"krate":0,"index":6481},"children":[],"decl_id":null,"docs":" Feeds a slice of this type into the given [`Hasher`].","sig":null,"attributes":[{"value":"stable(feature = \"hash_slice\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1983391,"byte_end":1983441,"line_start":191,"line_end":191,"column_start":5,"column_end":55}}]},{"kind":"Trait","id":{"krate":0,"index":6486},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1984579,"byte_end":1984585,"line_start":232,"line_end":232,"column_start":11,"column_end":17},"name":"Hasher","qualname":"::hash::Hasher","value":"Hasher","parent":null,"children":[{"krate":0,"index":6487},{"krate":0,"index":6488},{"krate":0,"index":6489},{"krate":0,"index":6490},{"krate":0,"index":6491},{"krate":0,"index":6492},{"krate":0,"index":6493},{"krate":0,"index":6494},{"krate":0,"index":6495},{"krate":0,"index":6496},{"krate":0,"index":6497},{"krate":0,"index":6498},{"krate":0,"index":6499},{"krate":0,"index":6500}],"decl_id":null,"docs":" A trait for hashing an arbitrary stream of bytes.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1984523,"byte_end":1984568,"line_start":231,"line_end":231,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":6487},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1985296,"byte_end":1985302,"line_start":254,"line_end":254,"column_start":8,"column_end":14},"name":"finish","qualname":"::hash::Hasher::finish","value":"fn (&self) -> u64","parent":{"krate":0,"index":6486},"children":[],"decl_id":null,"docs":" Returns the hash value for the values written so far.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1985243,"byte_end":1985288,"line_start":253,"line_end":253,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":6488},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1985787,"byte_end":1985792,"line_start":272,"line_end":272,"column_start":8,"column_end":13},"name":"write","qualname":"::hash::Hasher::write","value":"fn (&mut self, bytes: &[u8]) -> ()","parent":{"krate":0,"index":6486},"children":[],"decl_id":null,"docs":" Writes some data into this `Hasher`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1985734,"byte_end":1985779,"line_start":271,"line_end":271,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":6489},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1985945,"byte_end":1985953,"line_start":277,"line_end":277,"column_start":8,"column_end":16},"name":"write_u8","qualname":"::hash::Hasher::write_u8","value":"fn (&mut self, i: u8) -> ()","parent":{"krate":0,"index":6486},"children":[],"decl_id":null,"docs":" Writes a single `u8` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1985871,"byte_end":1985880,"line_start":275,"line_end":275,"column_start":5,"column_end":14}},{"value":"stable(feature = \"hasher_write\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1985885,"byte_end":1985937,"line_start":276,"line_end":276,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":6490},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1986131,"byte_end":1986140,"line_start":283,"line_end":283,"column_start":8,"column_end":17},"name":"write_u16","qualname":"::hash::Hasher::write_u16","value":"fn (&mut self, i: u16) -> ()","parent":{"krate":0,"index":6486},"children":[],"decl_id":null,"docs":" Writes a single `u16` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1986057,"byte_end":1986066,"line_start":281,"line_end":281,"column_start":5,"column_end":14}},{"value":"stable(feature = \"hasher_write\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1986071,"byte_end":1986123,"line_start":282,"line_end":282,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":6491},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1986331,"byte_end":1986340,"line_start":289,"line_end":289,"column_start":8,"column_end":17},"name":"write_u32","qualname":"::hash::Hasher::write_u32","value":"fn (&mut self, i: u32) -> ()","parent":{"krate":0,"index":6486},"children":[],"decl_id":null,"docs":" Writes a single `u32` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1986257,"byte_end":1986266,"line_start":287,"line_end":287,"column_start":5,"column_end":14}},{"value":"stable(feature = \"hasher_write\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1986271,"byte_end":1986323,"line_start":288,"line_end":288,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":6492},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1986531,"byte_end":1986540,"line_start":295,"line_end":295,"column_start":8,"column_end":17},"name":"write_u64","qualname":"::hash::Hasher::write_u64","value":"fn (&mut self, i: u64) -> ()","parent":{"krate":0,"index":6486},"children":[],"decl_id":null,"docs":" Writes a single `u64` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1986457,"byte_end":1986466,"line_start":293,"line_end":293,"column_start":5,"column_end":14}},{"value":"stable(feature = \"hasher_write\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1986471,"byte_end":1986523,"line_start":294,"line_end":294,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":6493},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1986725,"byte_end":1986735,"line_start":301,"line_end":301,"column_start":8,"column_end":18},"name":"write_u128","qualname":"::hash::Hasher::write_u128","value":"fn (&mut self, i: u128) -> ()","parent":{"krate":0,"index":6486},"children":[],"decl_id":null,"docs":" Writes a single `u128` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1986658,"byte_end":1986667,"line_start":299,"line_end":299,"column_start":5,"column_end":14}},{"value":"stable(feature = \"i128\", since = \"1.26.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1986672,"byte_end":1986717,"line_start":300,"line_end":300,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":6494},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1986929,"byte_end":1986940,"line_start":307,"line_end":307,"column_start":8,"column_end":19},"name":"write_usize","qualname":"::hash::Hasher::write_usize","value":"fn (&mut self, i: usize) -> ()","parent":{"krate":0,"index":6486},"children":[],"decl_id":null,"docs":" Writes a single `usize` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1986855,"byte_end":1986864,"line_start":305,"line_end":305,"column_start":5,"column_end":14}},{"value":"stable(feature = \"hasher_write\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1986869,"byte_end":1986921,"line_start":306,"line_end":306,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":6495},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1987133,"byte_end":1987141,"line_start":314,"line_end":314,"column_start":8,"column_end":16},"name":"write_i8","qualname":"::hash::Hasher::write_i8","value":"fn (&mut self, i: i8) -> ()","parent":{"krate":0,"index":6486},"children":[],"decl_id":null,"docs":" Writes a single `i8` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1987059,"byte_end":1987068,"line_start":312,"line_end":312,"column_start":5,"column_end":14}},{"value":"stable(feature = \"hasher_write\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1987073,"byte_end":1987125,"line_start":313,"line_end":313,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":6496},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1987325,"byte_end":1987334,"line_start":320,"line_end":320,"column_start":8,"column_end":17},"name":"write_i16","qualname":"::hash::Hasher::write_i16","value":"fn (&mut self, i: i16) -> ()","parent":{"krate":0,"index":6486},"children":[],"decl_id":null,"docs":" Writes a single `i16` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1987251,"byte_end":1987260,"line_start":318,"line_end":318,"column_start":5,"column_end":14}},{"value":"stable(feature = \"hasher_write\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1987265,"byte_end":1987317,"line_start":319,"line_end":319,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":6497},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1987525,"byte_end":1987534,"line_start":326,"line_end":326,"column_start":8,"column_end":17},"name":"write_i32","qualname":"::hash::Hasher::write_i32","value":"fn (&mut self, i: i32) -> ()","parent":{"krate":0,"index":6486},"children":[],"decl_id":null,"docs":" Writes a single `i32` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1987451,"byte_end":1987460,"line_start":324,"line_end":324,"column_start":5,"column_end":14}},{"value":"stable(feature = \"hasher_write\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1987465,"byte_end":1987517,"line_start":325,"line_end":325,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":6498},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1987725,"byte_end":1987734,"line_start":332,"line_end":332,"column_start":8,"column_end":17},"name":"write_i64","qualname":"::hash::Hasher::write_i64","value":"fn (&mut self, i: i64) -> ()","parent":{"krate":0,"index":6486},"children":[],"decl_id":null,"docs":" Writes a single `i64` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1987651,"byte_end":1987660,"line_start":330,"line_end":330,"column_start":5,"column_end":14}},{"value":"stable(feature = \"hasher_write\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1987665,"byte_end":1987717,"line_start":331,"line_end":331,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":6499},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1987919,"byte_end":1987929,"line_start":338,"line_end":338,"column_start":8,"column_end":18},"name":"write_i128","qualname":"::hash::Hasher::write_i128","value":"fn (&mut self, i: i128) -> ()","parent":{"krate":0,"index":6486},"children":[],"decl_id":null,"docs":" Writes a single `i128` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1987852,"byte_end":1987861,"line_start":336,"line_end":336,"column_start":5,"column_end":14}},{"value":"stable(feature = \"i128\", since = \"1.26.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1987866,"byte_end":1987911,"line_start":337,"line_end":337,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":6500},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1988123,"byte_end":1988134,"line_start":344,"line_end":344,"column_start":8,"column_end":19},"name":"write_isize","qualname":"::hash::Hasher::write_isize","value":"fn (&mut self, i: isize) -> ()","parent":{"krate":0,"index":6486},"children":[],"decl_id":null,"docs":" Writes a single `isize` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1988049,"byte_end":1988058,"line_start":342,"line_end":342,"column_start":5,"column_end":14}},{"value":"stable(feature = \"hasher_write\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1988063,"byte_end":1988115,"line_start":343,"line_end":343,"column_start":5,"column_end":57}}]},{"kind":"Trait","id":{"krate":0,"index":6517},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1990393,"byte_end":1990404,"line_start":425,"line_end":425,"column_start":11,"column_end":22},"name":"BuildHasher","qualname":"::hash::BuildHasher","value":"BuildHasher","parent":null,"children":[{"krate":0,"index":6518},{"krate":0,"index":6519}],"decl_id":null,"docs":" A trait for creating instances of [`Hasher`].","sig":null,"attributes":[{"value":"stable(since = \"1.7.0\", feature = \"build_hasher\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1990330,"byte_end":1990382,"line_start":424,"line_end":424,"column_start":1,"column_end":53}}]},{"kind":"Type","id":{"krate":0,"index":6518},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1990522,"byte_end":1990528,"line_start":428,"line_end":428,"column_start":10,"column_end":16},"name":"Hasher","qualname":"::hash::BuildHasher::Hasher","value":"type Hasher: Hasher;","parent":{"krate":0,"index":6517},"children":[],"decl_id":null,"docs":" Type of the hasher that will be created.\n","sig":null,"attributes":[{"value":"stable(since = \"1.7.0\", feature = \"build_hasher\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1990460,"byte_end":1990512,"line_start":427,"line_end":427,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":6519},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1991020,"byte_end":1991032,"line_start":447,"line_end":447,"column_start":8,"column_end":20},"name":"build_hasher","qualname":"::hash::BuildHasher::build_hasher","value":"fn (&self) -> Self::Hasher","parent":{"krate":0,"index":6517},"children":[],"decl_id":null,"docs":" Creates a new hasher.","sig":null,"attributes":[{"value":"stable(since = \"1.7.0\", feature = \"build_hasher\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1990960,"byte_end":1991012,"line_start":446,"line_end":446,"column_start":5,"column_end":57}}]},{"kind":"Struct","id":{"krate":0,"index":6520},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1992761,"byte_end":1992779,"line_start":499,"line_end":499,"column_start":12,"column_end":30},"name":"BuildHasherDefault","qualname":"::hash::BuildHasherDefault","value":"","parent":null,"children":[],"decl_id":null,"docs":" Used to create a default [`BuildHasher`] instance for types that implement\n [`Hasher`] and [`Default`].","sig":null,"attributes":[{"value":"stable(since = \"1.7.0\", feature = \"build_hasher\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1992697,"byte_end":1992749,"line_start":498,"line_end":498,"column_start":1,"column_end":53}}]},{"kind":"Mod","id":{"krate":0,"index":6581},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"fmt","qualname":"::fmt","value":"src/libcore/fmt/mod.rs","parent":null,"children":[{"krate":0,"index":6582},{"krate":0,"index":6588},{"krate":0,"index":6589},{"krate":0,"index":6590},{"krate":0,"index":6591},{"krate":0,"index":6592},{"krate":0,"index":6593},{"krate":0,"index":6594},{"krate":0,"index":6595},{"krate":0,"index":6626},{"krate":0,"index":6660},{"krate":0,"index":34569},{"krate":0,"index":34576},{"krate":0,"index":6774},{"krate":0,"index":6780},{"krate":0,"index":6782},{"krate":0,"index":34632},{"krate":0,"index":34651},{"krate":0,"index":34649},{"krate":0,"index":34647},{"krate":0,"index":34645},{"krate":0,"index":34643},{"krate":0,"index":34640},{"krate":0,"index":34638},{"krate":0,"index":34636},{"krate":0,"index":34634},{"krate":0,"index":6783},{"krate":0,"index":6788},{"krate":0,"index":6793},{"krate":0,"index":6803},{"krate":0,"index":34652},{"krate":0,"index":34659},{"krate":0,"index":34656},{"krate":0,"index":6806},{"krate":0,"index":34661},{"krate":0,"index":34676},{"krate":0,"index":34674},{"krate":0,"index":6814},{"krate":0,"index":34677},{"krate":0,"index":34685},{"krate":0,"index":34682},{"krate":0,"index":6820},{"krate":0,"index":6822},{"krate":0,"index":6824},{"krate":0,"index":6826},{"krate":0,"index":6828},{"krate":0,"index":6830},{"krate":0,"index":6832},{"krate":0,"index":6834},{"krate":0,"index":6836},{"krate":0,"index":6838},{"krate":0,"index":6840},{"krate":0,"index":6842},{"krate":0,"index":6843},{"krate":0,"index":6846},{"krate":0,"index":6849},{"krate":0,"index":6889},{"krate":0,"index":6893},{"krate":0,"index":6895},{"krate":0,"index":34687},{"krate":0,"index":34690},{"krate":0,"index":34693},{"krate":0,"index":34696},{"krate":0,"index":34699},{"krate":0,"index":34702},{"krate":0,"index":34705},{"krate":0,"index":34708},{"krate":0,"index":34711},{"krate":0,"index":34714},{"krate":0,"index":34717},{"krate":0,"index":34720},{"krate":0,"index":34723},{"krate":0,"index":34726},{"krate":0,"index":34729},{"krate":0,"index":34732},{"krate":0,"index":6896},{"krate":0,"index":6898},{"krate":0,"index":6900},{"krate":0,"index":6902},{"krate":0,"index":6904},{"krate":0,"index":6906},{"krate":0,"index":6908},{"krate":0,"index":6910},{"krate":0,"index":6913},{"krate":0,"index":6916},{"krate":0,"index":6919},{"krate":0,"index":6922},{"krate":0,"index":6925},{"krate":0,"index":6928},{"krate":0,"index":6931},{"krate":0,"index":6932},{"krate":0,"index":6933},{"krate":0,"index":34735},{"krate":0,"index":34749},{"krate":0,"index":34762},{"krate":0,"index":34774},{"krate":0,"index":34785},{"krate":0,"index":34795},{"krate":0,"index":34804},{"krate":0,"index":34812},{"krate":0,"index":34819},{"krate":0,"index":34825},{"krate":0,"index":34830},{"krate":0,"index":34834},{"krate":0,"index":6934},{"krate":0,"index":6937},{"krate":0,"index":6939},{"krate":0,"index":6942},{"krate":0,"index":6945},{"krate":0,"index":6952},{"krate":0,"index":6955},{"krate":0,"index":6958}],"decl_id":null,"docs":" Utilities for formatting and printing strings.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2010657,"byte_end":2010703,"line_start":3,"line_end":3,"column_start":1,"column_end":47}}]},{"kind":"Method","id":{"krate":0,"index":6637},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2085165,"byte_end":2085169,"line_start":14,"line_end":14,"column_start":8,"column_end":12},"name":"zero","qualname":"::fmt::num::Int::zero","value":"fn () -> Self","parent":{"krate":0,"index":6636},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6638},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2085188,"byte_end":2085195,"line_start":15,"line_end":15,"column_start":8,"column_end":15},"name":"from_u8","qualname":"::fmt::num::Int::from_u8","value":"fn (u: u8) -> Self","parent":{"krate":0,"index":6636},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6639},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2085219,"byte_end":2085224,"line_start":16,"line_end":16,"column_start":8,"column_end":13},"name":"to_u8","qualname":"::fmt::num::Int::to_u8","value":"fn (&self) -> u8","parent":{"krate":0,"index":6636},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6640},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2085246,"byte_end":2085252,"line_start":17,"line_end":17,"column_start":8,"column_end":14},"name":"to_u16","qualname":"::fmt::num::Int::to_u16","value":"fn (&self) -> u16","parent":{"krate":0,"index":6636},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6641},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2085275,"byte_end":2085281,"line_start":18,"line_end":18,"column_start":8,"column_end":14},"name":"to_u32","qualname":"::fmt::num::Int::to_u32","value":"fn (&self) -> u32","parent":{"krate":0,"index":6636},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6642},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2085304,"byte_end":2085310,"line_start":19,"line_end":19,"column_start":8,"column_end":14},"name":"to_u64","qualname":"::fmt::num::Int::to_u64","value":"fn (&self) -> u64","parent":{"krate":0,"index":6636},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6643},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2085333,"byte_end":2085340,"line_start":20,"line_end":20,"column_start":8,"column_end":15},"name":"to_u128","qualname":"::fmt::num::Int::to_u128","value":"fn (&self) -> u128","parent":{"krate":0,"index":6636},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":6646},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2085936,"byte_end":2085940,"line_start":40,"line_end":40,"column_start":11,"column_end":15},"name":"BASE","qualname":"::fmt::num::GenericRadix::BASE","value":"u8","parent":{"krate":0,"index":6645},"children":[],"decl_id":null,"docs":" The number of digits.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":6647},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2085997,"byte_end":2086003,"line_start":43,"line_end":43,"column_start":11,"column_end":17},"name":"PREFIX","qualname":"::fmt::num::GenericRadix::PREFIX","value":"&'static str","parent":{"krate":0,"index":6645},"children":[],"decl_id":null,"docs":" A radix-specific prefix string.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6648},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2086085,"byte_end":2086090,"line_start":46,"line_end":46,"column_start":8,"column_end":13},"name":"digit","qualname":"::fmt::num::GenericRadix::digit","value":"fn (x: u8) -> u8","parent":{"krate":0,"index":6645},"children":[],"decl_id":null,"docs":" Converts an integer to corresponding radix digit.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6649},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2086174,"byte_end":2086181,"line_start":49,"line_end":49,"column_start":8,"column_end":15},"name":"fmt_int","qualname":"::fmt::num::GenericRadix::fmt_int","value":"fn <T> (&self, mut x: T, f: &mut fmt::Formatter<'_>) -> fmt::Result","parent":{"krate":0,"index":6645},"children":[],"decl_id":null,"docs":" Format an integer using the radix using a formatter.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":6674},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2096739,"byte_end":2096750,"line_start":82,"line_end":82,"column_start":12,"column_end":23},"name":"DebugStruct","qualname":"::fmt::builders::DebugStruct","value":"DebugStruct {  }","parent":null,"children":[{"krate":0,"index":6677},{"krate":0,"index":6678},{"krate":0,"index":6679}],"decl_id":null,"docs":" A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.","sig":null,"attributes":[{"value":"must_use = \"must eventually call `finish()` on Debug builders\"","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2096567,"byte_end":2096632,"line_start":79,"line_end":79,"column_start":1,"column_end":66}},{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2096633,"byte_end":2096672,"line_start":80,"line_end":80,"column_start":1,"column_end":40}},{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2096673,"byte_end":2096727,"line_start":81,"line_end":81,"column_start":1,"column_end":55}}]},{"kind":"Function","id":{"krate":0,"index":6680},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2096859,"byte_end":2096875,"line_start":88,"line_end":88,"column_start":8,"column_end":24},"name":"debug_struct_new","qualname":"::fmt::builders::debug_struct_new","value":"fn <'a, 'b> (fmt: &'a mut fmt::Formatter<'b>, name: &str) -> DebugStruct<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6686},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2098186,"byte_end":2098191,"line_start":129,"line_end":129,"column_start":12,"column_end":17},"name":"field","qualname":"<DebugStruct>::field","value":"fn (&mut self, name: &str, value: &dyn fmt::Debug) -> &mut DebugStruct<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":" Adds a new field to the generated struct output.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2098120,"byte_end":2098174,"line_start":128,"line_end":128,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":6688},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2099926,"byte_end":2099932,"line_start":182,"line_end":182,"column_start":12,"column_end":18},"name":"finish","qualname":"<DebugStruct>::finish","value":"fn (&mut self) -> fmt::Result","parent":null,"children":[],"decl_id":null,"docs":" Finishes output and returns any error encountered.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2099860,"byte_end":2099914,"line_start":181,"line_end":181,"column_start":5,"column_end":59}}]},{"kind":"Struct","id":{"krate":0,"index":6691},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2101310,"byte_end":2101320,"line_start":233,"line_end":233,"column_start":12,"column_end":22},"name":"DebugTuple","qualname":"::fmt::builders::DebugTuple","value":"DebugTuple {  }","parent":null,"children":[{"krate":0,"index":6694},{"krate":0,"index":6695},{"krate":0,"index":6696},{"krate":0,"index":6697}],"decl_id":null,"docs":" A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.","sig":null,"attributes":[{"value":"must_use = \"must eventually call `finish()` on Debug builders\"","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2101138,"byte_end":2101203,"line_start":230,"line_end":230,"column_start":1,"column_end":66}},{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2101204,"byte_end":2101243,"line_start":231,"line_end":231,"column_start":1,"column_end":40}},{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2101244,"byte_end":2101298,"line_start":232,"line_end":232,"column_start":1,"column_end":55}}]},{"kind":"Function","id":{"krate":0,"index":6698},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2101448,"byte_end":2101463,"line_start":240,"line_end":240,"column_start":8,"column_end":23},"name":"debug_tuple_new","qualname":"::fmt::builders::debug_tuple_new","value":"fn <'a, 'b> (fmt: &'a mut fmt::Formatter<'b>, name: &str) -> DebugTuple<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6704},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2102480,"byte_end":2102485,"line_start":275,"line_end":275,"column_start":12,"column_end":17},"name":"field","qualname":"<DebugTuple>::field","value":"fn (&mut self, value: &dyn fmt::Debug) -> &mut DebugTuple<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":" Adds a new field to the generated tuple struct output.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2102414,"byte_end":2102468,"line_start":274,"line_end":274,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":6706},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2103940,"byte_end":2103946,"line_start":321,"line_end":321,"column_start":12,"column_end":18},"name":"finish","qualname":"<DebugTuple>::finish","value":"fn (&mut self) -> fmt::Result","parent":null,"children":[],"decl_id":null,"docs":" Finishes output and returns any error encountered.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2103874,"byte_end":2103928,"line_start":320,"line_end":320,"column_start":5,"column_end":59}}]},{"kind":"Struct","id":{"krate":0,"index":6721},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2106125,"byte_end":2106133,"line_start":401,"line_end":401,"column_start":12,"column_end":20},"name":"DebugSet","qualname":"::fmt::builders::DebugSet","value":"DebugSet {  }","parent":null,"children":[{"krate":0,"index":6724}],"decl_id":null,"docs":" A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.","sig":null,"attributes":[{"value":"must_use = \"must eventually call `finish()` on Debug builders\"","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2105953,"byte_end":2106018,"line_start":398,"line_end":398,"column_start":1,"column_end":66}},{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2106019,"byte_end":2106058,"line_start":399,"line_end":399,"column_start":1,"column_end":40}},{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2106059,"byte_end":2106113,"line_start":400,"line_end":400,"column_start":1,"column_end":55}}]},{"kind":"Function","id":{"krate":0,"index":6725},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2106189,"byte_end":2106202,"line_start":405,"line_end":405,"column_start":8,"column_end":21},"name":"debug_set_new","qualname":"::fmt::builders::debug_set_new","value":"fn <'a, 'b> (fmt: &'a mut fmt::Formatter<'b>) -> DebugSet<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6731},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2107175,"byte_end":2107180,"line_start":441,"line_end":441,"column_start":12,"column_end":17},"name":"entry","qualname":"<DebugSet>::entry","value":"fn (&mut self, entry: &dyn fmt::Debug) -> &mut DebugSet<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":" Adds a new entry to the set output.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2107109,"byte_end":2107163,"line_start":440,"line_end":440,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":6732},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2108040,"byte_end":2108047,"line_start":470,"line_end":470,"column_start":12,"column_end":19},"name":"entries","qualname":"<DebugSet>::entries","value":"fn <D, I> (&mut self, entries: I) -> &mut DebugSet<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":" Adds the contents of an iterator of entries to the set output.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2107974,"byte_end":2108028,"line_start":469,"line_end":469,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":6735},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2108903,"byte_end":2108909,"line_start":503,"line_end":503,"column_start":12,"column_end":18},"name":"finish","qualname":"<DebugSet>::finish","value":"fn (&mut self) -> fmt::Result","parent":null,"children":[],"decl_id":null,"docs":" Finishes output and returns any error encountered.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2108837,"byte_end":2108891,"line_start":502,"line_end":502,"column_start":5,"column_end":59}}]},{"kind":"Struct","id":{"krate":0,"index":6737},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2109898,"byte_end":2109907,"line_start":538,"line_end":538,"column_start":12,"column_end":21},"name":"DebugList","qualname":"::fmt::builders::DebugList","value":"DebugList {  }","parent":null,"children":[{"krate":0,"index":6740}],"decl_id":null,"docs":" A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.","sig":null,"attributes":[{"value":"must_use = \"must eventually call `finish()` on Debug builders\"","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2109726,"byte_end":2109791,"line_start":535,"line_end":535,"column_start":1,"column_end":66}},{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2109792,"byte_end":2109831,"line_start":536,"line_end":536,"column_start":1,"column_end":40}},{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2109832,"byte_end":2109886,"line_start":537,"line_end":537,"column_start":1,"column_end":55}}]},{"kind":"Function","id":{"krate":0,"index":6741},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2109963,"byte_end":2109977,"line_start":542,"line_end":542,"column_start":8,"column_end":22},"name":"debug_list_new","qualname":"::fmt::builders::debug_list_new","value":"fn <'a, 'b> (fmt: &'a mut fmt::Formatter<'b>) -> DebugList<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6747},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2110959,"byte_end":2110964,"line_start":578,"line_end":578,"column_start":12,"column_end":17},"name":"entry","qualname":"<DebugList>::entry","value":"fn (&mut self, entry: &dyn fmt::Debug) -> &mut DebugList<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":" Adds a new entry to the list output.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2110893,"byte_end":2110947,"line_start":577,"line_end":577,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":6748},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2111772,"byte_end":2111779,"line_start":607,"line_end":607,"column_start":12,"column_end":19},"name":"entries","qualname":"<DebugList>::entries","value":"fn <D, I> (&mut self, entries: I) -> &mut DebugList<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":" Adds the contents of an iterator of entries to the list output.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2111706,"byte_end":2111760,"line_start":606,"line_end":606,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":6751},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2112637,"byte_end":2112643,"line_start":640,"line_end":640,"column_start":12,"column_end":18},"name":"finish","qualname":"<DebugList>::finish","value":"fn (&mut self) -> fmt::Result","parent":null,"children":[],"decl_id":null,"docs":" Finishes output and returns any error encountered.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2112571,"byte_end":2112625,"line_start":639,"line_end":639,"column_start":5,"column_end":59}}]},{"kind":"Struct","id":{"krate":0,"index":6753},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2113711,"byte_end":2113719,"line_start":675,"line_end":675,"column_start":12,"column_end":20},"name":"DebugMap","qualname":"::fmt::builders::DebugMap","value":"DebugMap {  }","parent":null,"children":[{"krate":0,"index":6756},{"krate":0,"index":6757},{"krate":0,"index":6758}],"decl_id":null,"docs":" A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.","sig":null,"attributes":[{"value":"must_use = \"must eventually call `finish()` on Debug builders\"","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2113539,"byte_end":2113604,"line_start":672,"line_end":672,"column_start":1,"column_end":66}},{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2113605,"byte_end":2113644,"line_start":673,"line_end":673,"column_start":1,"column_end":40}},{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2113645,"byte_end":2113699,"line_start":674,"line_end":674,"column_start":1,"column_end":55}}]},{"kind":"Function","id":{"krate":0,"index":6759},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2113828,"byte_end":2113841,"line_start":681,"line_end":681,"column_start":8,"column_end":21},"name":"debug_map_new","qualname":"::fmt::builders::debug_map_new","value":"fn <'a, 'b> (fmt: &'a mut fmt::Formatter<'b>) -> DebugMap<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6765},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2114755,"byte_end":2114760,"line_start":714,"line_end":714,"column_start":12,"column_end":17},"name":"entry","qualname":"<DebugMap>::entry","value":"fn (&mut self, key: &dyn fmt::Debug, value: &dyn fmt::Debug) -> &mut DebugMap<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":" Adds a new entry to the map output.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2114689,"byte_end":2114743,"line_start":713,"line_end":713,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":6767},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2116439,"byte_end":2116446,"line_start":765,"line_end":765,"column_start":12,"column_end":19},"name":"entries","qualname":"<DebugMap>::entries","value":"fn <K, V, I> (&mut self, entries: I) -> &mut DebugMap<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":" Adds the contents of an iterator of entries to the map output.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2116373,"byte_end":2116427,"line_start":764,"line_end":764,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":6771},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2117432,"byte_end":2117438,"line_start":799,"line_end":799,"column_start":12,"column_end":18},"name":"finish","qualname":"<DebugMap>::finish","value":"fn (&mut self) -> fmt::Result","parent":null,"children":[],"decl_id":null,"docs":" Finishes output and returns any error encountered.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2117366,"byte_end":2117420,"line_start":798,"line_end":798,"column_start":5,"column_end":59}}]},{"kind":"TupleVariant","id":{"krate":0,"index":34570},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2011221,"byte_end":2011225,"line_start":24,"line_end":24,"column_start":5,"column_end":9},"name":"Left","qualname":"::fmt::Alignment::Left","value":"Alignment::Left","parent":{"krate":0,"index":34569},"children":[],"decl_id":null,"docs":" Indication that contents should be left-aligned.\n","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags_align\", since = \"1.28.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2011103,"byte_end":2011159,"line_start":22,"line_end":22,"column_start":5,"column_end":61}}]},{"kind":"TupleVariant","id":{"krate":0,"index":34572},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2011350,"byte_end":2011355,"line_start":27,"line_end":27,"column_start":5,"column_end":10},"name":"Right","qualname":"::fmt::Alignment::Right","value":"Alignment::Right","parent":{"krate":0,"index":34569},"children":[],"decl_id":null,"docs":" Indication that contents should be right-aligned.\n","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags_align\", since = \"1.28.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2011231,"byte_end":2011287,"line_start":25,"line_end":25,"column_start":5,"column_end":61}}]},{"kind":"TupleVariant","id":{"krate":0,"index":34574},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2011481,"byte_end":2011487,"line_start":30,"line_end":30,"column_start":5,"column_end":11},"name":"Center","qualname":"::fmt::Alignment::Center","value":"Alignment::Center","parent":{"krate":0,"index":34569},"children":[],"decl_id":null,"docs":" Indication that contents should be center-aligned.\n","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags_align\", since = \"1.28.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2011361,"byte_end":2011417,"line_start":28,"line_end":28,"column_start":5,"column_end":61}}]},{"kind":"Enum","id":{"krate":0,"index":34569},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2011087,"byte_end":2011096,"line_start":21,"line_end":21,"column_start":10,"column_end":19},"name":"Alignment","qualname":"::fmt::Alignment","value":"Alignment::{Left, Right, Center}","parent":null,"children":[{"krate":0,"index":34570},{"krate":0,"index":34572},{"krate":0,"index":34574}],"decl_id":null,"docs":" Possible alignments returned by `Formatter::align`\n","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags_align\", since = \"1.28.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2010949,"byte_end":2011005,"line_start":18,"line_end":18,"column_start":1,"column_end":57}}]},{"kind":"Mod","id":{"krate":0,"index":6780},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2011753,"byte_end":2011755,"line_start":39,"line_end":39,"column_start":9,"column_end":11},"name":"rt","qualname":"::fmt::rt","value":"src/libcore/fmt/mod.rs","parent":null,"children":[{"krate":0,"index":6781}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"fmt_internals\",\n           reason = \"internal to format_args!\",\n           issue = \"0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2011630,"byte_end":2011729,"line_start":36,"line_end":37,"column_start":1,"column_end":25}}]},{"kind":"Mod","id":{"krate":0,"index":6781},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"v1","qualname":"::fmt::rt::v1","value":"src/libcore/fmt/rt/v1.rs","parent":null,"children":[{"krate":0,"index":34578},{"krate":0,"index":34583},{"krate":0,"index":34581},{"krate":0,"index":34584},{"krate":0,"index":34592},{"krate":0,"index":34590},{"krate":0,"index":34593},{"krate":0,"index":34608},{"krate":0,"index":34606},{"krate":0,"index":34604},{"krate":0,"index":34602},{"krate":0,"index":34609},{"krate":0,"index":34622},{"krate":0,"index":34620},{"krate":0,"index":34623},{"krate":0,"index":34631},{"krate":0,"index":34629}],"decl_id":null,"docs":" This is an internal module used by the ifmt! runtime. These structures are\n emitted to static arrays to precompile format strings ahead of time.","sig":null,"attributes":[{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2117921,"byte_end":2117961,"line_start":6,"line_end":6,"column_start":1,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":34578},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2117997,"byte_end":2118005,"line_start":9,"line_end":9,"column_start":12,"column_end":20},"name":"Argument","qualname":"::fmt::rt::v1::Argument","value":"Argument { position, format }","parent":null,"children":[{"krate":0,"index":34579},{"krate":0,"index":34580}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2117986,"byte_end":2118065,"line_start":9,"line_end":12,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":34579},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118016,"byte_end":2118024,"line_start":10,"line_end":10,"column_start":9,"column_end":17},"name":"position","qualname":"::fmt::rt::v1::Argument::position","value":"fmt::rt::v1::Position","parent":{"krate":0,"index":34578},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":34580},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118044,"byte_end":2118050,"line_start":11,"line_end":11,"column_start":9,"column_end":15},"name":"format","qualname":"::fmt::rt::v1::Argument::format","value":"fmt::rt::v1::FormatSpec","parent":{"krate":0,"index":34578},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":34584},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118101,"byte_end":2118111,"line_start":15,"line_end":15,"column_start":12,"column_end":22},"name":"FormatSpec","qualname":"::fmt::rt::v1::FormatSpec","value":"FormatSpec { fill, align, flags, precision, width }","parent":null,"children":[{"krate":0,"index":34585},{"krate":0,"index":34586},{"krate":0,"index":34587},{"krate":0,"index":34588},{"krate":0,"index":34589}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118090,"byte_end":2118229,"line_start":15,"line_end":21,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":34585},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118122,"byte_end":2118126,"line_start":16,"line_end":16,"column_start":9,"column_end":13},"name":"fill","qualname":"::fmt::rt::v1::FormatSpec::fill","value":"char","parent":{"krate":0,"index":34584},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":34586},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118142,"byte_end":2118147,"line_start":17,"line_end":17,"column_start":9,"column_end":14},"name":"align","qualname":"::fmt::rt::v1::FormatSpec::align","value":"fmt::rt::v1::Alignment","parent":{"krate":0,"index":34584},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":34587},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118168,"byte_end":2118173,"line_start":18,"line_end":18,"column_start":9,"column_end":14},"name":"flags","qualname":"::fmt::rt::v1::FormatSpec::flags","value":"u32","parent":{"krate":0,"index":34584},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":34588},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118188,"byte_end":2118197,"line_start":19,"line_end":19,"column_start":9,"column_end":18},"name":"precision","qualname":"::fmt::rt::v1::FormatSpec::precision","value":"fmt::rt::v1::Count","parent":{"krate":0,"index":34584},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":34589},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118214,"byte_end":2118219,"line_start":20,"line_end":20,"column_start":9,"column_end":14},"name":"width","qualname":"::fmt::rt::v1::FormatSpec::width","value":"fmt::rt::v1::Count","parent":{"krate":0,"index":34584},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":34594},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118432,"byte_end":2118436,"line_start":27,"line_end":27,"column_start":5,"column_end":9},"name":"Left","qualname":"::fmt::rt::v1::Alignment::Left","value":"Alignment::Left","parent":{"krate":0,"index":34593},"children":[],"decl_id":null,"docs":" Indication that contents should be left-aligned.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":34596},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118500,"byte_end":2118505,"line_start":29,"line_end":29,"column_start":5,"column_end":10},"name":"Right","qualname":"::fmt::rt::v1::Alignment::Right","value":"Alignment::Right","parent":{"krate":0,"index":34593},"children":[],"decl_id":null,"docs":" Indication that contents should be right-aligned.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":34598},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118570,"byte_end":2118576,"line_start":31,"line_end":31,"column_start":5,"column_end":11},"name":"Center","qualname":"::fmt::rt::v1::Alignment::Center","value":"Alignment::Center","parent":{"krate":0,"index":34593},"children":[],"decl_id":null,"docs":" Indication that contents should be center-aligned.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":34600},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118618,"byte_end":2118625,"line_start":33,"line_end":33,"column_start":5,"column_end":12},"name":"Unknown","qualname":"::fmt::rt::v1::Alignment::Unknown","value":"Alignment::Unknown","parent":{"krate":0,"index":34593},"children":[],"decl_id":null,"docs":" No alignment was requested.\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":34593},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118359,"byte_end":2118368,"line_start":25,"line_end":25,"column_start":10,"column_end":19},"name":"Alignment","qualname":"::fmt::rt::v1::Alignment","value":"Alignment::{Left, Right, Center, Unknown}","parent":null,"children":[{"krate":0,"index":34594},{"krate":0,"index":34596},{"krate":0,"index":34598},{"krate":0,"index":34600}],"decl_id":null,"docs":" Possible alignments that can be requested as part of a formatting directive.\n","sig":null,"attributes":[{"value":"structural_match","span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118350,"byte_end":2118628,"line_start":25,"line_end":34,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118350,"byte_end":2118628,"line_start":25,"line_end":34,"column_start":1,"column_end":2}}]},{"kind":"TupleVariant","id":{"krate":0,"index":34610},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118674,"byte_end":2118676,"line_start":38,"line_end":38,"column_start":5,"column_end":7},"name":"Is","qualname":"::fmt::rt::v1::Count::Is","value":"Count::Is(usize)","parent":{"krate":0,"index":34609},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":34613},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118689,"byte_end":2118694,"line_start":39,"line_end":39,"column_start":5,"column_end":10},"name":"Param","qualname":"::fmt::rt::v1::Count::Param","value":"Count::Param(usize)","parent":{"krate":0,"index":34609},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":34616},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118707,"byte_end":2118716,"line_start":40,"line_end":40,"column_start":5,"column_end":14},"name":"NextParam","qualname":"::fmt::rt::v1::Count::NextParam","value":"Count::NextParam","parent":{"krate":0,"index":34609},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":34618},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118722,"byte_end":2118729,"line_start":41,"line_end":41,"column_start":5,"column_end":12},"name":"Implied","qualname":"::fmt::rt::v1::Count::Implied","value":"Count::Implied","parent":{"krate":0,"index":34609},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":34609},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118662,"byte_end":2118667,"line_start":37,"line_end":37,"column_start":10,"column_end":15},"name":"Count","qualname":"::fmt::rt::v1::Count","value":"Count::{Is, Param, NextParam, Implied}","parent":null,"children":[{"krate":0,"index":34610},{"krate":0,"index":34613},{"krate":0,"index":34616},{"krate":0,"index":34618}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118653,"byte_end":2118732,"line_start":37,"line_end":42,"column_start":1,"column_end":2}}]},{"kind":"TupleVariant","id":{"krate":0,"index":34624},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118781,"byte_end":2118785,"line_start":46,"line_end":46,"column_start":5,"column_end":9},"name":"Next","qualname":"::fmt::rt::v1::Position::Next","value":"Position::Next","parent":{"krate":0,"index":34623},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":34626},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118791,"byte_end":2118793,"line_start":47,"line_end":47,"column_start":5,"column_end":7},"name":"At","qualname":"::fmt::rt::v1::Position::At","value":"Position::At(usize)","parent":{"krate":0,"index":34623},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":34623},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118766,"byte_end":2118774,"line_start":45,"line_end":45,"column_start":10,"column_end":18},"name":"Position","qualname":"::fmt::rt::v1::Position","value":"Position::{Next, At}","parent":null,"children":[{"krate":0,"index":34624},{"krate":0,"index":34626}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2118757,"byte_end":2118803,"line_start":45,"line_end":48,"column_start":1,"column_end":2}}]},{"kind":"Type","id":{"krate":0,"index":6782},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2012333,"byte_end":2012339,"line_start":68,"line_end":68,"column_start":10,"column_end":16},"name":"Result","qualname":"::fmt::Result","value":"result::Result<(), Error>","parent":null,"children":[],"decl_id":null,"docs":" The type returned by formatter methods.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2012278,"byte_end":2012323,"line_start":67,"line_end":67,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":34632},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2013316,"byte_end":2013321,"line_start":95,"line_end":95,"column_start":12,"column_end":17},"name":"Error","qualname":"::fmt::Error","value":"","parent":null,"children":[],"decl_id":null,"docs":" The error type which is returned from formatting a message into a stream.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2013182,"byte_end":2013227,"line_start":93,"line_end":93,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2013305,"byte_end":2013322,"line_start":95,"line_end":95,"column_start":1,"column_end":18}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2013305,"byte_end":2013322,"line_start":95,"line_end":95,"column_start":1,"column_end":18}}]},{"kind":"Trait","id":{"krate":0,"index":6783},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2013989,"byte_end":2013994,"line_start":110,"line_end":110,"column_start":11,"column_end":16},"name":"Write","qualname":"::fmt::Write","value":"Write","parent":null,"children":[{"krate":0,"index":6784},{"krate":0,"index":6785},{"krate":0,"index":6787}],"decl_id":null,"docs":" A collection of methods that are required to format a message into a stream.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2013933,"byte_end":2013978,"line_start":109,"line_end":109,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":6784},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2014829,"byte_end":2014838,"line_start":138,"line_end":138,"column_start":8,"column_end":17},"name":"write_str","qualname":"::fmt::Write::write_str","value":"fn (&mut self, s: &str) -> Result","parent":{"krate":0,"index":6783},"children":[],"decl_id":null,"docs":" Writes a slice of bytes into this writer, returning whether the write\n succeeded.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2014776,"byte_end":2014821,"line_start":137,"line_end":137,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":6785},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2015849,"byte_end":2015859,"line_start":169,"line_end":169,"column_start":8,"column_end":18},"name":"write_char","qualname":"::fmt::Write::write_char","value":"fn (&mut self, c: char) -> Result","parent":{"krate":0,"index":6783},"children":[],"decl_id":null,"docs":" Writes a [`char`] into this writer, returning whether the write succeeded.","sig":null,"attributes":[{"value":"stable(feature = \"fmt_write_char\", since = \"1.1.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2015787,"byte_end":2015841,"line_start":168,"line_end":168,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":6787},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2016625,"byte_end":2016634,"line_start":194,"line_end":194,"column_start":8,"column_end":17},"name":"write_fmt","qualname":"::fmt::Write::write_fmt","value":"fn (mut self: &mut Self, args: Arguments<'_>) -> Result","parent":{"krate":0,"index":6783},"children":[],"decl_id":null,"docs":" Glue for usage of the [`write!`] macro with implementors of this trait.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2016572,"byte_end":2016617,"line_start":193,"line_end":193,"column_start":5,"column_end":50}}]},{"kind":"Struct","id":{"krate":0,"index":6793},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2017773,"byte_end":2017782,"line_start":228,"line_end":228,"column_start":12,"column_end":21},"name":"Formatter","qualname":"::fmt::Formatter","value":"Formatter {  }","parent":null,"children":[{"krate":0,"index":6795},{"krate":0,"index":6796},{"krate":0,"index":6797},{"krate":0,"index":6798},{"krate":0,"index":6799},{"krate":0,"index":6800},{"krate":0,"index":6801},{"krate":0,"index":6802}],"decl_id":null,"docs":" Configuration for formatting.","sig":null,"attributes":[{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2017676,"byte_end":2017715,"line_start":226,"line_end":226,"column_start":1,"column_end":40}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2017716,"byte_end":2017761,"line_start":227,"line_end":227,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":34652},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2019206,"byte_end":2019216,"line_start":264,"line_end":264,"column_start":12,"column_end":22},"name":"ArgumentV1","qualname":"::fmt::ArgumentV1","value":"ArgumentV1 {  }","parent":null,"children":[{"krate":0,"index":34654},{"krate":0,"index":34655}],"decl_id":null,"docs":" This struct represents the generic \"argument\" which is taken by the Xprintf\n family of functions. It contains a function to format the given value. At\n compile time it is ensured that the function and the value have the correct\n types, and then this struct is used to canonicalize arguments to one type.\n","sig":null,"attributes":[{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2019040,"byte_end":2019079,"line_start":260,"line_end":260,"column_start":1,"column_end":40}},{"value":"unstable(feature = \"fmt_internals\",\n           reason = \"internal to format_args!\",\n           issue = \"0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2019080,"byte_end":2019179,"line_start":261,"line_end":262,"column_start":1,"column_end":25}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2019195,"byte_end":2019301,"line_start":264,"line_end":267,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":6809},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2019586,"byte_end":2019589,"line_start":278,"line_end":278,"column_start":12,"column_end":15},"name":"new","qualname":"<ArgumentV1>::new","value":"fn <'b, T> (x: &'b T, f: fn(&T, &mut Formatter<'_>) -> Result) -> ArgumentV1<'b>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"fmt_internals\",\n           reason = \"internal to format_args!\",\n           issue = \"0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2019471,"byte_end":2019574,"line_start":276,"line_end":277,"column_start":5,"column_end":29}}]},{"kind":"Method","id":{"krate":0,"index":6812},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2019988,"byte_end":2019998,"line_start":291,"line_end":291,"column_start":12,"column_end":22},"name":"from_usize","qualname":"<ArgumentV1>::from_usize","value":"fn (x: &usize) -> ArgumentV1<'_>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"fmt_internals\",\n           reason = \"internal to format_args!\",\n           issue = \"0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2019873,"byte_end":2019976,"line_start":289,"line_end":290,"column_start":5,"column_end":29}}]},{"kind":"Method","id":{"krate":0,"index":6816},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2020781,"byte_end":2020787,"line_start":314,"line_end":314,"column_start":12,"column_end":18},"name":"new_v1","qualname":"<Arguments>::new_v1","value":"fn (pieces: &'a [&'a str], args: &'a [ArgumentV1<'a>]) -> Arguments<'a>","parent":null,"children":[],"decl_id":null,"docs":" When using the format_args!() macro, this function is used to generate the\n Arguments structure.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2020652,"byte_end":2020661,"line_start":311,"line_end":311,"column_start":20,"column_end":29}},{"value":"unstable(feature = \"fmt_internals\",\n           reason = \"internal to format_args!\",\n           issue = \"0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2020666,"byte_end":2020769,"line_start":312,"line_end":313,"column_start":5,"column_end":29}}]},{"kind":"Method","id":{"krate":0,"index":6817},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2021543,"byte_end":2021559,"line_start":332,"line_end":332,"column_start":12,"column_end":28},"name":"new_v1_formatted","qualname":"<Arguments>::new_v1_formatted","value":"fn (pieces: &'a [&'a str], args: &'a [ArgumentV1<'a>], fmt: &'a [rt::v1::Argument]) -> Arguments<'a>","parent":null,"children":[],"decl_id":null,"docs":" This function is used to specify nonstandard formatting parameters.\n The `pieces` array must be at least as long as `fmt` to construct\n a valid Arguments structure. Also, any `Count` within `fmt` that is\n `CountIsParam` or `CountIsNextParam` has to point to an argument\n created with `argumentusize`. However, failing to do so doesn't cause\n unsafety, but will ignore invalid .\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2021414,"byte_end":2021423,"line_start":329,"line_end":329,"column_start":20,"column_end":29}},{"value":"unstable(feature = \"fmt_internals\",\n           reason = \"internal to format_args!\",\n           issue = \"0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2021428,"byte_end":2021531,"line_start":330,"line_end":331,"column_start":5,"column_end":29}}]},{"kind":"Method","id":{"krate":0,"index":6818},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2022179,"byte_end":2022197,"line_start":349,"line_end":349,"column_start":12,"column_end":30},"name":"estimated_capacity","qualname":"<Arguments>::estimated_capacity","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Estimates the length of the formatted text.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2022050,"byte_end":2022059,"line_start":346,"line_end":346,"column_start":20,"column_end":29}},{"value":"unstable(feature = \"fmt_internals\",\n           reason = \"internal to format_args!\",\n           issue = \"0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2022064,"byte_end":2022167,"line_start":347,"line_end":348,"column_start":5,"column_end":29}}]},{"kind":"Struct","id":{"krate":0,"index":34677},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2024066,"byte_end":2024075,"line_start":395,"line_end":395,"column_start":12,"column_end":21},"name":"Arguments","qualname":"::fmt::Arguments","value":"Arguments {  }","parent":null,"children":[{"krate":0,"index":34679},{"krate":0,"index":34680},{"krate":0,"index":34681}],"decl_id":null,"docs":" This structure represents a safely precompiled version of a format string\n and its arguments. This cannot be generated at runtime because it cannot\n safely be done, so no constructors are given and the fields are private\n to prevent modification.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2023986,"byte_end":2024031,"line_start":393,"line_end":393,"column_start":1,"column_end":46}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2024055,"byte_end":2024437,"line_start":395,"line_end":405,"column_start":1,"column_end":2}}]},{"kind":"Trait","id":{"krate":0,"index":6824},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2027516,"byte_end":2027521,"line_start":522,"line_end":522,"column_start":11,"column_end":16},"name":"Debug","qualname":"::fmt::Debug","value":"Debug","parent":null,"children":[{"krate":0,"index":6825}],"decl_id":null,"docs":" `?` formatting.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2027079,"byte_end":2027124,"line_start":513,"line_end":513,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(on(crate_local,\n                            label =\n                                \"`{Self}` cannot be formatted using `{{:?}}`\",\n                            note =\n                                \"add `#[derive(Debug)]` or manually implement `{Debug}`\"),\n                         message = \"`{Self}` doesn't implement `{Debug}`\",\n                         label =\n                             \"`{Self}` cannot be formatted using `{{:?}}` because it doesn't implement `{Debug}`\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2027125,"byte_end":2027458,"line_start":514,"line_end":519,"column_start":1,"column_end":3}},{"value":"lang = \"debug_trait\"","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2027482,"byte_end":2027505,"line_start":521,"line_end":521,"column_start":1,"column_end":24}}]},{"kind":"Method","id":{"krate":0,"index":6825},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2028171,"byte_end":2028174,"line_start":545,"line_end":545,"column_start":8,"column_end":11},"name":"fmt","qualname":"::fmt::Debug::fmt","value":"fn (&self, f: &mut Formatter<'_>) -> Result","parent":{"krate":0,"index":6824},"children":[],"decl_id":null,"docs":" Formats the value using the given formatter.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2028118,"byte_end":2028163,"line_start":544,"line_end":544,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":6826},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2029580,"byte_end":2029587,"line_start":594,"line_end":594,"column_start":11,"column_end":18},"name":"Display","qualname":"::fmt::Display","value":"Display","parent":null,"children":[{"krate":0,"index":6827}],"decl_id":null,"docs":" Format trait for an empty format, `{}`.","sig":null,"attributes":[{"value":"rustc_on_unimplemented(on(_Self = \"std::path::Path\",\n                            label =\n                                \"`{Self}` cannot be formatted with the default formatter; call `.display()` on it\",\n                            note =\n                                \"call `.display()` or `.to_string_lossy()` to safely print paths, \\\n              as they may contain non-Unicode data\"),\n                         message = \"`{Self}` doesn't implement `{Display}`\",\n                         label =\n                             \"`{Self}` cannot be formatted with the default formatter\",\n                         note =\n                             \"in format strings you may be able to use `{{:?}}` (or {{:#?}} for pretty-print) instead\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2028972,"byte_end":2029502,"line_start":581,"line_end":591,"column_start":1,"column_end":3}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2029524,"byte_end":2029569,"line_start":593,"line_end":593,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":6827},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2030233,"byte_end":2030236,"line_start":617,"line_end":617,"column_start":8,"column_end":11},"name":"fmt","qualname":"::fmt::Display::fmt","value":"fn (&self, f: &mut Formatter<'_>) -> Result","parent":{"krate":0,"index":6826},"children":[],"decl_id":null,"docs":" Formats the value using the given formatter.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2030180,"byte_end":2030225,"line_start":616,"line_end":616,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":6828},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2031438,"byte_end":2031443,"line_start":666,"line_end":666,"column_start":11,"column_end":16},"name":"Octal","qualname":"::fmt::Octal","value":"Octal","parent":null,"children":[{"krate":0,"index":6829}],"decl_id":null,"docs":" `o` formatting.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2031382,"byte_end":2031427,"line_start":665,"line_end":665,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":6829},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2031556,"byte_end":2031559,"line_start":669,"line_end":669,"column_start":8,"column_end":11},"name":"fmt","qualname":"::fmt::Octal::fmt","value":"fn (&self, f: &mut Formatter<'_>) -> Result","parent":{"krate":0,"index":6828},"children":[],"decl_id":null,"docs":" Formats the value using the given formatter.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2031503,"byte_end":2031548,"line_start":668,"line_end":668,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":6830},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2032981,"byte_end":2032987,"line_start":722,"line_end":722,"column_start":11,"column_end":17},"name":"Binary","qualname":"::fmt::Binary","value":"Binary","parent":null,"children":[{"krate":0,"index":6831}],"decl_id":null,"docs":" `b` formatting.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2032925,"byte_end":2032970,"line_start":721,"line_end":721,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":6831},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2033100,"byte_end":2033103,"line_start":725,"line_end":725,"column_start":8,"column_end":11},"name":"fmt","qualname":"::fmt::Binary::fmt","value":"fn (&self, f: &mut Formatter<'_>) -> Result","parent":{"krate":0,"index":6830},"children":[],"decl_id":null,"docs":" Formats the value using the given formatter.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2033047,"byte_end":2033092,"line_start":724,"line_end":724,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":6832},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2034352,"byte_end":2034360,"line_start":775,"line_end":775,"column_start":11,"column_end":19},"name":"LowerHex","qualname":"::fmt::LowerHex","value":"LowerHex","parent":null,"children":[{"krate":0,"index":6833}],"decl_id":null,"docs":" `x` formatting.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2034296,"byte_end":2034341,"line_start":774,"line_end":774,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":6833},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2034473,"byte_end":2034476,"line_start":778,"line_end":778,"column_start":8,"column_end":11},"name":"fmt","qualname":"::fmt::LowerHex::fmt","value":"fn (&self, f: &mut Formatter<'_>) -> Result","parent":{"krate":0,"index":6832},"children":[],"decl_id":null,"docs":" Formats the value using the given formatter.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2034420,"byte_end":2034465,"line_start":777,"line_end":777,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":6834},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2035725,"byte_end":2035733,"line_start":828,"line_end":828,"column_start":11,"column_end":19},"name":"UpperHex","qualname":"::fmt::UpperHex","value":"UpperHex","parent":null,"children":[{"krate":0,"index":6835}],"decl_id":null,"docs":" `X` formatting.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2035669,"byte_end":2035714,"line_start":827,"line_end":827,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":6835},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2035846,"byte_end":2035849,"line_start":831,"line_end":831,"column_start":8,"column_end":11},"name":"fmt","qualname":"::fmt::UpperHex::fmt","value":"fn (&self, f: &mut Formatter<'_>) -> Result","parent":{"krate":0,"index":6834},"children":[],"decl_id":null,"docs":" Formats the value using the given formatter.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2035793,"byte_end":2035838,"line_start":830,"line_end":830,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":6836},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2036865,"byte_end":2036872,"line_start":873,"line_end":873,"column_start":11,"column_end":18},"name":"Pointer","qualname":"::fmt::Pointer","value":"Pointer","parent":null,"children":[{"krate":0,"index":6837}],"decl_id":null,"docs":" `p` formatting.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2036809,"byte_end":2036854,"line_start":872,"line_end":872,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":6837},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2036985,"byte_end":2036988,"line_start":876,"line_end":876,"column_start":8,"column_end":11},"name":"fmt","qualname":"::fmt::Pointer::fmt","value":"fn (&self, f: &mut Formatter<'_>) -> Result","parent":{"krate":0,"index":6836},"children":[],"decl_id":null,"docs":" Formats the value using the given formatter.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2036932,"byte_end":2036977,"line_start":875,"line_end":875,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":6838},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2037911,"byte_end":2037919,"line_start":916,"line_end":916,"column_start":11,"column_end":19},"name":"LowerExp","qualname":"::fmt::LowerExp","value":"LowerExp","parent":null,"children":[{"krate":0,"index":6839}],"decl_id":null,"docs":" `e` formatting.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2037855,"byte_end":2037900,"line_start":915,"line_end":915,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":6839},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2038032,"byte_end":2038035,"line_start":919,"line_end":919,"column_start":8,"column_end":11},"name":"fmt","qualname":"::fmt::LowerExp::fmt","value":"fn (&self, f: &mut Formatter<'_>) -> Result","parent":{"krate":0,"index":6838},"children":[],"decl_id":null,"docs":" Formats the value using the given formatter.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2037979,"byte_end":2038024,"line_start":918,"line_end":918,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":6840},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2038959,"byte_end":2038967,"line_start":959,"line_end":959,"column_start":11,"column_end":19},"name":"UpperExp","qualname":"::fmt::UpperExp","value":"UpperExp","parent":null,"children":[{"krate":0,"index":6841}],"decl_id":null,"docs":" `E` formatting.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2038903,"byte_end":2038948,"line_start":958,"line_end":958,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":6841},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2039080,"byte_end":2039083,"line_start":962,"line_end":962,"column_start":8,"column_end":11},"name":"fmt","qualname":"::fmt::UpperExp::fmt","value":"fn (&self, f: &mut Formatter<'_>) -> Result","parent":{"krate":0,"index":6840},"children":[],"decl_id":null,"docs":" Formats the value using the given formatter.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2039027,"byte_end":2039072,"line_start":961,"line_end":961,"column_start":5,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":6842},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2040079,"byte_end":2040084,"line_start":997,"line_end":997,"column_start":8,"column_end":13},"name":"write","qualname":"::fmt::write","value":"fn (output: &mut dyn Write, args: Arguments<'_>) -> Result","parent":null,"children":[],"decl_id":null,"docs":" The `write` function takes an output stream, and an `Arguments` struct\n that can be precompiled with the `format_args!` macro.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2040026,"byte_end":2040071,"line_start":996,"line_end":996,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":6857},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2045421,"byte_end":2045433,"line_start":1163,"line_end":1163,"column_start":12,"column_end":24},"name":"pad_integral","qualname":"<Formatter>::pad_integral","value":"fn (&mut self, is_nonnegative: bool, prefix: &str, buf: &str) -> Result","parent":null,"children":[],"decl_id":null,"docs":" Performs the correct padding for an integer which has already been\n emitted into a str. The str should *not* contain the sign for the\n integer, that will be added by this method.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2045364,"byte_end":2045409,"line_start":1162,"line_end":1162,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":6859},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2048917,"byte_end":2048920,"line_start":1260,"line_end":1260,"column_start":12,"column_end":15},"name":"pad","qualname":"<Formatter>::pad","value":"fn (&mut self, s: &str) -> Result","parent":null,"children":[],"decl_id":null,"docs":" This function takes a string slice and emits it to the internal buffer\n after applying the relevant formatting flags specified. The flags\n recognized for generic strings are:","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2048860,"byte_end":2048905,"line_start":1259,"line_end":1259,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":6866},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2055706,"byte_end":2055715,"line_start":1433,"line_end":1433,"column_start":12,"column_end":21},"name":"write_str","qualname":"<Formatter>::write_str","value":"fn (&mut self, data: &str) -> Result","parent":null,"children":[],"decl_id":null,"docs":" Writes some data to the underlying buffer contained within this\n formatter.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2055649,"byte_end":2055694,"line_start":1432,"line_end":1432,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":6867},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2056359,"byte_end":2056368,"line_start":1456,"line_end":1456,"column_start":12,"column_end":21},"name":"write_fmt","qualname":"<Formatter>::write_fmt","value":"fn (&mut self, fmt: Arguments<'_>) -> Result","parent":null,"children":[],"decl_id":null,"docs":" Writes some formatted information into this instance.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2056302,"byte_end":2056347,"line_start":1455,"line_end":1455,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":6868},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2056739,"byte_end":2056744,"line_start":1465,"line_end":1465,"column_start":12,"column_end":17},"name":"flags","qualname":"<Formatter>::flags","value":"fn (&self) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Flags for formatting\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2056481,"byte_end":2056526,"line_start":1461,"line_end":1461,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.24.0\",\n                   reason =\n                       \"use the `sign_plus`, `sign_minus`, `alternate`, \\\n                                 or `sign_aware_zero_pad` methods instead\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2056531,"byte_end":2056727,"line_start":1462,"line_end":1464,"column_start":5,"column_end":77}}]},{"kind":"Method","id":{"krate":0,"index":6869},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2057650,"byte_end":2057654,"line_start":1495,"line_end":1495,"column_start":12,"column_end":16},"name":"fill","qualname":"<Formatter>::fill","value":"fn (&self) -> char","parent":null,"children":[],"decl_id":null,"docs":" Character used as 'fill' whenever there is alignment.","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags\", since = \"1.5.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2057589,"byte_end":2057638,"line_start":1494,"line_end":1494,"column_start":5,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":6870},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2058794,"byte_end":2058799,"line_start":1531,"line_end":1531,"column_start":12,"column_end":17},"name":"align","qualname":"<Formatter>::align","value":"fn (&self) -> Option<Alignment>","parent":null,"children":[],"decl_id":null,"docs":" Flag indicating what form of alignment was requested.","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags_align\", since = \"1.28.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2058726,"byte_end":2058782,"line_start":1530,"line_end":1530,"column_start":5,"column_end":61}}]},{"kind":"Method","id":{"krate":0,"index":6871},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2059996,"byte_end":2060001,"line_start":1565,"line_end":1565,"column_start":12,"column_end":17},"name":"width","qualname":"<Formatter>::width","value":"fn (&self) -> Option<usize>","parent":null,"children":[],"decl_id":null,"docs":" Optionally specified integer width that the output should be.","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags\", since = \"1.5.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2059935,"byte_end":2059984,"line_start":1564,"line_end":1564,"column_start":5,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":6872},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2060909,"byte_end":2060918,"line_start":1592,"line_end":1592,"column_start":12,"column_end":21},"name":"precision","qualname":"<Formatter>::precision","value":"fn (&self) -> Option<usize>","parent":null,"children":[],"decl_id":null,"docs":" Optionally specified precision for numeric types.","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags\", since = \"1.5.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2060848,"byte_end":2060897,"line_start":1591,"line_end":1591,"column_start":5,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":6873},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2061777,"byte_end":2061786,"line_start":1620,"line_end":1620,"column_start":12,"column_end":21},"name":"sign_plus","qualname":"<Formatter>::sign_plus","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Determines if the `+` flag was specified.","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags\", since = \"1.5.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2061716,"byte_end":2061765,"line_start":1619,"line_end":1619,"column_start":5,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":6874},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2062609,"byte_end":2062619,"line_start":1646,"line_end":1646,"column_start":12,"column_end":22},"name":"sign_minus","qualname":"<Formatter>::sign_minus","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Determines if the `-` flag was specified.","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags\", since = \"1.5.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2062548,"byte_end":2062597,"line_start":1645,"line_end":1645,"column_start":5,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":6875},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2063374,"byte_end":2063383,"line_start":1671,"line_end":1671,"column_start":12,"column_end":21},"name":"alternate","qualname":"<Formatter>::alternate","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Determines if the `#` flag was specified.","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags\", since = \"1.5.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2063313,"byte_end":2063362,"line_start":1670,"line_end":1670,"column_start":5,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":6876},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2064104,"byte_end":2064123,"line_start":1694,"line_end":1694,"column_start":12,"column_end":31},"name":"sign_aware_zero_pad","qualname":"<Formatter>::sign_aware_zero_pad","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Determines if the `0` flag was specified.","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags\", since = \"1.5.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2064043,"byte_end":2064092,"line_start":1693,"line_end":1693,"column_start":5,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":6879},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2065728,"byte_end":2065740,"line_start":1742,"line_end":1742,"column_start":12,"column_end":24},"name":"debug_struct","qualname":"<Formatter>::debug_struct","value":"fn <'b> (&'b mut self, name: &str) -> DebugStruct<'b, 'a>","parent":null,"children":[],"decl_id":null,"docs":" Creates a [`DebugStruct`] builder designed to assist with creation of\n [`fmt::Debug`] implementations for structs.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2065662,"byte_end":2065716,"line_start":1741,"line_end":1741,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":6881},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2066716,"byte_end":2066727,"line_start":1773,"line_end":1773,"column_start":12,"column_end":23},"name":"debug_tuple","qualname":"<Formatter>::debug_tuple","value":"fn <'b> (&'b mut self, name: &str) -> DebugTuple<'b, 'a>","parent":null,"children":[],"decl_id":null,"docs":" Creates a `DebugTuple` builder designed to assist with creation of\n `fmt::Debug` implementations for tuple structs.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2066650,"byte_end":2066704,"line_start":1772,"line_end":1772,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":6883},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2067447,"byte_end":2067457,"line_start":1797,"line_end":1797,"column_start":12,"column_end":22},"name":"debug_list","qualname":"<Formatter>::debug_list","value":"fn <'b> (&'b mut self) -> DebugList<'b, 'a>","parent":null,"children":[],"decl_id":null,"docs":" Creates a `DebugList` builder designed to assist with creation of\n `fmt::Debug` implementations for list-like structures.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2067381,"byte_end":2067435,"line_start":1796,"line_end":1796,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":6885},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2069271,"byte_end":2069280,"line_start":1856,"line_end":1856,"column_start":12,"column_end":21},"name":"debug_set","qualname":"<Formatter>::debug_set","value":"fn <'b> (&'b mut self) -> DebugSet<'b, 'a>","parent":null,"children":[],"decl_id":null,"docs":" Creates a `DebugSet` builder designed to assist with creation of\n `fmt::Debug` implementations for set-like structures.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2069205,"byte_end":2069259,"line_start":1855,"line_end":1855,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":6887},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2070063,"byte_end":2070072,"line_start":1880,"line_end":1880,"column_start":12,"column_end":21},"name":"debug_map","qualname":"<Formatter>::debug_map","value":"fn <'b> (&'b mut self) -> DebugMap<'b, 'a>","parent":null,"children":[],"decl_id":null,"docs":" Creates a `DebugMap` builder designed to assist with creation of\n `fmt::Debug` implementations for map-like structures.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2069997,"byte_end":2070051,"line_start":1879,"line_end":1879,"column_start":5,"column_end":59}}]},{"kind":"Mod","id":{"krate":0,"index":6961},"span":{"file_name":"src/libcore/time.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"time","qualname":"::time","value":"src/libcore/time.rs","parent":null,"children":[{"krate":0,"index":6962},{"krate":0,"index":6965},{"krate":0,"index":6966},{"krate":0,"index":6975},{"krate":0,"index":6976},{"krate":0,"index":6977},{"krate":0,"index":6978},{"krate":0,"index":6979},{"krate":0,"index":34837},{"krate":0,"index":34863},{"krate":0,"index":34862},{"krate":0,"index":34859},{"krate":0,"index":34857},{"krate":0,"index":34847},{"krate":0,"index":34845},{"krate":0,"index":34842},{"krate":0,"index":34840},{"krate":0,"index":6980},{"krate":0,"index":7010},{"krate":0,"index":7013},{"krate":0,"index":7015},{"krate":0,"index":7018},{"krate":0,"index":7020},{"krate":0,"index":7023},{"krate":0,"index":7026},{"krate":0,"index":7028},{"krate":0,"index":7031},{"krate":0,"index":7033},{"krate":0,"index":7034},{"krate":0,"index":7037},{"krate":0,"index":7041}],"decl_id":null,"docs":" Temporal quantification.","sig":null,"attributes":[{"value":"stable(feature = \"duration_core\", since = \"1.25.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2118805,"byte_end":2118860,"line_start":1,"line_end":1,"column_start":1,"column_end":56}}]},{"kind":"Struct","id":{"krate":0,"index":34837},"span":{"file_name":"src/libcore/time.rs","byte_start":2120528,"byte_end":2120536,"line_start":55,"line_end":55,"column_start":12,"column_end":20},"name":"Duration","qualname":"::time::Duration","value":"Duration {  }","parent":null,"children":[{"krate":0,"index":34838},{"krate":0,"index":34839}],"decl_id":null,"docs":" A `Duration` type to represent a span of time, typically used for system\n timeouts.","sig":null,"attributes":[{"value":"stable(feature = \"duration\", since = \"1.3.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2120398,"byte_end":2120446,"line_start":53,"line_end":53,"column_start":1,"column_end":49}},{"value":"structural_match","span":{"file_name":"src/libcore/time.rs","byte_start":2120517,"byte_end":2120608,"line_start":55,"line_end":58,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/time.rs","byte_start":2120517,"byte_end":2120608,"line_start":55,"line_end":58,"column_start":1,"column_end":2}}]},{"kind":"Const","id":{"krate":0,"index":6981},"span":{"file_name":"src/libcore/time.rs","byte_start":2120943,"byte_end":2120949,"line_start":72,"line_end":72,"column_start":15,"column_end":21},"name":"SECOND","qualname":"::time::Duration::SECOND","value":"Duration","parent":{"krate":0,"index":6980},"children":[],"decl_id":null,"docs":" The duration of one second.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_constants\", issue = \"57391\")","span":{"file_name":"src/libcore/time.rs","byte_start":2120868,"byte_end":2120928,"line_start":71,"line_end":71,"column_start":5,"column_end":65}}]},{"kind":"Const","id":{"krate":0,"index":6982},"span":{"file_name":"src/libcore/time.rs","byte_start":2121316,"byte_end":2121327,"line_start":85,"line_end":85,"column_start":15,"column_end":26},"name":"MILLISECOND","qualname":"::time::Duration::MILLISECOND","value":"Duration","parent":{"krate":0,"index":6980},"children":[],"decl_id":null,"docs":" The duration of one millisecond.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_constants\", issue = \"57391\")","span":{"file_name":"src/libcore/time.rs","byte_start":2121241,"byte_end":2121301,"line_start":84,"line_end":84,"column_start":5,"column_end":65}}]},{"kind":"Const","id":{"krate":0,"index":6983},"span":{"file_name":"src/libcore/time.rs","byte_start":2121696,"byte_end":2121707,"line_start":98,"line_end":98,"column_start":15,"column_end":26},"name":"MICROSECOND","qualname":"::time::Duration::MICROSECOND","value":"Duration","parent":{"krate":0,"index":6980},"children":[],"decl_id":null,"docs":" The duration of one microsecond.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_constants\", issue = \"57391\")","span":{"file_name":"src/libcore/time.rs","byte_start":2121621,"byte_end":2121681,"line_start":97,"line_end":97,"column_start":5,"column_end":65}}]},{"kind":"Const","id":{"krate":0,"index":6984},"span":{"file_name":"src/libcore/time.rs","byte_start":2122073,"byte_end":2122083,"line_start":111,"line_end":111,"column_start":15,"column_end":25},"name":"NANOSECOND","qualname":"::time::Duration::NANOSECOND","value":"Duration","parent":{"krate":0,"index":6980},"children":[],"decl_id":null,"docs":" The duration of one nanosecond.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_constants\", issue = \"57391\")","span":{"file_name":"src/libcore/time.rs","byte_start":2121998,"byte_end":2122058,"line_start":110,"line_end":110,"column_start":5,"column_end":65}}]},{"kind":"Method","id":{"krate":0,"index":6985},"span":{"file_name":"src/libcore/time.rs","byte_start":2122773,"byte_end":2122776,"line_start":133,"line_end":133,"column_start":12,"column_end":15},"name":"new","qualname":"<Duration>::new","value":"fn (secs: u64, nanos: u32) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Duration` from the specified number of whole seconds and\n additional nanoseconds.","sig":null,"attributes":[{"value":"stable(feature = \"duration\", since = \"1.3.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2122699,"byte_end":2122747,"line_start":131,"line_end":131,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2122752,"byte_end":2122761,"line_start":132,"line_end":132,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":37151},"span":{"file_name":"src/libcore/time.rs","byte_start":2123446,"byte_end":2123455,"line_start":155,"line_end":155,"column_start":18,"column_end":27},"name":"from_secs","qualname":"<Duration>::from_secs","value":"fn (secs: u64) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Duration` from the specified number of whole seconds.","sig":null,"attributes":[{"value":"stable(feature = \"duration\", since = \"1.3.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2123342,"byte_end":2123390,"line_start":152,"line_end":152,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2123395,"byte_end":2123404,"line_start":153,"line_end":153,"column_start":5,"column_end":14}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/time.rs","byte_start":2123409,"byte_end":2123428,"line_start":154,"line_end":154,"column_start":5,"column_end":24}}]},{"kind":"Method","id":{"krate":0,"index":37150},"span":{"file_name":"src/libcore/time.rs","byte_start":2123969,"byte_end":2123980,"line_start":174,"line_end":174,"column_start":18,"column_end":29},"name":"from_millis","qualname":"<Duration>::from_millis","value":"fn (millis: u64) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Duration` from the specified number of milliseconds.","sig":null,"attributes":[{"value":"stable(feature = \"duration\", since = \"1.3.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2123865,"byte_end":2123913,"line_start":171,"line_end":171,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2123918,"byte_end":2123927,"line_start":172,"line_end":172,"column_start":5,"column_end":14}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/time.rs","byte_start":2123932,"byte_end":2123951,"line_start":173,"line_end":173,"column_start":5,"column_end":24}}]},{"kind":"Method","id":{"krate":0,"index":37149},"span":{"file_name":"src/libcore/time.rs","byte_start":2124616,"byte_end":2124627,"line_start":196,"line_end":196,"column_start":18,"column_end":29},"name":"from_micros","qualname":"<Duration>::from_micros","value":"fn (micros: u64) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Duration` from the specified number of microseconds.","sig":null,"attributes":[{"value":"stable(feature = \"duration_from_micros\", since = \"1.27.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2124499,"byte_end":2124560,"line_start":193,"line_end":193,"column_start":5,"column_end":66}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2124565,"byte_end":2124574,"line_start":194,"line_end":194,"column_start":5,"column_end":14}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/time.rs","byte_start":2124579,"byte_end":2124598,"line_start":195,"line_end":195,"column_start":5,"column_end":24}}]},{"kind":"Method","id":{"krate":0,"index":37148},"span":{"file_name":"src/libcore/time.rs","byte_start":2125259,"byte_end":2125269,"line_start":218,"line_end":218,"column_start":18,"column_end":28},"name":"from_nanos","qualname":"<Duration>::from_nanos","value":"fn (nanos: u64) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Duration` from the specified number of nanoseconds.","sig":null,"attributes":[{"value":"stable(feature = \"duration_extras\", since = \"1.27.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2125147,"byte_end":2125203,"line_start":215,"line_end":215,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2125208,"byte_end":2125217,"line_start":216,"line_end":216,"column_start":5,"column_end":14}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/time.rs","byte_start":2125222,"byte_end":2125241,"line_start":217,"line_end":217,"column_start":5,"column_end":24}}]},{"kind":"Method","id":{"krate":0,"index":6986},"span":{"file_name":"src/libcore/time.rs","byte_start":2126427,"byte_end":2126434,"line_start":255,"line_end":255,"column_start":18,"column_end":25},"name":"as_secs","qualname":"<Duration>::as_secs","value":"fn (&self) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Returns the number of _whole_ seconds contained by this `Duration`.","sig":null,"attributes":[{"value":"stable(feature = \"duration\", since = \"1.3.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2126347,"byte_end":2126395,"line_start":253,"line_end":253,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2126400,"byte_end":2126409,"line_start":254,"line_end":254,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6987},"span":{"file_name":"src/libcore/time.rs","byte_start":2127115,"byte_end":2127128,"line_start":274,"line_end":274,"column_start":18,"column_end":31},"name":"subsec_millis","qualname":"<Duration>::subsec_millis","value":"fn (&self) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Returns the fractional part of this `Duration`, in whole milliseconds.","sig":null,"attributes":[{"value":"stable(feature = \"duration_extras\", since = \"1.27.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2127027,"byte_end":2127083,"line_start":272,"line_end":272,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2127088,"byte_end":2127097,"line_start":273,"line_end":273,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6988},"span":{"file_name":"src/libcore/time.rs","byte_start":2127836,"byte_end":2127849,"line_start":293,"line_end":293,"column_start":18,"column_end":31},"name":"subsec_micros","qualname":"<Duration>::subsec_micros","value":"fn (&self) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Returns the fractional part of this `Duration`, in whole microseconds.","sig":null,"attributes":[{"value":"stable(feature = \"duration_extras\", since = \"1.27.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2127748,"byte_end":2127804,"line_start":291,"line_end":291,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2127809,"byte_end":2127818,"line_start":292,"line_end":292,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6989},"span":{"file_name":"src/libcore/time.rs","byte_start":2128538,"byte_end":2128550,"line_start":312,"line_end":312,"column_start":18,"column_end":30},"name":"subsec_nanos","qualname":"<Duration>::subsec_nanos","value":"fn (&self) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Returns the fractional part of this `Duration`, in nanoseconds.","sig":null,"attributes":[{"value":"stable(feature = \"duration\", since = \"1.3.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2128458,"byte_end":2128506,"line_start":310,"line_end":310,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2128511,"byte_end":2128520,"line_start":311,"line_end":311,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6990},"span":{"file_name":"src/libcore/time.rs","byte_start":2128959,"byte_end":2128968,"line_start":326,"line_end":326,"column_start":18,"column_end":27},"name":"as_millis","qualname":"<Duration>::as_millis","value":"fn (&self) -> u128","parent":null,"children":[],"decl_id":null,"docs":" Returns the total number of whole milliseconds contained by this `Duration`.","sig":null,"attributes":[{"value":"stable(feature = \"duration_as_u128\", since = \"1.33.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2128870,"byte_end":2128927,"line_start":324,"line_end":324,"column_start":5,"column_end":62}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2128932,"byte_end":2128941,"line_start":325,"line_end":325,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6991},"span":{"file_name":"src/libcore/time.rs","byte_start":2129466,"byte_end":2129475,"line_start":342,"line_end":342,"column_start":18,"column_end":27},"name":"as_micros","qualname":"<Duration>::as_micros","value":"fn (&self) -> u128","parent":null,"children":[],"decl_id":null,"docs":" Returns the total number of whole microseconds contained by this `Duration`.","sig":null,"attributes":[{"value":"stable(feature = \"duration_as_u128\", since = \"1.33.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2129377,"byte_end":2129434,"line_start":340,"line_end":340,"column_start":5,"column_end":62}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2129439,"byte_end":2129448,"line_start":341,"line_end":341,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6992},"span":{"file_name":"src/libcore/time.rs","byte_start":2129968,"byte_end":2129976,"line_start":358,"line_end":358,"column_start":18,"column_end":26},"name":"as_nanos","qualname":"<Duration>::as_nanos","value":"fn (&self) -> u128","parent":null,"children":[],"decl_id":null,"docs":" Returns the total number of nanoseconds contained by this `Duration`.","sig":null,"attributes":[{"value":"stable(feature = \"duration_as_u128\", since = \"1.33.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2129879,"byte_end":2129936,"line_start":356,"line_end":356,"column_start":5,"column_end":62}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2129941,"byte_end":2129950,"line_start":357,"line_end":357,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6993},"span":{"file_name":"src/libcore/time.rs","byte_start":2130669,"byte_end":2130680,"line_start":379,"line_end":379,"column_start":12,"column_end":23},"name":"checked_add","qualname":"<Duration>::checked_add","value":"fn (self, rhs: Duration) -> Option<Duration>","parent":null,"children":[],"decl_id":null,"docs":" Checked `Duration` addition. Computes `self + other`, returning [`None`]\n if overflow occurred.","sig":null,"attributes":[{"value":"stable(feature = \"duration_checked_ops\", since = \"1.16.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2130582,"byte_end":2130643,"line_start":377,"line_end":377,"column_start":5,"column_end":66}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2130648,"byte_end":2130657,"line_start":378,"line_end":378,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6994},"span":{"file_name":"src/libcore/time.rs","byte_start":2131923,"byte_end":2131934,"line_start":417,"line_end":417,"column_start":12,"column_end":23},"name":"checked_sub","qualname":"<Duration>::checked_sub","value":"fn (self, rhs: Duration) -> Option<Duration>","parent":null,"children":[],"decl_id":null,"docs":" Checked `Duration` subtraction. Computes `self - other`, returning [`None`]\n if the result would be negative or if overflow occurred.","sig":null,"attributes":[{"value":"stable(feature = \"duration_checked_ops\", since = \"1.16.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2131836,"byte_end":2131897,"line_start":415,"line_end":415,"column_start":5,"column_end":66}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2131902,"byte_end":2131911,"line_start":416,"line_end":416,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6995},"span":{"file_name":"src/libcore/time.rs","byte_start":2133131,"byte_end":2133142,"line_start":453,"line_end":453,"column_start":12,"column_end":23},"name":"checked_mul","qualname":"<Duration>::checked_mul","value":"fn (self, rhs: u32) -> Option<Duration>","parent":null,"children":[],"decl_id":null,"docs":" Checked `Duration` multiplication. Computes `self * other`, returning\n [`None`] if overflow occurred.","sig":null,"attributes":[{"value":"stable(feature = \"duration_checked_ops\", since = \"1.16.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2133044,"byte_end":2133105,"line_start":451,"line_end":451,"column_start":5,"column_end":66}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2133110,"byte_end":2133119,"line_start":452,"line_end":452,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6997},"span":{"file_name":"src/libcore/time.rs","byte_start":2134402,"byte_end":2134413,"line_start":489,"line_end":489,"column_start":12,"column_end":23},"name":"checked_div","qualname":"<Duration>::checked_div","value":"fn (self, rhs: u32) -> Option<Duration>","parent":null,"children":[],"decl_id":null,"docs":" Checked `Duration` division. Computes `self / other`, returning [`None`]\n if `other == 0`.","sig":null,"attributes":[{"value":"stable(feature = \"duration_checked_ops\", since = \"1.16.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2134315,"byte_end":2134376,"line_start":487,"line_end":487,"column_start":5,"column_end":66}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2134381,"byte_end":2134390,"line_start":488,"line_end":488,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6998},"span":{"file_name":"src/libcore/time.rs","byte_start":2135354,"byte_end":2135365,"line_start":516,"line_end":516,"column_start":18,"column_end":29},"name":"as_secs_f64","qualname":"<Duration>::as_secs_f64","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the number of seconds contained by this `Duration` as `f64`.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_float\", issue = \"54361\")","span":{"file_name":"src/libcore/time.rs","byte_start":2135266,"byte_end":2135322,"line_start":514,"line_end":514,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2135327,"byte_end":2135336,"line_start":515,"line_end":515,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6999},"span":{"file_name":"src/libcore/time.rs","byte_start":2135951,"byte_end":2135962,"line_start":534,"line_end":534,"column_start":18,"column_end":29},"name":"as_secs_f32","qualname":"<Duration>::as_secs_f32","value":"fn (&self) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the number of seconds contained by this `Duration` as `f32`.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_float\", issue = \"54361\")","span":{"file_name":"src/libcore/time.rs","byte_start":2135863,"byte_end":2135919,"line_start":532,"line_end":532,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2135924,"byte_end":2135933,"line_start":533,"line_end":533,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7000},"span":{"file_name":"src/libcore/time.rs","byte_start":2136598,"byte_end":2136611,"line_start":554,"line_end":554,"column_start":12,"column_end":25},"name":"from_secs_f64","qualname":"<Duration>::from_secs_f64","value":"fn (secs: f64) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Duration` from the specified number of seconds represented\n as `f64`.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_float\", issue = \"54361\")","span":{"file_name":"src/libcore/time.rs","byte_start":2136516,"byte_end":2136572,"line_start":552,"line_end":552,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2136577,"byte_end":2136586,"line_start":553,"line_end":553,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7002},"span":{"file_name":"src/libcore/time.rs","byte_start":2137858,"byte_end":2137871,"line_start":590,"line_end":590,"column_start":12,"column_end":25},"name":"from_secs_f32","qualname":"<Duration>::from_secs_f32","value":"fn (secs: f32) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Duration` from the specified number of seconds represented\n as `f32`.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_float\", issue = \"54361\")","span":{"file_name":"src/libcore/time.rs","byte_start":2137776,"byte_end":2137832,"line_start":588,"line_end":588,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2137837,"byte_end":2137846,"line_start":589,"line_end":589,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7004},"span":{"file_name":"src/libcore/time.rs","byte_start":2139136,"byte_end":2139143,"line_start":626,"line_end":626,"column_start":12,"column_end":19},"name":"mul_f64","qualname":"<Duration>::mul_f64","value":"fn (self, rhs: f64) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Multiplies `Duration` by `f64`.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_float\", issue = \"54361\")","span":{"file_name":"src/libcore/time.rs","byte_start":2139054,"byte_end":2139110,"line_start":624,"line_end":624,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2139115,"byte_end":2139124,"line_start":625,"line_end":625,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7005},"span":{"file_name":"src/libcore/time.rs","byte_start":2139912,"byte_end":2139919,"line_start":648,"line_end":648,"column_start":12,"column_end":19},"name":"mul_f32","qualname":"<Duration>::mul_f32","value":"fn (self, rhs: f32) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Multiplies `Duration` by `f32`.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_float\", issue = \"54361\")","span":{"file_name":"src/libcore/time.rs","byte_start":2139830,"byte_end":2139886,"line_start":646,"line_end":646,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2139891,"byte_end":2139900,"line_start":647,"line_end":647,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7006},"span":{"file_name":"src/libcore/time.rs","byte_start":2140619,"byte_end":2140626,"line_start":669,"line_end":669,"column_start":12,"column_end":19},"name":"div_f64","qualname":"<Duration>::div_f64","value":"fn (self, rhs: f64) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Divide `Duration` by `f64`.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_float\", issue = \"54361\")","span":{"file_name":"src/libcore/time.rs","byte_start":2140537,"byte_end":2140593,"line_start":667,"line_end":667,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2140598,"byte_end":2140607,"line_start":668,"line_end":668,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7007},"span":{"file_name":"src/libcore/time.rs","byte_start":2141429,"byte_end":2141436,"line_start":692,"line_end":692,"column_start":12,"column_end":19},"name":"div_f32","qualname":"<Duration>::div_f32","value":"fn (self, rhs: f32) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Divide `Duration` by `f32`.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_float\", issue = \"54361\")","span":{"file_name":"src/libcore/time.rs","byte_start":2141347,"byte_end":2141403,"line_start":690,"line_end":690,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2141408,"byte_end":2141417,"line_start":691,"line_end":691,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7008},"span":{"file_name":"src/libcore/time.rs","byte_start":2141958,"byte_end":2141974,"line_start":709,"line_end":709,"column_start":12,"column_end":28},"name":"div_duration_f64","qualname":"<Duration>::div_duration_f64","value":"fn (self, rhs: Duration) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Divide `Duration` by `Duration` and return `f64`.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_float\", issue = \"54361\")","span":{"file_name":"src/libcore/time.rs","byte_start":2141876,"byte_end":2141932,"line_start":707,"line_end":707,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2141937,"byte_end":2141946,"line_start":708,"line_end":708,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7009},"span":{"file_name":"src/libcore/time.rs","byte_start":2142485,"byte_end":2142501,"line_start":726,"line_end":726,"column_start":12,"column_end":28},"name":"div_duration_f32","qualname":"<Duration>::div_duration_f32","value":"fn (self, rhs: Duration) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Divide `Duration` by `Duration` and return `f32`.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_float\", issue = \"54361\")","span":{"file_name":"src/libcore/time.rs","byte_start":2142403,"byte_end":2142459,"line_start":724,"line_end":724,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2142464,"byte_end":2142473,"line_start":725,"line_end":725,"column_start":5,"column_end":14}}]},{"kind":"Mod","id":{"krate":0,"index":7046},"span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"unicode","qualname":"::unicode","value":"src/libcore/unicode/mod.rs","parent":null,"children":[{"krate":0,"index":7047},{"krate":0,"index":7066},{"krate":0,"index":7075},{"krate":0,"index":7120},{"krate":0,"index":7121},{"krate":0,"index":7125},{"krate":0,"index":7129}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"unicode_internals\", issue = \"0\")","span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":2151034,"byte_end":2151090,"line_start":1,"line_end":1,"column_start":1,"column_end":57}},{"value":"allow(missing_docs)","span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":2151091,"byte_end":2151114,"line_start":2,"line_end":2,"column_start":1,"column_end":24}}]},{"kind":"Struct","id":{"krate":0,"index":7048},"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2152728,"byte_end":2152736,"line_start":20,"line_end":20,"column_start":12,"column_end":20},"name":"BoolTrie","qualname":"::unicode::bool_trie::BoolTrie","value":"BoolTrie { r1, r2, r3, r4, r5, r6 }","parent":null,"children":[{"krate":0,"index":7049},{"krate":0,"index":7051},{"krate":0,"index":7053},{"krate":0,"index":7054},{"krate":0,"index":7056},{"krate":0,"index":7057}],"decl_id":null,"docs":" BoolTrie is a trie for representing a set of Unicode codepoints. It is\n implemented with postfix compression (sharing of identical child nodes),\n which gives both compact size and fast lookup.","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":7049},"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2152811,"byte_end":2152813,"line_start":22,"line_end":22,"column_start":9,"column_end":11},"name":"r1","qualname":"::unicode::bool_trie::BoolTrie::r1","value":"[u64; _]","parent":{"krate":0,"index":7048},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":7051},"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2152911,"byte_end":2152913,"line_start":25,"line_end":25,"column_start":9,"column_end":11},"name":"r2","qualname":"::unicode::bool_trie::BoolTrie::r2","value":"[u8; _]","parent":{"krate":0,"index":7048},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":7053},"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2152954,"byte_end":2152956,"line_start":26,"line_end":26,"column_start":9,"column_end":11},"name":"r3","qualname":"::unicode::bool_trie::BoolTrie::r3","value":"&'static [u64]","parent":{"krate":0,"index":7048},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":7054},"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2153061,"byte_end":2153063,"line_start":29,"line_end":29,"column_start":9,"column_end":11},"name":"r4","qualname":"::unicode::bool_trie::BoolTrie::r4","value":"[u8; _]","parent":{"krate":0,"index":7048},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":7056},"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2153105,"byte_end":2153107,"line_start":30,"line_end":30,"column_start":9,"column_end":11},"name":"r5","qualname":"::unicode::bool_trie::BoolTrie::r5","value":"&'static [u8]","parent":{"krate":0,"index":7048},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":7057},"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2153150,"byte_end":2153152,"line_start":31,"line_end":31,"column_start":9,"column_end":11},"name":"r6","qualname":"::unicode::bool_trie::BoolTrie::r6","value":"&'static [u64]","parent":{"krate":0,"index":7048},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7059},"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2153210,"byte_end":2153216,"line_start":34,"line_end":34,"column_start":12,"column_end":18},"name":"lookup","qualname":"<BoolTrie>::lookup","value":"fn (&self, c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":7060},"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2153746,"byte_end":2153759,"line_start":49,"line_end":49,"column_start":12,"column_end":25},"name":"SmallBoolTrie","qualname":"::unicode::bool_trie::SmallBoolTrie","value":"SmallBoolTrie {  }","parent":null,"children":[{"krate":0,"index":7061},{"krate":0,"index":7062}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7064},"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2153893,"byte_end":2153899,"line_start":55,"line_end":55,"column_start":12,"column_end":18},"name":"lookup","qualname":"<SmallBoolTrie>::lookup","value":"fn (&self, c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":7080},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2166327,"byte_end":2166342,"line_start":11,"line_end":11,"column_start":11,"column_end":26},"name":"UNICODE_VERSION","qualname":"::unicode::tables::UNICODE_VERSION","value":"UnicodeVersion","parent":null,"children":[],"decl_id":null,"docs":" The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n `char` and `str` methods are based on.\n","sig":null,"attributes":[{"value":"unstable(feature = \"unicode_version\", issue = \"49726\")","span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2166259,"byte_end":2166316,"line_start":10,"line_end":10,"column_start":1,"column_end":58}}]},{"kind":"Mod","id":{"krate":0,"index":7081},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2166447,"byte_end":2166463,"line_start":17,"line_end":17,"column_start":9,"column_end":25},"name":"general_category","qualname":"::unicode::tables::general_category","value":"src/libcore/unicode/tables.rs","parent":null,"children":[{"krate":0,"index":7082},{"krate":0,"index":7083},{"krate":0,"index":7084},{"krate":0,"index":7085}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":7082},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2166480,"byte_end":2166488,"line_start":18,"line_end":18,"column_start":15,"column_end":23},"name":"Cc_table","qualname":"::unicode::tables::general_category::Cc_table","value":"&super::SmallBoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":7083},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2166680,"byte_end":2166682,"line_start":27,"line_end":27,"column_start":12,"column_end":14},"name":"Cc","qualname":"::unicode::tables::general_category::Cc","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":7084},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2166750,"byte_end":2166757,"line_start":31,"line_end":31,"column_start":15,"column_end":22},"name":"N_table","qualname":"::unicode::tables::general_category::N_table","value":"&super::BoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":7085},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2175569,"byte_end":2175570,"line_start":136,"line_end":136,"column_start":12,"column_end":13},"name":"N","qualname":"::unicode::tables::general_category::N","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":7086},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2175634,"byte_end":2175650,"line_start":142,"line_end":142,"column_start":9,"column_end":25},"name":"derived_property","qualname":"::unicode::tables::derived_property","value":"src/libcore/unicode/tables.rs","parent":null,"children":[{"krate":0,"index":7087},{"krate":0,"index":7088},{"krate":0,"index":7089},{"krate":0,"index":7090},{"krate":0,"index":7091},{"krate":0,"index":7092},{"krate":0,"index":7093},{"krate":0,"index":7094},{"krate":0,"index":7095},{"krate":0,"index":7096},{"krate":0,"index":7097},{"krate":0,"index":7098},{"krate":0,"index":7099},{"krate":0,"index":7100},{"krate":0,"index":7101},{"krate":0,"index":7102}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":7087},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2175667,"byte_end":2175683,"line_start":143,"line_end":143,"column_start":15,"column_end":31},"name":"Alphabetic_table","qualname":"::unicode::tables::derived_property::Alphabetic_table","value":"&super::BoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":7088},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2191592,"byte_end":2191602,"line_start":322,"line_end":322,"column_start":12,"column_end":22},"name":"Alphabetic","qualname":"::unicode::tables::derived_property::Alphabetic","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":7089},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2191678,"byte_end":2191698,"line_start":326,"line_end":326,"column_start":15,"column_end":35},"name":"Case_Ignorable_table","qualname":"::unicode::tables::derived_property::Case_Ignorable_table","value":"&super::BoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":7090},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2202742,"byte_end":2202756,"line_start":456,"line_end":456,"column_start":12,"column_end":26},"name":"Case_Ignorable","qualname":"::unicode::tables::derived_property::Case_Ignorable","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":7091},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2202836,"byte_end":2202847,"line_start":460,"line_end":460,"column_start":15,"column_end":26},"name":"Cased_table","qualname":"::unicode::tables::derived_property::Cased_table","value":"&super::BoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":7092},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2210858,"byte_end":2210863,"line_start":557,"line_end":557,"column_start":12,"column_end":17},"name":"Cased","qualname":"::unicode::tables::derived_property::Cased","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":7093},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2210934,"byte_end":2210955,"line_start":561,"line_end":561,"column_start":15,"column_end":36},"name":"Grapheme_Extend_table","qualname":"::unicode::tables::derived_property::Grapheme_Extend_table","value":"&super::BoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":7094},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2221022,"byte_end":2221037,"line_start":680,"line_end":680,"column_start":12,"column_end":27},"name":"Grapheme_Extend","qualname":"::unicode::tables::derived_property::Grapheme_Extend","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":7095},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2221118,"byte_end":2221133,"line_start":684,"line_end":684,"column_start":15,"column_end":30},"name":"Lowercase_table","qualname":"::unicode::tables::derived_property::Lowercase_table","value":"&super::BoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":7096},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2228983,"byte_end":2228992,"line_start":780,"line_end":780,"column_start":12,"column_end":21},"name":"Lowercase","qualname":"::unicode::tables::derived_property::Lowercase","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":7097},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2229067,"byte_end":2229082,"line_start":784,"line_end":784,"column_start":15,"column_end":30},"name":"Uppercase_table","qualname":"::unicode::tables::derived_property::Uppercase_table","value":"&super::BoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":7098},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2237051,"byte_end":2237060,"line_start":881,"line_end":881,"column_start":12,"column_end":21},"name":"Uppercase","qualname":"::unicode::tables::derived_property::Uppercase","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":7099},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2237135,"byte_end":2237153,"line_start":885,"line_end":885,"column_start":15,"column_end":33},"name":"XID_Continue_table","qualname":"::unicode::tables::derived_property::XID_Continue_table","value":"&super::BoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":7100},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2252410,"byte_end":2252422,"line_start":1058,"line_end":1058,"column_start":12,"column_end":24},"name":"XID_Continue","qualname":"::unicode::tables::derived_property::XID_Continue","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":7101},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2252500,"byte_end":2252515,"line_start":1062,"line_end":1062,"column_start":15,"column_end":30},"name":"XID_Start_table","qualname":"::unicode::tables::derived_property::XID_Start_table","value":"&super::BoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":7102},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2267867,"byte_end":2267876,"line_start":1236,"line_end":1236,"column_start":12,"column_end":21},"name":"XID_Start","qualname":"::unicode::tables::derived_property::XID_Start","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":7103},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2267948,"byte_end":2267956,"line_start":1242,"line_end":1242,"column_start":9,"column_end":17},"name":"property","qualname":"::unicode::tables::property","value":"src/libcore/unicode/tables.rs","parent":null,"children":[{"krate":0,"index":7104},{"krate":0,"index":7105},{"krate":0,"index":7106},{"krate":0,"index":7107}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":7104},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2267973,"byte_end":2267998,"line_start":1243,"line_end":1243,"column_start":15,"column_end":40},"name":"Pattern_White_Space_table","qualname":"::unicode::tables::property::Pattern_White_Space_table","value":"&super::SmallBoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":7105},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2268656,"byte_end":2268675,"line_start":1256,"line_end":1256,"column_start":12,"column_end":31},"name":"Pattern_White_Space","qualname":"::unicode::tables::property::Pattern_White_Space","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":7106},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2268760,"byte_end":2268777,"line_start":1260,"line_end":1260,"column_start":15,"column_end":32},"name":"White_Space_table","qualname":"::unicode::tables::property::White_Space_table","value":"&super::SmallBoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":7107},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2269703,"byte_end":2269714,"line_start":1276,"line_end":1276,"column_start":12,"column_end":23},"name":"White_Space","qualname":"::unicode::tables::property::White_Space","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":7108},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2269788,"byte_end":2269799,"line_start":1282,"line_end":1282,"column_start":9,"column_end":20},"name":"conversions","qualname":"::unicode::tables::conversions","value":"src/libcore/unicode/tables.rs","parent":null,"children":[{"krate":0,"index":7109},{"krate":0,"index":7111},{"krate":0,"index":7113},{"krate":0,"index":7116},{"krate":0,"index":7118}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":7109},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2269813,"byte_end":2269821,"line_start":1283,"line_end":1283,"column_start":12,"column_end":20},"name":"to_lower","qualname":"::unicode::tables::conversions::to_lower","value":"fn (c: char) -> [char; 3]","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":7111},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2270032,"byte_end":2270040,"line_start":1290,"line_end":1290,"column_start":12,"column_end":20},"name":"to_upper","qualname":"::unicode::tables::conversions::to_upper","value":"fn (c: char) -> [char; 3]","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":34865},"span":{"file_name":"src/libcore/unicode/version.rs","byte_start":2394562,"byte_end":2394576,"line_start":6,"line_end":6,"column_start":12,"column_end":26},"name":"UnicodeVersion","qualname":"::unicode::version::UnicodeVersion","value":"UnicodeVersion { major, minor, micro }","parent":null,"children":[{"krate":0,"index":34866},{"krate":0,"index":34867},{"krate":0,"index":34868},{"krate":0,"index":34869}],"decl_id":null,"docs":" Represents a Unicode Version.","sig":null,"attributes":[{"value":"unstable(feature = \"unicode_version\", issue = \"49726\")","span":{"file_name":"src/libcore/unicode/version.rs","byte_start":2394493,"byte_end":2394550,"line_start":5,"line_end":5,"column_start":1,"column_end":58}},{"value":"structural_match","span":{"file_name":"src/libcore/unicode/version.rs","byte_start":2394551,"byte_end":2394798,"line_start":6,"line_end":18,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/unicode/version.rs","byte_start":2394551,"byte_end":2394798,"line_start":6,"line_end":18,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":34866},"span":{"file_name":"src/libcore/unicode/version.rs","byte_start":2394610,"byte_end":2394615,"line_start":8,"line_end":8,"column_start":9,"column_end":14},"name":"major","qualname":"::unicode::version::UnicodeVersion::major","value":"u32","parent":{"krate":0,"index":34865},"children":[],"decl_id":null,"docs":" Major version.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":34867},"span":{"file_name":"src/libcore/unicode/version.rs","byte_start":2394654,"byte_end":2394659,"line_start":11,"line_end":11,"column_start":9,"column_end":14},"name":"minor","qualname":"::unicode::version::UnicodeVersion::minor","value":"u32","parent":{"krate":0,"index":34865},"children":[],"decl_id":null,"docs":" Minor version.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":34868},"span":{"file_name":"src/libcore/unicode/version.rs","byte_start":2394710,"byte_end":2394715,"line_start":14,"line_end":14,"column_start":9,"column_end":14},"name":"micro","qualname":"::unicode::version::UnicodeVersion::micro","value":"u32","parent":{"krate":0,"index":34865},"children":[],"decl_id":null,"docs":" Micro (or Update) version.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":7121},"span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":2151264,"byte_end":2151280,"line_start":10,"line_end":10,"column_start":9,"column_end":25},"name":"derived_property","qualname":"::unicode::derived_property","value":"src/libcore/unicode/mod.rs","parent":null,"children":[{"krate":0,"index":7122}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":7125},"span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":2151372,"byte_end":2151383,"line_start":13,"line_end":13,"column_start":9,"column_end":20},"name":"conversions","qualname":"::unicode::conversions","value":"src/libcore/unicode/mod.rs","parent":null,"children":[{"krate":0,"index":7126}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":7129},"span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":2151492,"byte_end":2151500,"line_start":18,"line_end":18,"column_start":9,"column_end":17},"name":"property","qualname":"::unicode::property","value":"src/libcore/unicode/mod.rs","parent":null,"children":[{"krate":0,"index":7130}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":7131},"span":{"file_name":"src/libcore/future/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"future","qualname":"::future","value":"src/libcore/future/mod.rs","parent":null,"children":[{"krate":0,"index":7132},{"krate":0,"index":7150}],"decl_id":null,"docs":" Asynchronous values.\n","sig":null,"attributes":[{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/future/mod.rs","byte_start":2394800,"byte_end":2394853,"line_start":1,"line_end":1,"column_start":1,"column_end":54}}]},{"kind":"Trait","id":{"krate":0,"index":7139},"span":{"file_name":"src/libcore/future/future.rs","byte_start":2396144,"byte_end":2396150,"line_start":29,"line_end":29,"column_start":11,"column_end":17},"name":"Future","qualname":"::future::future::Future","value":"Future","parent":null,"children":[{"krate":0,"index":7140},{"krate":0,"index":7141}],"decl_id":null,"docs":" A future represents an asynchronous computation.","sig":null,"attributes":[{"value":"must_use = \"futures do nothing unless you `.await` or poll them\"","span":{"file_name":"src/libcore/future/future.rs","byte_start":2395962,"byte_end":2396029,"line_start":26,"line_end":26,"column_start":1,"column_end":68}},{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/future/future.rs","byte_start":2396030,"byte_end":2396082,"line_start":27,"line_end":27,"column_start":1,"column_end":53}},{"value":"lang = \"future_trait\"","span":{"file_name":"src/libcore/future/future.rs","byte_start":2396110,"byte_end":2396131,"line_start":28,"line_end":28,"column_start":28,"column_end":49}}]},{"kind":"Type","id":{"krate":0,"index":7140},"span":{"file_name":"src/libcore/future/future.rs","byte_start":2396269,"byte_end":2396275,"line_start":32,"line_end":32,"column_start":10,"column_end":16},"name":"Output","qualname":"::future::future::Future::Output","value":"type Output;","parent":{"krate":0,"index":7139},"children":[],"decl_id":null,"docs":" The type of value produced on completion.\n","sig":null,"attributes":[{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/future/future.rs","byte_start":2396207,"byte_end":2396259,"line_start":31,"line_end":31,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":7141},"span":{"file_name":"src/libcore/future/future.rs","byte_start":2399621,"byte_end":2399625,"line_start":97,"line_end":97,"column_start":8,"column_end":12},"name":"poll","qualname":"::future::future::Future::poll","value":"fn (self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>","parent":{"krate":0,"index":7139},"children":[],"decl_id":null,"docs":" Attempt to resolve the future to a final value, registering\n the current task for wakeup if the value is not yet available.","sig":null,"attributes":[{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/future/future.rs","byte_start":2399561,"byte_end":2399613,"line_start":96,"line_end":96,"column_start":5,"column_end":57}}]},{"kind":"Mod","id":{"krate":0,"index":7151},"span":{"file_name":"src/libcore/task/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"task","qualname":"::task","value":"src/libcore/task/mod.rs","parent":null,"children":[{"krate":0,"index":7152},{"krate":0,"index":7191},{"krate":0,"index":7192},{"krate":0,"index":7225}],"decl_id":null,"docs":" Types and Traits for working with asynchronous tasks.\n","sig":null,"attributes":[{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/task/mod.rs","byte_start":2400308,"byte_end":2400361,"line_start":1,"line_end":1,"column_start":1,"column_end":54}}]},{"kind":"TupleVariant","id":{"krate":0,"index":34902},"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2401197,"byte_end":2401202,"line_start":14,"line_end":14,"column_start":5,"column_end":10},"name":"Ready","qualname":"::task::poll::Poll::Ready","value":"Poll::Ready(T)","parent":{"krate":0,"index":34900},"children":[],"decl_id":null,"docs":" Represents that a value is immediately ready.\n","sig":null,"attributes":[{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2401140,"byte_end":2401192,"line_start":13,"line_end":13,"column_start":5,"column_end":57}}]},{"kind":"TupleVariant","id":{"krate":0,"index":34905},"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2401568,"byte_end":2401575,"line_start":25,"line_end":25,"column_start":5,"column_end":12},"name":"Pending","qualname":"::task::poll::Poll::Pending","value":"Poll::Pending","parent":{"krate":0,"index":34900},"children":[],"decl_id":null,"docs":" Represents that a value is not ready yet.","sig":null,"attributes":[{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2401511,"byte_end":2401563,"line_start":24,"line_end":24,"column_start":5,"column_end":57}}]},{"kind":"Enum","id":{"krate":0,"index":34900},"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2401072,"byte_end":2401076,"line_start":11,"line_end":11,"column_start":10,"column_end":14},"name":"Poll","qualname":"::task::poll::Poll","value":"Poll::{Ready, Pending}","parent":null,"children":[{"krate":0,"index":34902},{"krate":0,"index":34905}],"decl_id":null,"docs":" Indicates whether a value is available or if the current task has been\n scheduled to receive a wakeup instead.\n","sig":null,"attributes":[{"value":"must_use =\n      \"this `Poll` may be a `Pending` variant, which should be handled\"","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2400862,"byte_end":2400941,"line_start":8,"line_end":8,"column_start":1,"column_end":80}},{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2401010,"byte_end":2401062,"line_start":10,"line_end":10,"column_start":1,"column_end":53}},{"value":"structural_match","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2401063,"byte_end":2401578,"line_start":11,"line_end":26,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2401063,"byte_end":2401578,"line_start":11,"line_end":26,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":7157},"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2401740,"byte_end":2401743,"line_start":31,"line_end":31,"column_start":12,"column_end":15},"name":"map","qualname":"<Poll<T>>::map","value":"fn <U, F> (self, f: F) -> Poll<U>","parent":null,"children":[],"decl_id":null,"docs":" Changes the ready value of this `Poll` with the closure provided.\n","sig":null,"attributes":[{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2401676,"byte_end":2401728,"line_start":30,"line_end":30,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":7160},"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2402072,"byte_end":2402080,"line_start":43,"line_end":43,"column_start":12,"column_end":20},"name":"is_ready","qualname":"<Poll<T>>::is_ready","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this is `Poll::Ready`\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2401994,"byte_end":2402003,"line_start":41,"line_end":41,"column_start":5,"column_end":14}},{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2402008,"byte_end":2402060,"line_start":42,"line_end":42,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":7161},"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2402341,"byte_end":2402351,"line_start":53,"line_end":53,"column_start":12,"column_end":22},"name":"is_pending","qualname":"<Poll<T>>::is_pending","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this is `Poll::Pending`\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2402263,"byte_end":2402272,"line_start":51,"line_end":51,"column_start":5,"column_end":14}},{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2402277,"byte_end":2402329,"line_start":52,"line_end":52,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":7165},"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2402579,"byte_end":2402585,"line_start":61,"line_end":61,"column_start":12,"column_end":18},"name":"map_ok","qualname":"<Poll<Result<T, E>>>::map_ok","value":"fn <U, F> (self, f: F) -> Poll<Result<U, E>>","parent":null,"children":[],"decl_id":null,"docs":" Changes the success value of this `Poll` with the closure provided.\n","sig":null,"attributes":[{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2402515,"byte_end":2402567,"line_start":60,"line_end":60,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":7168},"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2403001,"byte_end":2403008,"line_start":73,"line_end":73,"column_start":12,"column_end":19},"name":"map_err","qualname":"<Poll<Result<T, E>>>::map_err","value":"fn <U, F> (self, f: F) -> Poll<Result<T, U>>","parent":null,"children":[],"decl_id":null,"docs":" Changes the error value of this `Poll` with the closure provided.\n","sig":null,"attributes":[{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2402937,"byte_end":2402989,"line_start":72,"line_end":72,"column_start":5,"column_end":57}}]},{"kind":"Struct","id":{"krate":0,"index":34936},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2405254,"byte_end":2405262,"line_start":17,"line_end":17,"column_start":12,"column_end":20},"name":"RawWaker","qualname":"::task::wake::RawWaker","value":"RawWaker {  }","parent":null,"children":[{"krate":0,"index":34937},{"krate":0,"index":34938}],"decl_id":null,"docs":" A `RawWaker` allows the implementor of a task executor to create a [`Waker`]\n which provides customized wakeup behavior.","sig":null,"attributes":[{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2405190,"byte_end":2405242,"line_start":16,"line_end":16,"column_start":1,"column_end":53}}]},{"kind":"Method","id":{"krate":0,"index":37147},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2406493,"byte_end":2406496,"line_start":42,"line_end":42,"column_start":18,"column_end":21},"name":"new","qualname":"<RawWaker>::new","value":"fn (data: *const (), vtable: &'static RawWakerVTable) -> RawWaker","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `RawWaker` from the provided `data` pointer and `vtable`.","sig":null,"attributes":[{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2406423,"byte_end":2406475,"line_start":41,"line_end":41,"column_start":5,"column_end":57}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2406399,"byte_end":2406418,"line_start":40,"line_end":40,"column_start":5,"column_end":24}}]},{"kind":"Struct","id":{"krate":0,"index":34944},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2407305,"byte_end":2407319,"line_start":64,"line_end":64,"column_start":12,"column_end":26},"name":"RawWakerVTable","qualname":"::task::wake::RawWakerVTable","value":"RawWakerVTable {  }","parent":null,"children":[{"krate":0,"index":34945},{"krate":0,"index":34946},{"krate":0,"index":34947},{"krate":0,"index":34948}],"decl_id":null,"docs":" A virtual function pointer table (vtable) that specifies the behavior\n of a [`RawWaker`].","sig":null,"attributes":[{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2407200,"byte_end":2407252,"line_start":62,"line_end":62,"column_start":1,"column_end":53}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2407294,"byte_end":2409121,"line_start":64,"line_end":106,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":37146},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2411261,"byte_end":2411264,"line_start":157,"line_end":157,"column_start":18,"column_end":21},"name":"new","qualname":"<RawWakerVTable>::new","value":"fn (clone: unsafe fn(*const ()) -> RawWaker, wake: unsafe fn(*const ()), wake_by_ref: unsafe fn(*const ()), drop: unsafe fn(*const ())) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `RawWakerVTable` from the provided `clone`, `wake`,\n `wake_by_ref`, and `drop` functions.","sig":null,"attributes":[{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2410852,"byte_end":2410904,"line_start":150,"line_end":150,"column_start":5,"column_end":57}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2410828,"byte_end":2410847,"line_start":149,"line_end":149,"column_start":5,"column_end":24}},{"value":"rustc_allow_const_fn_ptr","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2411216,"byte_end":2411243,"line_start":156,"line_end":156,"column_start":5,"column_end":32}}]},{"kind":"Struct","id":{"krate":0,"index":7199},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2411788,"byte_end":2411795,"line_start":177,"line_end":177,"column_start":12,"column_end":19},"name":"Context","qualname":"::task::wake::Context","value":"Context {  }","parent":null,"children":[{"krate":0,"index":7201},{"krate":0,"index":7202}],"decl_id":null,"docs":" The `Context` of an asynchronous task.","sig":null,"attributes":[{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2411724,"byte_end":2411776,"line_start":176,"line_end":176,"column_start":1,"column_end":53}}]},{"kind":"Method","id":{"krate":0,"index":7205},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2412239,"byte_end":2412249,"line_start":190,"line_end":190,"column_start":12,"column_end":22},"name":"from_waker","qualname":"<Context>::from_waker","value":"fn (waker: &'a Waker) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Create a new `Context` from a `&Waker`.\n","sig":null,"attributes":[{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2412161,"byte_end":2412213,"line_start":188,"line_end":188,"column_start":5,"column_end":57}},{"value":"inline","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2412218,"byte_end":2412227,"line_start":189,"line_end":189,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7206},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2412513,"byte_end":2412518,"line_start":200,"line_end":200,"column_start":12,"column_end":17},"name":"waker","qualname":"<Context>::waker","value":"fn (&self) -> &'a Waker","parent":null,"children":[],"decl_id":null,"docs":" Returns a reference to the `Waker` for the current task.\n","sig":null,"attributes":[{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2412435,"byte_end":2412487,"line_start":198,"line_end":198,"column_start":5,"column_end":57}},{"value":"inline","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2412492,"byte_end":2412501,"line_start":199,"line_end":199,"column_start":5,"column_end":14}}]},{"kind":"Struct","id":{"krate":0,"index":7209},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2413228,"byte_end":2413233,"line_start":225,"line_end":225,"column_start":12,"column_end":17},"name":"Waker","qualname":"::task::wake::Waker","value":"Waker {  }","parent":null,"children":[{"krate":0,"index":7210}],"decl_id":null,"docs":" A `Waker` is a handle for waking up a task by notifying its executor that it\n is ready to be run.","sig":null,"attributes":[{"value":"repr(transparent)","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2413143,"byte_end":2413163,"line_start":223,"line_end":223,"column_start":1,"column_end":21}},{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2413164,"byte_end":2413216,"line_start":224,"line_end":224,"column_start":1,"column_end":53}}]},{"kind":"Method","id":{"krate":0,"index":7215},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2413654,"byte_end":2413658,"line_start":240,"line_end":240,"column_start":12,"column_end":16},"name":"wake","qualname":"<Waker>::wake","value":"fn (self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Wake up the task associated with this `Waker`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2413576,"byte_end":2413585,"line_start":238,"line_end":238,"column_start":5,"column_end":14}},{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2413590,"byte_end":2413642,"line_start":239,"line_end":239,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":7216},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2414620,"byte_end":2414631,"line_start":262,"line_end":262,"column_start":12,"column_end":23},"name":"wake_by_ref","qualname":"<Waker>::wake_by_ref","value":"fn (&self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Wake up the task associated with this `Waker` without consuming the `Waker`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2414542,"byte_end":2414551,"line_start":260,"line_end":260,"column_start":5,"column_end":14}},{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2414556,"byte_end":2414608,"line_start":261,"line_end":261,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":7217},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2415388,"byte_end":2415397,"line_start":279,"line_end":279,"column_start":12,"column_end":21},"name":"will_wake","qualname":"<Waker>::will_wake","value":"fn (&self, other: &Waker) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this `Waker` and another `Waker` have awoken the same task.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2415310,"byte_end":2415319,"line_start":277,"line_end":277,"column_start":5,"column_end":14}},{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2415324,"byte_end":2415376,"line_start":278,"line_end":278,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":7218},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2415926,"byte_end":2415934,"line_start":293,"line_end":293,"column_start":19,"column_end":27},"name":"from_raw","qualname":"<Waker>::from_raw","value":"fn (waker: RawWaker) -> Waker","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Waker` from [`RawWaker`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2415841,"byte_end":2415850,"line_start":291,"line_end":291,"column_start":5,"column_end":14}},{"value":"stable(feature = \"futures_api\", since = \"1.36.0\")","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2415855,"byte_end":2415907,"line_start":292,"line_end":292,"column_start":5,"column_end":57}}]},{"kind":"Mod","id":{"krate":0,"index":7230},"span":{"file_name":"src/libcore/alloc.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"alloc","qualname":"::alloc","value":"src/libcore/alloc.rs","parent":null,"children":[{"krate":0,"index":7231},{"krate":0,"index":7232},{"krate":0,"index":7233},{"krate":0,"index":7234},{"krate":0,"index":7235},{"krate":0,"index":7238},{"krate":0,"index":34957},{"krate":0,"index":34961},{"krate":0,"index":7239},{"krate":0,"index":34963},{"krate":0,"index":34975},{"krate":0,"index":34973},{"krate":0,"index":34971},{"krate":0,"index":34968},{"krate":0,"index":34966},{"krate":0,"index":7241},{"krate":0,"index":34976},{"krate":0,"index":34985},{"krate":0,"index":34982},{"krate":0,"index":34980},{"krate":0,"index":34978},{"krate":0,"index":7260},{"krate":0,"index":34987},{"krate":0,"index":34995},{"krate":0,"index":34993},{"krate":0,"index":34991},{"krate":0,"index":34989},{"krate":0,"index":7262},{"krate":0,"index":34997},{"krate":0,"index":35005},{"krate":0,"index":35003},{"krate":0,"index":35001},{"krate":0,"index":34999},{"krate":0,"index":7264},{"krate":0,"index":7266},{"krate":0,"index":7268},{"krate":0,"index":7273}],"decl_id":null,"docs":" Memory allocation APIs\n","sig":null,"attributes":[{"value":"allow(missing_docs)","span":{"file_name":"src/libcore/lib.rs","byte_start":6643,"byte_end":6665,"line_start":219,"line_end":219,"column_start":1,"column_end":23}},{"value":"stable(feature = \"alloc_module\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2417246,"byte_end":2417300,"line_start":3,"line_end":3,"column_start":1,"column_end":55}}]},{"kind":"Struct","id":{"krate":0,"index":34957},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2417617,"byte_end":2417623,"line_start":16,"line_end":16,"column_start":12,"column_end":18},"name":"Excess","qualname":"::alloc::Excess","value":"","parent":null,"children":[],"decl_id":null,"docs":" Represents the combination of a starting address and\n a total capacity of the returned block.\n","sig":null,"attributes":[{"value":"unstable(feature = \"allocator_api\", issue = \"32838\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2417533,"byte_end":2417588,"line_start":14,"line_end":14,"column_start":1,"column_end":56}}]},{"kind":"Struct","id":{"krate":0,"index":34963},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2418461,"byte_end":2418467,"line_start":38,"line_end":38,"column_start":12,"column_end":18},"name":"Layout","qualname":"::alloc::Layout","value":"Layout {  }","parent":null,"children":[{"krate":0,"index":34964},{"krate":0,"index":34965}],"decl_id":null,"docs":" Layout of a block of memory.","sig":null,"attributes":[{"value":"stable(feature = \"alloc_layout\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2418326,"byte_end":2418379,"line_start":35,"line_end":35,"column_start":1,"column_end":54}},{"value":"lang = \"alloc_layout\"","span":{"file_name":"src/libcore/alloc.rs","byte_start":2418425,"byte_end":2418449,"line_start":37,"line_end":37,"column_start":1,"column_end":25}},{"value":"structural_match","span":{"file_name":"src/libcore/alloc.rs","byte_start":2418450,"byte_end":2418984,"line_start":38,"line_end":50,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/alloc.rs","byte_start":2418450,"byte_end":2418984,"line_start":38,"line_end":50,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":7242},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2419506,"byte_end":2419521,"line_start":66,"line_end":66,"column_start":12,"column_end":27},"name":"from_size_align","qualname":"<Layout>::from_size_align","value":"fn (size: usize, align: usize) -> Result<Self, LayoutErr>","parent":null,"children":[],"decl_id":null,"docs":" Constructs a `Layout` from a given `size` and `align`,\n or returns `LayoutErr` if either of the following conditions\n are not met:","sig":null,"attributes":[{"value":"stable(feature = \"alloc_layout\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2419427,"byte_end":2419480,"line_start":64,"line_end":64,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2419485,"byte_end":2419494,"line_start":65,"line_end":65,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7243},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2420819,"byte_end":2420844,"line_start":102,"line_end":102,"column_start":25,"column_end":50},"name":"from_size_align_unchecked","qualname":"<Layout>::from_size_align_unchecked","value":"fn (size: usize, align: usize) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a layout, bypassing all checks.","sig":null,"attributes":[{"value":"stable(feature = \"alloc_layout\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2420727,"byte_end":2420780,"line_start":100,"line_end":100,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2420785,"byte_end":2420794,"line_start":101,"line_end":101,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7244},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2421116,"byte_end":2421120,"line_start":109,"line_end":109,"column_start":12,"column_end":16},"name":"size","qualname":"<Layout>::size","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" The minimum size in bytes for a memory block of this layout.\n","sig":null,"attributes":[{"value":"stable(feature = \"alloc_layout\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2421037,"byte_end":2421090,"line_start":107,"line_end":107,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2421095,"byte_end":2421104,"line_start":108,"line_end":108,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7245},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2421306,"byte_end":2421311,"line_start":114,"line_end":114,"column_start":12,"column_end":17},"name":"align","qualname":"<Layout>::align","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" The minimum byte alignment for a memory block of this layout.\n","sig":null,"attributes":[{"value":"stable(feature = \"alloc_layout\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2421227,"byte_end":2421280,"line_start":112,"line_end":112,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2421285,"byte_end":2421294,"line_start":113,"line_end":113,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7246},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2421506,"byte_end":2421509,"line_start":119,"line_end":119,"column_start":12,"column_end":15},"name":"new","qualname":"<Layout>::new","value":"fn <T> () -> Self","parent":null,"children":[],"decl_id":null,"docs":" Constructs a `Layout` suitable for holding a value of type `T`.\n","sig":null,"attributes":[{"value":"stable(feature = \"alloc_layout\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2421427,"byte_end":2421480,"line_start":117,"line_end":117,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2421485,"byte_end":2421494,"line_start":118,"line_end":118,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7248},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2422289,"byte_end":2422298,"line_start":136,"line_end":136,"column_start":12,"column_end":21},"name":"for_value","qualname":"<Layout>::for_value","value":"fn <T> (t: &T) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Produces layout describing a record that could be used to\n allocate backing structure for `T` (which could be a trait\n or other unsized type like a slice).\n","sig":null,"attributes":[{"value":"stable(feature = \"alloc_layout\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2422210,"byte_end":2422263,"line_start":134,"line_end":134,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2422268,"byte_end":2422277,"line_start":135,"line_end":135,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7250},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2423461,"byte_end":2423469,"line_start":162,"line_end":162,"column_start":12,"column_end":20},"name":"align_to","qualname":"<Layout>::align_to","value":"fn (&self, align: usize) -> Result<Self, LayoutErr>","parent":null,"children":[],"decl_id":null,"docs":" Creates a layout describing the record that can hold a value\n of the same layout as `self`, but that also is aligned to\n alignment `align` (measured in bytes).","sig":null,"attributes":[{"value":"unstable(feature = \"alloc_layout_extra\", issue = \"55724\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2423375,"byte_end":2423435,"line_start":160,"line_end":160,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2423440,"byte_end":2423449,"line_start":161,"line_end":161,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7251},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2424525,"byte_end":2424543,"line_start":184,"line_end":184,"column_start":12,"column_end":30},"name":"padding_needed_for","qualname":"<Layout>::padding_needed_for","value":"fn (&self, align: usize) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the amount of padding we must insert after `self`\n to ensure that the following address will satisfy `align`\n (measured in bytes).","sig":null,"attributes":[{"value":"unstable(feature = \"alloc_layout_extra\", issue = \"55724\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2424439,"byte_end":2424499,"line_start":182,"line_end":182,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2424504,"byte_end":2424513,"line_start":183,"line_end":183,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7252},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2426037,"byte_end":2426049,"line_start":220,"line_end":220,"column_start":12,"column_end":24},"name":"pad_to_align","qualname":"<Layout>::pad_to_align","value":"fn (&self) -> Result<Layout, LayoutErr>","parent":null,"children":[],"decl_id":null,"docs":" Creates a layout by rounding the size of this layout up to a multiple\n of the layout's alignment.","sig":null,"attributes":[{"value":"unstable(feature = \"alloc_layout_extra\", issue = \"55724\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2425951,"byte_end":2426011,"line_start":218,"line_end":218,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2426016,"byte_end":2426025,"line_start":219,"line_end":219,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7253},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2426839,"byte_end":2426845,"line_start":238,"line_end":238,"column_start":12,"column_end":18},"name":"repeat","qualname":"<Layout>::repeat","value":"fn (&self, n: usize) -> Result<(Self, usize), LayoutErr>","parent":null,"children":[],"decl_id":null,"docs":" Creates a layout describing the record for `n` instances of\n `self`, with a suitable amount of padding between each to\n ensure that each instance is given its requested size and\n alignment. On success, returns `(k, offs)` where `k` is the\n layout of the array and `offs` is the distance between the start\n of each element in the array.","sig":null,"attributes":[{"value":"unstable(feature = \"alloc_layout_extra\", issue = \"55724\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2426753,"byte_end":2426813,"line_start":236,"line_end":236,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2426818,"byte_end":2426827,"line_start":237,"line_end":237,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7254},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2428246,"byte_end":2428252,"line_start":267,"line_end":267,"column_start":12,"column_end":18},"name":"extend","qualname":"<Layout>::extend","value":"fn (&self, next: Self) -> Result<(Self, usize), LayoutErr>","parent":null,"children":[],"decl_id":null,"docs":" Creates a layout describing the record for `self` followed by\n `next`, including any necessary padding to ensure that `next`\n will be properly aligned. Note that the result layout will\n satisfy the alignment properties of both `self` and `next`.","sig":null,"attributes":[{"value":"unstable(feature = \"alloc_layout_extra\", issue = \"55724\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2428160,"byte_end":2428220,"line_start":265,"line_end":265,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2428225,"byte_end":2428234,"line_start":266,"line_end":266,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7255},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2429423,"byte_end":2429436,"line_start":294,"line_end":294,"column_start":12,"column_end":25},"name":"repeat_packed","qualname":"<Layout>::repeat_packed","value":"fn (&self, n: usize) -> Result<Self, LayoutErr>","parent":null,"children":[],"decl_id":null,"docs":" Creates a layout describing the record for `n` instances of\n `self`, with no padding between each instance.","sig":null,"attributes":[{"value":"unstable(feature = \"alloc_layout_extra\", issue = \"55724\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2429337,"byte_end":2429397,"line_start":292,"line_end":292,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2429402,"byte_end":2429411,"line_start":293,"line_end":293,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7256},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2430048,"byte_end":2430061,"line_start":307,"line_end":307,"column_start":12,"column_end":25},"name":"extend_packed","qualname":"<Layout>::extend_packed","value":"fn (&self, next: Self) -> Result<Self, LayoutErr>","parent":null,"children":[],"decl_id":null,"docs":" Creates a layout describing the record for `self` followed by\n `next` with no additional padding between the two. Since no\n padding is inserted, the alignment of `next` is irrelevant,\n and is not incorporated *at all* into the resulting layout.","sig":null,"attributes":[{"value":"unstable(feature = \"alloc_layout_extra\", issue = \"55724\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2429962,"byte_end":2430022,"line_start":305,"line_end":305,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2430027,"byte_end":2430036,"line_start":306,"line_end":306,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7257},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2430529,"byte_end":2430534,"line_start":319,"line_end":319,"column_start":12,"column_end":17},"name":"array","qualname":"<Layout>::array","value":"fn <T> (n: usize) -> Result<Self, LayoutErr>","parent":null,"children":[],"decl_id":null,"docs":" Creates a layout describing the record for a `[T; n]`.","sig":null,"attributes":[{"value":"unstable(feature = \"alloc_layout_extra\", issue = \"55724\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2430443,"byte_end":2430503,"line_start":317,"line_end":317,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2430508,"byte_end":2430517,"line_start":318,"line_end":318,"column_start":5,"column_end":14}}]},{"kind":"Struct","id":{"krate":0,"index":34976},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2431004,"byte_end":2431013,"line_start":334,"line_end":334,"column_start":12,"column_end":21},"name":"LayoutErr","qualname":"::alloc::LayoutErr","value":"LayoutErr {  }","parent":null,"children":[{"krate":0,"index":34977}],"decl_id":null,"docs":" The parameters given to `Layout::from_size_align`\n or some other `Layout` constructor\n do not satisfy its documented constraints.\n","sig":null,"attributes":[{"value":"stable(feature = \"alloc_layout\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2430900,"byte_end":2430953,"line_start":332,"line_end":332,"column_start":1,"column_end":54}},{"value":"structural_match","span":{"file_name":"src/libcore/alloc.rs","byte_start":2430993,"byte_end":2431033,"line_start":334,"line_end":336,"column_start":1,"column_end":2}}]},{"kind":"Struct","id":{"krate":0,"index":34987},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2431615,"byte_end":2431623,"line_start":352,"line_end":352,"column_start":12,"column_end":20},"name":"AllocErr","qualname":"::alloc::AllocErr","value":"","parent":null,"children":[],"decl_id":null,"docs":" The `AllocErr` error indicates an allocation failure\n that may be due to resource exhaustion or to\n something wrong when combining the given input arguments with this\n allocator.\n","sig":null,"attributes":[{"value":"unstable(feature = \"allocator_api\", issue = \"32838\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2431509,"byte_end":2431564,"line_start":350,"line_end":350,"column_start":1,"column_end":56}},{"value":"structural_match","span":{"file_name":"src/libcore/alloc.rs","byte_start":2431604,"byte_end":2431624,"line_start":352,"line_end":352,"column_start":1,"column_end":21}}]},{"kind":"Struct","id":{"krate":0,"index":34997},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2432157,"byte_end":2432177,"line_start":367,"line_end":367,"column_start":12,"column_end":32},"name":"CannotReallocInPlace","qualname":"::alloc::CannotReallocInPlace","value":"","parent":null,"children":[],"decl_id":null,"docs":" The `CannotReallocInPlace` error is used when `grow_in_place` or\n `shrink_in_place` were unable to reuse the given memory block for\n a requested layout.\n","sig":null,"attributes":[{"value":"unstable(feature = \"allocator_api\", issue = \"32838\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2432051,"byte_end":2432106,"line_start":365,"line_end":365,"column_start":1,"column_end":56}},{"value":"structural_match","span":{"file_name":"src/libcore/alloc.rs","byte_start":2432146,"byte_end":2432178,"line_start":367,"line_end":367,"column_start":1,"column_end":33}}]},{"kind":"Method","id":{"krate":0,"index":7265},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2432275,"byte_end":2432286,"line_start":371,"line_end":371,"column_start":12,"column_end":23},"name":"description","qualname":"<CannotReallocInPlace>::description","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":7268},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2434492,"byte_end":2434503,"line_start":436,"line_end":436,"column_start":18,"column_end":29},"name":"GlobalAlloc","qualname":"::alloc::GlobalAlloc","value":"GlobalAlloc","parent":null,"children":[{"krate":0,"index":7269},{"krate":0,"index":7270},{"krate":0,"index":7271},{"krate":0,"index":7272}],"decl_id":null,"docs":" A memory allocator that can be registered as the standard library’s default\n though the `#[global_allocator]` attributes.","sig":null,"attributes":[{"value":"stable(feature = \"global_alloc\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2434421,"byte_end":2434474,"line_start":435,"line_end":435,"column_start":1,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":7269},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2435993,"byte_end":2435998,"line_start":470,"line_end":470,"column_start":15,"column_end":20},"name":"alloc","qualname":"::alloc::GlobalAlloc::alloc","value":"fn (&self, layout: Layout) -> *mut u8","parent":{"krate":0,"index":7268},"children":[],"decl_id":null,"docs":" Allocate memory as described by the given `layout`.","sig":null,"attributes":[{"value":"stable(feature = \"global_alloc\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2435925,"byte_end":2435978,"line_start":469,"line_end":469,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":7270},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2436574,"byte_end":2436581,"line_start":485,"line_end":485,"column_start":15,"column_end":22},"name":"dealloc","qualname":"::alloc::GlobalAlloc::dealloc","value":"fn (&self, ptr: *mut u8, layout: Layout) -> ()","parent":{"krate":0,"index":7268},"children":[],"decl_id":null,"docs":" Deallocate the block of memory at the given `ptr` pointer with the given `layout`.","sig":null,"attributes":[{"value":"stable(feature = \"global_alloc\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2436506,"byte_end":2436559,"line_start":484,"line_end":484,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":7271},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2437500,"byte_end":2437512,"line_start":507,"line_end":507,"column_start":15,"column_end":27},"name":"alloc_zeroed","qualname":"::alloc::GlobalAlloc::alloc_zeroed","value":"fn (&self, layout: Layout) -> *mut u8","parent":{"krate":0,"index":7268},"children":[],"decl_id":null,"docs":" Behaves like `alloc`, but also ensures that the contents\n are set to zero before being returned.","sig":null,"attributes":[{"value":"stable(feature = \"global_alloc\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2437432,"byte_end":2437485,"line_start":506,"line_end":506,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":7272},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2440086,"byte_end":2440093,"line_start":567,"line_end":567,"column_start":15,"column_end":22},"name":"realloc","qualname":"::alloc::GlobalAlloc::realloc","value":"fn (&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8","parent":{"krate":0,"index":7268},"children":[],"decl_id":null,"docs":" Shrink or grow a block of memory to the given `new_size`.\n The block is described by the given `ptr` pointer and `layout`.","sig":null,"attributes":[{"value":"stable(feature = \"global_alloc\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2440018,"byte_end":2440071,"line_start":566,"line_end":566,"column_start":5,"column_end":58}}]},{"kind":"Trait","id":{"krate":0,"index":7273},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2444279,"byte_end":2444284,"line_start":662,"line_end":662,"column_start":18,"column_end":23},"name":"Alloc","qualname":"::alloc::Alloc","value":"Alloc","parent":null,"children":[{"krate":0,"index":7274},{"krate":0,"index":7275},{"krate":0,"index":7276},{"krate":0,"index":7277},{"krate":0,"index":7278},{"krate":0,"index":7279},{"krate":0,"index":7281},{"krate":0,"index":7283},{"krate":0,"index":7284},{"krate":0,"index":7285},{"krate":0,"index":7288},{"krate":0,"index":7290},{"krate":0,"index":7293},{"krate":0,"index":7295}],"decl_id":null,"docs":" An implementation of `Alloc` can allocate, reallocate, and\n deallocate arbitrary blocks of data described via `Layout`.","sig":null,"attributes":[{"value":"unstable(feature = \"allocator_api\", issue = \"32838\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2444206,"byte_end":2444261,"line_start":661,"line_end":661,"column_start":1,"column_end":56}}]},{"kind":"Method","id":{"krate":0,"index":7274},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2446391,"byte_end":2446396,"line_start":710,"line_end":710,"column_start":15,"column_end":20},"name":"alloc","qualname":"::alloc::Alloc::alloc","value":"fn (&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr>","parent":{"krate":0,"index":7273},"children":[],"decl_id":null,"docs":" Returns a pointer meeting the size and alignment guarantees of\n `layout`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7275},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2447036,"byte_end":2447043,"line_start":727,"line_end":727,"column_start":15,"column_end":22},"name":"dealloc","qualname":"::alloc::Alloc::dealloc","value":"fn (&mut self, ptr: NonNull<u8>, layout: Layout) -> ()","parent":{"krate":0,"index":7273},"children":[],"decl_id":null,"docs":" Deallocate the memory referenced by `ptr`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7276},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2448450,"byte_end":2448461,"line_start":759,"line_end":759,"column_start":8,"column_end":19},"name":"usable_size","qualname":"::alloc::Alloc::usable_size","value":"fn (&self, layout: &Layout) -> (usize, usize)","parent":{"krate":0,"index":7273},"children":[],"decl_id":null,"docs":" Returns bounds on the guaranteed usable size of a successful\n allocation created with the specified `layout`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2448433,"byte_end":2448442,"line_start":758,"line_end":758,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7277},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2451091,"byte_end":2451098,"line_start":820,"line_end":820,"column_start":15,"column_end":22},"name":"realloc","qualname":"::alloc::Alloc::realloc","value":"fn (&mut self, ptr: NonNull<u8>, layout: Layout, new_size: usize) -> Result<NonNull<u8>, AllocErr>","parent":{"krate":0,"index":7273},"children":[],"decl_id":null,"docs":" Returns a pointer suitable for holding data described by\n a new layout with `layout`’s alignment and a size given\n by `new_size`. To\n accomplish this, this may extend or shrink the allocation\n referenced by `ptr` to fit the new layout.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7278},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2452846,"byte_end":2452858,"line_start":866,"line_end":866,"column_start":15,"column_end":27},"name":"alloc_zeroed","qualname":"::alloc::Alloc::alloc_zeroed","value":"fn (&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr>","parent":{"krate":0,"index":7273},"children":[],"decl_id":null,"docs":" Behaves like `alloc`, but also ensures that the contents\n are set to zero before being returned.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7279},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2453916,"byte_end":2453928,"line_start":894,"line_end":894,"column_start":15,"column_end":27},"name":"alloc_excess","qualname":"::alloc::Alloc::alloc_excess","value":"fn (&mut self, layout: Layout) -> Result<Excess, AllocErr>","parent":{"krate":0,"index":7273},"children":[],"decl_id":null,"docs":" Behaves like `alloc`, but also returns the whole size of\n the returned block. For some `layout` inputs, like arrays, this\n may include extra storage usable for additional data.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7281},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2454934,"byte_end":2454948,"line_start":918,"line_end":918,"column_start":15,"column_end":29},"name":"realloc_excess","qualname":"::alloc::Alloc::realloc_excess","value":"fn (&mut self, ptr: NonNull<u8>, layout: Layout, new_size: usize) -> Result<Excess, AllocErr>","parent":{"krate":0,"index":7273},"children":[],"decl_id":null,"docs":" Behaves like `realloc`, but also returns the whole size of\n the returned block. For some `layout` inputs, like arrays, this\n may include extra storage usable for additional data.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7283},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2456999,"byte_end":2457012,"line_start":963,"line_end":963,"column_start":15,"column_end":28},"name":"grow_in_place","qualname":"::alloc::Alloc::grow_in_place","value":"fn (&mut self, ptr: NonNull<u8>, layout: Layout, new_size: usize) -> Result<(), CannotReallocInPlace>","parent":{"krate":0,"index":7273},"children":[],"decl_id":null,"docs":" Attempts to extend the allocation referenced by `ptr` to fit `new_size`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7284},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2459530,"byte_end":2459545,"line_start":1018,"line_end":1018,"column_start":15,"column_end":30},"name":"shrink_in_place","qualname":"::alloc::Alloc::shrink_in_place","value":"fn (&mut self, ptr: NonNull<u8>, layout: Layout, new_size: usize) -> Result<(), CannotReallocInPlace>","parent":{"krate":0,"index":7273},"children":[],"decl_id":null,"docs":" Attempts to shrink the allocation referenced by `ptr` to fit `new_size`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7285},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2461674,"byte_end":2461683,"line_start":1067,"line_end":1067,"column_start":8,"column_end":17},"name":"alloc_one","qualname":"::alloc::Alloc::alloc_one","value":"fn <T> (&mut self) -> Result<NonNull<T>, AllocErr>","parent":{"krate":0,"index":7273},"children":[],"decl_id":null,"docs":" Allocates a block suitable for holding an instance of `T`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7288},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2462631,"byte_end":2462642,"line_start":1095,"line_end":1095,"column_start":15,"column_end":26},"name":"dealloc_one","qualname":"::alloc::Alloc::dealloc_one","value":"fn <T> (&mut self, ptr: NonNull<T>) -> ()","parent":{"krate":0,"index":7273},"children":[],"decl_id":null,"docs":" Deallocates a block suitable for holding an instance of `T`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7290},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2464272,"byte_end":2464283,"line_start":1136,"line_end":1136,"column_start":8,"column_end":19},"name":"alloc_array","qualname":"::alloc::Alloc::alloc_array","value":"fn <T> (&mut self, n: usize) -> Result<NonNull<T>, AllocErr>","parent":{"krate":0,"index":7273},"children":[],"decl_id":null,"docs":" Allocates a block suitable for holding `n` instances of `T`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7293},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2465998,"byte_end":2466011,"line_start":1183,"line_end":1183,"column_start":15,"column_end":28},"name":"realloc_array","qualname":"::alloc::Alloc::realloc_array","value":"fn <T> (&mut self, ptr: NonNull<T>, n_old: usize, n_new: usize) -> Result<NonNull<T>, AllocErr>","parent":{"krate":0,"index":7273},"children":[],"decl_id":null,"docs":" Reallocates a block previously suitable for holding `n_old`\n instances of `T`, returning a block suitable for holding\n `n_new` instances of `T`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7295},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2467344,"byte_end":2467357,"line_start":1220,"line_end":1220,"column_start":15,"column_end":28},"name":"dealloc_array","qualname":"::alloc::Alloc::dealloc_array","value":"fn <T> (&mut self, ptr: NonNull<T>, n: usize) -> Result<(), AllocErr>","parent":{"krate":0,"index":7273},"children":[],"decl_id":null,"docs":" Deallocates a block suitable for holding `n` instances of `T`.","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":7315},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/mod.rs","byte_start":2474133,"byte_end":2474137,"line_start":17,"line_end":17,"column_start":9,"column_end":13},"name":"arch","qualname":"::core_arch::arch","value":"src/libcore/../stdsimd/crates/core_arch/src/mod.rs","parent":null,"children":[{"krate":0,"index":7316}],"decl_id":null,"docs":"SIMD and vendor intrinsics module.","sig":null,"attributes":[{"value":"stable(feature = \"simd_arch\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/mod.rs","byte_start":2474074,"byte_end":2474124,"line_start":16,"line_end":16,"column_start":1,"column_end":51}}]},{"kind":"Mod","id":{"krate":0,"index":7316},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/mod.rs","byte_start":2474834,"byte_end":2474840,"line_start":35,"line_end":35,"column_start":13,"column_end":19},"name":"x86_64","qualname":"::core_arch::arch::x86_64","value":"src/libcore/../stdsimd/crates/core_arch/src/mod.rs","parent":null,"children":[{"krate":0,"index":7317},{"krate":0,"index":7318}],"decl_id":null,"docs":" Platform-specific intrinsics for the `x86_64` platform.","sig":null,"attributes":[{"value":"cfg(any(target_arch = \"x86_64\", dox))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/mod.rs","byte_start":2474687,"byte_end":2474727,"line_start":32,"line_end":32,"column_start":5,"column_end":45}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/mod.rs","byte_start":2474772,"byte_end":2474821,"line_start":34,"line_end":34,"column_start":5,"column_end":54}}]},{"kind":"ForeignFunction","id":{"krate":0,"index":7321},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2494553,"byte_end":2494560,"line_start":6,"line_end":6,"column_start":12,"column_end":19},"name":"simd_eq","qualname":"::core_arch::simd_llvm::simd_eq","value":"fn <T, U> (x: T, y: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7324},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2494596,"byte_end":2494603,"line_start":7,"line_end":7,"column_start":12,"column_end":19},"name":"simd_ne","qualname":"::core_arch::simd_llvm::simd_ne","value":"fn <T, U> (x: T, y: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7327},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2494639,"byte_end":2494646,"line_start":8,"line_end":8,"column_start":12,"column_end":19},"name":"simd_lt","qualname":"::core_arch::simd_llvm::simd_lt","value":"fn <T, U> (x: T, y: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7330},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2494682,"byte_end":2494689,"line_start":9,"line_end":9,"column_start":12,"column_end":19},"name":"simd_le","qualname":"::core_arch::simd_llvm::simd_le","value":"fn <T, U> (x: T, y: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7333},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2494725,"byte_end":2494732,"line_start":10,"line_end":10,"column_start":12,"column_end":19},"name":"simd_gt","qualname":"::core_arch::simd_llvm::simd_gt","value":"fn <T, U> (x: T, y: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7336},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2494768,"byte_end":2494775,"line_start":11,"line_end":11,"column_start":12,"column_end":19},"name":"simd_ge","qualname":"::core_arch::simd_llvm::simd_ge","value":"fn <T, U> (x: T, y: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7339},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2494812,"byte_end":2494825,"line_start":13,"line_end":13,"column_start":12,"column_end":25},"name":"simd_shuffle2","qualname":"::core_arch::simd_llvm::simd_shuffle2","value":"fn <T, U> (x: T, y: T, idx: [u32; 2]) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7343},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2494876,"byte_end":2494889,"line_start":14,"line_end":14,"column_start":12,"column_end":25},"name":"simd_shuffle4","qualname":"::core_arch::simd_llvm::simd_shuffle4","value":"fn <T, U> (x: T, y: T, idx: [u32; 4]) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7347},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2494940,"byte_end":2494953,"line_start":15,"line_end":15,"column_start":12,"column_end":25},"name":"simd_shuffle8","qualname":"::core_arch::simd_llvm::simd_shuffle8","value":"fn <T, U> (x: T, y: T, idx: [u32; 8]) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7351},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2495004,"byte_end":2495018,"line_start":16,"line_end":16,"column_start":12,"column_end":26},"name":"simd_shuffle16","qualname":"::core_arch::simd_llvm::simd_shuffle16","value":"fn <T, U> (x: T, y: T, idx: [u32; 16]) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7355},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2495070,"byte_end":2495084,"line_start":17,"line_end":17,"column_start":12,"column_end":26},"name":"simd_shuffle32","qualname":"::core_arch::simd_llvm::simd_shuffle32","value":"fn <T, U> (x: T, y: T, idx: [u32; 32]) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7359},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2495136,"byte_end":2495150,"line_start":18,"line_end":18,"column_start":12,"column_end":26},"name":"simd_shuffle64","qualname":"::core_arch::simd_llvm::simd_shuffle64","value":"fn <T, U> (x: T, y: T, idx: [u32; 64]) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7363},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2495202,"byte_end":2495217,"line_start":19,"line_end":19,"column_start":12,"column_end":27},"name":"simd_shuffle128","qualname":"::core_arch::simd_llvm::simd_shuffle128","value":"fn <T, U> (x: T, y: T, idx: [u32; 128]) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7367},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2495271,"byte_end":2495282,"line_start":21,"line_end":21,"column_start":12,"column_end":23},"name":"simd_insert","qualname":"::core_arch::simd_llvm::simd_insert","value":"fn <T, U> (x: T, idx: u32, val: U) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7370},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2495330,"byte_end":2495342,"line_start":22,"line_end":22,"column_start":12,"column_end":24},"name":"simd_extract","qualname":"::core_arch::simd_llvm::simd_extract","value":"fn <T, U> (x: T, idx: u32) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7373},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2495383,"byte_end":2495392,"line_start":24,"line_end":24,"column_start":12,"column_end":21},"name":"simd_cast","qualname":"::core_arch::simd_llvm::simd_cast","value":"fn <T, U> (x: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7376},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2495423,"byte_end":2495431,"line_start":26,"line_end":26,"column_start":12,"column_end":20},"name":"simd_add","qualname":"::core_arch::simd_llvm::simd_add","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7378},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2495464,"byte_end":2495472,"line_start":27,"line_end":27,"column_start":12,"column_end":20},"name":"simd_sub","qualname":"::core_arch::simd_llvm::simd_sub","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7380},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2495505,"byte_end":2495513,"line_start":28,"line_end":28,"column_start":12,"column_end":20},"name":"simd_mul","qualname":"::core_arch::simd_llvm::simd_mul","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7382},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2495546,"byte_end":2495554,"line_start":29,"line_end":29,"column_start":12,"column_end":20},"name":"simd_div","qualname":"::core_arch::simd_llvm::simd_div","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7384},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2495587,"byte_end":2495595,"line_start":30,"line_end":30,"column_start":12,"column_end":20},"name":"simd_rem","qualname":"::core_arch::simd_llvm::simd_rem","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7386},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2495628,"byte_end":2495636,"line_start":31,"line_end":31,"column_start":12,"column_end":20},"name":"simd_shl","qualname":"::core_arch::simd_llvm::simd_shl","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7388},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2495669,"byte_end":2495677,"line_start":32,"line_end":32,"column_start":12,"column_end":20},"name":"simd_shr","qualname":"::core_arch::simd_llvm::simd_shr","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7390},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2495710,"byte_end":2495718,"line_start":33,"line_end":33,"column_start":12,"column_end":20},"name":"simd_and","qualname":"::core_arch::simd_llvm::simd_and","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7392},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2495751,"byte_end":2495758,"line_start":34,"line_end":34,"column_start":12,"column_end":19},"name":"simd_or","qualname":"::core_arch::simd_llvm::simd_or","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7394},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2495791,"byte_end":2495799,"line_start":35,"line_end":35,"column_start":12,"column_end":20},"name":"simd_xor","qualname":"::core_arch::simd_llvm::simd_xor","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7396},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2495833,"byte_end":2495858,"line_start":37,"line_end":37,"column_start":12,"column_end":37},"name":"simd_reduce_add_unordered","qualname":"::core_arch::simd_llvm::simd_reduce_add_unordered","value":"fn <T, U> (x: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7399},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2495888,"byte_end":2495913,"line_start":38,"line_end":38,"column_start":12,"column_end":37},"name":"simd_reduce_mul_unordered","qualname":"::core_arch::simd_llvm::simd_reduce_mul_unordered","value":"fn <T, U> (x: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7402},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2495943,"byte_end":2495966,"line_start":39,"line_end":39,"column_start":12,"column_end":35},"name":"simd_reduce_add_ordered","qualname":"::core_arch::simd_llvm::simd_reduce_add_ordered","value":"fn <T, U> (x: T, acc: U) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7405},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2496004,"byte_end":2496027,"line_start":40,"line_end":40,"column_start":12,"column_end":35},"name":"simd_reduce_mul_ordered","qualname":"::core_arch::simd_llvm::simd_reduce_mul_ordered","value":"fn <T, U> (x: T, acc: U) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7408},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2496065,"byte_end":2496080,"line_start":41,"line_end":41,"column_start":12,"column_end":27},"name":"simd_reduce_min","qualname":"::core_arch::simd_llvm::simd_reduce_min","value":"fn <T, U> (x: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7411},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2496110,"byte_end":2496125,"line_start":42,"line_end":42,"column_start":12,"column_end":27},"name":"simd_reduce_max","qualname":"::core_arch::simd_llvm::simd_reduce_max","value":"fn <T, U> (x: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7414},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2496155,"byte_end":2496178,"line_start":43,"line_end":43,"column_start":12,"column_end":35},"name":"simd_reduce_min_nanless","qualname":"::core_arch::simd_llvm::simd_reduce_min_nanless","value":"fn <T, U> (x: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7417},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2496208,"byte_end":2496231,"line_start":44,"line_end":44,"column_start":12,"column_end":35},"name":"simd_reduce_max_nanless","qualname":"::core_arch::simd_llvm::simd_reduce_max_nanless","value":"fn <T, U> (x: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7420},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2496261,"byte_end":2496276,"line_start":45,"line_end":45,"column_start":12,"column_end":27},"name":"simd_reduce_and","qualname":"::core_arch::simd_llvm::simd_reduce_and","value":"fn <T, U> (x: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7423},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2496306,"byte_end":2496320,"line_start":46,"line_end":46,"column_start":12,"column_end":26},"name":"simd_reduce_or","qualname":"::core_arch::simd_llvm::simd_reduce_or","value":"fn <T, U> (x: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7426},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2496350,"byte_end":2496365,"line_start":47,"line_end":47,"column_start":12,"column_end":27},"name":"simd_reduce_xor","qualname":"::core_arch::simd_llvm::simd_reduce_xor","value":"fn <T, U> (x: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7429},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2496395,"byte_end":2496410,"line_start":48,"line_end":48,"column_start":12,"column_end":27},"name":"simd_reduce_all","qualname":"::core_arch::simd_llvm::simd_reduce_all","value":"fn <T> (x: T) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7431},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2496440,"byte_end":2496455,"line_start":49,"line_end":49,"column_start":12,"column_end":27},"name":"simd_reduce_any","qualname":"::core_arch::simd_llvm::simd_reduce_any","value":"fn <T> (x: T) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7433},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2496486,"byte_end":2496497,"line_start":51,"line_end":51,"column_start":12,"column_end":23},"name":"simd_select","qualname":"::core_arch::simd_llvm::simd_select","value":"fn <M, T> (m: M, a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7436},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2496539,"byte_end":2496558,"line_start":52,"line_end":52,"column_start":12,"column_end":31},"name":"simd_select_bitmask","qualname":"::core_arch::simd_llvm::simd_select_bitmask","value":"fn <M, T> (m: M, a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7439},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2496601,"byte_end":2496610,"line_start":54,"line_end":54,"column_start":12,"column_end":21},"name":"simd_fmin","qualname":"::core_arch::simd_llvm::simd_fmin","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7441},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2496643,"byte_end":2496652,"line_start":55,"line_end":55,"column_start":12,"column_end":21},"name":"simd_fmax","qualname":"::core_arch::simd_llvm::simd_fmax","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7443},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2496686,"byte_end":2496696,"line_start":57,"line_end":57,"column_start":12,"column_end":22},"name":"simd_fsqrt","qualname":"::core_arch::simd_llvm::simd_fsqrt","value":"fn <T> (a: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":7445},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2496723,"byte_end":2496731,"line_start":58,"line_end":58,"column_start":12,"column_end":20},"name":"simd_fma","qualname":"::core_arch::simd_llvm::simd_fma","value":"fn <T> (a: T, b: T, c: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":36982},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2498543,"byte_end":2498548,"line_start":51,"line_end":51,"column_start":16,"column_end":21},"name":"__m64","qualname":"::core_arch::x86::__m64","value":"","parent":null,"children":[],"decl_id":null,"docs":" 64-bit wide integer vector type, x86-specific","sig":null,"attributes":[{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2487995,"byte_end":2488025,"line_start":276,"line_end":276,"column_start":9,"column_end":39}},{"value":"repr(simd)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488034,"byte_end":2488047,"line_start":277,"line_end":277,"column_start":9,"column_end":22}},{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488056,"byte_end":2488104,"line_start":278,"line_end":278,"column_start":9,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488113,"byte_end":2488143,"line_start":279,"line_end":279,"column_start":9,"column_end":39}}]},{"kind":"Struct","id":{"krate":0,"index":36990},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2500256,"byte_end":2500263,"line_start":95,"line_end":95,"column_start":16,"column_end":23},"name":"__m128i","qualname":"::core_arch::x86::__m128i","value":"","parent":null,"children":[],"decl_id":null,"docs":" 128-bit wide integer vector type, x86-specific","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2487939,"byte_end":2487946,"line_start":274,"line_end":274,"column_start":11,"column_end":18}},{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2487995,"byte_end":2488025,"line_start":276,"line_end":276,"column_start":9,"column_end":39}},{"value":"repr(simd)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488034,"byte_end":2488047,"line_start":277,"line_end":277,"column_start":9,"column_end":22}},{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488056,"byte_end":2488104,"line_start":278,"line_end":278,"column_start":9,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488113,"byte_end":2488143,"line_start":279,"line_end":279,"column_start":9,"column_end":39}}]},{"kind":"Struct","id":{"krate":0,"index":36999},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2501686,"byte_end":2501692,"line_start":132,"line_end":132,"column_start":16,"column_end":22},"name":"__m128","qualname":"::core_arch::x86::__m128","value":"","parent":null,"children":[],"decl_id":null,"docs":" 128-bit wide set of four `f32` types, x86-specific","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2487939,"byte_end":2487946,"line_start":274,"line_end":274,"column_start":11,"column_end":18}},{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2487995,"byte_end":2488025,"line_start":276,"line_end":276,"column_start":9,"column_end":39}},{"value":"repr(simd)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488034,"byte_end":2488047,"line_start":277,"line_end":277,"column_start":9,"column_end":22}},{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488056,"byte_end":2488104,"line_start":278,"line_end":278,"column_start":9,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488113,"byte_end":2488143,"line_start":279,"line_end":279,"column_start":9,"column_end":39}}]},{"kind":"Struct","id":{"krate":0,"index":37010},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2503112,"byte_end":2503119,"line_start":169,"line_end":169,"column_start":16,"column_end":23},"name":"__m128d","qualname":"::core_arch::x86::__m128d","value":"","parent":null,"children":[],"decl_id":null,"docs":" 128-bit wide set of two `f64` types, x86-specific","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2487939,"byte_end":2487946,"line_start":274,"line_end":274,"column_start":11,"column_end":18}},{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2487995,"byte_end":2488025,"line_start":276,"line_end":276,"column_start":9,"column_end":39}},{"value":"repr(simd)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488034,"byte_end":2488047,"line_start":277,"line_end":277,"column_start":9,"column_end":22}},{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488056,"byte_end":2488104,"line_start":278,"line_end":278,"column_start":9,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488113,"byte_end":2488143,"line_start":279,"line_end":279,"column_start":9,"column_end":39}}]},{"kind":"Struct","id":{"krate":0,"index":37019},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2504702,"byte_end":2504709,"line_start":210,"line_end":210,"column_start":16,"column_end":23},"name":"__m256i","qualname":"::core_arch::x86::__m256i","value":"","parent":null,"children":[],"decl_id":null,"docs":" 256-bit wide integer vector type, x86-specific","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2487939,"byte_end":2487946,"line_start":274,"line_end":274,"column_start":11,"column_end":18}},{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2487995,"byte_end":2488025,"line_start":276,"line_end":276,"column_start":9,"column_end":39}},{"value":"repr(simd)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488034,"byte_end":2488047,"line_start":277,"line_end":277,"column_start":9,"column_end":22}},{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488056,"byte_end":2488104,"line_start":278,"line_end":278,"column_start":9,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488113,"byte_end":2488143,"line_start":279,"line_end":279,"column_start":9,"column_end":39}}]},{"kind":"Struct","id":{"krate":0,"index":37030},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2506180,"byte_end":2506186,"line_start":247,"line_end":247,"column_start":16,"column_end":22},"name":"__m256","qualname":"::core_arch::x86::__m256","value":"","parent":null,"children":[],"decl_id":null,"docs":" 256-bit wide set of eight `f32` types, x86-specific","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2487939,"byte_end":2487946,"line_start":274,"line_end":274,"column_start":11,"column_end":18}},{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2487995,"byte_end":2488025,"line_start":276,"line_end":276,"column_start":9,"column_end":39}},{"value":"repr(simd)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488034,"byte_end":2488047,"line_start":277,"line_end":277,"column_start":9,"column_end":22}},{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488056,"byte_end":2488104,"line_start":278,"line_end":278,"column_start":9,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488113,"byte_end":2488143,"line_start":279,"line_end":279,"column_start":9,"column_end":39}}]},{"kind":"Struct","id":{"krate":0,"index":37045},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2507654,"byte_end":2507661,"line_start":284,"line_end":284,"column_start":16,"column_end":23},"name":"__m256d","qualname":"::core_arch::x86::__m256d","value":"","parent":null,"children":[],"decl_id":null,"docs":" 256-bit wide set of four `f64` types, x86-specific","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2487939,"byte_end":2487946,"line_start":274,"line_end":274,"column_start":11,"column_end":18}},{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2487995,"byte_end":2488025,"line_start":276,"line_end":276,"column_start":9,"column_end":39}},{"value":"repr(simd)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488034,"byte_end":2488047,"line_start":277,"line_end":277,"column_start":9,"column_end":22}},{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488056,"byte_end":2488104,"line_start":278,"line_end":278,"column_start":9,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488113,"byte_end":2488143,"line_start":279,"line_end":279,"column_start":9,"column_end":39}}]},{"kind":"Struct","id":{"krate":0,"index":37056},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2508652,"byte_end":2508659,"line_start":305,"line_end":305,"column_start":16,"column_end":23},"name":"__m512i","qualname":"::core_arch::x86::__m512i","value":"","parent":null,"children":[],"decl_id":null,"docs":" 512-bit wide integer vector type, x86-specific","sig":null,"attributes":[{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2487995,"byte_end":2488025,"line_start":276,"line_end":276,"column_start":9,"column_end":39}},{"value":"repr(simd)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488034,"byte_end":2488047,"line_start":277,"line_end":277,"column_start":9,"column_end":22}},{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488056,"byte_end":2488104,"line_start":278,"line_end":278,"column_start":9,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488113,"byte_end":2488143,"line_start":279,"line_end":279,"column_start":9,"column_end":39}}]},{"kind":"Struct","id":{"krate":0,"index":37071},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2509539,"byte_end":2509545,"line_start":322,"line_end":322,"column_start":16,"column_end":22},"name":"__m512","qualname":"::core_arch::x86::__m512","value":"","parent":null,"children":[],"decl_id":null,"docs":" 512-bit wide set of sixteen `f32` types, x86-specific","sig":null,"attributes":[{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2487995,"byte_end":2488025,"line_start":276,"line_end":276,"column_start":9,"column_end":39}},{"value":"repr(simd)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488034,"byte_end":2488047,"line_start":277,"line_end":277,"column_start":9,"column_end":22}},{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488056,"byte_end":2488104,"line_start":278,"line_end":278,"column_start":9,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488113,"byte_end":2488143,"line_start":279,"line_end":279,"column_start":9,"column_end":39}}]},{"kind":"Struct","id":{"krate":0,"index":37094},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2510482,"byte_end":2510489,"line_start":342,"line_end":342,"column_start":16,"column_end":23},"name":"__m512d","qualname":"::core_arch::x86::__m512d","value":"","parent":null,"children":[],"decl_id":null,"docs":" 512-bit wide set of eight `f64` types, x86-specific","sig":null,"attributes":[{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2487995,"byte_end":2488025,"line_start":276,"line_end":276,"column_start":9,"column_end":39}},{"value":"repr(simd)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488034,"byte_end":2488047,"line_start":277,"line_end":277,"column_start":9,"column_end":22}},{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488056,"byte_end":2488104,"line_start":278,"line_end":278,"column_start":9,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2488113,"byte_end":2488143,"line_start":279,"line_end":279,"column_start":9,"column_end":39}}]},{"kind":"Type","id":{"krate":0,"index":7457},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2510644,"byte_end":2510653,"line_start":347,"line_end":347,"column_start":10,"column_end":19},"name":"__mmask16","qualname":"::core_arch::x86::__mmask16","value":"i16","parent":null,"children":[],"decl_id":null,"docs":" The `__mmask16` type used in AVX-512 intrinsics, a 16-bit integer\n","sig":null,"attributes":[{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2510604,"byte_end":2510634,"line_start":346,"line_end":346,"column_start":1,"column_end":31}}]},{"kind":"Method","id":{"krate":0,"index":7459},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2510849,"byte_end":2510857,"line_start":357,"line_end":357,"column_start":8,"column_end":16},"name":"as_m128i","qualname":"::core_arch::x86::m128iExt::as_m128i","value":"fn (self) -> __m128i","parent":{"krate":0,"index":7458},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7460},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2510898,"byte_end":2510906,"line_start":360,"line_end":360,"column_start":8,"column_end":16},"name":"as_u8x16","qualname":"::core_arch::x86::m128iExt::as_u8x16","value":"fn (self) -> crate::core_arch::simd::u8x16","parent":{"krate":0,"index":7458},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2510881,"byte_end":2510890,"line_start":359,"line_end":359,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7461},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2511022,"byte_end":2511030,"line_start":365,"line_end":365,"column_start":8,"column_end":16},"name":"as_u16x8","qualname":"::core_arch::x86::m128iExt::as_u16x8","value":"fn (self) -> crate::core_arch::simd::u16x8","parent":{"krate":0,"index":7458},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2511005,"byte_end":2511014,"line_start":364,"line_end":364,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7462},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2511146,"byte_end":2511154,"line_start":370,"line_end":370,"column_start":8,"column_end":16},"name":"as_u32x4","qualname":"::core_arch::x86::m128iExt::as_u32x4","value":"fn (self) -> crate::core_arch::simd::u32x4","parent":{"krate":0,"index":7458},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2511129,"byte_end":2511138,"line_start":369,"line_end":369,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7463},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2511270,"byte_end":2511278,"line_start":375,"line_end":375,"column_start":8,"column_end":16},"name":"as_u64x2","qualname":"::core_arch::x86::m128iExt::as_u64x2","value":"fn (self) -> crate::core_arch::simd::u64x2","parent":{"krate":0,"index":7458},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2511253,"byte_end":2511262,"line_start":374,"line_end":374,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7464},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2511394,"byte_end":2511402,"line_start":380,"line_end":380,"column_start":8,"column_end":16},"name":"as_i8x16","qualname":"::core_arch::x86::m128iExt::as_i8x16","value":"fn (self) -> crate::core_arch::simd::i8x16","parent":{"krate":0,"index":7458},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2511377,"byte_end":2511386,"line_start":379,"line_end":379,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7465},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2511518,"byte_end":2511526,"line_start":385,"line_end":385,"column_start":8,"column_end":16},"name":"as_i16x8","qualname":"::core_arch::x86::m128iExt::as_i16x8","value":"fn (self) -> crate::core_arch::simd::i16x8","parent":{"krate":0,"index":7458},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2511501,"byte_end":2511510,"line_start":384,"line_end":384,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7466},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2511642,"byte_end":2511650,"line_start":390,"line_end":390,"column_start":8,"column_end":16},"name":"as_i32x4","qualname":"::core_arch::x86::m128iExt::as_i32x4","value":"fn (self) -> crate::core_arch::simd::i32x4","parent":{"krate":0,"index":7458},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2511625,"byte_end":2511634,"line_start":389,"line_end":389,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7467},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2511766,"byte_end":2511774,"line_start":395,"line_end":395,"column_start":8,"column_end":16},"name":"as_i64x2","qualname":"::core_arch::x86::m128iExt::as_i64x2","value":"fn (self) -> crate::core_arch::simd::i64x2","parent":{"krate":0,"index":7458},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2511749,"byte_end":2511758,"line_start":394,"line_end":394,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7471},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2512094,"byte_end":2512102,"line_start":410,"line_end":410,"column_start":8,"column_end":16},"name":"as_m256i","qualname":"::core_arch::x86::m256iExt::as_m256i","value":"fn (self) -> __m256i","parent":{"krate":0,"index":7470},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7472},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2512143,"byte_end":2512151,"line_start":413,"line_end":413,"column_start":8,"column_end":16},"name":"as_u8x32","qualname":"::core_arch::x86::m256iExt::as_u8x32","value":"fn (self) -> crate::core_arch::simd::u8x32","parent":{"krate":0,"index":7470},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2512126,"byte_end":2512135,"line_start":412,"line_end":412,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7473},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2512267,"byte_end":2512276,"line_start":418,"line_end":418,"column_start":8,"column_end":17},"name":"as_u16x16","qualname":"::core_arch::x86::m256iExt::as_u16x16","value":"fn (self) -> crate::core_arch::simd::u16x16","parent":{"krate":0,"index":7470},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2512250,"byte_end":2512259,"line_start":417,"line_end":417,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7474},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2512393,"byte_end":2512401,"line_start":423,"line_end":423,"column_start":8,"column_end":16},"name":"as_u32x8","qualname":"::core_arch::x86::m256iExt::as_u32x8","value":"fn (self) -> crate::core_arch::simd::u32x8","parent":{"krate":0,"index":7470},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2512376,"byte_end":2512385,"line_start":422,"line_end":422,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7475},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2512517,"byte_end":2512525,"line_start":428,"line_end":428,"column_start":8,"column_end":16},"name":"as_u64x4","qualname":"::core_arch::x86::m256iExt::as_u64x4","value":"fn (self) -> crate::core_arch::simd::u64x4","parent":{"krate":0,"index":7470},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2512500,"byte_end":2512509,"line_start":427,"line_end":427,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7476},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2512641,"byte_end":2512649,"line_start":433,"line_end":433,"column_start":8,"column_end":16},"name":"as_i8x32","qualname":"::core_arch::x86::m256iExt::as_i8x32","value":"fn (self) -> crate::core_arch::simd::i8x32","parent":{"krate":0,"index":7470},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2512624,"byte_end":2512633,"line_start":432,"line_end":432,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7477},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2512765,"byte_end":2512774,"line_start":438,"line_end":438,"column_start":8,"column_end":17},"name":"as_i16x16","qualname":"::core_arch::x86::m256iExt::as_i16x16","value":"fn (self) -> crate::core_arch::simd::i16x16","parent":{"krate":0,"index":7470},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2512748,"byte_end":2512757,"line_start":437,"line_end":437,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7478},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2512891,"byte_end":2512899,"line_start":443,"line_end":443,"column_start":8,"column_end":16},"name":"as_i32x8","qualname":"::core_arch::x86::m256iExt::as_i32x8","value":"fn (self) -> crate::core_arch::simd::i32x8","parent":{"krate":0,"index":7470},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2512874,"byte_end":2512883,"line_start":442,"line_end":442,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7479},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2513015,"byte_end":2513023,"line_start":448,"line_end":448,"column_start":8,"column_end":16},"name":"as_i64x4","qualname":"::core_arch::x86::m256iExt::as_i64x4","value":"fn (self) -> crate::core_arch::simd::i64x4","parent":{"krate":0,"index":7470},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2512998,"byte_end":2513007,"line_start":447,"line_end":447,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7483},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2513343,"byte_end":2513351,"line_start":463,"line_end":463,"column_start":8,"column_end":16},"name":"as_m512i","qualname":"::core_arch::x86::m512iExt::as_m512i","value":"fn (self) -> __m512i","parent":{"krate":0,"index":7482},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7484},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2513392,"byte_end":2513401,"line_start":466,"line_end":466,"column_start":8,"column_end":17},"name":"as_i32x16","qualname":"::core_arch::x86::m512iExt::as_i32x16","value":"fn (self) -> crate::core_arch::simd::i32x16","parent":{"krate":0,"index":7482},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2513375,"byte_end":2513384,"line_start":465,"line_end":465,"column_start":5,"column_end":14}}]},{"kind":"Function","id":{"krate":0,"index":7488},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/eflags.rs","byte_start":2518699,"byte_end":2518711,"line_start":31,"line_end":31,"column_start":15,"column_end":27},"name":"__readeflags","qualname":"::core_arch::x86::eflags::__readeflags","value":"fn () -> u64","parent":null,"children":[],"decl_id":null,"docs":" Reads EFLAGS.","sig":null,"attributes":[{"value":"cfg(target_arch = \"x86_64\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/eflags.rs","byte_start":2518464,"byte_end":2518494,"line_start":23,"line_end":23,"column_start":1,"column_end":31}},{"value":"inline(always)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/eflags.rs","byte_start":2518495,"byte_end":2518512,"line_start":24,"line_end":24,"column_start":1,"column_end":18}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/eflags.rs","byte_start":2518513,"byte_end":2518562,"line_start":25,"line_end":25,"column_start":1,"column_end":50}},{"value":"rustc_deprecated(since = \"1.29.0\",\n                   reason = \"See issue #51810 - use inline assembly instead\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/eflags.rs","byte_start":2518563,"byte_end":2518669,"line_start":26,"line_end":29,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":7489},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/eflags.rs","byte_start":2519656,"byte_end":2519669,"line_start":63,"line_end":63,"column_start":15,"column_end":28},"name":"__writeeflags","qualname":"::core_arch::x86::eflags::__writeeflags","value":"fn (eflags: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Write EFLAGS.","sig":null,"attributes":[{"value":"cfg(target_arch = \"x86_64\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/eflags.rs","byte_start":2519421,"byte_end":2519451,"line_start":55,"line_end":55,"column_start":1,"column_end":31}},{"value":"inline(always)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/eflags.rs","byte_start":2519452,"byte_end":2519469,"line_start":56,"line_end":56,"column_start":1,"column_end":18}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/eflags.rs","byte_start":2519470,"byte_end":2519519,"line_start":57,"line_end":57,"column_start":1,"column_end":50}},{"value":"rustc_deprecated(since = \"1.29.0\",\n                   reason = \"See issue #51810 - use inline assembly instead\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/eflags.rs","byte_start":2519520,"byte_end":2519626,"line_start":58,"line_end":61,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":7495},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fxsr.rs","byte_start":2521138,"byte_end":2521145,"line_start":30,"line_end":30,"column_start":15,"column_end":22},"name":"_fxsave","qualname":"::core_arch::x86::fxsr::_fxsave","value":"fn (mem_addr: *mut u8) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Saves the `x87` FPU, `MMX` technology, `XMM`, and `MXCSR` registers to the\n 512-byte-long 16-byte-aligned memory region `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fxsr.rs","byte_start":2520989,"byte_end":2520998,"line_start":26,"line_end":26,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fxsr\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fxsr.rs","byte_start":2520999,"byte_end":2521033,"line_start":27,"line_end":27,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fxsr.rs","byte_start":2521074,"byte_end":2521123,"line_start":29,"line_end":29,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7496},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fxsr.rs","byte_start":2522011,"byte_end":2522019,"line_start":54,"line_end":54,"column_start":15,"column_end":23},"name":"_fxrstor","qualname":"::core_arch::x86::fxsr::_fxrstor","value":"fn (mem_addr: *const u8) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Restores the `XMM`, `MMX`, `MXCSR`, and `x87` FPU registers from the\n 512-byte-long 16-byte-aligned memory region `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fxsr.rs","byte_start":2521861,"byte_end":2521870,"line_start":50,"line_end":50,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fxsr\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fxsr.rs","byte_start":2521871,"byte_end":2521905,"line_start":51,"line_end":51,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fxsr.rs","byte_start":2521947,"byte_end":2521996,"line_start":53,"line_end":53,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7499},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bswap.rs","byte_start":2523837,"byte_end":2523843,"line_start":13,"line_end":13,"column_start":15,"column_end":21},"name":"_bswap","qualname":"::core_arch::x86::bswap::_bswap","value":"fn (x: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Returns an integer with the reversed byte order of x","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bswap.rs","byte_start":2523724,"byte_end":2523733,"line_start":10,"line_end":10,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bswap.rs","byte_start":2523773,"byte_end":2523822,"line_start":12,"line_end":12,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7504},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdtsc.rs","byte_start":2525138,"byte_end":2525144,"line_start":25,"line_end":25,"column_start":15,"column_end":21},"name":"_rdtsc","qualname":"::core_arch::x86::rdtsc::_rdtsc","value":"fn () -> u64","parent":null,"children":[],"decl_id":null,"docs":" Reads the current value of the processor’s time-stamp counter.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdtsc.rs","byte_start":2525025,"byte_end":2525034,"line_start":22,"line_end":22,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdtsc.rs","byte_start":2525074,"byte_end":2525123,"line_start":24,"line_end":24,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7505},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdtsc.rs","byte_start":2525998,"byte_end":2526006,"line_start":48,"line_end":48,"column_start":15,"column_end":23},"name":"__rdtscp","qualname":"::core_arch::x86::rdtsc::__rdtscp","value":"fn (aux: *mut u32) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Reads the current value of the processor’s time-stamp counter and\n the `IA32_TSC_AUX MSR`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdtsc.rs","byte_start":2525884,"byte_end":2525893,"line_start":45,"line_end":45,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdtsc.rs","byte_start":2525934,"byte_end":2525983,"line_start":47,"line_end":47,"column_start":1,"column_end":50}}]},{"kind":"Struct","id":{"krate":0,"index":37109},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2527117,"byte_end":2527128,"line_start":12,"line_end":12,"column_start":12,"column_end":23},"name":"CpuidResult","qualname":"::core_arch::x86::cpuid::CpuidResult","value":"CpuidResult { eax, ebx, ecx, edx }","parent":null,"children":[{"krate":0,"index":37110},{"krate":0,"index":37111},{"krate":0,"index":37112},{"krate":0,"index":37113}],"decl_id":null,"docs":" Result of the `cpuid` instruction.\n","sig":null,"attributes":[{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2526865,"byte_end":2526913,"line_start":8,"line_end":8,"column_start":1,"column_end":49}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2527056,"byte_end":2527105,"line_start":11,"line_end":11,"column_start":1,"column_end":50}},{"value":"structural_match","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2527106,"byte_end":2527508,"line_start":12,"line_end":25,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2527106,"byte_end":2527508,"line_start":12,"line_end":25,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":37110},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2527215,"byte_end":2527218,"line_start":15,"line_end":15,"column_start":9,"column_end":12},"name":"eax","qualname":"::core_arch::x86::cpuid::CpuidResult::eax","value":"u32","parent":{"krate":0,"index":37109},"children":[],"decl_id":null,"docs":" EAX register.\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2527157,"byte_end":2527206,"line_start":14,"line_end":14,"column_start":5,"column_end":54}}]},{"kind":"Field","id":{"krate":0,"index":37111},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2527309,"byte_end":2527312,"line_start":18,"line_end":18,"column_start":9,"column_end":12},"name":"ebx","qualname":"::core_arch::x86::cpuid::CpuidResult::ebx","value":"u32","parent":{"krate":0,"index":37109},"children":[],"decl_id":null,"docs":" EBX register.\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2527251,"byte_end":2527300,"line_start":17,"line_end":17,"column_start":5,"column_end":54}}]},{"kind":"Field","id":{"krate":0,"index":37112},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2527403,"byte_end":2527406,"line_start":21,"line_end":21,"column_start":9,"column_end":12},"name":"ecx","qualname":"::core_arch::x86::cpuid::CpuidResult::ecx","value":"u32","parent":{"krate":0,"index":37109},"children":[],"decl_id":null,"docs":" ECX register.\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2527345,"byte_end":2527394,"line_start":20,"line_end":20,"column_start":5,"column_end":54}}]},{"kind":"Field","id":{"krate":0,"index":37113},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2527497,"byte_end":2527500,"line_start":24,"line_end":24,"column_start":9,"column_end":12},"name":"edx","qualname":"::core_arch::x86::cpuid::CpuidResult::edx","value":"u32","parent":{"krate":0,"index":37109},"children":[],"decl_id":null,"docs":" EDX register.\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2527439,"byte_end":2527488,"line_start":23,"line_end":23,"column_start":5,"column_end":54}}]},{"kind":"Function","id":{"krate":0,"index":7511},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2528764,"byte_end":2528777,"line_start":53,"line_end":53,"column_start":15,"column_end":28},"name":"__cpuid_count","qualname":"::core_arch::x86::cpuid::__cpuid_count","value":"fn (leaf: u32, sub_leaf: u32) -> CpuidResult","parent":null,"children":[],"decl_id":null,"docs":" Returns the result of the `cpuid` instruction for a given `leaf` (`EAX`)\n and\n `sub_leaf` (`ECX`).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2528651,"byte_end":2528660,"line_start":50,"line_end":50,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2528700,"byte_end":2528749,"line_start":52,"line_end":52,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7512},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2529567,"byte_end":2529574,"line_start":80,"line_end":80,"column_start":15,"column_end":22},"name":"__cpuid","qualname":"::core_arch::x86::cpuid::__cpuid","value":"fn (leaf: u32) -> CpuidResult","parent":null,"children":[],"decl_id":null,"docs":" See [`__cpuid_count`](fn.__cpuid_count.html).\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2529454,"byte_end":2529463,"line_start":77,"line_end":77,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2529503,"byte_end":2529552,"line_start":79,"line_end":79,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7513},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2529701,"byte_end":2529710,"line_start":86,"line_end":86,"column_start":8,"column_end":17},"name":"has_cpuid","qualname":"::core_arch::x86::cpuid::has_cpuid","value":"fn () -> bool","parent":null,"children":[],"decl_id":null,"docs":" Does the host support the `cpuid` instruction?\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2529684,"byte_end":2529693,"line_start":85,"line_end":85,"column_start":1,"column_end":10}}]},{"kind":"Function","id":{"krate":0,"index":7514},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2532822,"byte_end":2532837,"line_start":167,"line_end":167,"column_start":15,"column_end":30},"name":"__get_cpuid_max","qualname":"::core_arch::x86::cpuid::__get_cpuid_max","value":"fn (leaf: u32) -> (u32, u32)","parent":null,"children":[],"decl_id":null,"docs":" Returns the highest-supported `leaf` (`EAX`) and sub-leaf (`ECX`) `cpuid`\n values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2532748,"byte_end":2532757,"line_start":165,"line_end":165,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2532758,"byte_end":2532807,"line_start":166,"line_end":166,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7525},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2534776,"byte_end":2534782,"line_start":39,"line_end":39,"column_start":15,"column_end":21},"name":"_xsave","qualname":"::core_arch::x86::xsave::_xsave","value":"fn (mem_addr: *mut u8, save_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial save of the enabled processor states to memory at\n `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2534627,"byte_end":2534636,"line_start":35,"line_end":35,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2534637,"byte_end":2534672,"line_start":36,"line_end":36,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2534712,"byte_end":2534761,"line_start":38,"line_end":38,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7526},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2535443,"byte_end":2535450,"line_start":55,"line_end":55,"column_start":15,"column_end":22},"name":"_xrstor","qualname":"::core_arch::x86::xsave::_xrstor","value":"fn (mem_addr: *const u8, rs_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial restore of the enabled processor states using\n the state information stored in memory at `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2535293,"byte_end":2535302,"line_start":51,"line_end":51,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2535303,"byte_end":2535338,"line_start":52,"line_end":52,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2535379,"byte_end":2535428,"line_start":54,"line_end":54,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7527},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2535704,"byte_end":2535730,"line_start":63,"line_end":63,"column_start":11,"column_end":37},"name":"_XCR_XFEATURE_ENABLED_MASK","qualname":"::core_arch::x86::xsave::_XCR_XFEATURE_ENABLED_MASK","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" `XFEATURE_ENABLED_MASK` for `XCR`","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2535644,"byte_end":2535693,"line_start":62,"line_end":62,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7528},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2536160,"byte_end":2536167,"line_start":75,"line_end":75,"column_start":15,"column_end":22},"name":"_xsetbv","qualname":"::core_arch::x86::xsave::_xsetbv","value":"fn (a: u32, val: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies 64-bits from `val` to the extended control register (`XCR`) specified\n by `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2536010,"byte_end":2536019,"line_start":71,"line_end":71,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2536020,"byte_end":2536055,"line_start":72,"line_end":72,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2536096,"byte_end":2536145,"line_start":74,"line_end":74,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7529},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2536585,"byte_end":2536592,"line_start":87,"line_end":87,"column_start":15,"column_end":22},"name":"_xgetbv","qualname":"::core_arch::x86::xsave::_xgetbv","value":"fn (xcr_no: u32) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Reads the contents of the extended control register `XCR`\n specified in `xcr_no`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2536435,"byte_end":2536444,"line_start":83,"line_end":83,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2536445,"byte_end":2536480,"line_start":84,"line_end":84,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2536521,"byte_end":2536570,"line_start":86,"line_end":86,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7530},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2537426,"byte_end":2537435,"line_start":107,"line_end":107,"column_start":15,"column_end":24},"name":"_xsaveopt","qualname":"::core_arch::x86::xsave::_xsaveopt","value":"fn (mem_addr: *mut u8, save_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial save of the enabled processor states to memory at\n `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2537265,"byte_end":2537274,"line_start":103,"line_end":103,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave,xsaveopt\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2537275,"byte_end":2537319,"line_start":104,"line_end":104,"column_start":1,"column_end":45}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2537362,"byte_end":2537411,"line_start":106,"line_end":106,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7531},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2538133,"byte_end":2538140,"line_start":123,"line_end":123,"column_start":15,"column_end":22},"name":"_xsavec","qualname":"::core_arch::x86::xsave::_xsavec","value":"fn (mem_addr: *mut u8, save_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial save of the enabled processor states to memory\n at `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2537976,"byte_end":2537985,"line_start":119,"line_end":119,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave,xsavec\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2537986,"byte_end":2538028,"line_start":120,"line_end":120,"column_start":1,"column_end":43}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2538069,"byte_end":2538118,"line_start":122,"line_end":122,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7532},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2538901,"byte_end":2538908,"line_start":140,"line_end":140,"column_start":15,"column_end":22},"name":"_xsaves","qualname":"::core_arch::x86::xsave::_xsaves","value":"fn (mem_addr: *mut u8, save_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial save of the enabled processor states to memory at\n `mem_addr`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2538744,"byte_end":2538753,"line_start":136,"line_end":136,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave,xsaves\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2538754,"byte_end":2538796,"line_start":137,"line_end":137,"column_start":1,"column_end":43}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2538837,"byte_end":2538886,"line_start":139,"line_end":139,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7533},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2539814,"byte_end":2539822,"line_start":159,"line_end":159,"column_start":15,"column_end":23},"name":"_xrstors","qualname":"::core_arch::x86::xsave::_xrstors","value":"fn (mem_addr: *const u8, rs_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial restore of the enabled processor states using the\n state information stored in memory at `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2539656,"byte_end":2539665,"line_start":155,"line_end":155,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave,xsaves\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2539666,"byte_end":2539708,"line_start":156,"line_end":156,"column_start":1,"column_end":43}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2539750,"byte_end":2539799,"line_start":158,"line_end":158,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7544},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2543776,"byte_end":2543786,"line_start":19,"line_end":19,"column_start":15,"column_end":25},"name":"_mm_add_ss","qualname":"::core_arch::x86::sse::_mm_add_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Adds the first component of `a` and `b`, the other components are copied\n from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2543629,"byte_end":2543638,"line_start":15,"line_end":15,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2543639,"byte_end":2543672,"line_start":16,"line_end":16,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2543712,"byte_end":2543761,"line_start":18,"line_end":18,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7545},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2544123,"byte_end":2544133,"line_start":30,"line_end":30,"column_start":15,"column_end":25},"name":"_mm_add_ps","qualname":"::core_arch::x86::sse::_mm_add_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Adds __m128 vectors.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2543976,"byte_end":2543985,"line_start":26,"line_end":26,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2543986,"byte_end":2544019,"line_start":27,"line_end":27,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2544059,"byte_end":2544108,"line_start":29,"line_end":29,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7546},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2544545,"byte_end":2544555,"line_start":42,"line_end":42,"column_start":15,"column_end":25},"name":"_mm_sub_ss","qualname":"::core_arch::x86::sse::_mm_sub_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Subtracts the first component of `b` from `a`, the other components are\n copied from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2544398,"byte_end":2544407,"line_start":38,"line_end":38,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2544408,"byte_end":2544441,"line_start":39,"line_end":39,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2544481,"byte_end":2544530,"line_start":41,"line_end":41,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7547},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2544897,"byte_end":2544907,"line_start":53,"line_end":53,"column_start":15,"column_end":25},"name":"_mm_sub_ps","qualname":"::core_arch::x86::sse::_mm_sub_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Subtracts __m128 vectors.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2544750,"byte_end":2544759,"line_start":49,"line_end":49,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2544760,"byte_end":2544793,"line_start":50,"line_end":50,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2544833,"byte_end":2544882,"line_start":52,"line_end":52,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7548},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2545319,"byte_end":2545329,"line_start":65,"line_end":65,"column_start":15,"column_end":25},"name":"_mm_mul_ss","qualname":"::core_arch::x86::sse::_mm_mul_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the first component of `a` and `b`, the other components are\n copied from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2545172,"byte_end":2545181,"line_start":61,"line_end":61,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2545182,"byte_end":2545215,"line_start":62,"line_end":62,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2545255,"byte_end":2545304,"line_start":64,"line_end":64,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7549},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2545672,"byte_end":2545682,"line_start":76,"line_end":76,"column_start":15,"column_end":25},"name":"_mm_mul_ps","qualname":"::core_arch::x86::sse::_mm_mul_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies __m128 vectors.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2545525,"byte_end":2545534,"line_start":72,"line_end":72,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2545535,"byte_end":2545568,"line_start":73,"line_end":73,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2545608,"byte_end":2545657,"line_start":75,"line_end":75,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7550},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2546090,"byte_end":2546100,"line_start":88,"line_end":88,"column_start":15,"column_end":25},"name":"_mm_div_ss","qualname":"::core_arch::x86::sse::_mm_div_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Divides the first component of `b` by `a`, the other components are\n copied from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2545943,"byte_end":2545952,"line_start":84,"line_end":84,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2545953,"byte_end":2545986,"line_start":85,"line_end":85,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2546026,"byte_end":2546075,"line_start":87,"line_end":87,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7551},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2546440,"byte_end":2546450,"line_start":99,"line_end":99,"column_start":15,"column_end":25},"name":"_mm_div_ps","qualname":"::core_arch::x86::sse::_mm_div_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Divides __m128 vectors.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2546293,"byte_end":2546302,"line_start":95,"line_end":95,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2546303,"byte_end":2546336,"line_start":96,"line_end":96,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2546376,"byte_end":2546425,"line_start":98,"line_end":98,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7552},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2546903,"byte_end":2546914,"line_start":111,"line_end":111,"column_start":15,"column_end":26},"name":"_mm_sqrt_ss","qualname":"::core_arch::x86::sse::_mm_sqrt_ss","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns the square root of the first single-precision (32-bit)\n floating-point element in `a`, the other elements are unchanged.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2546755,"byte_end":2546764,"line_start":107,"line_end":107,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2546765,"byte_end":2546798,"line_start":108,"line_end":108,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2546839,"byte_end":2546888,"line_start":110,"line_end":110,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7553},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2547315,"byte_end":2547326,"line_start":123,"line_end":123,"column_start":15,"column_end":26},"name":"_mm_sqrt_ps","qualname":"::core_arch::x86::sse::_mm_sqrt_ps","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns the square root of packed single-precision (32-bit) floating-point\n elements in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2547167,"byte_end":2547176,"line_start":119,"line_end":119,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2547177,"byte_end":2547210,"line_start":120,"line_end":120,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2547251,"byte_end":2547300,"line_start":122,"line_end":122,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7554},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2547772,"byte_end":2547782,"line_start":135,"line_end":135,"column_start":15,"column_end":25},"name":"_mm_rcp_ss","qualname":"::core_arch::x86::sse::_mm_rcp_ss","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns the approximate reciprocal of the first single-precision\n (32-bit) floating-point element in `a`, the other elements are unchanged.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2547625,"byte_end":2547634,"line_start":131,"line_end":131,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2547635,"byte_end":2547668,"line_start":132,"line_end":132,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2547708,"byte_end":2547757,"line_start":134,"line_end":134,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7555},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2548191,"byte_end":2548201,"line_start":147,"line_end":147,"column_start":15,"column_end":25},"name":"_mm_rcp_ps","qualname":"::core_arch::x86::sse::_mm_rcp_ps","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns the approximate reciprocal of packed single-precision (32-bit)\n floating-point elements in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2548044,"byte_end":2548053,"line_start":143,"line_end":143,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2548054,"byte_end":2548087,"line_start":144,"line_end":144,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2548127,"byte_end":2548176,"line_start":146,"line_end":146,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7556},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2548662,"byte_end":2548674,"line_start":159,"line_end":159,"column_start":15,"column_end":27},"name":"_mm_rsqrt_ss","qualname":"::core_arch::x86::sse::_mm_rsqrt_ss","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns the approximate reciprocal square root of the fist single-precision\n (32-bit) floating-point elements in `a`, the other elements are unchanged.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2548513,"byte_end":2548522,"line_start":155,"line_end":155,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2548523,"byte_end":2548556,"line_start":156,"line_end":156,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2548598,"byte_end":2548647,"line_start":158,"line_end":158,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7557},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2549101,"byte_end":2549113,"line_start":171,"line_end":171,"column_start":15,"column_end":27},"name":"_mm_rsqrt_ps","qualname":"::core_arch::x86::sse::_mm_rsqrt_ps","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns the approximate reciprocal square root of packed single-precision\n (32-bit) floating-point elements in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2548952,"byte_end":2548961,"line_start":167,"line_end":167,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2548962,"byte_end":2548995,"line_start":168,"line_end":168,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2549037,"byte_end":2549086,"line_start":170,"line_end":170,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7558},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2549620,"byte_end":2549630,"line_start":184,"line_end":184,"column_start":15,"column_end":25},"name":"_mm_min_ss","qualname":"::core_arch::x86::sse::_mm_min_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the first single-precision (32-bit) floating-point element of `a`\n and `b`, and return the minimum value in the first element of the return\n value, the other elements are copied from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2549473,"byte_end":2549482,"line_start":180,"line_end":180,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2549483,"byte_end":2549516,"line_start":181,"line_end":181,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2549556,"byte_end":2549605,"line_start":183,"line_end":183,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7559},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2550077,"byte_end":2550087,"line_start":196,"line_end":196,"column_start":15,"column_end":25},"name":"_mm_min_ps","qualname":"::core_arch::x86::sse::_mm_min_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares packed single-precision (32-bit) floating-point elements in `a` and\n `b`, and return the corresponding minimum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2549930,"byte_end":2549939,"line_start":192,"line_end":192,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2549940,"byte_end":2549973,"line_start":193,"line_end":193,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2550013,"byte_end":2550062,"line_start":195,"line_end":195,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7560},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2550606,"byte_end":2550616,"line_start":209,"line_end":209,"column_start":15,"column_end":25},"name":"_mm_max_ss","qualname":"::core_arch::x86::sse::_mm_max_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the first single-precision (32-bit) floating-point element of `a`\n and `b`, and return the maximum value in the first element of the return\n value, the other elements are copied from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2550459,"byte_end":2550468,"line_start":205,"line_end":205,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2550469,"byte_end":2550502,"line_start":206,"line_end":206,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2550542,"byte_end":2550591,"line_start":208,"line_end":208,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7561},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2551063,"byte_end":2551073,"line_start":221,"line_end":221,"column_start":15,"column_end":25},"name":"_mm_max_ps","qualname":"::core_arch::x86::sse::_mm_max_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares packed single-precision (32-bit) floating-point elements in `a` and\n `b`, and return the corresponding maximum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2550916,"byte_end":2550925,"line_start":217,"line_end":217,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2550926,"byte_end":2550959,"line_start":218,"line_end":218,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2550999,"byte_end":2551048,"line_start":220,"line_end":220,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7562},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2551602,"byte_end":2551612,"line_start":236,"line_end":236,"column_start":15,"column_end":25},"name":"_mm_and_ps","qualname":"::core_arch::x86::sse::_mm_and_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Bitwise AND of packed single-precision (32-bit) floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2551315,"byte_end":2551324,"line_start":228,"line_end":228,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2551325,"byte_end":2551358,"line_start":229,"line_end":229,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2551538,"byte_end":2551587,"line_start":235,"line_end":235,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7563},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2552320,"byte_end":2552333,"line_start":257,"line_end":257,"column_start":15,"column_end":28},"name":"_mm_andnot_ps","qualname":"::core_arch::x86::sse::_mm_andnot_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Bitwise AND-NOT of packed single-precision (32-bit) floating-point\n elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2552019,"byte_end":2552028,"line_start":248,"line_end":248,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2552029,"byte_end":2552062,"line_start":249,"line_end":249,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2552256,"byte_end":2552305,"line_start":256,"line_end":256,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7564},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2553034,"byte_end":2553043,"line_start":275,"line_end":275,"column_start":15,"column_end":24},"name":"_mm_or_ps","qualname":"::core_arch::x86::sse::_mm_or_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Bitwise OR of packed single-precision (32-bit) floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2552746,"byte_end":2552755,"line_start":267,"line_end":267,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2552756,"byte_end":2552789,"line_start":268,"line_end":268,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2552970,"byte_end":2553019,"line_start":274,"line_end":274,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7565},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2553686,"byte_end":2553696,"line_start":293,"line_end":293,"column_start":15,"column_end":25},"name":"_mm_xor_ps","qualname":"::core_arch::x86::sse::_mm_xor_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Bitwise exclusive OR of packed single-precision (32-bit) floating-point\n elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2553396,"byte_end":2553405,"line_start":285,"line_end":285,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2553406,"byte_end":2553439,"line_start":286,"line_end":286,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2553622,"byte_end":2553671,"line_start":292,"line_end":292,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7566},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2554341,"byte_end":2554353,"line_start":308,"line_end":308,"column_start":15,"column_end":27},"name":"_mm_cmpeq_ss","qualname":"::core_arch::x86::sse::_mm_cmpeq_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lowest `f32` of both inputs for equality. The lowest 32 bits of\n the result will be `0xffffffff` if the two inputs are equal, or `0`\n otherwise. The upper 96 bits of the result are the upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2554192,"byte_end":2554201,"line_start":304,"line_end":304,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2554202,"byte_end":2554235,"line_start":305,"line_end":305,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2554277,"byte_end":2554326,"line_start":307,"line_end":307,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7567},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2554925,"byte_end":2554937,"line_start":322,"line_end":322,"column_start":15,"column_end":27},"name":"_mm_cmplt_ss","qualname":"::core_arch::x86::sse::_mm_cmplt_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lowest `f32` of both inputs for less than. The lowest 32 bits\n of the result will be `0xffffffff` if `a.extract(0)` is less than\n `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the\n upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2554776,"byte_end":2554785,"line_start":318,"line_end":318,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2554786,"byte_end":2554819,"line_start":319,"line_end":319,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2554861,"byte_end":2554910,"line_start":321,"line_end":321,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7568},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2555527,"byte_end":2555539,"line_start":336,"line_end":336,"column_start":15,"column_end":27},"name":"_mm_cmple_ss","qualname":"::core_arch::x86::sse::_mm_cmple_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lowest `f32` of both inputs for less than or equal. The lowest\n 32 bits of the result will be `0xffffffff` if `a.extract(0)` is less than\n or equal `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result\n are the upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2555378,"byte_end":2555387,"line_start":332,"line_end":332,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2555388,"byte_end":2555421,"line_start":333,"line_end":333,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2555463,"byte_end":2555512,"line_start":335,"line_end":335,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7569},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2556117,"byte_end":2556129,"line_start":350,"line_end":350,"column_start":15,"column_end":27},"name":"_mm_cmpgt_ss","qualname":"::core_arch::x86::sse::_mm_cmpgt_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lowest `f32` of both inputs for greater than. The lowest 32\n bits of the result will be `0xffffffff` if `a.extract(0)` is greater\n than `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result\n are the upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2555968,"byte_end":2555977,"line_start":346,"line_end":346,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2555978,"byte_end":2556011,"line_start":347,"line_end":347,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2556053,"byte_end":2556102,"line_start":349,"line_end":349,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7570},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2556757,"byte_end":2556769,"line_start":364,"line_end":364,"column_start":15,"column_end":27},"name":"_mm_cmpge_ss","qualname":"::core_arch::x86::sse::_mm_cmpge_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lowest `f32` of both inputs for greater than or equal. The\n lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is\n greater than or equal `b.extract(0)`, or `0` otherwise. The upper 96 bits\n of the result are the upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2556608,"byte_end":2556617,"line_start":360,"line_end":360,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2556618,"byte_end":2556651,"line_start":361,"line_end":361,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2556693,"byte_end":2556742,"line_start":363,"line_end":363,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7571},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2557379,"byte_end":2557392,"line_start":378,"line_end":378,"column_start":15,"column_end":28},"name":"_mm_cmpneq_ss","qualname":"::core_arch::x86::sse::_mm_cmpneq_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lowest `f32` of both inputs for inequality. The lowest 32 bits\n of the result will be `0xffffffff` if `a.extract(0)` is not equal to\n `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the\n upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2557229,"byte_end":2557238,"line_start":374,"line_end":374,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2557239,"byte_end":2557272,"line_start":375,"line_end":375,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2557315,"byte_end":2557364,"line_start":377,"line_end":377,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7572},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2557974,"byte_end":2557987,"line_start":392,"line_end":392,"column_start":15,"column_end":28},"name":"_mm_cmpnlt_ss","qualname":"::core_arch::x86::sse::_mm_cmpnlt_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lowest `f32` of both inputs for not-less-than. The lowest 32\n bits of the result will be `0xffffffff` if `a.extract(0)` is not less than\n `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the\n upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2557824,"byte_end":2557833,"line_start":388,"line_end":388,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2557834,"byte_end":2557867,"line_start":389,"line_end":389,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2557910,"byte_end":2557959,"line_start":391,"line_end":391,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7573},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2558590,"byte_end":2558603,"line_start":406,"line_end":406,"column_start":15,"column_end":28},"name":"_mm_cmpnle_ss","qualname":"::core_arch::x86::sse::_mm_cmpnle_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lowest `f32` of both inputs for not-less-than-or-equal. The\n lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not\n less than or equal to `b.extract(0)`, or `0` otherwise. The upper 96 bits\n of the result are the upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2558440,"byte_end":2558449,"line_start":402,"line_end":402,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2558450,"byte_end":2558483,"line_start":403,"line_end":403,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2558526,"byte_end":2558575,"line_start":405,"line_end":405,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7574},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2559191,"byte_end":2559204,"line_start":420,"line_end":420,"column_start":15,"column_end":28},"name":"_mm_cmpngt_ss","qualname":"::core_arch::x86::sse::_mm_cmpngt_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lowest `f32` of both inputs for not-greater-than. The lowest 32\n bits of the result will be `0xffffffff` if `a.extract(0)` is not greater\n than `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are\n the upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2559041,"byte_end":2559050,"line_start":416,"line_end":416,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2559051,"byte_end":2559084,"line_start":417,"line_end":417,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2559127,"byte_end":2559176,"line_start":419,"line_end":419,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7575},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2559845,"byte_end":2559858,"line_start":434,"line_end":434,"column_start":15,"column_end":28},"name":"_mm_cmpnge_ss","qualname":"::core_arch::x86::sse::_mm_cmpnge_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lowest `f32` of both inputs for not-greater-than-or-equal. The\n lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not\n greater than or equal to `b.extract(0)`, or `0` otherwise. The upper 96\n bits of the result are the upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2559695,"byte_end":2559704,"line_start":430,"line_end":430,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2559705,"byte_end":2559738,"line_start":431,"line_end":431,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2559781,"byte_end":2559830,"line_start":433,"line_end":433,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7576},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2560473,"byte_end":2560486,"line_start":448,"line_end":448,"column_start":15,"column_end":28},"name":"_mm_cmpord_ss","qualname":"::core_arch::x86::sse::_mm_cmpord_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Checks if the lowest `f32` of both inputs are ordered. The lowest 32 bits of\n the result will be `0xffffffff` if neither of `a.extract(0)` or\n `b.extract(0)` is a NaN, or `0` otherwise. The upper 96 bits of the result\n are the upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2560323,"byte_end":2560332,"line_start":444,"line_end":444,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2560333,"byte_end":2560366,"line_start":445,"line_end":445,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2560409,"byte_end":2560458,"line_start":447,"line_end":447,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7577},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2561071,"byte_end":2561086,"line_start":462,"line_end":462,"column_start":15,"column_end":30},"name":"_mm_cmpunord_ss","qualname":"::core_arch::x86::sse::_mm_cmpunord_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Checks if the lowest `f32` of both inputs are unordered. The lowest 32 bits\n of the result will be `0xffffffff` if any of `a.extract(0)` or\n `b.extract(0)` is a NaN, or `0` otherwise. The upper 96 bits of the result\n are the upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2560919,"byte_end":2560928,"line_start":458,"line_end":458,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2560929,"byte_end":2560962,"line_start":459,"line_end":459,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2561007,"byte_end":2561056,"line_start":461,"line_end":461,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7578},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2561599,"byte_end":2561611,"line_start":475,"line_end":475,"column_start":15,"column_end":27},"name":"_mm_cmpeq_ps","qualname":"::core_arch::x86::sse::_mm_cmpeq_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n The result in the output vector will be `0xffffffff` if the input elements\n were equal, or `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2561450,"byte_end":2561459,"line_start":471,"line_end":471,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2561460,"byte_end":2561493,"line_start":472,"line_end":472,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2561535,"byte_end":2561584,"line_start":474,"line_end":474,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7579},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562165,"byte_end":2562177,"line_start":488,"line_end":488,"column_start":15,"column_end":27},"name":"_mm_cmplt_ps","qualname":"::core_arch::x86::sse::_mm_cmplt_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n The result in the output vector will be `0xffffffff` if the input element\n in `a` is less than the corresponding element in `b`, or `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562016,"byte_end":2562025,"line_start":484,"line_end":484,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562026,"byte_end":2562059,"line_start":485,"line_end":485,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562101,"byte_end":2562150,"line_start":487,"line_end":487,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7580},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562747,"byte_end":2562759,"line_start":502,"line_end":502,"column_start":15,"column_end":27},"name":"_mm_cmple_ps","qualname":"::core_arch::x86::sse::_mm_cmple_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n The result in the output vector will be `0xffffffff` if the input element\n in `a` is less than or equal to the corresponding element in `b`, or `0`\n otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562598,"byte_end":2562607,"line_start":498,"line_end":498,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562608,"byte_end":2562641,"line_start":499,"line_end":499,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562683,"byte_end":2562732,"line_start":501,"line_end":501,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7581},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2563316,"byte_end":2563328,"line_start":515,"line_end":515,"column_start":15,"column_end":27},"name":"_mm_cmpgt_ps","qualname":"::core_arch::x86::sse::_mm_cmpgt_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n The result in the output vector will be `0xffffffff` if the input element\n in `a` is greater than the corresponding element in `b`, or `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2563167,"byte_end":2563176,"line_start":511,"line_end":511,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2563177,"byte_end":2563210,"line_start":512,"line_end":512,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2563252,"byte_end":2563301,"line_start":514,"line_end":514,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7582},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2563901,"byte_end":2563913,"line_start":529,"line_end":529,"column_start":15,"column_end":27},"name":"_mm_cmpge_ps","qualname":"::core_arch::x86::sse::_mm_cmpge_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n The result in the output vector will be `0xffffffff` if the input element\n in `a` is greater than or equal to the corresponding element in `b`, or `0`\n otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2563752,"byte_end":2563761,"line_start":525,"line_end":525,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2563762,"byte_end":2563795,"line_start":526,"line_end":526,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2563837,"byte_end":2563886,"line_start":528,"line_end":528,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7583},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564435,"byte_end":2564448,"line_start":542,"line_end":542,"column_start":15,"column_end":28},"name":"_mm_cmpneq_ps","qualname":"::core_arch::x86::sse::_mm_cmpneq_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n The result in the output vector will be `0xffffffff` if the input elements\n are **not** equal, or `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564285,"byte_end":2564294,"line_start":538,"line_end":538,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564295,"byte_end":2564328,"line_start":539,"line_end":539,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564371,"byte_end":2564420,"line_start":541,"line_end":541,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7584},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2565016,"byte_end":2565029,"line_start":556,"line_end":556,"column_start":15,"column_end":28},"name":"_mm_cmpnlt_ps","qualname":"::core_arch::x86::sse::_mm_cmpnlt_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n The result in the output vector will be `0xffffffff` if the input element\n in `a` is **not** less than the corresponding element in `b`, or `0`\n otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564866,"byte_end":2564875,"line_start":552,"line_end":552,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564876,"byte_end":2564909,"line_start":553,"line_end":553,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564952,"byte_end":2565001,"line_start":555,"line_end":555,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7585},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2565609,"byte_end":2565622,"line_start":570,"line_end":570,"column_start":15,"column_end":28},"name":"_mm_cmpnle_ps","qualname":"::core_arch::x86::sse::_mm_cmpnle_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n The result in the output vector will be `0xffffffff` if the input element\n in `a` is **not** less than or equal to the corresponding element in `b`, or\n `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2565459,"byte_end":2565468,"line_start":566,"line_end":566,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2565469,"byte_end":2565502,"line_start":567,"line_end":567,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2565545,"byte_end":2565594,"line_start":569,"line_end":569,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7586},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2566193,"byte_end":2566206,"line_start":584,"line_end":584,"column_start":15,"column_end":28},"name":"_mm_cmpngt_ps","qualname":"::core_arch::x86::sse::_mm_cmpngt_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n The result in the output vector will be `0xffffffff` if the input element\n in `a` is **not** greater than the corresponding element in `b`, or `0`\n otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2566043,"byte_end":2566052,"line_start":580,"line_end":580,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2566053,"byte_end":2566086,"line_start":581,"line_end":581,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2566129,"byte_end":2566178,"line_start":583,"line_end":583,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7587},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2566789,"byte_end":2566802,"line_start":598,"line_end":598,"column_start":15,"column_end":28},"name":"_mm_cmpnge_ps","qualname":"::core_arch::x86::sse::_mm_cmpnge_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n The result in the output vector will be `0xffffffff` if the input element\n in `a` is **not** greater than or equal to the corresponding element in `b`,\n or `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2566639,"byte_end":2566648,"line_start":594,"line_end":594,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2566649,"byte_end":2566682,"line_start":595,"line_end":595,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2566725,"byte_end":2566774,"line_start":597,"line_end":597,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7588},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2567433,"byte_end":2567446,"line_start":612,"line_end":612,"column_start":15,"column_end":28},"name":"_mm_cmpord_ps","qualname":"::core_arch::x86::sse::_mm_cmpord_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n Returns four floats that have one of two possible bit patterns. The element\n in the output vector will be `0xffffffff` if the input elements in `a` and\n `b` are ordered (i.e., neither of them is a NaN), or 0 otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2567283,"byte_end":2567292,"line_start":608,"line_end":608,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2567293,"byte_end":2567326,"line_start":609,"line_end":609,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2567369,"byte_end":2567418,"line_start":611,"line_end":611,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7589},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2568087,"byte_end":2568102,"line_start":626,"line_end":626,"column_start":15,"column_end":30},"name":"_mm_cmpunord_ps","qualname":"::core_arch::x86::sse::_mm_cmpunord_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n Returns four floats that have one of two possible bit patterns. The element\n in the output vector will be `0xffffffff` if the input elements in `a` and\n `b` are unordered (i.e., at least on of them is a NaN), or 0 otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2567935,"byte_end":2567944,"line_start":622,"line_end":622,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2567945,"byte_end":2567978,"line_start":623,"line_end":623,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2568023,"byte_end":2568072,"line_start":625,"line_end":625,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7590},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2568545,"byte_end":2568558,"line_start":638,"line_end":638,"column_start":15,"column_end":28},"name":"_mm_comieq_ss","qualname":"::core_arch::x86::sse::_mm_comieq_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if they are equal, or `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2568397,"byte_end":2568406,"line_start":634,"line_end":634,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2568407,"byte_end":2568440,"line_start":635,"line_end":635,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2568481,"byte_end":2568530,"line_start":637,"line_end":637,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7591},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2569033,"byte_end":2569046,"line_start":650,"line_end":650,"column_start":15,"column_end":28},"name":"_mm_comilt_ss","qualname":"::core_arch::x86::sse::_mm_comilt_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if the value from `a` is less than the one from `b`, or `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2568885,"byte_end":2568894,"line_start":646,"line_end":646,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2568895,"byte_end":2568928,"line_start":647,"line_end":647,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2568969,"byte_end":2569018,"line_start":649,"line_end":649,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7592},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2569537,"byte_end":2569550,"line_start":663,"line_end":663,"column_start":15,"column_end":28},"name":"_mm_comile_ss","qualname":"::core_arch::x86::sse::_mm_comile_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if the value from `a` is less than or equal to the one from `b`, or `0`\n otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2569389,"byte_end":2569398,"line_start":659,"line_end":659,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2569399,"byte_end":2569432,"line_start":660,"line_end":660,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2569473,"byte_end":2569522,"line_start":662,"line_end":662,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7593},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2570032,"byte_end":2570045,"line_start":676,"line_end":676,"column_start":15,"column_end":28},"name":"_mm_comigt_ss","qualname":"::core_arch::x86::sse::_mm_comigt_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if the value from `a` is greater than the one from `b`, or `0`\n otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2569884,"byte_end":2569893,"line_start":672,"line_end":672,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2569894,"byte_end":2569927,"line_start":673,"line_end":673,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2569968,"byte_end":2570017,"line_start":675,"line_end":675,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7594},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2570539,"byte_end":2570552,"line_start":689,"line_end":689,"column_start":15,"column_end":28},"name":"_mm_comige_ss","qualname":"::core_arch::x86::sse::_mm_comige_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if the value from `a` is greater than or equal to the one from `b`, or\n `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2570391,"byte_end":2570400,"line_start":685,"line_end":685,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2570401,"byte_end":2570434,"line_start":686,"line_end":686,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2570475,"byte_end":2570524,"line_start":688,"line_end":688,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7595},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2571002,"byte_end":2571016,"line_start":701,"line_end":701,"column_start":15,"column_end":29},"name":"_mm_comineq_ss","qualname":"::core_arch::x86::sse::_mm_comineq_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if they are **not** equal, or `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2570854,"byte_end":2570863,"line_start":697,"line_end":697,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2570864,"byte_end":2570897,"line_start":698,"line_end":698,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2570938,"byte_end":2570987,"line_start":700,"line_end":700,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7596},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2571545,"byte_end":2571559,"line_start":714,"line_end":714,"column_start":15,"column_end":29},"name":"_mm_ucomieq_ss","qualname":"::core_arch::x86::sse::_mm_ucomieq_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if they are equal, or `0` otherwise. This instruction will not signal\n an exception if either argument is a quiet NaN.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2571396,"byte_end":2571405,"line_start":710,"line_end":710,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2571406,"byte_end":2571439,"line_start":711,"line_end":711,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2571481,"byte_end":2571530,"line_start":713,"line_end":713,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7597},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2572126,"byte_end":2572140,"line_start":728,"line_end":728,"column_start":15,"column_end":29},"name":"_mm_ucomilt_ss","qualname":"::core_arch::x86::sse::_mm_ucomilt_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if the value from `a` is less than the one from `b`, or `0` otherwise.\n This instruction will not signal an exception if either argument is a quiet\n NaN.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2571977,"byte_end":2571986,"line_start":724,"line_end":724,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2571987,"byte_end":2572020,"line_start":725,"line_end":725,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2572062,"byte_end":2572111,"line_start":727,"line_end":727,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7598},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2572719,"byte_end":2572733,"line_start":742,"line_end":742,"column_start":15,"column_end":29},"name":"_mm_ucomile_ss","qualname":"::core_arch::x86::sse::_mm_ucomile_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if the value from `a` is less than or equal to the one from `b`, or `0`\n otherwise. This instruction will not signal an exception if either argument\n is a quiet NaN.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2572570,"byte_end":2572579,"line_start":738,"line_end":738,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2572580,"byte_end":2572613,"line_start":739,"line_end":739,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2572655,"byte_end":2572704,"line_start":741,"line_end":741,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7599},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2573303,"byte_end":2573317,"line_start":756,"line_end":756,"column_start":15,"column_end":29},"name":"_mm_ucomigt_ss","qualname":"::core_arch::x86::sse::_mm_ucomigt_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if the value from `a` is greater than the one from `b`, or `0`\n otherwise. This instruction will not signal an exception if either argument\n is a quiet NaN.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2573154,"byte_end":2573163,"line_start":752,"line_end":752,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2573164,"byte_end":2573197,"line_start":753,"line_end":753,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2573239,"byte_end":2573288,"line_start":755,"line_end":755,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7600},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2573899,"byte_end":2573913,"line_start":770,"line_end":770,"column_start":15,"column_end":29},"name":"_mm_ucomige_ss","qualname":"::core_arch::x86::sse::_mm_ucomige_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if the value from `a` is greater than or equal to the one from `b`, or\n `0` otherwise. This instruction will not signal an exception if either\n argument is a quiet NaN.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2573750,"byte_end":2573759,"line_start":766,"line_end":766,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2573760,"byte_end":2573793,"line_start":767,"line_end":767,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2573835,"byte_end":2573884,"line_start":769,"line_end":769,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7601},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2574451,"byte_end":2574466,"line_start":783,"line_end":783,"column_start":15,"column_end":30},"name":"_mm_ucomineq_ss","qualname":"::core_arch::x86::sse::_mm_ucomineq_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if they are **not** equal, or `0` otherwise. This instruction will not\n signal an exception if either argument is a quiet NaN.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2574302,"byte_end":2574311,"line_start":779,"line_end":779,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2574312,"byte_end":2574345,"line_start":780,"line_end":780,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2574387,"byte_end":2574436,"line_start":782,"line_end":782,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7602},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2575235,"byte_end":2575249,"line_start":801,"line_end":801,"column_start":15,"column_end":29},"name":"_mm_cvtss_si32","qualname":"::core_arch::x86::sse::_mm_cvtss_si32","value":"fn (a: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Converts the lowest 32 bit float in the input vector to a 32 bit integer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2575085,"byte_end":2575094,"line_start":797,"line_end":797,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2575095,"byte_end":2575128,"line_start":798,"line_end":798,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2575171,"byte_end":2575220,"line_start":800,"line_end":800,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7603},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2575611,"byte_end":2575624,"line_start":812,"line_end":812,"column_start":15,"column_end":28},"name":"_mm_cvt_ss2si","qualname":"::core_arch::x86::sse::_mm_cvt_ss2si","value":"fn (a: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Alias for [`_mm_cvtss_si32`](fn._mm_cvtss_si32.html).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2575461,"byte_end":2575470,"line_start":808,"line_end":808,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2575471,"byte_end":2575504,"line_start":809,"line_end":809,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2575547,"byte_end":2575596,"line_start":811,"line_end":811,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7604},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2576415,"byte_end":2576430,"line_start":832,"line_end":832,"column_start":15,"column_end":30},"name":"_mm_cvttss_si32","qualname":"::core_arch::x86::sse::_mm_cvttss_si32","value":"fn (a: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Converts the lowest 32 bit float in the input vector to a 32 bit integer\n with\n truncation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2576264,"byte_end":2576273,"line_start":828,"line_end":828,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2576274,"byte_end":2576307,"line_start":829,"line_end":829,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2576351,"byte_end":2576400,"line_start":831,"line_end":831,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7605},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2576797,"byte_end":2576811,"line_start":843,"line_end":843,"column_start":15,"column_end":29},"name":"_mm_cvtt_ss2si","qualname":"::core_arch::x86::sse::_mm_cvtt_ss2si","value":"fn (a: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Alias for [`_mm_cvttss_si32`](fn._mm_cvttss_si32.html).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2576646,"byte_end":2576655,"line_start":839,"line_end":839,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2576656,"byte_end":2576689,"line_start":840,"line_end":840,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2576733,"byte_end":2576782,"line_start":842,"line_end":842,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7606},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2577264,"byte_end":2577277,"line_start":855,"line_end":855,"column_start":15,"column_end":28},"name":"_mm_cvtss_f32","qualname":"::core_arch::x86::sse::_mm_cvtss_f32","value":"fn (a: __m128) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Extracts the lowest 32 bit float from the input vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2577032,"byte_end":2577041,"line_start":850,"line_end":850,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2577042,"byte_end":2577075,"line_start":851,"line_end":851,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2577200,"byte_end":2577249,"line_start":854,"line_end":854,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7607},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2577838,"byte_end":2577852,"line_start":870,"line_end":870,"column_start":15,"column_end":29},"name":"_mm_cvtsi32_ss","qualname":"::core_arch::x86::sse::_mm_cvtsi32_ss","value":"fn (a: __m128, b: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts a 32 bit integer to a 32 bit float. The result vector is the input\n vector `a` with the lowest 32 bit float replaced by the converted integer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2577688,"byte_end":2577697,"line_start":866,"line_end":866,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2577698,"byte_end":2577731,"line_start":867,"line_end":867,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2577774,"byte_end":2577823,"line_start":869,"line_end":869,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7608},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2578228,"byte_end":2578241,"line_start":881,"line_end":881,"column_start":15,"column_end":28},"name":"_mm_cvt_si2ss","qualname":"::core_arch::x86::sse::_mm_cvt_si2ss","value":"fn (a: __m128, b: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Alias for [`_mm_cvtsi32_ss`](fn._mm_cvtsi32_ss.html).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2578078,"byte_end":2578087,"line_start":877,"line_end":877,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2578088,"byte_end":2578121,"line_start":878,"line_end":878,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2578164,"byte_end":2578213,"line_start":880,"line_end":880,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7609},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2578649,"byte_end":2578659,"line_start":893,"line_end":893,"column_start":15,"column_end":25},"name":"_mm_set_ss","qualname":"::core_arch::x86::sse::_mm_set_ss","value":"fn (a: f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Construct a `__m128` with the lowest element set to `a` and the rest set to\n zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2578502,"byte_end":2578511,"line_start":889,"line_end":889,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2578512,"byte_end":2578545,"line_start":890,"line_end":890,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2578585,"byte_end":2578634,"line_start":892,"line_end":892,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7610},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2579026,"byte_end":2579037,"line_start":904,"line_end":904,"column_start":15,"column_end":26},"name":"_mm_set1_ps","qualname":"::core_arch::x86::sse::_mm_set1_ps","value":"fn (a: f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Construct a `__m128` with all element set to `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2578878,"byte_end":2578887,"line_start":900,"line_end":900,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2578888,"byte_end":2578921,"line_start":901,"line_end":901,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2578962,"byte_end":2579011,"line_start":903,"line_end":903,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7611},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2579395,"byte_end":2579406,"line_start":915,"line_end":915,"column_start":15,"column_end":26},"name":"_mm_set_ps1","qualname":"::core_arch::x86::sse::_mm_set_ps1","value":"fn (a: f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Alias for [`_mm_set1_ps`](fn._mm_set1_ps.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2579247,"byte_end":2579256,"line_start":911,"line_end":911,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2579257,"byte_end":2579290,"line_start":912,"line_end":912,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2579331,"byte_end":2579380,"line_start":914,"line_end":914,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7612},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2580263,"byte_end":2580273,"line_start":942,"line_end":942,"column_start":15,"column_end":25},"name":"_mm_set_ps","qualname":"::core_arch::x86::sse::_mm_set_ps","value":"fn (a: f32, b: f32, c: f32, d: f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Construct a `__m128` from four floating point values highest to lowest.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2580113,"byte_end":2580122,"line_start":938,"line_end":938,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2580123,"byte_end":2580156,"line_start":939,"line_end":939,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2580199,"byte_end":2580248,"line_start":941,"line_end":941,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7613},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2581067,"byte_end":2581078,"line_start":962,"line_end":962,"column_start":15,"column_end":26},"name":"_mm_setr_ps","qualname":"::core_arch::x86::sse::_mm_setr_ps","value":"fn (a: f32, b: f32, c: f32, d: f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Construct a `__m128` from four floating point values lowest to highest.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2580750,"byte_end":2580759,"line_start":956,"line_end":956,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2580760,"byte_end":2580793,"line_start":957,"line_end":957,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2581003,"byte_end":2581052,"line_start":961,"line_end":961,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7614},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2581475,"byte_end":2581489,"line_start":973,"line_end":973,"column_start":15,"column_end":29},"name":"_mm_setzero_ps","qualname":"::core_arch::x86::sse::_mm_setzero_ps","value":"fn () -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Construct a `__m128` with all elements initialized to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2581328,"byte_end":2581337,"line_start":969,"line_end":969,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2581338,"byte_end":2581371,"line_start":970,"line_end":970,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2581411,"byte_end":2581460,"line_start":972,"line_end":972,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7615},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2581732,"byte_end":2581743,"line_start":982,"line_end":982,"column_start":14,"column_end":25},"name":"_MM_SHUFFLE","qualname":"::core_arch::x86::sse::_MM_SHUFFLE","value":"fn (z: u32, y: u32, x: u32, w: u32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" A utility function for creating masks to use with Intel shuffle and\n permute intrinsics.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2581634,"byte_end":2581643,"line_start":979,"line_end":979,"column_start":1,"column_end":10}},{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2581644,"byte_end":2581668,"line_start":980,"line_end":980,"column_start":1,"column_end":25}},{"value":"unstable(feature = \"stdsimd\", issue = \"27731\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2581669,"byte_end":2581718,"line_start":981,"line_end":981,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7616},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2582404,"byte_end":2582418,"line_start":998,"line_end":998,"column_start":15,"column_end":29},"name":"_mm_shuffle_ps","qualname":"::core_arch::x86::sse::_mm_shuffle_ps","value":"fn (a: __m128, b: __m128, mask: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Shuffles packed single-precision (32-bit) floating-point elements in `a` and\n `b` using `mask`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2582214,"byte_end":2582223,"line_start":993,"line_end":993,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2582224,"byte_end":2582257,"line_start":994,"line_end":994,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2582308,"byte_end":2582339,"line_start":996,"line_end":996,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2582340,"byte_end":2582389,"line_start":997,"line_end":997,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7621},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2584254,"byte_end":2584269,"line_start":1052,"line_end":1052,"column_start":15,"column_end":30},"name":"_mm_unpackhi_ps","qualname":"::core_arch::x86::sse::_mm_unpackhi_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave single-precision (32-bit) floating-point elements\n from the higher half of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2584104,"byte_end":2584113,"line_start":1048,"line_end":1048,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2584114,"byte_end":2584147,"line_start":1049,"line_end":1049,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2584190,"byte_end":2584239,"line_start":1051,"line_end":1051,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7622},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2584728,"byte_end":2584743,"line_start":1064,"line_end":1064,"column_start":15,"column_end":30},"name":"_mm_unpacklo_ps","qualname":"::core_arch::x86::sse::_mm_unpacklo_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave single-precision (32-bit) floating-point elements\n from the lower half of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2584578,"byte_end":2584587,"line_start":1060,"line_end":1060,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2584588,"byte_end":2584621,"line_start":1061,"line_end":1061,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2584664,"byte_end":2584713,"line_start":1063,"line_end":1063,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7623},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2585217,"byte_end":2585230,"line_start":1076,"line_end":1076,"column_start":15,"column_end":28},"name":"_mm_movehl_ps","qualname":"::core_arch::x86::sse::_mm_movehl_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Combine higher half of `a` and `b`. The highwe half of `b` occupies the\n lower half of result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2585035,"byte_end":2585044,"line_start":1072,"line_end":1072,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2585045,"byte_end":2585078,"line_start":1073,"line_end":1073,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2585153,"byte_end":2585202,"line_start":1075,"line_end":1075,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7624},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2585771,"byte_end":2585784,"line_start":1089,"line_end":1089,"column_start":15,"column_end":28},"name":"_mm_movelh_ps","qualname":"::core_arch::x86::sse::_mm_movelh_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Combine lower half of `a` and `b`. The lower half of `b` occupies the\n higher half of result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2585589,"byte_end":2585598,"line_start":1085,"line_end":1085,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2585599,"byte_end":2585632,"line_start":1086,"line_end":1086,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2585707,"byte_end":2585756,"line_start":1088,"line_end":1088,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7625},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2586312,"byte_end":2586327,"line_start":1103,"line_end":1103,"column_start":15,"column_end":30},"name":"_mm_movemask_ps","qualname":"::core_arch::x86::sse::_mm_movemask_ps","value":"fn (a: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Returns a mask of the most significant bit of each element in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2586162,"byte_end":2586171,"line_start":1099,"line_end":1099,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2586172,"byte_end":2586205,"line_start":1100,"line_end":1100,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2586248,"byte_end":2586297,"line_start":1102,"line_end":1102,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7626},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2587124,"byte_end":2587136,"line_start":1129,"line_end":1129,"column_start":15,"column_end":27},"name":"_mm_loadh_pi","qualname":"::core_arch::x86::sse::_mm_loadh_pi","value":"fn (a: __m128, p: *const __m64) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Sets the upper two single-precision floating-point values with 64 bits of\n data loaded from the address `p`; the lower two values are passed through\n from `a`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2586537,"byte_end":2586546,"line_start":1110,"line_end":1110,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2586547,"byte_end":2586580,"line_start":1111,"line_end":1111,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":7627},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2587851,"byte_end":2587863,"line_start":1150,"line_end":1150,"column_start":15,"column_end":27},"name":"_mm_loadl_pi","qualname":"::core_arch::x86::sse::_mm_loadl_pi","value":"fn (a: __m128, p: *const __m64) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Loads two floats from `p` into the lower half of a `__m128`. The upper half\n is copied from the upper half of `a`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2587443,"byte_end":2587452,"line_start":1138,"line_end":1138,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2587453,"byte_end":2587486,"line_start":1139,"line_end":1139,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":7628},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2588471,"byte_end":2588482,"line_start":1167,"line_end":1167,"column_start":15,"column_end":26},"name":"_mm_load_ss","qualname":"::core_arch::x86::sse::_mm_load_ss","value":"fn (p: *const f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Construct a `__m128` with the lowest element read from `p` and the other\n elements set to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2588324,"byte_end":2588333,"line_start":1163,"line_end":1163,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2588334,"byte_end":2588367,"line_start":1164,"line_end":1164,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2588407,"byte_end":2588456,"line_start":1166,"line_end":1166,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7629},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2588982,"byte_end":2588994,"line_start":1182,"line_end":1182,"column_start":15,"column_end":27},"name":"_mm_load1_ps","qualname":"::core_arch::x86::sse::_mm_load1_ps","value":"fn (p: *const f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Construct a `__m128` by duplicating the value read from `p` into all\n elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2588835,"byte_end":2588844,"line_start":1178,"line_end":1178,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2588845,"byte_end":2588878,"line_start":1179,"line_end":1179,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2588918,"byte_end":2588967,"line_start":1181,"line_end":1181,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7630},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2589377,"byte_end":2589389,"line_start":1194,"line_end":1194,"column_start":15,"column_end":27},"name":"_mm_load_ps1","qualname":"::core_arch::x86::sse::_mm_load_ps1","value":"fn (p: *const f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Alias for [`_mm_load1_ps`](fn._mm_load1_ps.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2589230,"byte_end":2589239,"line_start":1190,"line_end":1190,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2589240,"byte_end":2589273,"line_start":1191,"line_end":1191,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2589313,"byte_end":2589362,"line_start":1193,"line_end":1193,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7631},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2590095,"byte_end":2590106,"line_start":1213,"line_end":1213,"column_start":15,"column_end":26},"name":"_mm_load_ps","qualname":"::core_arch::x86::sse::_mm_load_ps","value":"fn (p: *const f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Loads four `f32` values from *aligned* memory into a `__m128`. If the\n pointer is not aligned to a 128-bit boundary (16 bytes) a general\n protection fault will be triggered (fatal program crash).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2589910,"byte_end":2589919,"line_start":1208,"line_end":1208,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2589920,"byte_end":2589953,"line_start":1209,"line_end":1209,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2589994,"byte_end":2590043,"line_start":1211,"line_end":1211,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2590044,"byte_end":2590080,"line_start":1212,"line_end":1212,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":7632},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2590678,"byte_end":2590690,"line_start":1230,"line_end":1230,"column_start":15,"column_end":27},"name":"_mm_loadu_ps","qualname":"::core_arch::x86::sse::_mm_loadu_ps","value":"fn (p: *const f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Loads four `f32` values from memory into a `__m128`. There are no\n restrictions\n on memory alignment. For aligned memory\n [`_mm_load_ps`](fn._mm_load_ps.html)\n may be faster.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2590530,"byte_end":2590539,"line_start":1226,"line_end":1226,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2590540,"byte_end":2590573,"line_start":1227,"line_end":1227,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2590614,"byte_end":2590663,"line_start":1229,"line_end":1229,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7633},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2591870,"byte_end":2591882,"line_start":1267,"line_end":1267,"column_start":15,"column_end":27},"name":"_mm_loadr_ps","qualname":"::core_arch::x86::sse::_mm_loadr_ps","value":"fn (p: *const f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Loads four `f32` values from aligned memory into a `__m128` in reverse\n order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2591722,"byte_end":2591731,"line_start":1263,"line_end":1263,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2591732,"byte_end":2591765,"line_start":1264,"line_end":1264,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2591806,"byte_end":2591855,"line_start":1266,"line_end":1266,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7634},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2592610,"byte_end":2592623,"line_start":1287,"line_end":1287,"column_start":15,"column_end":28},"name":"_mm_storeh_pi","qualname":"::core_arch::x86::sse::_mm_storeh_pi","value":"fn (p: *mut __m64, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the upper half of `a` (64 bits) into memory.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2592185,"byte_end":2592194,"line_start":1276,"line_end":1276,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2592195,"byte_end":2592228,"line_start":1277,"line_end":1277,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":7635},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2593703,"byte_end":2593716,"line_start":1321,"line_end":1321,"column_start":15,"column_end":28},"name":"_mm_storel_pi","qualname":"::core_arch::x86::sse::_mm_storel_pi","value":"fn (p: *mut __m64, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the lower half of `a` (64 bits) into memory.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2593402,"byte_end":2593411,"line_start":1310,"line_end":1310,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2593412,"byte_end":2593445,"line_start":1311,"line_end":1311,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":7636},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2594538,"byte_end":2594550,"line_start":1347,"line_end":1347,"column_start":15,"column_end":27},"name":"_mm_store_ss","qualname":"::core_arch::x86::sse::_mm_store_ss","value":"fn (p: *mut f32, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the lowest 32 bit float of `a` into memory.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2594391,"byte_end":2594400,"line_start":1343,"line_end":1343,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2594401,"byte_end":2594434,"line_start":1344,"line_end":1344,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2594474,"byte_end":2594523,"line_start":1346,"line_end":1346,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7637},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2595388,"byte_end":2595401,"line_start":1374,"line_end":1374,"column_start":15,"column_end":28},"name":"_mm_store1_ps","qualname":"::core_arch::x86::sse::_mm_store1_ps","value":"fn (p: *mut f32, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the lowest 32 bit float of `a` repeated four times into *aligned*\n memory.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2595203,"byte_end":2595212,"line_start":1369,"line_end":1369,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2595213,"byte_end":2595246,"line_start":1370,"line_end":1370,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2595287,"byte_end":2595336,"line_start":1372,"line_end":1372,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2595337,"byte_end":2595373,"line_start":1373,"line_end":1373,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":7638},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2595832,"byte_end":2595845,"line_start":1386,"line_end":1386,"column_start":15,"column_end":28},"name":"_mm_store_ps1","qualname":"::core_arch::x86::sse::_mm_store_ps1","value":"fn (p: *mut f32, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Alias for [`_mm_store1_ps`](fn._mm_store1_ps.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2595684,"byte_end":2595693,"line_start":1382,"line_end":1382,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2595694,"byte_end":2595727,"line_start":1383,"line_end":1383,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2595768,"byte_end":2595817,"line_start":1385,"line_end":1385,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7639},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2596548,"byte_end":2596560,"line_start":1406,"line_end":1406,"column_start":15,"column_end":27},"name":"_mm_store_ps","qualname":"::core_arch::x86::sse::_mm_store_ps","value":"fn (p: *mut f32, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores four 32-bit floats into *aligned* memory.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2596363,"byte_end":2596372,"line_start":1401,"line_end":1401,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2596373,"byte_end":2596406,"line_start":1402,"line_end":1402,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2596447,"byte_end":2596496,"line_start":1404,"line_end":1404,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2596497,"byte_end":2596533,"line_start":1405,"line_end":1405,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":7640},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2597115,"byte_end":2597128,"line_start":1421,"line_end":1421,"column_start":15,"column_end":28},"name":"_mm_storeu_ps","qualname":"::core_arch::x86::sse::_mm_storeu_ps","value":"fn (p: *mut f32, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores four 32-bit floats into memory. There are no restrictions on memory\n alignment. For aligned memory [`_mm_store_ps`](fn._mm_store_ps.html) may be\n faster.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2596967,"byte_end":2596976,"line_start":1417,"line_end":1417,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2596977,"byte_end":2597010,"line_start":1418,"line_end":1418,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2597051,"byte_end":2597100,"line_start":1420,"line_end":1420,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7641},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2598071,"byte_end":2598084,"line_start":1450,"line_end":1450,"column_start":15,"column_end":28},"name":"_mm_storer_ps","qualname":"::core_arch::x86::sse::_mm_storer_ps","value":"fn (p: *mut f32, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores four 32-bit floats into *aligned* memory in reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2597886,"byte_end":2597895,"line_start":1445,"line_end":1445,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2597896,"byte_end":2597929,"line_start":1446,"line_end":1446,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2597970,"byte_end":2598019,"line_start":1448,"line_end":1448,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2598020,"byte_end":2598056,"line_start":1449,"line_end":1449,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":7642},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2598673,"byte_end":2598684,"line_start":1468,"line_end":1468,"column_start":15,"column_end":26},"name":"_mm_move_ss","qualname":"::core_arch::x86::sse::_mm_move_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns a `__m128` with the first component from `b` and the remaining\n components from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2598526,"byte_end":2598535,"line_start":1464,"line_end":1464,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2598536,"byte_end":2598569,"line_start":1465,"line_end":1465,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2598609,"byte_end":2598658,"line_start":1467,"line_end":1467,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7643},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2599320,"byte_end":2599330,"line_start":1484,"line_end":1484,"column_start":15,"column_end":25},"name":"_mm_sfence","qualname":"::core_arch::x86::sse::_mm_sfence","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a serializing operation on all store-to-memory instructions that\n were issued prior to this instruction.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2599172,"byte_end":2599181,"line_start":1480,"line_end":1480,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2599182,"byte_end":2599215,"line_start":1481,"line_end":1481,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2599256,"byte_end":2599305,"line_start":1483,"line_end":1483,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7644},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2599749,"byte_end":2599759,"line_start":1497,"line_end":1497,"column_start":15,"column_end":25},"name":"_mm_getcsr","qualname":"::core_arch::x86::sse::_mm_getcsr","value":"fn () -> u32","parent":null,"children":[],"decl_id":null,"docs":" Gets the unsigned 32-bit value of the MXCSR control and status register.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2599600,"byte_end":2599609,"line_start":1493,"line_end":1493,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2599610,"byte_end":2599643,"line_start":1494,"line_end":1494,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2599685,"byte_end":2599734,"line_start":1496,"line_end":1496,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7645},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2604779,"byte_end":2604789,"line_start":1634,"line_end":1634,"column_start":15,"column_end":25},"name":"_mm_setcsr","qualname":"::core_arch::x86::sse::_mm_setcsr","value":"fn (val: u32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Sets the MXCSR register with the 32-bit unsigned integer value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2604630,"byte_end":2604639,"line_start":1630,"line_end":1630,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2604640,"byte_end":2604673,"line_start":1631,"line_end":1631,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2604715,"byte_end":2604764,"line_start":1633,"line_end":1633,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7646},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2604952,"byte_end":2604970,"line_start":1640,"line_end":1640,"column_start":11,"column_end":29},"name":"_MM_EXCEPT_INVALID","qualname":"::core_arch::x86::sse::_MM_EXCEPT_INVALID","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2604892,"byte_end":2604941,"line_start":1639,"line_end":1639,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7647},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2605089,"byte_end":2605106,"line_start":1643,"line_end":1643,"column_start":11,"column_end":28},"name":"_MM_EXCEPT_DENORM","qualname":"::core_arch::x86::sse::_MM_EXCEPT_DENORM","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2605029,"byte_end":2605078,"line_start":1642,"line_end":1642,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7648},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2605225,"byte_end":2605244,"line_start":1646,"line_end":1646,"column_start":11,"column_end":30},"name":"_MM_EXCEPT_DIV_ZERO","qualname":"::core_arch::x86::sse::_MM_EXCEPT_DIV_ZERO","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2605165,"byte_end":2605214,"line_start":1645,"line_end":1645,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7649},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2605363,"byte_end":2605382,"line_start":1649,"line_end":1649,"column_start":11,"column_end":30},"name":"_MM_EXCEPT_OVERFLOW","qualname":"::core_arch::x86::sse::_MM_EXCEPT_OVERFLOW","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2605303,"byte_end":2605352,"line_start":1648,"line_end":1648,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7650},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2605501,"byte_end":2605521,"line_start":1652,"line_end":1652,"column_start":11,"column_end":31},"name":"_MM_EXCEPT_UNDERFLOW","qualname":"::core_arch::x86::sse::_MM_EXCEPT_UNDERFLOW","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2605441,"byte_end":2605490,"line_start":1651,"line_end":1651,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7651},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2605640,"byte_end":2605658,"line_start":1655,"line_end":1655,"column_start":11,"column_end":29},"name":"_MM_EXCEPT_INEXACT","qualname":"::core_arch::x86::sse::_MM_EXCEPT_INEXACT","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2605580,"byte_end":2605629,"line_start":1654,"line_end":1654,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7652},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2605803,"byte_end":2605818,"line_start":1658,"line_end":1658,"column_start":11,"column_end":26},"name":"_MM_EXCEPT_MASK","qualname":"::core_arch::x86::sse::_MM_EXCEPT_MASK","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_MM_GET_EXCEPTION_STATE`](fn._MM_GET_EXCEPTION_STATE.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2605743,"byte_end":2605792,"line_start":1657,"line_end":1657,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7653},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2605938,"byte_end":2605954,"line_start":1662,"line_end":1662,"column_start":11,"column_end":27},"name":"_MM_MASK_INVALID","qualname":"::core_arch::x86::sse::_MM_MASK_INVALID","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2605878,"byte_end":2605927,"line_start":1661,"line_end":1661,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7654},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2606073,"byte_end":2606088,"line_start":1665,"line_end":1665,"column_start":11,"column_end":26},"name":"_MM_MASK_DENORM","qualname":"::core_arch::x86::sse::_MM_MASK_DENORM","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2606013,"byte_end":2606062,"line_start":1664,"line_end":1664,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7655},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2606207,"byte_end":2606224,"line_start":1668,"line_end":1668,"column_start":11,"column_end":28},"name":"_MM_MASK_DIV_ZERO","qualname":"::core_arch::x86::sse::_MM_MASK_DIV_ZERO","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2606147,"byte_end":2606196,"line_start":1667,"line_end":1667,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7656},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2606343,"byte_end":2606360,"line_start":1671,"line_end":1671,"column_start":11,"column_end":28},"name":"_MM_MASK_OVERFLOW","qualname":"::core_arch::x86::sse::_MM_MASK_OVERFLOW","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2606283,"byte_end":2606332,"line_start":1670,"line_end":1670,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7657},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2606479,"byte_end":2606497,"line_start":1674,"line_end":1674,"column_start":11,"column_end":29},"name":"_MM_MASK_UNDERFLOW","qualname":"::core_arch::x86::sse::_MM_MASK_UNDERFLOW","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2606419,"byte_end":2606468,"line_start":1673,"line_end":1673,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7658},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2606616,"byte_end":2606632,"line_start":1677,"line_end":1677,"column_start":11,"column_end":27},"name":"_MM_MASK_INEXACT","qualname":"::core_arch::x86::sse::_MM_MASK_INEXACT","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2606556,"byte_end":2606605,"line_start":1676,"line_end":1676,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7659},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2606775,"byte_end":2606788,"line_start":1680,"line_end":1680,"column_start":11,"column_end":24},"name":"_MM_MASK_MASK","qualname":"::core_arch::x86::sse::_MM_MASK_MASK","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_MM_GET_EXCEPTION_MASK`](fn._MM_GET_EXCEPTION_MASK.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2606715,"byte_end":2606764,"line_start":1679,"line_end":1679,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7660},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2606908,"byte_end":2606925,"line_start":1684,"line_end":1684,"column_start":11,"column_end":28},"name":"_MM_ROUND_NEAREST","qualname":"::core_arch::x86::sse::_MM_ROUND_NEAREST","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2606848,"byte_end":2606897,"line_start":1683,"line_end":1683,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7661},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2607044,"byte_end":2607058,"line_start":1687,"line_end":1687,"column_start":11,"column_end":25},"name":"_MM_ROUND_DOWN","qualname":"::core_arch::x86::sse::_MM_ROUND_DOWN","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2606984,"byte_end":2607033,"line_start":1686,"line_end":1686,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7662},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2607177,"byte_end":2607189,"line_start":1690,"line_end":1690,"column_start":11,"column_end":23},"name":"_MM_ROUND_UP","qualname":"::core_arch::x86::sse::_MM_ROUND_UP","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2607117,"byte_end":2607166,"line_start":1689,"line_end":1689,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7663},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2607308,"byte_end":2607329,"line_start":1693,"line_end":1693,"column_start":11,"column_end":32},"name":"_MM_ROUND_TOWARD_ZERO","qualname":"::core_arch::x86::sse::_MM_ROUND_TOWARD_ZERO","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2607248,"byte_end":2607297,"line_start":1692,"line_end":1692,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7664},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2607471,"byte_end":2607485,"line_start":1697,"line_end":1697,"column_start":11,"column_end":25},"name":"_MM_ROUND_MASK","qualname":"::core_arch::x86::sse::_MM_ROUND_MASK","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_MM_GET_ROUNDING_MODE`](fn._MM_GET_ROUNDING_MODE.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2607411,"byte_end":2607460,"line_start":1696,"line_end":1696,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7665},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2607631,"byte_end":2607650,"line_start":1701,"line_end":1701,"column_start":11,"column_end":30},"name":"_MM_FLUSH_ZERO_MASK","qualname":"::core_arch::x86::sse::_MM_FLUSH_ZERO_MASK","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_MM_GET_FLUSH_ZERO_MODE`](fn._MM_GET_FLUSH_ZERO_MODE.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2607571,"byte_end":2607620,"line_start":1700,"line_end":1700,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7666},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2607769,"byte_end":2607786,"line_start":1704,"line_end":1704,"column_start":11,"column_end":28},"name":"_MM_FLUSH_ZERO_ON","qualname":"::core_arch::x86::sse::_MM_FLUSH_ZERO_ON","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2607709,"byte_end":2607758,"line_start":1703,"line_end":1703,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7667},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2607905,"byte_end":2607923,"line_start":1707,"line_end":1707,"column_start":11,"column_end":29},"name":"_MM_FLUSH_ZERO_OFF","qualname":"::core_arch::x86::sse::_MM_FLUSH_ZERO_OFF","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2607845,"byte_end":2607894,"line_start":1706,"line_end":1706,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7668},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2608239,"byte_end":2608261,"line_start":1716,"line_end":1716,"column_start":15,"column_end":37},"name":"_MM_GET_EXCEPTION_MASK","qualname":"::core_arch::x86::sse::_MM_GET_EXCEPTION_MASK","value":"fn () -> u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2608106,"byte_end":2608115,"line_start":1712,"line_end":1712,"column_start":1,"column_end":10}},{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2608116,"byte_end":2608140,"line_start":1713,"line_end":1713,"column_start":1,"column_end":25}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2608141,"byte_end":2608174,"line_start":1714,"line_end":1714,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2608175,"byte_end":2608224,"line_start":1715,"line_end":1715,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7669},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2608609,"byte_end":2608632,"line_start":1727,"line_end":1727,"column_start":15,"column_end":38},"name":"_MM_GET_EXCEPTION_STATE","qualname":"::core_arch::x86::sse::_MM_GET_EXCEPTION_STATE","value":"fn () -> u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2608476,"byte_end":2608485,"line_start":1723,"line_end":1723,"column_start":1,"column_end":10}},{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2608486,"byte_end":2608510,"line_start":1724,"line_end":1724,"column_start":1,"column_end":25}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2608511,"byte_end":2608544,"line_start":1725,"line_end":1725,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2608545,"byte_end":2608594,"line_start":1726,"line_end":1726,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7670},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2608982,"byte_end":2609005,"line_start":1738,"line_end":1738,"column_start":15,"column_end":38},"name":"_MM_GET_FLUSH_ZERO_MODE","qualname":"::core_arch::x86::sse::_MM_GET_FLUSH_ZERO_MODE","value":"fn () -> u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2608849,"byte_end":2608858,"line_start":1734,"line_end":1734,"column_start":1,"column_end":10}},{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2608859,"byte_end":2608883,"line_start":1735,"line_end":1735,"column_start":1,"column_end":25}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2608884,"byte_end":2608917,"line_start":1736,"line_end":1736,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2608918,"byte_end":2608967,"line_start":1737,"line_end":1737,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7671},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2609357,"byte_end":2609378,"line_start":1749,"line_end":1749,"column_start":15,"column_end":36},"name":"_MM_GET_ROUNDING_MODE","qualname":"::core_arch::x86::sse::_MM_GET_ROUNDING_MODE","value":"fn () -> u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2609224,"byte_end":2609233,"line_start":1745,"line_end":1745,"column_start":1,"column_end":10}},{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2609234,"byte_end":2609258,"line_start":1746,"line_end":1746,"column_start":1,"column_end":25}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2609259,"byte_end":2609292,"line_start":1747,"line_end":1747,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2609293,"byte_end":2609342,"line_start":1748,"line_end":1748,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7672},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2609726,"byte_end":2609748,"line_start":1760,"line_end":1760,"column_start":15,"column_end":37},"name":"_MM_SET_EXCEPTION_MASK","qualname":"::core_arch::x86::sse::_MM_SET_EXCEPTION_MASK","value":"fn (x: u32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2609593,"byte_end":2609602,"line_start":1756,"line_end":1756,"column_start":1,"column_end":10}},{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2609603,"byte_end":2609627,"line_start":1757,"line_end":1757,"column_start":1,"column_end":25}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2609628,"byte_end":2609661,"line_start":1758,"line_end":1758,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2609662,"byte_end":2609711,"line_start":1759,"line_end":1759,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7673},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2610114,"byte_end":2610137,"line_start":1771,"line_end":1771,"column_start":15,"column_end":38},"name":"_MM_SET_EXCEPTION_STATE","qualname":"::core_arch::x86::sse::_MM_SET_EXCEPTION_STATE","value":"fn (x: u32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2609981,"byte_end":2609990,"line_start":1767,"line_end":1767,"column_start":1,"column_end":10}},{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2609991,"byte_end":2610015,"line_start":1768,"line_end":1768,"column_start":1,"column_end":25}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2610016,"byte_end":2610049,"line_start":1769,"line_end":1769,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2610050,"byte_end":2610099,"line_start":1770,"line_end":1770,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7674},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2610505,"byte_end":2610528,"line_start":1782,"line_end":1782,"column_start":15,"column_end":38},"name":"_MM_SET_FLUSH_ZERO_MODE","qualname":"::core_arch::x86::sse::_MM_SET_FLUSH_ZERO_MODE","value":"fn (x: u32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2610372,"byte_end":2610381,"line_start":1778,"line_end":1778,"column_start":1,"column_end":10}},{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2610382,"byte_end":2610406,"line_start":1779,"line_end":1779,"column_start":1,"column_end":25}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2610407,"byte_end":2610440,"line_start":1780,"line_end":1780,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2610441,"byte_end":2610490,"line_start":1781,"line_end":1781,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7675},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2610959,"byte_end":2610980,"line_start":1795,"line_end":1795,"column_start":15,"column_end":36},"name":"_MM_SET_ROUNDING_MODE","qualname":"::core_arch::x86::sse::_MM_SET_ROUNDING_MODE","value":"fn (x: u32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2610826,"byte_end":2610835,"line_start":1791,"line_end":1791,"column_start":1,"column_end":10}},{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2610836,"byte_end":2610860,"line_start":1792,"line_end":1792,"column_start":1,"column_end":25}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2610861,"byte_end":2610894,"line_start":1793,"line_end":1793,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2610895,"byte_end":2610944,"line_start":1794,"line_end":1794,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7676},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2611155,"byte_end":2611166,"line_start":1801,"line_end":1801,"column_start":11,"column_end":22},"name":"_MM_HINT_T0","qualname":"::core_arch::x86::sse::_MM_HINT_T0","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_prefetch`](fn._mm_prefetch.html).\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2611095,"byte_end":2611144,"line_start":1800,"line_end":1800,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7677},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2611286,"byte_end":2611297,"line_start":1805,"line_end":1805,"column_start":11,"column_end":22},"name":"_MM_HINT_T1","qualname":"::core_arch::x86::sse::_MM_HINT_T1","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_prefetch`](fn._mm_prefetch.html).\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2611226,"byte_end":2611275,"line_start":1804,"line_end":1804,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7678},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2611417,"byte_end":2611428,"line_start":1809,"line_end":1809,"column_start":11,"column_end":22},"name":"_MM_HINT_T2","qualname":"::core_arch::x86::sse::_MM_HINT_T2","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_prefetch`](fn._mm_prefetch.html).\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2611357,"byte_end":2611406,"line_start":1808,"line_end":1808,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":7679},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2611548,"byte_end":2611560,"line_start":1813,"line_end":1813,"column_start":11,"column_end":23},"name":"_MM_HINT_NTA","qualname":"::core_arch::x86::sse::_MM_HINT_NTA","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_prefetch`](fn._mm_prefetch.html).\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2611488,"byte_end":2611537,"line_start":1812,"line_end":1812,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7680},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2613529,"byte_end":2613541,"line_start":1861,"line_end":1861,"column_start":15,"column_end":27},"name":"_mm_prefetch","qualname":"::core_arch::x86::sse::_mm_prefetch","value":"fn (p: *const i8, strategy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Fetch the cache line that contains address `p` using the given `strategy`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2613115,"byte_end":2613124,"line_start":1853,"line_end":1853,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2613125,"byte_end":2613158,"line_start":1854,"line_end":1854,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2613433,"byte_end":2613464,"line_start":1859,"line_end":1859,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2613465,"byte_end":2613514,"line_start":1860,"line_end":1860,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7682},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2614421,"byte_end":2614437,"line_start":1885,"line_end":1885,"column_start":15,"column_end":31},"name":"_mm_undefined_ps","qualname":"::core_arch::x86::sse::_mm_undefined_ps","value":"fn () -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns vector of type __m128 with undefined elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2614313,"byte_end":2614322,"line_start":1882,"line_end":1882,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2614323,"byte_end":2614356,"line_start":1883,"line_end":1883,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2614357,"byte_end":2614406,"line_start":1884,"line_end":1884,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7683},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2614889,"byte_end":2614906,"line_start":1897,"line_end":1897,"column_start":15,"column_end":32},"name":"_MM_TRANSPOSE4_PS","qualname":"::core_arch::x86::sse::_MM_TRANSPOSE4_PS","value":"fn (row0: &mut __m128, row1: &mut __m128, row2: &mut __m128, row3: &mut __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Transpose the 4x4 matrix formed by 4 rows of __m128 in place.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2614756,"byte_end":2614765,"line_start":1893,"line_end":1893,"column_start":1,"column_end":10}},{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2614766,"byte_end":2614790,"line_start":1894,"line_end":1894,"column_start":1,"column_end":25}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2614791,"byte_end":2614824,"line_start":1895,"line_end":1895,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2614825,"byte_end":2614874,"line_start":1896,"line_end":1896,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7739},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2620524,"byte_end":2620537,"line_start":2037,"line_end":2037,"column_start":15,"column_end":28},"name":"_mm_stream_ps","qualname":"::core_arch::x86::sse::_mm_stream_ps","value":"fn (mem_addr: *mut f32, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores `a` into the memory at `mem_addr` using a non-temporal memory hint.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2620338,"byte_end":2620347,"line_start":2032,"line_end":2032,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2620348,"byte_end":2620381,"line_start":2033,"line_end":2033,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2620423,"byte_end":2620472,"line_start":2035,"line_end":2035,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2620473,"byte_end":2620509,"line_start":2036,"line_end":2036,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":7740},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2620831,"byte_end":2620844,"line_start":2046,"line_end":2046,"column_start":15,"column_end":28},"name":"_mm_stream_pi","qualname":"::core_arch::x86::sse::_mm_stream_pi","value":"fn (mem_addr: *mut __m64, a: __m64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 64-bits of integer data from a into memory using a non-temporal\n memory hint.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2620729,"byte_end":2620738,"line_start":2043,"line_end":2043,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2620739,"byte_end":2620776,"line_start":2044,"line_end":2044,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7741},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2621119,"byte_end":2621131,"line_start":2055,"line_end":2055,"column_start":15,"column_end":27},"name":"_mm_max_pi16","qualname":"::core_arch::x86::sse::_mm_max_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares the packed 16-bit signed integers of `a` and `b` writing the\n greatest value into the result.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2621017,"byte_end":2621026,"line_start":2052,"line_end":2052,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2621027,"byte_end":2621064,"line_start":2053,"line_end":2053,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7742},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2621395,"byte_end":2621404,"line_start":2064,"line_end":2064,"column_start":15,"column_end":24},"name":"_m_pmaxsw","qualname":"::core_arch::x86::sse::_m_pmaxsw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares the packed 16-bit signed integers of `a` and `b` writing the\n greatest value into the result.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2621293,"byte_end":2621302,"line_start":2061,"line_end":2061,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2621303,"byte_end":2621340,"line_start":2062,"line_end":2062,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7743},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2621673,"byte_end":2621684,"line_start":2073,"line_end":2073,"column_start":15,"column_end":26},"name":"_mm_max_pu8","qualname":"::core_arch::x86::sse::_mm_max_pu8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares the packed 8-bit signed integers of `a` and `b` writing the\n greatest value into the result.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2621571,"byte_end":2621580,"line_start":2070,"line_end":2070,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2621581,"byte_end":2621618,"line_start":2071,"line_end":2071,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7744},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2621947,"byte_end":2621956,"line_start":2082,"line_end":2082,"column_start":15,"column_end":24},"name":"_m_pmaxub","qualname":"::core_arch::x86::sse::_m_pmaxub","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares the packed 8-bit signed integers of `a` and `b` writing the\n greatest value into the result.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2621845,"byte_end":2621854,"line_start":2079,"line_end":2079,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2621855,"byte_end":2621892,"line_start":2080,"line_end":2080,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7745},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2622225,"byte_end":2622237,"line_start":2091,"line_end":2091,"column_start":15,"column_end":27},"name":"_mm_min_pi16","qualname":"::core_arch::x86::sse::_mm_min_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares the packed 16-bit signed integers of `a` and `b` writing the\n smallest value into the result.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2622123,"byte_end":2622132,"line_start":2088,"line_end":2088,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2622133,"byte_end":2622170,"line_start":2089,"line_end":2089,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7746},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2622501,"byte_end":2622510,"line_start":2100,"line_end":2100,"column_start":15,"column_end":24},"name":"_m_pminsw","qualname":"::core_arch::x86::sse::_m_pminsw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares the packed 16-bit signed integers of `a` and `b` writing the\n smallest value into the result.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2622399,"byte_end":2622408,"line_start":2097,"line_end":2097,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2622409,"byte_end":2622446,"line_start":2098,"line_end":2098,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7747},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2622779,"byte_end":2622790,"line_start":2109,"line_end":2109,"column_start":15,"column_end":26},"name":"_mm_min_pu8","qualname":"::core_arch::x86::sse::_mm_min_pu8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares the packed 8-bit signed integers of `a` and `b` writing the\n smallest value into the result.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2622677,"byte_end":2622686,"line_start":2106,"line_end":2106,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2622687,"byte_end":2622724,"line_start":2107,"line_end":2107,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7748},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2623053,"byte_end":2623062,"line_start":2118,"line_end":2118,"column_start":15,"column_end":24},"name":"_m_pminub","qualname":"::core_arch::x86::sse::_m_pminub","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares the packed 8-bit signed integers of `a` and `b` writing the\n smallest value into the result.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2622951,"byte_end":2622960,"line_start":2115,"line_end":2115,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2622961,"byte_end":2622998,"line_start":2116,"line_end":2116,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7749},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2623386,"byte_end":2623400,"line_start":2128,"line_end":2128,"column_start":15,"column_end":29},"name":"_mm_mulhi_pu16","qualname":"::core_arch::x86::sse::_mm_mulhi_pu16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed 16-bit unsigned integer values and writes the\n high-order 16 bits of each 32-bit product to the corresponding bits in\n the destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2623283,"byte_end":2623292,"line_start":2125,"line_end":2125,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2623293,"byte_end":2623330,"line_start":2126,"line_end":2126,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7750},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2623709,"byte_end":2623723,"line_start":2138,"line_end":2138,"column_start":15,"column_end":29},"name":"_mm_mullo_pi16","qualname":"::core_arch::x86::sse::_mm_mullo_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed 16-bit integer values and writes the\n low-order 16 bits of each 32-bit product to the corresponding bits in\n the destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2623607,"byte_end":2623616,"line_start":2135,"line_end":2135,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2623617,"byte_end":2623654,"line_start":2136,"line_end":2136,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7751},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2624042,"byte_end":2624052,"line_start":2148,"line_end":2148,"column_start":15,"column_end":25},"name":"_m_pmulhuw","qualname":"::core_arch::x86::sse::_m_pmulhuw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed 16-bit unsigned integer values and writes the\n high-order 16 bits of each 32-bit product to the corresponding bits in\n the destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2623939,"byte_end":2623948,"line_start":2145,"line_end":2145,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2623949,"byte_end":2623986,"line_start":2146,"line_end":2146,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7752},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2624369,"byte_end":2624380,"line_start":2158,"line_end":2158,"column_start":15,"column_end":26},"name":"_mm_avg_pu8","qualname":"::core_arch::x86::sse::_mm_avg_pu8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Computes the rounded averages of the packed unsigned 8-bit integer\n values and writes the averages to the corresponding bits in the\n destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2624268,"byte_end":2624277,"line_start":2155,"line_end":2155,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2624278,"byte_end":2624315,"line_start":2156,"line_end":2156,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7753},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2624688,"byte_end":2624696,"line_start":2168,"line_end":2168,"column_start":15,"column_end":23},"name":"_m_pavgb","qualname":"::core_arch::x86::sse::_m_pavgb","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Computes the rounded averages of the packed unsigned 8-bit integer\n values and writes the averages to the corresponding bits in the\n destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2624587,"byte_end":2624596,"line_start":2165,"line_end":2165,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2624597,"byte_end":2624634,"line_start":2166,"line_end":2166,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7754},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2625011,"byte_end":2625023,"line_start":2178,"line_end":2178,"column_start":15,"column_end":27},"name":"_mm_avg_pu16","qualname":"::core_arch::x86::sse::_mm_avg_pu16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Computes the rounded averages of the packed unsigned 16-bit integer\n values and writes the averages to the corresponding bits in the\n destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2624910,"byte_end":2624919,"line_start":2175,"line_end":2175,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2624920,"byte_end":2624957,"line_start":2176,"line_end":2176,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7755},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2625332,"byte_end":2625340,"line_start":2188,"line_end":2188,"column_start":15,"column_end":23},"name":"_m_pavgw","qualname":"::core_arch::x86::sse::_m_pavgw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Computes the rounded averages of the packed unsigned 16-bit integer\n values and writes the averages to the corresponding bits in the\n destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2625231,"byte_end":2625240,"line_start":2185,"line_end":2185,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2625241,"byte_end":2625278,"line_start":2186,"line_end":2186,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7756},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2625801,"byte_end":2625812,"line_start":2199,"line_end":2199,"column_start":15,"column_end":26},"name":"_mm_sad_pu8","qualname":"::core_arch::x86::sse::_mm_sad_pu8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtracts the corresponding 8-bit unsigned integer values of the two\n 64-bit vector operands and computes the absolute value for each of the\n difference. Then sum of the 8 absolute differences is written to the\n bits `[15:0]` of the destination; the remaining bits `[63:16]` are cleared.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2625699,"byte_end":2625708,"line_start":2196,"line_end":2196,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2625709,"byte_end":2625746,"line_start":2197,"line_end":2197,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7757},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2626267,"byte_end":2626276,"line_start":2210,"line_end":2210,"column_start":15,"column_end":24},"name":"_m_psadbw","qualname":"::core_arch::x86::sse::_m_psadbw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtracts the corresponding 8-bit unsigned integer values of the two\n 64-bit vector operands and computes the absolute value for each of the\n difference. Then sum of the 8 absolute differences is written to the\n bits `[15:0]` of the destination; the remaining bits `[63:16]` are cleared.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2626165,"byte_end":2626174,"line_start":2207,"line_end":2207,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2626175,"byte_end":2626212,"line_start":2208,"line_end":2208,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7758},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2626717,"byte_end":2626731,"line_start":2221,"line_end":2221,"column_start":15,"column_end":29},"name":"_mm_cvtpi32_ps","qualname":"::core_arch::x86::sse::_mm_cvtpi32_ps","value":"fn (a: __m128, b: __m64) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts two elements of a 64-bit vector of `[2 x i32]` into two\n floating point values and writes them to the lower 64-bits of the\n destination. The remaining higher order elements of the destination are\n copied from the corresponding elements in the first operand.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2626613,"byte_end":2626622,"line_start":2218,"line_end":2218,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2626623,"byte_end":2626660,"line_start":2219,"line_end":2219,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7759},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2627171,"byte_end":2627184,"line_start":2232,"line_end":2232,"column_start":15,"column_end":28},"name":"_mm_cvt_pi2ps","qualname":"::core_arch::x86::sse::_mm_cvt_pi2ps","value":"fn (a: __m128, b: __m64) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts two elements of a 64-bit vector of `[2 x i32]` into two\n floating point values and writes them to the lower 64-bits of the\n destination. The remaining higher order elements of the destination are\n copied from the corresponding elements in the first operand.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2627067,"byte_end":2627076,"line_start":2229,"line_end":2229,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2627077,"byte_end":2627114,"line_start":2230,"line_end":2230,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7760},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2627430,"byte_end":2627443,"line_start":2240,"line_end":2240,"column_start":15,"column_end":28},"name":"_mm_cvtpi8_ps","qualname":"::core_arch::x86::sse::_mm_cvtpi8_ps","value":"fn (a: __m64) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts the lower 4 8-bit values of `a` into a 128-bit vector of 4 `f32`s.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2627326,"byte_end":2627335,"line_start":2237,"line_end":2237,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2627336,"byte_end":2627373,"line_start":2238,"line_end":2238,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7761},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2627776,"byte_end":2627789,"line_start":2251,"line_end":2251,"column_start":15,"column_end":28},"name":"_mm_cvtpu8_ps","qualname":"::core_arch::x86::sse::_mm_cvtpu8_ps","value":"fn (a: __m64) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts the lower 4 8-bit values of `a` into a 128-bit vector of 4 `f32`s.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2627672,"byte_end":2627681,"line_start":2248,"line_end":2248,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2627682,"byte_end":2627719,"line_start":2249,"line_end":2249,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7762},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2628083,"byte_end":2628097,"line_start":2261,"line_end":2261,"column_start":15,"column_end":29},"name":"_mm_cvtpi16_ps","qualname":"::core_arch::x86::sse::_mm_cvtpi16_ps","value":"fn (a: __m64) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts a 64-bit vector of `i16`s into a 128-bit vector of 4 `f32`s.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2627979,"byte_end":2627988,"line_start":2258,"line_end":2258,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2627989,"byte_end":2628026,"line_start":2259,"line_end":2259,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7763},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2628551,"byte_end":2628565,"line_start":2276,"line_end":2276,"column_start":15,"column_end":29},"name":"_mm_cvtpu16_ps","qualname":"::core_arch::x86::sse::_mm_cvtpu16_ps","value":"fn (a: __m64) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts a 64-bit vector of `i16`s into a 128-bit vector of 4 `f32`s.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2628447,"byte_end":2628456,"line_start":2273,"line_end":2273,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2628457,"byte_end":2628494,"line_start":2274,"line_end":2274,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7764},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2629052,"byte_end":2629068,"line_start":2291,"line_end":2291,"column_start":15,"column_end":31},"name":"_mm_cvtpi32x2_ps","qualname":"::core_arch::x86::sse::_mm_cvtpi32x2_ps","value":"fn (a: __m64, b: __m64) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts the two 32-bit signed integer values from each 64-bit vector\n operand of `[2 x i32]` into a 128-bit vector of `[4 x float]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2628948,"byte_end":2628957,"line_start":2288,"line_end":2288,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2628958,"byte_end":2628995,"line_start":2289,"line_end":2289,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7765},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2629697,"byte_end":2629714,"line_start":2308,"line_end":2308,"column_start":15,"column_end":32},"name":"_mm_maskmove_si64","qualname":"::core_arch::x86::sse::_mm_maskmove_si64","value":"fn (a: __m64, mask: __m64, mem_addr: *mut i8) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Conditionally copies the values from each 8-bit element in the first\n 64-bit integer vector operand to the specified memory location, as\n specified by the most significant bit in the corresponding element in the\n second 64-bit integer vector operand.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2629593,"byte_end":2629602,"line_start":2305,"line_end":2305,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2629603,"byte_end":2629640,"line_start":2306,"line_end":2306,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7766},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2630265,"byte_end":2630276,"line_start":2322,"line_end":2322,"column_start":15,"column_end":26},"name":"_m_maskmovq","qualname":"::core_arch::x86::sse::_m_maskmovq","value":"fn (a: __m64, mask: __m64, mem_addr: *mut i8) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Conditionally copies the values from each 8-bit element in the first\n 64-bit integer vector operand to the specified memory location, as\n specified by the most significant bit in the corresponding element in the\n second 64-bit integer vector operand.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2630161,"byte_end":2630170,"line_start":2319,"line_end":2319,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2630171,"byte_end":2630208,"line_start":2320,"line_end":2320,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7767},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2630640,"byte_end":2630656,"line_start":2332,"line_end":2332,"column_start":15,"column_end":31},"name":"_mm_extract_pi16","qualname":"::core_arch::x86::sse::_mm_extract_pi16","value":"fn (a: __m64, imm2: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Extracts 16-bit element from a 64-bit vector of `[4 x i16]` and\n returns it, as specified by the immediate integer operand.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2630496,"byte_end":2630505,"line_start":2328,"line_end":2328,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2630506,"byte_end":2630543,"line_start":2329,"line_end":2329,"column_start":1,"column_end":38}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2630594,"byte_end":2630625,"line_start":2331,"line_end":2331,"column_start":1,"column_end":32}}]},{"kind":"Function","id":{"krate":0,"index":7769},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2631099,"byte_end":2631108,"line_start":2347,"line_end":2347,"column_start":15,"column_end":24},"name":"_m_pextrw","qualname":"::core_arch::x86::sse::_m_pextrw","value":"fn (a: __m64, imm2: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Extracts 16-bit element from a 64-bit vector of `[4 x i16]` and\n returns it, as specified by the immediate integer operand.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2630955,"byte_end":2630964,"line_start":2343,"line_end":2343,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2630965,"byte_end":2631002,"line_start":2344,"line_end":2344,"column_start":1,"column_end":38}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2631053,"byte_end":2631084,"line_start":2346,"line_end":2346,"column_start":1,"column_end":32}}]},{"kind":"Function","id":{"krate":0,"index":7771},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2631615,"byte_end":2631630,"line_start":2363,"line_end":2363,"column_start":15,"column_end":30},"name":"_mm_insert_pi16","qualname":"::core_arch::x86::sse::_mm_insert_pi16","value":"fn (a: __m64, d: i32, imm2: i32) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Copies data from the 64-bit vector of `[4 x i16]` to the destination,\n and inserts the lower 16-bits of an integer operand at the 16-bit offset\n specified by the immediate operand `n`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2631471,"byte_end":2631480,"line_start":2359,"line_end":2359,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2631481,"byte_end":2631518,"line_start":2360,"line_end":2360,"column_start":1,"column_end":38}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2631569,"byte_end":2631600,"line_start":2362,"line_end":2362,"column_start":1,"column_end":32}}]},{"kind":"Function","id":{"krate":0,"index":7773},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2632143,"byte_end":2632152,"line_start":2379,"line_end":2379,"column_start":15,"column_end":24},"name":"_m_pinsrw","qualname":"::core_arch::x86::sse::_m_pinsrw","value":"fn (a: __m64, d: i32, imm2: i32) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Copies data from the 64-bit vector of `[4 x i16]` to the destination,\n and inserts the lower 16-bits of an integer operand at the 16-bit offset\n specified by the immediate operand `n`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2631999,"byte_end":2632008,"line_start":2375,"line_end":2375,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2632009,"byte_end":2632046,"line_start":2376,"line_end":2376,"column_start":1,"column_end":38}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2632097,"byte_end":2632128,"line_start":2378,"line_end":2378,"column_start":1,"column_end":32}}]},{"kind":"Function","id":{"krate":0,"index":7775},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2632630,"byte_end":2632646,"line_start":2394,"line_end":2394,"column_start":15,"column_end":31},"name":"_mm_movemask_pi8","qualname":"::core_arch::x86::sse::_mm_movemask_pi8","value":"fn (a: __m64) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Takes the most significant bit from each 8-bit element in a 64-bit\n integer vector to create a 16-bit mask value. Zero-extends the value to\n 32-bit integer and writes it to the destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2632526,"byte_end":2632535,"line_start":2391,"line_end":2391,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2632536,"byte_end":2632573,"line_start":2392,"line_end":2392,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7776},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2632989,"byte_end":2633000,"line_start":2404,"line_end":2404,"column_start":15,"column_end":26},"name":"_m_pmovmskb","qualname":"::core_arch::x86::sse::_m_pmovmskb","value":"fn (a: __m64) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Takes the most significant bit from each 8-bit element in a 64-bit\n integer vector to create a 16-bit mask value. Zero-extends the value to\n 32-bit integer and writes it to the destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2632885,"byte_end":2632894,"line_start":2401,"line_end":2401,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2632895,"byte_end":2632932,"line_start":2402,"line_end":2402,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7777},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2633324,"byte_end":2633340,"line_start":2414,"line_end":2414,"column_start":15,"column_end":31},"name":"_mm_shuffle_pi16","qualname":"::core_arch::x86::sse::_mm_shuffle_pi16","value":"fn (a: __m64, imm8: i32) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Shuffles the 4 16-bit integers from a 64-bit integer vector to the\n destination, as specified by the immediate value operand.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2633180,"byte_end":2633189,"line_start":2410,"line_end":2410,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2633190,"byte_end":2633227,"line_start":2411,"line_end":2411,"column_start":1,"column_end":38}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2633278,"byte_end":2633309,"line_start":2413,"line_end":2413,"column_start":1,"column_end":32}}]},{"kind":"Function","id":{"krate":0,"index":7779},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2633780,"byte_end":2633789,"line_start":2429,"line_end":2429,"column_start":15,"column_end":24},"name":"_m_pshufw","qualname":"::core_arch::x86::sse::_m_pshufw","value":"fn (a: __m64, imm8: i32) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Shuffles the 4 16-bit integers from a 64-bit integer vector to the\n destination, as specified by the immediate value operand.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2633636,"byte_end":2633645,"line_start":2425,"line_end":2425,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2633646,"byte_end":2633683,"line_start":2426,"line_end":2426,"column_start":1,"column_end":38}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2633734,"byte_end":2633765,"line_start":2428,"line_end":2428,"column_start":1,"column_end":32}}]},{"kind":"Function","id":{"krate":0,"index":7781},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2634195,"byte_end":2634210,"line_start":2443,"line_end":2443,"column_start":15,"column_end":30},"name":"_mm_cvttps_pi32","qualname":"::core_arch::x86::sse::_mm_cvttps_pi32","value":"fn (a: __m128) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Converts the two lower packed single-precision (32-bit) floating-point\n elements in `a` to packed 32-bit integers with truncation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2634090,"byte_end":2634099,"line_start":2440,"line_end":2440,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2634100,"byte_end":2634137,"line_start":2441,"line_end":2441,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7782},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2634496,"byte_end":2634510,"line_start":2452,"line_end":2452,"column_start":15,"column_end":29},"name":"_mm_cvtt_ps2pi","qualname":"::core_arch::x86::sse::_mm_cvtt_ps2pi","value":"fn (a: __m128) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Converts the two lower packed single-precision (32-bit) floating-point\n elements in `a` to packed 32-bit integers with truncation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2634391,"byte_end":2634400,"line_start":2449,"line_end":2449,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2634401,"byte_end":2634438,"line_start":2450,"line_end":2450,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7783},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2634785,"byte_end":2634799,"line_start":2461,"line_end":2461,"column_start":15,"column_end":29},"name":"_mm_cvtps_pi32","qualname":"::core_arch::x86::sse::_mm_cvtps_pi32","value":"fn (a: __m128) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Converts the two lower packed single-precision (32-bit) floating-point\n elements in `a` to packed 32-bit integers.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2634681,"byte_end":2634690,"line_start":2458,"line_end":2458,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2634691,"byte_end":2634728,"line_start":2459,"line_end":2459,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7784},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2635067,"byte_end":2635080,"line_start":2470,"line_end":2470,"column_start":15,"column_end":28},"name":"_mm_cvt_ps2pi","qualname":"::core_arch::x86::sse::_mm_cvt_ps2pi","value":"fn (a: __m128) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Converts the two lower packed single-precision (32-bit) floating-point\n elements in `a` to packed 32-bit integers.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2634963,"byte_end":2634972,"line_start":2467,"line_end":2467,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2634973,"byte_end":2635010,"line_start":2468,"line_end":2468,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7785},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2635340,"byte_end":2635354,"line_start":2479,"line_end":2479,"column_start":15,"column_end":29},"name":"_mm_cvtps_pi16","qualname":"::core_arch::x86::sse::_mm_cvtps_pi16","value":"fn (a: __m128) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Converts packed single-precision (32-bit) floating-point elements in `a` to\n packed 16-bit integers.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2635236,"byte_end":2635245,"line_start":2476,"line_end":2476,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2635246,"byte_end":2635283,"line_start":2477,"line_end":2477,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7786},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2635772,"byte_end":2635785,"line_start":2492,"line_end":2492,"column_start":15,"column_end":28},"name":"_mm_cvtps_pi8","qualname":"::core_arch::x86::sse::_mm_cvtps_pi8","value":"fn (a: __m128) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Converts packed single-precision (32-bit) floating-point elements in `a` to\n packed 8-bit integers, and returns theem in the lower 4 elements of the\n result.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2635668,"byte_end":2635677,"line_start":2489,"line_end":2489,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2635678,"byte_end":2635715,"line_start":2490,"line_end":2490,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":7799},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2689834,"byte_end":2689843,"line_start":22,"line_end":22,"column_start":15,"column_end":24},"name":"_mm_pause","qualname":"::core_arch::x86::sse2::_mm_pause","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Provides a hint to the processor that the code sequence is a spin-wait loop.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2689691,"byte_end":2689700,"line_start":19,"line_end":19,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2689770,"byte_end":2689819,"line_start":21,"line_end":21,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7800},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2690393,"byte_end":2690404,"line_start":36,"line_end":36,"column_start":15,"column_end":26},"name":"_mm_clflush","qualname":"::core_arch::x86::sse2::_mm_clflush","value":"fn (p: *mut u8) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Invalidates and flushes the cache line that contains `p` from all levels of\n the cache hierarchy.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2690243,"byte_end":2690252,"line_start":32,"line_end":32,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2690253,"byte_end":2690287,"line_start":33,"line_end":33,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2690329,"byte_end":2690378,"line_start":35,"line_end":35,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7801},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2690997,"byte_end":2691007,"line_start":52,"line_end":52,"column_start":15,"column_end":25},"name":"_mm_lfence","qualname":"::core_arch::x86::sse2::_mm_lfence","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a serializing operation on all load-from-memory instructions\n that were issued prior to this instruction.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2690848,"byte_end":2690857,"line_start":48,"line_end":48,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2690858,"byte_end":2690892,"line_start":49,"line_end":49,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2690933,"byte_end":2690982,"line_start":51,"line_end":51,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7802},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2691636,"byte_end":2691646,"line_start":68,"line_end":68,"column_start":15,"column_end":25},"name":"_mm_mfence","qualname":"::core_arch::x86::sse2::_mm_mfence","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a serializing operation on all load-from-memory and store-to-memory\n instructions that were issued prior to this instruction.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2691487,"byte_end":2691496,"line_start":64,"line_end":64,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2691497,"byte_end":2691531,"line_start":65,"line_end":65,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2691572,"byte_end":2691621,"line_start":67,"line_end":67,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7803},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2691975,"byte_end":2691987,"line_start":79,"line_end":79,"column_start":15,"column_end":27},"name":"_mm_add_epi8","qualname":"::core_arch::x86::sse2::_mm_add_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 8-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2691827,"byte_end":2691836,"line_start":75,"line_end":75,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2691837,"byte_end":2691871,"line_start":76,"line_end":76,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2691911,"byte_end":2691960,"line_start":78,"line_end":78,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7804},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2692390,"byte_end":2692403,"line_start":90,"line_end":90,"column_start":15,"column_end":28},"name":"_mm_add_epi16","qualname":"::core_arch::x86::sse2::_mm_add_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 16-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2692242,"byte_end":2692251,"line_start":86,"line_end":86,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2692252,"byte_end":2692286,"line_start":87,"line_end":87,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2692326,"byte_end":2692375,"line_start":89,"line_end":89,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7805},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2692806,"byte_end":2692819,"line_start":101,"line_end":101,"column_start":15,"column_end":28},"name":"_mm_add_epi32","qualname":"::core_arch::x86::sse2::_mm_add_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 32-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2692658,"byte_end":2692667,"line_start":97,"line_end":97,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2692668,"byte_end":2692702,"line_start":98,"line_end":98,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2692742,"byte_end":2692791,"line_start":100,"line_end":100,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7806},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2693222,"byte_end":2693235,"line_start":112,"line_end":112,"column_start":15,"column_end":28},"name":"_mm_add_epi64","qualname":"::core_arch::x86::sse2::_mm_add_epi64","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 64-bit integers in `a` and \"b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2693074,"byte_end":2693083,"line_start":108,"line_end":108,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2693084,"byte_end":2693118,"line_start":109,"line_end":109,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2693158,"byte_end":2693207,"line_start":111,"line_end":111,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7807},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2693655,"byte_end":2693668,"line_start":123,"line_end":123,"column_start":15,"column_end":28},"name":"_mm_adds_epi8","qualname":"::core_arch::x86::sse2::_mm_adds_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 8-bit integers in `a` and `b` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2693506,"byte_end":2693515,"line_start":119,"line_end":119,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2693516,"byte_end":2693550,"line_start":120,"line_end":120,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2693591,"byte_end":2693640,"line_start":122,"line_end":122,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7808},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2694088,"byte_end":2694102,"line_start":134,"line_end":134,"column_start":15,"column_end":29},"name":"_mm_adds_epi16","qualname":"::core_arch::x86::sse2::_mm_adds_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 16-bit integers in `a` and `b` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2693939,"byte_end":2693948,"line_start":130,"line_end":130,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2693949,"byte_end":2693983,"line_start":131,"line_end":131,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2694024,"byte_end":2694073,"line_start":133,"line_end":133,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7809},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2694530,"byte_end":2694543,"line_start":145,"line_end":145,"column_start":15,"column_end":28},"name":"_mm_adds_epu8","qualname":"::core_arch::x86::sse2::_mm_adds_epu8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed unsigned 8-bit integers in `a` and `b` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2694380,"byte_end":2694389,"line_start":141,"line_end":141,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2694390,"byte_end":2694424,"line_start":142,"line_end":142,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2694466,"byte_end":2694515,"line_start":144,"line_end":144,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7810},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2694974,"byte_end":2694988,"line_start":156,"line_end":156,"column_start":15,"column_end":29},"name":"_mm_adds_epu16","qualname":"::core_arch::x86::sse2::_mm_adds_epu16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed unsigned 16-bit integers in `a` and `b` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2694824,"byte_end":2694833,"line_start":152,"line_end":152,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2694834,"byte_end":2694868,"line_start":153,"line_end":153,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2694910,"byte_end":2694959,"line_start":155,"line_end":155,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7811},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2695401,"byte_end":2695413,"line_start":167,"line_end":167,"column_start":15,"column_end":27},"name":"_mm_avg_epu8","qualname":"::core_arch::x86::sse2::_mm_avg_epu8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Averages packed unsigned 8-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2695253,"byte_end":2695262,"line_start":163,"line_end":163,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2695263,"byte_end":2695297,"line_start":164,"line_end":164,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2695337,"byte_end":2695386,"line_start":166,"line_end":166,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7812},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2695826,"byte_end":2695839,"line_start":178,"line_end":178,"column_start":15,"column_end":28},"name":"_mm_avg_epu16","qualname":"::core_arch::x86::sse2::_mm_avg_epu16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Averages packed unsigned 16-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2695678,"byte_end":2695687,"line_start":174,"line_end":174,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2695688,"byte_end":2695722,"line_start":175,"line_end":175,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2695762,"byte_end":2695811,"line_start":177,"line_end":177,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7813},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2696459,"byte_end":2696473,"line_start":193,"line_end":193,"column_start":15,"column_end":29},"name":"_mm_madd_epi16","qualname":"::core_arch::x86::sse2::_mm_madd_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies and then horizontally add signed 16 bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2696309,"byte_end":2696318,"line_start":189,"line_end":189,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2696319,"byte_end":2696353,"line_start":190,"line_end":190,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2696395,"byte_end":2696444,"line_start":192,"line_end":192,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7814},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2696923,"byte_end":2696936,"line_start":205,"line_end":205,"column_start":15,"column_end":28},"name":"_mm_max_epi16","qualname":"::core_arch::x86::sse2::_mm_max_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 16-bit integers in `a` and `b`, and returns the packed\n maximum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2696774,"byte_end":2696783,"line_start":201,"line_end":201,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2696784,"byte_end":2696818,"line_start":202,"line_end":202,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2696859,"byte_end":2696908,"line_start":204,"line_end":204,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7815},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2697392,"byte_end":2697404,"line_start":217,"line_end":217,"column_start":15,"column_end":27},"name":"_mm_max_epu8","qualname":"::core_arch::x86::sse2::_mm_max_epu8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 8-bit integers in `a` and `b`, and returns the\n packed maximum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2697243,"byte_end":2697252,"line_start":213,"line_end":213,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2697253,"byte_end":2697287,"line_start":214,"line_end":214,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2697328,"byte_end":2697377,"line_start":216,"line_end":216,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7816},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2697853,"byte_end":2697866,"line_start":229,"line_end":229,"column_start":15,"column_end":28},"name":"_mm_min_epi16","qualname":"::core_arch::x86::sse2::_mm_min_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 16-bit integers in `a` and `b`, and returns the packed\n minimum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2697704,"byte_end":2697713,"line_start":225,"line_end":225,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2697714,"byte_end":2697748,"line_start":226,"line_end":226,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2697789,"byte_end":2697838,"line_start":228,"line_end":228,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7817},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2698322,"byte_end":2698334,"line_start":241,"line_end":241,"column_start":15,"column_end":27},"name":"_mm_min_epu8","qualname":"::core_arch::x86::sse2::_mm_min_epu8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 8-bit integers in `a` and `b`, and returns the\n packed minimum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2698173,"byte_end":2698182,"line_start":237,"line_end":237,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2698183,"byte_end":2698217,"line_start":238,"line_end":238,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2698258,"byte_end":2698307,"line_start":240,"line_end":240,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7818},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2698877,"byte_end":2698892,"line_start":255,"line_end":255,"column_start":15,"column_end":30},"name":"_mm_mulhi_epi16","qualname":"::core_arch::x86::sse2::_mm_mulhi_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the packed 16-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2698728,"byte_end":2698737,"line_start":251,"line_end":251,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2698738,"byte_end":2698772,"line_start":252,"line_end":252,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2698813,"byte_end":2698862,"line_start":254,"line_end":254,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7819},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2699445,"byte_end":2699460,"line_start":269,"line_end":269,"column_start":15,"column_end":30},"name":"_mm_mulhi_epu16","qualname":"::core_arch::x86::sse2::_mm_mulhi_epu16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the packed unsigned 16-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2699295,"byte_end":2699304,"line_start":265,"line_end":265,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2699305,"byte_end":2699339,"line_start":266,"line_end":266,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2699381,"byte_end":2699430,"line_start":268,"line_end":268,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7820},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2700003,"byte_end":2700018,"line_start":283,"line_end":283,"column_start":15,"column_end":30},"name":"_mm_mullo_epi16","qualname":"::core_arch::x86::sse2::_mm_mullo_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the packed 16-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2699854,"byte_end":2699863,"line_start":279,"line_end":279,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2699864,"byte_end":2699898,"line_start":280,"line_end":280,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2699939,"byte_end":2699988,"line_start":282,"line_end":282,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7821},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2700520,"byte_end":2700533,"line_start":297,"line_end":297,"column_start":15,"column_end":28},"name":"_mm_mul_epu32","qualname":"::core_arch::x86::sse2::_mm_mul_epu32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the low unsigned 32-bit integers from each packed 64-bit element\n in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2700370,"byte_end":2700379,"line_start":293,"line_end":293,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2700380,"byte_end":2700414,"line_start":294,"line_end":294,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2700456,"byte_end":2700505,"line_start":296,"line_end":296,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7822},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2701241,"byte_end":2701253,"line_start":313,"line_end":313,"column_start":15,"column_end":27},"name":"_mm_sad_epu8","qualname":"::core_arch::x86::sse2::_mm_sad_epu8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sum the absolute differences of packed unsigned 8-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2701092,"byte_end":2701101,"line_start":309,"line_end":309,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2701102,"byte_end":2701136,"line_start":310,"line_end":310,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2701177,"byte_end":2701226,"line_start":312,"line_end":312,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7823},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2701683,"byte_end":2701695,"line_start":324,"line_end":324,"column_start":15,"column_end":27},"name":"_mm_sub_epi8","qualname":"::core_arch::x86::sse2::_mm_sub_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Subtracts packed 8-bit integers in `b` from packed 8-bit integers in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2701535,"byte_end":2701544,"line_start":320,"line_end":320,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2701545,"byte_end":2701579,"line_start":321,"line_end":321,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2701619,"byte_end":2701668,"line_start":323,"line_end":323,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7824},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2702130,"byte_end":2702143,"line_start":335,"line_end":335,"column_start":15,"column_end":28},"name":"_mm_sub_epi16","qualname":"::core_arch::x86::sse2::_mm_sub_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Subtracts packed 16-bit integers in `b` from packed 16-bit integers in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2701982,"byte_end":2701991,"line_start":331,"line_end":331,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2701992,"byte_end":2702026,"line_start":332,"line_end":332,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2702066,"byte_end":2702115,"line_start":334,"line_end":334,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7825},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2702577,"byte_end":2702590,"line_start":346,"line_end":346,"column_start":15,"column_end":28},"name":"_mm_sub_epi32","qualname":"::core_arch::x86::sse2::_mm_sub_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 32-bit integers in `b` from packed 32-bit integers in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2702429,"byte_end":2702438,"line_start":342,"line_end":342,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2702439,"byte_end":2702473,"line_start":343,"line_end":343,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2702513,"byte_end":2702562,"line_start":345,"line_end":345,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7826},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2703024,"byte_end":2703037,"line_start":357,"line_end":357,"column_start":15,"column_end":28},"name":"_mm_sub_epi64","qualname":"::core_arch::x86::sse2::_mm_sub_epi64","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 64-bit integers in `b` from packed 64-bit integers in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2702876,"byte_end":2702885,"line_start":353,"line_end":353,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2702886,"byte_end":2702920,"line_start":354,"line_end":354,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2702960,"byte_end":2703009,"line_start":356,"line_end":356,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7827},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2703491,"byte_end":2703504,"line_start":369,"line_end":369,"column_start":15,"column_end":28},"name":"_mm_subs_epi8","qualname":"::core_arch::x86::sse2::_mm_subs_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a`\n using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2703342,"byte_end":2703351,"line_start":365,"line_end":365,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2703352,"byte_end":2703386,"line_start":366,"line_end":366,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2703427,"byte_end":2703476,"line_start":368,"line_end":368,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7828},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2703959,"byte_end":2703973,"line_start":381,"line_end":381,"column_start":15,"column_end":29},"name":"_mm_subs_epi16","qualname":"::core_arch::x86::sse2::_mm_subs_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a`\n using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2703810,"byte_end":2703819,"line_start":377,"line_end":377,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2703820,"byte_end":2703854,"line_start":378,"line_end":378,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2703895,"byte_end":2703944,"line_start":380,"line_end":380,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7829},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2704444,"byte_end":2704457,"line_start":393,"line_end":393,"column_start":15,"column_end":28},"name":"_mm_subs_epu8","qualname":"::core_arch::x86::sse2::_mm_subs_epu8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed unsigned 8-bit integers in `b` from packed unsigned 8-bit\n integers in `a` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2704294,"byte_end":2704303,"line_start":389,"line_end":389,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2704304,"byte_end":2704338,"line_start":390,"line_end":390,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2704380,"byte_end":2704429,"line_start":392,"line_end":392,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7830},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2704932,"byte_end":2704946,"line_start":405,"line_end":405,"column_start":15,"column_end":29},"name":"_mm_subs_epu16","qualname":"::core_arch::x86::sse2::_mm_subs_epu16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed unsigned 16-bit integers in `b` from packed unsigned 16-bit\n integers in `a` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2704782,"byte_end":2704791,"line_start":401,"line_end":401,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2704792,"byte_end":2704826,"line_start":402,"line_end":402,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2704868,"byte_end":2704917,"line_start":404,"line_end":404,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7831},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2705405,"byte_end":2705419,"line_start":417,"line_end":417,"column_start":15,"column_end":29},"name":"_mm_slli_si128","qualname":"::core_arch::x86::sse2::_mm_slli_si128","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts `a` left by `imm8` bytes while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2705214,"byte_end":2705223,"line_start":412,"line_end":412,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2705224,"byte_end":2705258,"line_start":413,"line_end":413,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2705309,"byte_end":2705340,"line_start":415,"line_end":415,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2705341,"byte_end":2705390,"line_start":416,"line_end":416,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7834},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2707433,"byte_end":2707448,"line_start":484,"line_end":484,"column_start":15,"column_end":30},"name":"_mm_bslli_si128","qualname":"::core_arch::x86::sse2::_mm_bslli_si128","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts `a` left by `imm8` bytes while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2707242,"byte_end":2707251,"line_start":479,"line_end":479,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2707252,"byte_end":2707286,"line_start":480,"line_end":480,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2707337,"byte_end":2707368,"line_start":482,"line_end":482,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2707369,"byte_end":2707418,"line_start":483,"line_end":483,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7835},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2707890,"byte_end":2707905,"line_start":496,"line_end":496,"column_start":15,"column_end":30},"name":"_mm_bsrli_si128","qualname":"::core_arch::x86::sse2::_mm_bsrli_si128","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts `a` right by `imm8` bytes while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2707699,"byte_end":2707708,"line_start":491,"line_end":491,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2707709,"byte_end":2707743,"line_start":492,"line_end":492,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2707794,"byte_end":2707825,"line_start":494,"line_end":494,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2707826,"byte_end":2707875,"line_start":495,"line_end":495,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7836},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2708364,"byte_end":2708378,"line_start":508,"line_end":508,"column_start":15,"column_end":29},"name":"_mm_slli_epi16","qualname":"::core_arch::x86::sse2::_mm_slli_epi16","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` left by `imm8` while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2708174,"byte_end":2708183,"line_start":503,"line_end":503,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2708184,"byte_end":2708218,"line_start":504,"line_end":504,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2708268,"byte_end":2708299,"line_start":506,"line_end":506,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2708300,"byte_end":2708349,"line_start":507,"line_end":507,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7837},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2708808,"byte_end":2708821,"line_start":520,"line_end":520,"column_start":15,"column_end":28},"name":"_mm_sll_epi16","qualname":"::core_arch::x86::sse2::_mm_sll_epi16","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` left by `count` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2708660,"byte_end":2708669,"line_start":516,"line_end":516,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2708670,"byte_end":2708704,"line_start":517,"line_end":517,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2708744,"byte_end":2708793,"line_start":519,"line_end":519,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7838},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2709305,"byte_end":2709319,"line_start":532,"line_end":532,"column_start":15,"column_end":29},"name":"_mm_slli_epi32","qualname":"::core_arch::x86::sse2::_mm_slli_epi32","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` left by `imm8` while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2709115,"byte_end":2709124,"line_start":527,"line_end":527,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2709125,"byte_end":2709159,"line_start":528,"line_end":528,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2709209,"byte_end":2709240,"line_start":530,"line_end":530,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2709241,"byte_end":2709290,"line_start":531,"line_end":531,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7839},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2709749,"byte_end":2709762,"line_start":544,"line_end":544,"column_start":15,"column_end":28},"name":"_mm_sll_epi32","qualname":"::core_arch::x86::sse2::_mm_sll_epi32","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` left by `count` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2709601,"byte_end":2709610,"line_start":540,"line_end":540,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2709611,"byte_end":2709645,"line_start":541,"line_end":541,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2709685,"byte_end":2709734,"line_start":543,"line_end":543,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7840},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2710246,"byte_end":2710260,"line_start":556,"line_end":556,"column_start":15,"column_end":29},"name":"_mm_slli_epi64","qualname":"::core_arch::x86::sse2::_mm_slli_epi64","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` left by `imm8` while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2710056,"byte_end":2710065,"line_start":551,"line_end":551,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2710066,"byte_end":2710100,"line_start":552,"line_end":552,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2710150,"byte_end":2710181,"line_start":554,"line_end":554,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2710182,"byte_end":2710231,"line_start":555,"line_end":555,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7841},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2710690,"byte_end":2710703,"line_start":568,"line_end":568,"column_start":15,"column_end":28},"name":"_mm_sll_epi64","qualname":"::core_arch::x86::sse2::_mm_sll_epi64","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` left by `count` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2710542,"byte_end":2710551,"line_start":564,"line_end":564,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2710552,"byte_end":2710586,"line_start":565,"line_end":565,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2710626,"byte_end":2710675,"line_start":567,"line_end":567,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7842},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2711196,"byte_end":2711210,"line_start":581,"line_end":581,"column_start":15,"column_end":29},"name":"_mm_srai_epi16","qualname":"::core_arch::x86::sse2::_mm_srai_epi16","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` right by `imm8` while shifting in sign\n bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2711006,"byte_end":2711015,"line_start":576,"line_end":576,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2711016,"byte_end":2711050,"line_start":577,"line_end":577,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2711100,"byte_end":2711131,"line_start":579,"line_end":579,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2711132,"byte_end":2711181,"line_start":580,"line_end":580,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7843},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2711645,"byte_end":2711658,"line_start":593,"line_end":593,"column_start":15,"column_end":28},"name":"_mm_sra_epi16","qualname":"::core_arch::x86::sse2::_mm_sra_epi16","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` right by `count` while shifting in sign\n bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2711497,"byte_end":2711506,"line_start":589,"line_end":589,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2711507,"byte_end":2711541,"line_start":590,"line_end":590,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2711581,"byte_end":2711630,"line_start":592,"line_end":592,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7844},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2712151,"byte_end":2712165,"line_start":606,"line_end":606,"column_start":15,"column_end":29},"name":"_mm_srai_epi32","qualname":"::core_arch::x86::sse2::_mm_srai_epi32","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by `imm8` while shifting in sign\n bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2711961,"byte_end":2711970,"line_start":601,"line_end":601,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2711971,"byte_end":2712005,"line_start":602,"line_end":602,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2712055,"byte_end":2712086,"line_start":604,"line_end":604,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2712087,"byte_end":2712136,"line_start":605,"line_end":605,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7845},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2712600,"byte_end":2712613,"line_start":618,"line_end":618,"column_start":15,"column_end":28},"name":"_mm_sra_epi32","qualname":"::core_arch::x86::sse2::_mm_sra_epi32","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by `count` while shifting in sign\n bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2712452,"byte_end":2712461,"line_start":614,"line_end":614,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2712462,"byte_end":2712496,"line_start":615,"line_end":615,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2712536,"byte_end":2712585,"line_start":617,"line_end":617,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7846},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2713079,"byte_end":2713093,"line_start":630,"line_end":630,"column_start":15,"column_end":29},"name":"_mm_srli_si128","qualname":"::core_arch::x86::sse2::_mm_srli_si128","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts `a` right by `imm8` bytes while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2712888,"byte_end":2712897,"line_start":625,"line_end":625,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2712898,"byte_end":2712932,"line_start":626,"line_end":626,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2712983,"byte_end":2713014,"line_start":628,"line_end":628,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2713015,"byte_end":2713064,"line_start":629,"line_end":629,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7849},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2715111,"byte_end":2715125,"line_start":698,"line_end":698,"column_start":15,"column_end":29},"name":"_mm_srli_epi16","qualname":"::core_arch::x86::sse2::_mm_srli_epi16","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` right by `imm8` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2714921,"byte_end":2714930,"line_start":693,"line_end":693,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2714931,"byte_end":2714965,"line_start":694,"line_end":694,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2715015,"byte_end":2715046,"line_start":696,"line_end":696,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2715047,"byte_end":2715096,"line_start":697,"line_end":697,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7850},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2715556,"byte_end":2715569,"line_start":710,"line_end":710,"column_start":15,"column_end":28},"name":"_mm_srl_epi16","qualname":"::core_arch::x86::sse2::_mm_srl_epi16","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` right by `count` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2715408,"byte_end":2715417,"line_start":706,"line_end":706,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2715418,"byte_end":2715452,"line_start":707,"line_end":707,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2715492,"byte_end":2715541,"line_start":709,"line_end":709,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7851},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2716058,"byte_end":2716072,"line_start":723,"line_end":723,"column_start":15,"column_end":29},"name":"_mm_srli_epi32","qualname":"::core_arch::x86::sse2::_mm_srli_epi32","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by `imm8` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2715868,"byte_end":2715877,"line_start":718,"line_end":718,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2715878,"byte_end":2715912,"line_start":719,"line_end":719,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2715962,"byte_end":2715993,"line_start":721,"line_end":721,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2715994,"byte_end":2716043,"line_start":722,"line_end":722,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7852},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2716503,"byte_end":2716516,"line_start":735,"line_end":735,"column_start":15,"column_end":28},"name":"_mm_srl_epi32","qualname":"::core_arch::x86::sse2::_mm_srl_epi32","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by `count` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2716355,"byte_end":2716364,"line_start":731,"line_end":731,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2716365,"byte_end":2716399,"line_start":732,"line_end":732,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2716439,"byte_end":2716488,"line_start":734,"line_end":734,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7853},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2717005,"byte_end":2717019,"line_start":748,"line_end":748,"column_start":15,"column_end":29},"name":"_mm_srli_epi64","qualname":"::core_arch::x86::sse2::_mm_srli_epi64","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` right by `imm8` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2716815,"byte_end":2716824,"line_start":743,"line_end":743,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2716825,"byte_end":2716859,"line_start":744,"line_end":744,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2716909,"byte_end":2716940,"line_start":746,"line_end":746,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2716941,"byte_end":2716990,"line_start":747,"line_end":747,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7854},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2717450,"byte_end":2717463,"line_start":760,"line_end":760,"column_start":15,"column_end":28},"name":"_mm_srl_epi64","qualname":"::core_arch::x86::sse2::_mm_srl_epi64","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` right by `count` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2717302,"byte_end":2717311,"line_start":756,"line_end":756,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2717312,"byte_end":2717346,"line_start":757,"line_end":757,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2717386,"byte_end":2717435,"line_start":759,"line_end":759,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7855},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2717912,"byte_end":2717925,"line_start":772,"line_end":772,"column_start":15,"column_end":28},"name":"_mm_and_si128","qualname":"::core_arch::x86::sse2::_mm_and_si128","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 128 bits (representing integer data) in `a` and\n `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2717764,"byte_end":2717773,"line_start":768,"line_end":768,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2717774,"byte_end":2717808,"line_start":769,"line_end":769,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2717848,"byte_end":2717897,"line_start":771,"line_end":771,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7856},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2718354,"byte_end":2718370,"line_start":784,"line_end":784,"column_start":15,"column_end":31},"name":"_mm_andnot_si128","qualname":"::core_arch::x86::sse2::_mm_andnot_si128","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise NOT of 128 bits (representing integer data) in `a` and\n then AND with `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2718205,"byte_end":2718214,"line_start":780,"line_end":780,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2718215,"byte_end":2718249,"line_start":781,"line_end":781,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2718290,"byte_end":2718339,"line_start":783,"line_end":783,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7857},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2718807,"byte_end":2718819,"line_start":796,"line_end":796,"column_start":15,"column_end":27},"name":"_mm_or_si128","qualname":"::core_arch::x86::sse2::_mm_or_si128","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise OR of 128 bits (representing integer data) in `a` and\n `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2718660,"byte_end":2718669,"line_start":792,"line_end":792,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2718670,"byte_end":2718704,"line_start":793,"line_end":793,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2718743,"byte_end":2718792,"line_start":795,"line_end":795,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7858},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2719229,"byte_end":2719242,"line_start":808,"line_end":808,"column_start":15,"column_end":28},"name":"_mm_xor_si128","qualname":"::core_arch::x86::sse2::_mm_xor_si128","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise XOR of 128 bits (representing integer data) in `a` and\n `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2719081,"byte_end":2719090,"line_start":804,"line_end":804,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2719091,"byte_end":2719125,"line_start":805,"line_end":805,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2719165,"byte_end":2719214,"line_start":807,"line_end":807,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7859},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2719631,"byte_end":2719645,"line_start":819,"line_end":819,"column_start":15,"column_end":29},"name":"_mm_cmpeq_epi8","qualname":"::core_arch::x86::sse2::_mm_cmpeq_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 8-bit integers in `a` and `b` for equality.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2719481,"byte_end":2719490,"line_start":815,"line_end":815,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2719491,"byte_end":2719525,"line_start":816,"line_end":816,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2719567,"byte_end":2719616,"line_start":818,"line_end":818,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7860},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2720080,"byte_end":2720095,"line_start":830,"line_end":830,"column_start":15,"column_end":30},"name":"_mm_cmpeq_epi16","qualname":"::core_arch::x86::sse2::_mm_cmpeq_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 16-bit integers in `a` and `b` for equality.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2719930,"byte_end":2719939,"line_start":826,"line_end":826,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2719940,"byte_end":2719974,"line_start":827,"line_end":827,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2720016,"byte_end":2720065,"line_start":829,"line_end":829,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7861},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2720530,"byte_end":2720545,"line_start":841,"line_end":841,"column_start":15,"column_end":30},"name":"_mm_cmpeq_epi32","qualname":"::core_arch::x86::sse2::_mm_cmpeq_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 32-bit integers in `a` and `b` for equality.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2720380,"byte_end":2720389,"line_start":837,"line_end":837,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2720390,"byte_end":2720424,"line_start":838,"line_end":838,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2720466,"byte_end":2720515,"line_start":840,"line_end":840,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7862},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2720982,"byte_end":2720996,"line_start":852,"line_end":852,"column_start":15,"column_end":29},"name":"_mm_cmpgt_epi8","qualname":"::core_arch::x86::sse2::_mm_cmpgt_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 8-bit integers in `a` and `b` for greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2720832,"byte_end":2720841,"line_start":848,"line_end":848,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2720842,"byte_end":2720876,"line_start":849,"line_end":849,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2720918,"byte_end":2720967,"line_start":851,"line_end":851,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7863},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2721435,"byte_end":2721450,"line_start":863,"line_end":863,"column_start":15,"column_end":30},"name":"_mm_cmpgt_epi16","qualname":"::core_arch::x86::sse2::_mm_cmpgt_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 16-bit integers in `a` and `b` for greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2721285,"byte_end":2721294,"line_start":859,"line_end":859,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2721295,"byte_end":2721329,"line_start":860,"line_end":860,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2721371,"byte_end":2721420,"line_start":862,"line_end":862,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7864},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2721889,"byte_end":2721904,"line_start":874,"line_end":874,"column_start":15,"column_end":30},"name":"_mm_cmpgt_epi32","qualname":"::core_arch::x86::sse2::_mm_cmpgt_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 32-bit integers in `a` and `b` for greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2721739,"byte_end":2721748,"line_start":870,"line_end":870,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2721749,"byte_end":2721783,"line_start":871,"line_end":871,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2721825,"byte_end":2721874,"line_start":873,"line_end":873,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7865},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2722338,"byte_end":2722352,"line_start":885,"line_end":885,"column_start":15,"column_end":29},"name":"_mm_cmplt_epi8","qualname":"::core_arch::x86::sse2::_mm_cmplt_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 8-bit integers in `a` and `b` for less-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2722188,"byte_end":2722197,"line_start":881,"line_end":881,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2722198,"byte_end":2722232,"line_start":882,"line_end":882,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2722274,"byte_end":2722323,"line_start":884,"line_end":884,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7866},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2722788,"byte_end":2722803,"line_start":896,"line_end":896,"column_start":15,"column_end":30},"name":"_mm_cmplt_epi16","qualname":"::core_arch::x86::sse2::_mm_cmplt_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 16-bit integers in `a` and `b` for less-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2722638,"byte_end":2722647,"line_start":892,"line_end":892,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2722648,"byte_end":2722682,"line_start":893,"line_end":893,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2722724,"byte_end":2722773,"line_start":895,"line_end":895,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7867},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2723239,"byte_end":2723254,"line_start":907,"line_end":907,"column_start":15,"column_end":30},"name":"_mm_cmplt_epi32","qualname":"::core_arch::x86::sse2::_mm_cmplt_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 32-bit integers in `a` and `b` for less-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2723089,"byte_end":2723098,"line_start":903,"line_end":903,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2723099,"byte_end":2723133,"line_start":904,"line_end":904,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2723175,"byte_end":2723224,"line_start":906,"line_end":906,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7868},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2723747,"byte_end":2723762,"line_start":919,"line_end":919,"column_start":15,"column_end":30},"name":"_mm_cvtepi32_pd","qualname":"::core_arch::x86::sse2::_mm_cvtepi32_pd","value":"fn (a: __m128i) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Converts the lower two packed 32-bit integers in `a` to packed\n double-precision (64-bit) floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2723596,"byte_end":2723605,"line_start":915,"line_end":915,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2723606,"byte_end":2723640,"line_start":916,"line_end":916,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2723683,"byte_end":2723732,"line_start":918,"line_end":918,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7869},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2724236,"byte_end":2724250,"line_start":932,"line_end":932,"column_start":15,"column_end":29},"name":"_mm_cvtsi32_sd","qualname":"::core_arch::x86::sse2::_mm_cvtsi32_sd","value":"fn (a: __m128d, b: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns `a` with its lower element replaced by `b` after converting it to\n an `f64`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2724085,"byte_end":2724094,"line_start":928,"line_end":928,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2724095,"byte_end":2724129,"line_start":929,"line_end":929,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2724172,"byte_end":2724221,"line_start":931,"line_end":931,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7870},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2724694,"byte_end":2724709,"line_start":944,"line_end":944,"column_start":15,"column_end":30},"name":"_mm_cvtepi32_ps","qualname":"::core_arch::x86::sse2::_mm_cvtepi32_ps","value":"fn (a: __m128i) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 32-bit integers in `a` to packed single-precision (32-bit)\n floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2724543,"byte_end":2724552,"line_start":940,"line_end":940,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2724553,"byte_end":2724587,"line_start":941,"line_end":941,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2724630,"byte_end":2724679,"line_start":943,"line_end":943,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7871},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2725139,"byte_end":2725154,"line_start":956,"line_end":956,"column_start":15,"column_end":30},"name":"_mm_cvtps_epi32","qualname":"::core_arch::x86::sse2::_mm_cvtps_epi32","value":"fn (a: __m128) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed single-precision (32-bit) floating-point elements in `a`\n to packed 32-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2724988,"byte_end":2724997,"line_start":952,"line_end":952,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2724998,"byte_end":2725032,"line_start":953,"line_end":953,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2725075,"byte_end":2725124,"line_start":955,"line_end":955,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7872},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2725589,"byte_end":2725606,"line_start":968,"line_end":968,"column_start":15,"column_end":32},"name":"_mm_cvtsi32_si128","qualname":"::core_arch::x86::sse2::_mm_cvtsi32_si128","value":"fn (a: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns a vector whose lowest element is `a` and all higher elements are\n `0`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2725413,"byte_end":2725422,"line_start":964,"line_end":964,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2725423,"byte_end":2725457,"line_start":965,"line_end":965,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2725525,"byte_end":2725574,"line_start":967,"line_end":967,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7873},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2726006,"byte_end":2726023,"line_start":979,"line_end":979,"column_start":15,"column_end":32},"name":"_mm_cvtsi128_si32","qualname":"::core_arch::x86::sse2::_mm_cvtsi128_si32","value":"fn (a: __m128i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Returns the lowest element of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2725826,"byte_end":2725835,"line_start":975,"line_end":975,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2725836,"byte_end":2725870,"line_start":976,"line_end":976,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2725942,"byte_end":2725991,"line_start":978,"line_end":978,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7874},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2726429,"byte_end":2726443,"line_start":991,"line_end":991,"column_start":15,"column_end":29},"name":"_mm_set_epi64x","qualname":"::core_arch::x86::sse2::_mm_set_epi64x","value":"fn (e1: i64, e0: i64) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 64-bit integers with the supplied values, from highest to\n lowest.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2726283,"byte_end":2726292,"line_start":987,"line_end":987,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2726293,"byte_end":2726327,"line_start":988,"line_end":988,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2726365,"byte_end":2726414,"line_start":990,"line_end":990,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7875},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2726830,"byte_end":2726843,"line_start":1002,"line_end":1002,"column_start":15,"column_end":28},"name":"_mm_set_epi32","qualname":"::core_arch::x86::sse2::_mm_set_epi32","value":"fn (e3: i32, e2: i32, e1: i32, e0: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 32-bit integers with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2726684,"byte_end":2726693,"line_start":998,"line_end":998,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2726694,"byte_end":2726728,"line_start":999,"line_end":999,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2726766,"byte_end":2726815,"line_start":1001,"line_end":1001,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7876},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2727256,"byte_end":2727269,"line_start":1013,"line_end":1013,"column_start":15,"column_end":28},"name":"_mm_set_epi16","qualname":"::core_arch::x86::sse2::_mm_set_epi16","value":"fn (e7: i16, e6: i16, e5: i16, e4: i16, e3: i16, e2: i16, e1: i16, e0: i16) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 16-bit integers with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2727110,"byte_end":2727119,"line_start":1009,"line_end":1009,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2727120,"byte_end":2727154,"line_start":1010,"line_end":1010,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2727192,"byte_end":2727241,"line_start":1012,"line_end":1012,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7877},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2727767,"byte_end":2727779,"line_start":1033,"line_end":1033,"column_start":15,"column_end":27},"name":"_mm_set_epi8","qualname":"::core_arch::x86::sse2::_mm_set_epi8","value":"fn (e15: i8, e14: i8, e13: i8, e12: i8, e11: i8, e10: i8, e9: i8, e8: i8, e7: i8, e6: i8, e5: i8, e4: i8, e3: i8, e2: i8, e1: i8, e0: i8) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 8-bit integers with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2727621,"byte_end":2727630,"line_start":1029,"line_end":1029,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2727631,"byte_end":2727665,"line_start":1030,"line_end":1030,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2727703,"byte_end":2727752,"line_start":1032,"line_end":1032,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7878},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2728442,"byte_end":2728457,"line_start":1064,"line_end":1064,"column_start":15,"column_end":30},"name":"_mm_set1_epi64x","qualname":"::core_arch::x86::sse2::_mm_set1_epi64x","value":"fn (a: i64) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 64-bit integer `a` to all elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2728296,"byte_end":2728305,"line_start":1060,"line_end":1060,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2728306,"byte_end":2728340,"line_start":1061,"line_end":1061,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2728378,"byte_end":2728427,"line_start":1063,"line_end":1063,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7879},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2728819,"byte_end":2728833,"line_start":1075,"line_end":1075,"column_start":15,"column_end":29},"name":"_mm_set1_epi32","qualname":"::core_arch::x86::sse2::_mm_set1_epi32","value":"fn (a: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 32-bit integer `a` to all elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2728673,"byte_end":2728682,"line_start":1071,"line_end":1071,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2728683,"byte_end":2728717,"line_start":1072,"line_end":1072,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2728755,"byte_end":2728804,"line_start":1074,"line_end":1074,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7880},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2729200,"byte_end":2729214,"line_start":1086,"line_end":1086,"column_start":15,"column_end":29},"name":"_mm_set1_epi16","qualname":"::core_arch::x86::sse2::_mm_set1_epi16","value":"fn (a: i16) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 16-bit integer `a` to all elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2729054,"byte_end":2729063,"line_start":1082,"line_end":1082,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2729064,"byte_end":2729098,"line_start":1083,"line_end":1083,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2729136,"byte_end":2729185,"line_start":1085,"line_end":1085,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7881},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2729591,"byte_end":2729604,"line_start":1097,"line_end":1097,"column_start":15,"column_end":28},"name":"_mm_set1_epi8","qualname":"::core_arch::x86::sse2::_mm_set1_epi8","value":"fn (a: i8) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 8-bit integer `a` to all elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2729445,"byte_end":2729454,"line_start":1093,"line_end":1093,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2729455,"byte_end":2729489,"line_start":1094,"line_end":1094,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2729527,"byte_end":2729576,"line_start":1096,"line_end":1096,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7882},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2730029,"byte_end":2730043,"line_start":1108,"line_end":1108,"column_start":15,"column_end":29},"name":"_mm_setr_epi32","qualname":"::core_arch::x86::sse2::_mm_setr_epi32","value":"fn (e3: i32, e2: i32, e1: i32, e0: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 32-bit integers with the supplied values in reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2729883,"byte_end":2729892,"line_start":1104,"line_end":1104,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2729893,"byte_end":2729927,"line_start":1105,"line_end":1105,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2729965,"byte_end":2730014,"line_start":1107,"line_end":1107,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7883},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2730466,"byte_end":2730480,"line_start":1119,"line_end":1119,"column_start":15,"column_end":29},"name":"_mm_setr_epi16","qualname":"::core_arch::x86::sse2::_mm_setr_epi16","value":"fn (e7: i16, e6: i16, e5: i16, e4: i16, e3: i16, e2: i16, e1: i16, e0: i16) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 16-bit integers with the supplied values in reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2730320,"byte_end":2730329,"line_start":1115,"line_end":1115,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2730330,"byte_end":2730364,"line_start":1116,"line_end":1116,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2730402,"byte_end":2730451,"line_start":1118,"line_end":1118,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7884},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2730988,"byte_end":2731001,"line_start":1139,"line_end":1139,"column_start":15,"column_end":28},"name":"_mm_setr_epi8","qualname":"::core_arch::x86::sse2::_mm_setr_epi8","value":"fn (e15: i8, e14: i8, e13: i8, e12: i8, e11: i8, e10: i8, e9: i8, e8: i8, e7: i8, e6: i8, e5: i8, e4: i8, e3: i8, e2: i8, e1: i8, e0: i8) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 8-bit integers with the supplied values in reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2730842,"byte_end":2730851,"line_start":1135,"line_end":1135,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2730852,"byte_end":2730886,"line_start":1136,"line_end":1136,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2730924,"byte_end":2730973,"line_start":1138,"line_end":1138,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7885},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2731660,"byte_end":2731677,"line_start":1170,"line_end":1170,"column_start":15,"column_end":32},"name":"_mm_setzero_si128","qualname":"::core_arch::x86::sse2::_mm_setzero_si128","value":"fn () -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns a vector with all elements set to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2731512,"byte_end":2731521,"line_start":1166,"line_end":1166,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2731522,"byte_end":2731556,"line_start":1167,"line_end":1167,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2731596,"byte_end":2731645,"line_start":1169,"line_end":1169,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7886},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2732230,"byte_end":2732245,"line_start":1190,"line_end":1190,"column_start":15,"column_end":30},"name":"_mm_loadl_epi64","qualname":"::core_arch::x86::sse2::_mm_loadl_epi64","value":"fn (mem_addr: *const __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Loads 64-bit integer from memory into first element of returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2731911,"byte_end":2731920,"line_start":1177,"line_end":1177,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2731921,"byte_end":2731955,"line_start":1178,"line_end":1178,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2732166,"byte_end":2732215,"line_start":1189,"line_end":1189,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7887},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2732743,"byte_end":2732757,"line_start":1203,"line_end":1203,"column_start":15,"column_end":29},"name":"_mm_load_si128","qualname":"::core_arch::x86::sse2::_mm_load_si128","value":"fn (mem_addr: *const __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Loads 128-bits of integer data from memory into a new vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2732594,"byte_end":2732603,"line_start":1199,"line_end":1199,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2732604,"byte_end":2732638,"line_start":1200,"line_end":1200,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2732679,"byte_end":2732728,"line_start":1202,"line_end":1202,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7888},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2733220,"byte_end":2733235,"line_start":1216,"line_end":1216,"column_start":15,"column_end":30},"name":"_mm_loadu_si128","qualname":"::core_arch::x86::sse2::_mm_loadu_si128","value":"fn (mem_addr: *const __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Loads 128-bits of integer data from memory into a new vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2733071,"byte_end":2733080,"line_start":1212,"line_end":1212,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2733081,"byte_end":2733115,"line_start":1213,"line_end":1213,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2733156,"byte_end":2733205,"line_start":1215,"line_end":1215,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7889},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2734071,"byte_end":2734090,"line_start":1240,"line_end":1240,"column_start":15,"column_end":34},"name":"_mm_maskmoveu_si128","qualname":"::core_arch::x86::sse2::_mm_maskmoveu_si128","value":"fn (a: __m128i, mask: __m128i, mem_addr: *mut i8) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Conditionally store 8-bit integer elements from `a` into memory using\n `mask`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2733918,"byte_end":2733927,"line_start":1236,"line_end":1236,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2733928,"byte_end":2733962,"line_start":1237,"line_end":1237,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2734007,"byte_end":2734056,"line_start":1239,"line_end":1239,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7890},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2734579,"byte_end":2734594,"line_start":1253,"line_end":1253,"column_start":15,"column_end":30},"name":"_mm_store_si128","qualname":"::core_arch::x86::sse2::_mm_store_si128","value":"fn (mem_addr: *mut __m128i, a: __m128i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 128-bits of integer data from `a` into memory.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2734430,"byte_end":2734439,"line_start":1249,"line_end":1249,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2734440,"byte_end":2734474,"line_start":1250,"line_end":1250,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2734515,"byte_end":2734564,"line_start":1252,"line_end":1252,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7891},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2735079,"byte_end":2735095,"line_start":1266,"line_end":1266,"column_start":15,"column_end":31},"name":"_mm_storeu_si128","qualname":"::core_arch::x86::sse2::_mm_storeu_si128","value":"fn (mem_addr: *mut __m128i, a: __m128i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 128-bits of integer data from `a` into memory.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2734905,"byte_end":2734914,"line_start":1262,"line_end":1262,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2734915,"byte_end":2734949,"line_start":1263,"line_end":1263,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2735015,"byte_end":2735064,"line_start":1265,"line_end":1265,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7892},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2735762,"byte_end":2735778,"line_start":1288,"line_end":1288,"column_start":15,"column_end":31},"name":"_mm_storel_epi64","qualname":"::core_arch::x86::sse2::_mm_storel_epi64","value":"fn (mem_addr: *mut __m128i, a: __m128i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the lower 64-bit integer `a` to a memory location.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2735429,"byte_end":2735438,"line_start":1275,"line_end":1275,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2735439,"byte_end":2735473,"line_start":1276,"line_end":1276,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2735698,"byte_end":2735747,"line_start":1287,"line_end":1287,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7893},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2736360,"byte_end":2736376,"line_start":1301,"line_end":1301,"column_start":15,"column_end":31},"name":"_mm_stream_si128","qualname":"::core_arch::x86::sse2::_mm_stream_si128","value":"fn (mem_addr: *mut __m128i, a: __m128i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores a 128-bit integer vector to a 128-bit aligned memory location.\n To minimize caching, the data is flagged as non-temporal (unlikely to be\n used again soon).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2736193,"byte_end":2736202,"line_start":1297,"line_end":1297,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2736203,"byte_end":2736237,"line_start":1298,"line_end":1298,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2736296,"byte_end":2736345,"line_start":1300,"line_end":1300,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7894},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2736898,"byte_end":2736913,"line_start":1314,"line_end":1314,"column_start":15,"column_end":30},"name":"_mm_stream_si32","qualname":"::core_arch::x86::sse2::_mm_stream_si32","value":"fn (mem_addr: *mut i32, a: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores a 32-bit integer value in the specified memory location.\n To minimize caching, the data is flagged as non-temporal (unlikely to be\n used again soon).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2736749,"byte_end":2736758,"line_start":1310,"line_end":1310,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2736759,"byte_end":2736793,"line_start":1311,"line_end":1311,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2736834,"byte_end":2736883,"line_start":1313,"line_end":1313,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7895},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2737439,"byte_end":2737453,"line_start":1327,"line_end":1327,"column_start":15,"column_end":29},"name":"_mm_move_epi64","qualname":"::core_arch::x86::sse2::_mm_move_epi64","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns a vector where the low element is extracted from `a` and its upper\n element is zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2737210,"byte_end":2737219,"line_start":1322,"line_end":1322,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2737220,"byte_end":2737254,"line_start":1323,"line_end":1323,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2737375,"byte_end":2737424,"line_start":1326,"line_end":1326,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7896},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2737982,"byte_end":2737997,"line_start":1341,"line_end":1341,"column_start":15,"column_end":30},"name":"_mm_packs_epi16","qualname":"::core_arch::x86::sse2::_mm_packs_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers\n using signed saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2737831,"byte_end":2737840,"line_start":1337,"line_end":1337,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2737841,"byte_end":2737875,"line_start":1338,"line_end":1338,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2737918,"byte_end":2737967,"line_start":1340,"line_end":1340,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7897},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2738465,"byte_end":2738480,"line_start":1353,"line_end":1353,"column_start":15,"column_end":30},"name":"_mm_packs_epi32","qualname":"::core_arch::x86::sse2::_mm_packs_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers\n using signed saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2738314,"byte_end":2738323,"line_start":1349,"line_end":1349,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2738324,"byte_end":2738358,"line_start":1350,"line_end":1350,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2738401,"byte_end":2738450,"line_start":1352,"line_end":1352,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7898},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2738950,"byte_end":2738966,"line_start":1365,"line_end":1365,"column_start":15,"column_end":31},"name":"_mm_packus_epi16","qualname":"::core_arch::x86::sse2::_mm_packus_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers\n using unsigned saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2738799,"byte_end":2738808,"line_start":1361,"line_end":1361,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2738809,"byte_end":2738843,"line_start":1362,"line_end":1362,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2738886,"byte_end":2738935,"line_start":1364,"line_end":1364,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7899},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2739407,"byte_end":2739424,"line_start":1377,"line_end":1377,"column_start":15,"column_end":32},"name":"_mm_extract_epi16","qualname":"::core_arch::x86::sse2::_mm_extract_epi16","value":"fn (a: __m128i, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Returns the `imm8` element of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2739216,"byte_end":2739225,"line_start":1372,"line_end":1372,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2739226,"byte_end":2739260,"line_start":1373,"line_end":1373,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2739311,"byte_end":2739342,"line_start":1375,"line_end":1375,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2739343,"byte_end":2739392,"line_start":1376,"line_end":1376,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7900},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2739914,"byte_end":2739930,"line_start":1389,"line_end":1389,"column_start":15,"column_end":31},"name":"_mm_insert_epi16","qualname":"::core_arch::x86::sse2::_mm_insert_epi16","value":"fn (a: __m128i, i: i32, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector where the `imm8` element of `a` is replaced with `i`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2739723,"byte_end":2739732,"line_start":1384,"line_end":1384,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2739733,"byte_end":2739767,"line_start":1385,"line_end":1385,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2739818,"byte_end":2739849,"line_start":1387,"line_end":1387,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2739850,"byte_end":2739899,"line_start":1388,"line_end":1388,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7901},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2740388,"byte_end":2740405,"line_start":1400,"line_end":1400,"column_start":15,"column_end":32},"name":"_mm_movemask_epi8","qualname":"::core_arch::x86::sse2::_mm_movemask_epi8","value":"fn (a: __m128i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Returns a mask of the most significant bit of each element in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2740237,"byte_end":2740246,"line_start":1396,"line_end":1396,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2740247,"byte_end":2740281,"line_start":1397,"line_end":1397,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2740324,"byte_end":2740373,"line_start":1399,"line_end":1399,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7902},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2740831,"byte_end":2740848,"line_start":1412,"line_end":1412,"column_start":15,"column_end":32},"name":"_mm_shuffle_epi32","qualname":"::core_arch::x86::sse2::_mm_shuffle_epi32","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 32-bit integers in `a` using the control in `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2740640,"byte_end":2740649,"line_start":1407,"line_end":1407,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2740650,"byte_end":2740684,"line_start":1408,"line_end":1408,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2740735,"byte_end":2740766,"line_start":1410,"line_end":1410,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2740767,"byte_end":2740816,"line_start":1411,"line_end":1411,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7907},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2743299,"byte_end":2743318,"line_start":1479,"line_end":1479,"column_start":15,"column_end":34},"name":"_mm_shufflehi_epi16","qualname":"::core_arch::x86::sse2::_mm_shufflehi_epi16","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 16-bit integers in the high 64 bits of `a` using the control in\n `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2743107,"byte_end":2743116,"line_start":1474,"line_end":1474,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2743117,"byte_end":2743151,"line_start":1475,"line_end":1475,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2743203,"byte_end":2743234,"line_start":1477,"line_end":1477,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2743235,"byte_end":2743284,"line_start":1478,"line_end":1478,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7912},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2745398,"byte_end":2745417,"line_start":1539,"line_end":1539,"column_start":15,"column_end":34},"name":"_mm_shufflelo_epi16","qualname":"::core_arch::x86::sse2::_mm_shufflelo_epi16","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 16-bit integers in the low 64 bits of `a` using the control in\n `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2745206,"byte_end":2745215,"line_start":1534,"line_end":1534,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2745216,"byte_end":2745250,"line_start":1535,"line_end":1535,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2745302,"byte_end":2745333,"line_start":1537,"line_end":1537,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2745334,"byte_end":2745383,"line_start":1538,"line_end":1538,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7917},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2747308,"byte_end":2747325,"line_start":1595,"line_end":1595,"column_start":15,"column_end":32},"name":"_mm_unpackhi_epi8","qualname":"::core_arch::x86::sse2::_mm_unpackhi_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 8-bit integers from the high half of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2747156,"byte_end":2747165,"line_start":1591,"line_end":1591,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2747166,"byte_end":2747200,"line_start":1592,"line_end":1592,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2747244,"byte_end":2747293,"line_start":1594,"line_end":1594,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7918},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2747880,"byte_end":2747898,"line_start":1610,"line_end":1610,"column_start":15,"column_end":33},"name":"_mm_unpackhi_epi16","qualname":"::core_arch::x86::sse2::_mm_unpackhi_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 16-bit integers from the high half of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2747728,"byte_end":2747737,"line_start":1606,"line_end":1606,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2747738,"byte_end":2747772,"line_start":1607,"line_end":1607,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2747816,"byte_end":2747865,"line_start":1609,"line_end":1609,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7919},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2748401,"byte_end":2748419,"line_start":1622,"line_end":1622,"column_start":15,"column_end":33},"name":"_mm_unpackhi_epi32","qualname":"::core_arch::x86::sse2::_mm_unpackhi_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 32-bit integers from the high half of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2748250,"byte_end":2748259,"line_start":1618,"line_end":1618,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2748260,"byte_end":2748294,"line_start":1619,"line_end":1619,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2748337,"byte_end":2748386,"line_start":1621,"line_end":1621,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7920},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2748891,"byte_end":2748909,"line_start":1633,"line_end":1633,"column_start":15,"column_end":33},"name":"_mm_unpackhi_epi64","qualname":"::core_arch::x86::sse2::_mm_unpackhi_epi64","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 64-bit integers from the high half of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2748740,"byte_end":2748749,"line_start":1629,"line_end":1629,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2748750,"byte_end":2748784,"line_start":1630,"line_end":1630,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2748827,"byte_end":2748876,"line_start":1632,"line_end":1632,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7921},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2749373,"byte_end":2749390,"line_start":1644,"line_end":1644,"column_start":15,"column_end":32},"name":"_mm_unpacklo_epi8","qualname":"::core_arch::x86::sse2::_mm_unpacklo_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 8-bit integers from the low half of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2749221,"byte_end":2749230,"line_start":1640,"line_end":1640,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2749231,"byte_end":2749265,"line_start":1641,"line_end":1641,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2749309,"byte_end":2749358,"line_start":1643,"line_end":1643,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7922},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2749938,"byte_end":2749956,"line_start":1659,"line_end":1659,"column_start":15,"column_end":33},"name":"_mm_unpacklo_epi16","qualname":"::core_arch::x86::sse2::_mm_unpacklo_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 16-bit integers from the low half of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2749786,"byte_end":2749795,"line_start":1655,"line_end":1655,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2749796,"byte_end":2749830,"line_start":1656,"line_end":1656,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2749874,"byte_end":2749923,"line_start":1658,"line_end":1658,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7923},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2750456,"byte_end":2750474,"line_start":1671,"line_end":1671,"column_start":15,"column_end":33},"name":"_mm_unpacklo_epi32","qualname":"::core_arch::x86::sse2::_mm_unpacklo_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 32-bit integers from the low half of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2750305,"byte_end":2750314,"line_start":1667,"line_end":1667,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2750315,"byte_end":2750349,"line_start":1668,"line_end":1668,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2750392,"byte_end":2750441,"line_start":1670,"line_end":1670,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7924},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2750977,"byte_end":2750995,"line_start":1682,"line_end":1682,"column_start":15,"column_end":33},"name":"_mm_unpacklo_epi64","qualname":"::core_arch::x86::sse2::_mm_unpacklo_epi64","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 64-bit integers from the low half of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2750794,"byte_end":2750803,"line_start":1678,"line_end":1678,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2750804,"byte_end":2750838,"line_start":1679,"line_end":1679,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2750913,"byte_end":2750962,"line_start":1681,"line_end":1681,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7925},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2751485,"byte_end":2751495,"line_start":1694,"line_end":1694,"column_start":15,"column_end":25},"name":"_mm_add_sd","qualname":"::core_arch::x86::sse2::_mm_add_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the sum of the\n low elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2751337,"byte_end":2751346,"line_start":1690,"line_end":1690,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2751347,"byte_end":2751381,"line_start":1691,"line_end":1691,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2751421,"byte_end":2751470,"line_start":1693,"line_end":1693,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7926},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2751940,"byte_end":2751950,"line_start":1706,"line_end":1706,"column_start":15,"column_end":25},"name":"_mm_add_pd","qualname":"::core_arch::x86::sse2::_mm_add_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Adds packed double-precision (64-bit) floating-point elements in `a` and\n `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2751792,"byte_end":2751801,"line_start":1702,"line_end":1702,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2751802,"byte_end":2751836,"line_start":1703,"line_end":1703,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2751876,"byte_end":2751925,"line_start":1705,"line_end":1705,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7927},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2752413,"byte_end":2752423,"line_start":1718,"line_end":1718,"column_start":15,"column_end":25},"name":"_mm_div_sd","qualname":"::core_arch::x86::sse2::_mm_div_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the result of\n diving the lower element of `a` by the lower element of `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2752265,"byte_end":2752274,"line_start":1714,"line_end":1714,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2752275,"byte_end":2752309,"line_start":1715,"line_end":1715,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2752349,"byte_end":2752398,"line_start":1717,"line_end":1717,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7928},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2752888,"byte_end":2752898,"line_start":1730,"line_end":1730,"column_start":15,"column_end":25},"name":"_mm_div_pd","qualname":"::core_arch::x86::sse2::_mm_div_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Divide packed double-precision (64-bit) floating-point elements in `a` by\n packed elements in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2752740,"byte_end":2752749,"line_start":1726,"line_end":1726,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2752750,"byte_end":2752784,"line_start":1727,"line_end":1727,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2752824,"byte_end":2752873,"line_start":1729,"line_end":1729,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7929},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2753336,"byte_end":2753346,"line_start":1742,"line_end":1742,"column_start":15,"column_end":25},"name":"_mm_max_sd","qualname":"::core_arch::x86::sse2::_mm_max_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the maximum\n of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2753188,"byte_end":2753197,"line_start":1738,"line_end":1738,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2753198,"byte_end":2753232,"line_start":1739,"line_end":1739,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2753272,"byte_end":2753321,"line_start":1741,"line_end":1741,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7930},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2753759,"byte_end":2753769,"line_start":1754,"line_end":1754,"column_start":15,"column_end":25},"name":"_mm_max_pd","qualname":"::core_arch::x86::sse2::_mm_max_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the maximum values from corresponding elements in\n `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2753611,"byte_end":2753620,"line_start":1750,"line_end":1750,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2753621,"byte_end":2753655,"line_start":1751,"line_end":1751,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2753695,"byte_end":2753744,"line_start":1753,"line_end":1753,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7931},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2754204,"byte_end":2754214,"line_start":1766,"line_end":1766,"column_start":15,"column_end":25},"name":"_mm_min_sd","qualname":"::core_arch::x86::sse2::_mm_min_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the minimum\n of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2754056,"byte_end":2754065,"line_start":1762,"line_end":1762,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2754066,"byte_end":2754100,"line_start":1763,"line_end":1763,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2754140,"byte_end":2754189,"line_start":1765,"line_end":1765,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7932},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2754627,"byte_end":2754637,"line_start":1778,"line_end":1778,"column_start":15,"column_end":25},"name":"_mm_min_pd","qualname":"::core_arch::x86::sse2::_mm_min_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the minimum values from corresponding elements in\n `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2754479,"byte_end":2754488,"line_start":1774,"line_end":1774,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2754489,"byte_end":2754523,"line_start":1775,"line_end":1775,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2754563,"byte_end":2754612,"line_start":1777,"line_end":1777,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7933},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2755067,"byte_end":2755077,"line_start":1790,"line_end":1790,"column_start":15,"column_end":25},"name":"_mm_mul_sd","qualname":"::core_arch::x86::sse2::_mm_mul_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by multiplying the\n low elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2754919,"byte_end":2754928,"line_start":1786,"line_end":1786,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2754929,"byte_end":2754963,"line_start":1787,"line_end":1787,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2755003,"byte_end":2755052,"line_start":1789,"line_end":1789,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7934},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2755528,"byte_end":2755538,"line_start":1802,"line_end":1802,"column_start":15,"column_end":25},"name":"_mm_mul_pd","qualname":"::core_arch::x86::sse2::_mm_mul_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2755380,"byte_end":2755389,"line_start":1798,"line_end":1798,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2755390,"byte_end":2755424,"line_start":1799,"line_end":1799,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2755464,"byte_end":2755513,"line_start":1801,"line_end":1801,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7935},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2755970,"byte_end":2755981,"line_start":1814,"line_end":1814,"column_start":15,"column_end":26},"name":"_mm_sqrt_sd","qualname":"::core_arch::x86::sse2::_mm_sqrt_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the square\n root of the lower element `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2755821,"byte_end":2755830,"line_start":1810,"line_end":1810,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2755831,"byte_end":2755865,"line_start":1811,"line_end":1811,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2755906,"byte_end":2755955,"line_start":1813,"line_end":1813,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7936},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2756407,"byte_end":2756418,"line_start":1825,"line_end":1825,"column_start":15,"column_end":26},"name":"_mm_sqrt_pd","qualname":"::core_arch::x86::sse2::_mm_sqrt_pd","value":"fn (a: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the square root of each of the values in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2756258,"byte_end":2756267,"line_start":1821,"line_end":1821,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2756268,"byte_end":2756302,"line_start":1822,"line_end":1822,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2756343,"byte_end":2756392,"line_start":1824,"line_end":1824,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7937},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2756853,"byte_end":2756863,"line_start":1837,"line_end":1837,"column_start":15,"column_end":25},"name":"_mm_sub_sd","qualname":"::core_arch::x86::sse2::_mm_sub_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by subtracting the\n low element by `b` from the low element of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2756705,"byte_end":2756714,"line_start":1833,"line_end":1833,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2756715,"byte_end":2756749,"line_start":1834,"line_end":1834,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2756789,"byte_end":2756838,"line_start":1836,"line_end":1836,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7938},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2757313,"byte_end":2757323,"line_start":1849,"line_end":1849,"column_start":15,"column_end":25},"name":"_mm_sub_pd","qualname":"::core_arch::x86::sse2::_mm_sub_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed double-precision (64-bit) floating-point elements in `b`\n from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2757165,"byte_end":2757174,"line_start":1845,"line_end":1845,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2757175,"byte_end":2757209,"line_start":1846,"line_end":1846,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2757249,"byte_end":2757298,"line_start":1848,"line_end":1848,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7939},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2757751,"byte_end":2757761,"line_start":1861,"line_end":1861,"column_start":15,"column_end":25},"name":"_mm_and_pd","qualname":"::core_arch::x86::sse2::_mm_and_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of packed double-precision (64-bit) floating-point\n elements in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2757603,"byte_end":2757612,"line_start":1857,"line_end":1857,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2757613,"byte_end":2757647,"line_start":1858,"line_end":1858,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2757687,"byte_end":2757736,"line_start":1860,"line_end":1860,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7940},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2758229,"byte_end":2758242,"line_start":1874,"line_end":1874,"column_start":15,"column_end":28},"name":"_mm_andnot_pd","qualname":"::core_arch::x86::sse2::_mm_andnot_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise NOT of `a` and then AND with `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2758080,"byte_end":2758089,"line_start":1870,"line_end":1870,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2758090,"byte_end":2758124,"line_start":1871,"line_end":1871,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2758165,"byte_end":2758214,"line_start":1873,"line_end":1873,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7941},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2758692,"byte_end":2758701,"line_start":1887,"line_end":1887,"column_start":15,"column_end":24},"name":"_mm_or_pd","qualname":"::core_arch::x86::sse2::_mm_or_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise OR of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2758545,"byte_end":2758554,"line_start":1883,"line_end":1883,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2758555,"byte_end":2758589,"line_start":1884,"line_end":1884,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2758628,"byte_end":2758677,"line_start":1886,"line_end":1886,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7942},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2759149,"byte_end":2759159,"line_start":1900,"line_end":1900,"column_start":15,"column_end":25},"name":"_mm_xor_pd","qualname":"::core_arch::x86::sse2::_mm_xor_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise OR of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2759001,"byte_end":2759010,"line_start":1896,"line_end":1896,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2759011,"byte_end":2759045,"line_start":1897,"line_end":1897,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2759085,"byte_end":2759134,"line_start":1899,"line_end":1899,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7943},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2759699,"byte_end":2759711,"line_start":1914,"line_end":1914,"column_start":15,"column_end":27},"name":"_mm_cmpeq_sd","qualname":"::core_arch::x86::sse2::_mm_cmpeq_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the equality\n comparison of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2759549,"byte_end":2759558,"line_start":1910,"line_end":1910,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2759559,"byte_end":2759593,"line_start":1911,"line_end":1911,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2759635,"byte_end":2759684,"line_start":1913,"line_end":1913,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7944},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2760166,"byte_end":2760178,"line_start":1926,"line_end":1926,"column_start":15,"column_end":27},"name":"_mm_cmplt_sd","qualname":"::core_arch::x86::sse2::_mm_cmplt_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the less-than\n comparison of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2760016,"byte_end":2760025,"line_start":1922,"line_end":1922,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2760026,"byte_end":2760060,"line_start":1923,"line_end":1923,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2760102,"byte_end":2760151,"line_start":1925,"line_end":1925,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7945},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2760642,"byte_end":2760654,"line_start":1938,"line_end":1938,"column_start":15,"column_end":27},"name":"_mm_cmple_sd","qualname":"::core_arch::x86::sse2::_mm_cmple_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the\n less-than-or-equal comparison of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2760492,"byte_end":2760501,"line_start":1934,"line_end":1934,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2760502,"byte_end":2760536,"line_start":1935,"line_end":1935,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2760578,"byte_end":2760627,"line_start":1937,"line_end":1937,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7946},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2761112,"byte_end":2761124,"line_start":1950,"line_end":1950,"column_start":15,"column_end":27},"name":"_mm_cmpgt_sd","qualname":"::core_arch::x86::sse2::_mm_cmpgt_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the\n greater-than comparison of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2760962,"byte_end":2760971,"line_start":1946,"line_end":1946,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2760972,"byte_end":2761006,"line_start":1947,"line_end":1947,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2761048,"byte_end":2761097,"line_start":1949,"line_end":1949,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7947},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2761641,"byte_end":2761653,"line_start":1962,"line_end":1962,"column_start":15,"column_end":27},"name":"_mm_cmpge_sd","qualname":"::core_arch::x86::sse2::_mm_cmpge_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the\n greater-than-or-equal comparison of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2761491,"byte_end":2761500,"line_start":1958,"line_end":1958,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2761501,"byte_end":2761535,"line_start":1959,"line_end":1959,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2761577,"byte_end":2761626,"line_start":1961,"line_end":1961,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7948},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2762264,"byte_end":2762277,"line_start":1976,"line_end":1976,"column_start":15,"column_end":28},"name":"_mm_cmpord_sd","qualname":"::core_arch::x86::sse2::_mm_cmpord_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the result\n of comparing both of the lower elements of `a` and `b` to `NaN`. If\n neither are equal to `NaN` then `0xFFFFFFFFFFFFFFFF` is used and `0`\n otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2762113,"byte_end":2762122,"line_start":1972,"line_end":1972,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2762123,"byte_end":2762157,"line_start":1973,"line_end":1973,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2762200,"byte_end":2762249,"line_start":1975,"line_end":1975,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7949},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2762836,"byte_end":2762851,"line_start":1989,"line_end":1989,"column_start":15,"column_end":30},"name":"_mm_cmpunord_sd","qualname":"::core_arch::x86::sse2::_mm_cmpunord_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the result of\n comparing both of the lower elements of `a` and `b` to `NaN`. If either is\n equal to `NaN` then `0xFFFFFFFFFFFFFFFF` is used and `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2762683,"byte_end":2762692,"line_start":1985,"line_end":1985,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2762693,"byte_end":2762727,"line_start":1986,"line_end":1986,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2762772,"byte_end":2762821,"line_start":1988,"line_end":1988,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7950},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2763308,"byte_end":2763321,"line_start":2001,"line_end":2001,"column_start":15,"column_end":28},"name":"_mm_cmpneq_sd","qualname":"::core_arch::x86::sse2::_mm_cmpneq_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the not-equal\n comparison of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2763157,"byte_end":2763166,"line_start":1997,"line_end":1997,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2763167,"byte_end":2763201,"line_start":1998,"line_end":1998,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2763244,"byte_end":2763293,"line_start":2000,"line_end":2000,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7951},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2763782,"byte_end":2763795,"line_start":2013,"line_end":2013,"column_start":15,"column_end":28},"name":"_mm_cmpnlt_sd","qualname":"::core_arch::x86::sse2::_mm_cmpnlt_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the\n not-less-than comparison of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2763631,"byte_end":2763640,"line_start":2009,"line_end":2009,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2763641,"byte_end":2763675,"line_start":2010,"line_end":2010,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2763718,"byte_end":2763767,"line_start":2012,"line_end":2012,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7952},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2764265,"byte_end":2764278,"line_start":2025,"line_end":2025,"column_start":15,"column_end":28},"name":"_mm_cmpnle_sd","qualname":"::core_arch::x86::sse2::_mm_cmpnle_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the\n not-less-than-or-equal comparison of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2764114,"byte_end":2764123,"line_start":2021,"line_end":2021,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2764124,"byte_end":2764158,"line_start":2022,"line_end":2022,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2764201,"byte_end":2764250,"line_start":2024,"line_end":2024,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7953},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2764742,"byte_end":2764755,"line_start":2037,"line_end":2037,"column_start":15,"column_end":28},"name":"_mm_cmpngt_sd","qualname":"::core_arch::x86::sse2::_mm_cmpngt_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the\n not-greater-than comparison of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2764591,"byte_end":2764600,"line_start":2033,"line_end":2033,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2764601,"byte_end":2764635,"line_start":2034,"line_end":2034,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2764678,"byte_end":2764727,"line_start":2036,"line_end":2036,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7954},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2765279,"byte_end":2765292,"line_start":2049,"line_end":2049,"column_start":15,"column_end":28},"name":"_mm_cmpnge_sd","qualname":"::core_arch::x86::sse2::_mm_cmpnge_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the\n not-greater-than-or-equal comparison of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2765128,"byte_end":2765137,"line_start":2045,"line_end":2045,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2765138,"byte_end":2765172,"line_start":2046,"line_end":2046,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2765215,"byte_end":2765264,"line_start":2048,"line_end":2048,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7955},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2765731,"byte_end":2765743,"line_start":2060,"line_end":2060,"column_start":15,"column_end":27},"name":"_mm_cmpeq_pd","qualname":"::core_arch::x86::sse2::_mm_cmpeq_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` for equality.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2765581,"byte_end":2765590,"line_start":2056,"line_end":2056,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2765591,"byte_end":2765625,"line_start":2057,"line_end":2057,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2765667,"byte_end":2765716,"line_start":2059,"line_end":2059,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7956},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2766132,"byte_end":2766144,"line_start":2071,"line_end":2071,"column_start":15,"column_end":27},"name":"_mm_cmplt_pd","qualname":"::core_arch::x86::sse2::_mm_cmplt_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` for less-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2765982,"byte_end":2765991,"line_start":2067,"line_end":2067,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2765992,"byte_end":2766026,"line_start":2068,"line_end":2068,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2766068,"byte_end":2766117,"line_start":2070,"line_end":2070,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7957},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2766541,"byte_end":2766553,"line_start":2082,"line_end":2082,"column_start":15,"column_end":27},"name":"_mm_cmple_pd","qualname":"::core_arch::x86::sse2::_mm_cmple_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` for less-than-or-equal","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2766391,"byte_end":2766400,"line_start":2078,"line_end":2078,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2766401,"byte_end":2766435,"line_start":2079,"line_end":2079,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2766477,"byte_end":2766526,"line_start":2081,"line_end":2081,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7958},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2766945,"byte_end":2766957,"line_start":2093,"line_end":2093,"column_start":15,"column_end":27},"name":"_mm_cmpgt_pd","qualname":"::core_arch::x86::sse2::_mm_cmpgt_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` for greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2766795,"byte_end":2766804,"line_start":2089,"line_end":2089,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2766805,"byte_end":2766839,"line_start":2090,"line_end":2090,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2766881,"byte_end":2766930,"line_start":2092,"line_end":2092,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7959},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2767362,"byte_end":2767374,"line_start":2104,"line_end":2104,"column_start":15,"column_end":27},"name":"_mm_cmpge_pd","qualname":"::core_arch::x86::sse2::_mm_cmpge_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` for greater-than-or-equal.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2767212,"byte_end":2767221,"line_start":2100,"line_end":2100,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2767222,"byte_end":2767256,"line_start":2101,"line_end":2101,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2767298,"byte_end":2767347,"line_start":2103,"line_end":2103,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7960},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2767782,"byte_end":2767795,"line_start":2115,"line_end":2115,"column_start":15,"column_end":28},"name":"_mm_cmpord_pd","qualname":"::core_arch::x86::sse2::_mm_cmpord_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` to see if neither is `NaN`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2767631,"byte_end":2767640,"line_start":2111,"line_end":2111,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2767641,"byte_end":2767675,"line_start":2112,"line_end":2112,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2767718,"byte_end":2767767,"line_start":2114,"line_end":2114,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7961},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2768202,"byte_end":2768217,"line_start":2126,"line_end":2126,"column_start":15,"column_end":30},"name":"_mm_cmpunord_pd","qualname":"::core_arch::x86::sse2::_mm_cmpunord_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` to see if either is `NaN`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2768049,"byte_end":2768058,"line_start":2122,"line_end":2122,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2768059,"byte_end":2768093,"line_start":2123,"line_end":2123,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2768138,"byte_end":2768187,"line_start":2125,"line_end":2125,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7962},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2768608,"byte_end":2768621,"line_start":2137,"line_end":2137,"column_start":15,"column_end":28},"name":"_mm_cmpneq_pd","qualname":"::core_arch::x86::sse2::_mm_cmpneq_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` for not-equal.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2768457,"byte_end":2768466,"line_start":2133,"line_end":2133,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2768467,"byte_end":2768501,"line_start":2134,"line_end":2134,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2768544,"byte_end":2768593,"line_start":2136,"line_end":2136,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7963},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2769016,"byte_end":2769029,"line_start":2148,"line_end":2148,"column_start":15,"column_end":28},"name":"_mm_cmpnlt_pd","qualname":"::core_arch::x86::sse2::_mm_cmpnlt_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` for not-less-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2768865,"byte_end":2768874,"line_start":2144,"line_end":2144,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2768875,"byte_end":2768909,"line_start":2145,"line_end":2145,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2768952,"byte_end":2769001,"line_start":2147,"line_end":2147,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7964},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2769433,"byte_end":2769446,"line_start":2159,"line_end":2159,"column_start":15,"column_end":28},"name":"_mm_cmpnle_pd","qualname":"::core_arch::x86::sse2::_mm_cmpnle_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` for not-less-than-or-equal.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2769282,"byte_end":2769291,"line_start":2155,"line_end":2155,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2769292,"byte_end":2769326,"line_start":2156,"line_end":2156,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2769369,"byte_end":2769418,"line_start":2158,"line_end":2158,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7965},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2769844,"byte_end":2769857,"line_start":2170,"line_end":2170,"column_start":15,"column_end":28},"name":"_mm_cmpngt_pd","qualname":"::core_arch::x86::sse2::_mm_cmpngt_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` for not-greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2769693,"byte_end":2769702,"line_start":2166,"line_end":2166,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2769703,"byte_end":2769737,"line_start":2167,"line_end":2167,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2769780,"byte_end":2769829,"line_start":2169,"line_end":2169,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7966},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2770273,"byte_end":2770286,"line_start":2182,"line_end":2182,"column_start":15,"column_end":28},"name":"_mm_cmpnge_pd","qualname":"::core_arch::x86::sse2::_mm_cmpnge_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` for\n not-greater-than-or-equal.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2770122,"byte_end":2770131,"line_start":2178,"line_end":2178,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2770132,"byte_end":2770166,"line_start":2179,"line_end":2179,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2770209,"byte_end":2770258,"line_start":2181,"line_end":2181,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7967},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2770674,"byte_end":2770687,"line_start":2193,"line_end":2193,"column_start":15,"column_end":28},"name":"_mm_comieq_sd","qualname":"::core_arch::x86::sse2::_mm_comieq_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for equality.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2770525,"byte_end":2770534,"line_start":2189,"line_end":2189,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2770535,"byte_end":2770569,"line_start":2190,"line_end":2190,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2770610,"byte_end":2770659,"line_start":2192,"line_end":2192,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7968},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2771067,"byte_end":2771080,"line_start":2204,"line_end":2204,"column_start":15,"column_end":28},"name":"_mm_comilt_sd","qualname":"::core_arch::x86::sse2::_mm_comilt_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for less-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2770918,"byte_end":2770927,"line_start":2200,"line_end":2200,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2770928,"byte_end":2770962,"line_start":2201,"line_end":2201,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2771003,"byte_end":2771052,"line_start":2203,"line_end":2203,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7969},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2771469,"byte_end":2771482,"line_start":2215,"line_end":2215,"column_start":15,"column_end":28},"name":"_mm_comile_sd","qualname":"::core_arch::x86::sse2::_mm_comile_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for less-than-or-equal.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2771320,"byte_end":2771329,"line_start":2211,"line_end":2211,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2771330,"byte_end":2771364,"line_start":2212,"line_end":2212,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2771405,"byte_end":2771454,"line_start":2214,"line_end":2214,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7970},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2771865,"byte_end":2771878,"line_start":2226,"line_end":2226,"column_start":15,"column_end":28},"name":"_mm_comigt_sd","qualname":"::core_arch::x86::sse2::_mm_comigt_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2771716,"byte_end":2771725,"line_start":2222,"line_end":2222,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2771726,"byte_end":2771760,"line_start":2223,"line_end":2223,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2771801,"byte_end":2771850,"line_start":2225,"line_end":2225,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7971},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2772270,"byte_end":2772283,"line_start":2237,"line_end":2237,"column_start":15,"column_end":28},"name":"_mm_comige_sd","qualname":"::core_arch::x86::sse2::_mm_comige_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for greater-than-or-equal.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2772121,"byte_end":2772130,"line_start":2233,"line_end":2233,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2772131,"byte_end":2772165,"line_start":2234,"line_end":2234,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2772206,"byte_end":2772255,"line_start":2236,"line_end":2236,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7972},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2772664,"byte_end":2772678,"line_start":2248,"line_end":2248,"column_start":15,"column_end":29},"name":"_mm_comineq_sd","qualname":"::core_arch::x86::sse2::_mm_comineq_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for not-equal.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2772515,"byte_end":2772524,"line_start":2244,"line_end":2244,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2772525,"byte_end":2772559,"line_start":2245,"line_end":2245,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2772600,"byte_end":2772649,"line_start":2247,"line_end":2247,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7973},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2773060,"byte_end":2773074,"line_start":2259,"line_end":2259,"column_start":15,"column_end":29},"name":"_mm_ucomieq_sd","qualname":"::core_arch::x86::sse2::_mm_ucomieq_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for equality.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2772910,"byte_end":2772919,"line_start":2255,"line_end":2255,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2772920,"byte_end":2772954,"line_start":2256,"line_end":2256,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2772996,"byte_end":2773045,"line_start":2258,"line_end":2258,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7974},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2773457,"byte_end":2773471,"line_start":2270,"line_end":2270,"column_start":15,"column_end":29},"name":"_mm_ucomilt_sd","qualname":"::core_arch::x86::sse2::_mm_ucomilt_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for less-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2773307,"byte_end":2773316,"line_start":2266,"line_end":2266,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2773317,"byte_end":2773351,"line_start":2267,"line_end":2267,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2773393,"byte_end":2773442,"line_start":2269,"line_end":2269,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7975},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2773863,"byte_end":2773877,"line_start":2281,"line_end":2281,"column_start":15,"column_end":29},"name":"_mm_ucomile_sd","qualname":"::core_arch::x86::sse2::_mm_ucomile_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for less-than-or-equal.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2773713,"byte_end":2773722,"line_start":2277,"line_end":2277,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2773723,"byte_end":2773757,"line_start":2278,"line_end":2278,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2773799,"byte_end":2773848,"line_start":2280,"line_end":2280,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7976},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2774263,"byte_end":2774277,"line_start":2292,"line_end":2292,"column_start":15,"column_end":29},"name":"_mm_ucomigt_sd","qualname":"::core_arch::x86::sse2::_mm_ucomigt_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2774113,"byte_end":2774122,"line_start":2288,"line_end":2288,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2774123,"byte_end":2774157,"line_start":2289,"line_end":2289,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2774199,"byte_end":2774248,"line_start":2291,"line_end":2291,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7977},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2774672,"byte_end":2774686,"line_start":2303,"line_end":2303,"column_start":15,"column_end":29},"name":"_mm_ucomige_sd","qualname":"::core_arch::x86::sse2::_mm_ucomige_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for greater-than-or-equal.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2774522,"byte_end":2774531,"line_start":2299,"line_end":2299,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2774532,"byte_end":2774566,"line_start":2300,"line_end":2300,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2774608,"byte_end":2774657,"line_start":2302,"line_end":2302,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7978},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2775070,"byte_end":2775085,"line_start":2314,"line_end":2314,"column_start":15,"column_end":30},"name":"_mm_ucomineq_sd","qualname":"::core_arch::x86::sse2::_mm_ucomineq_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for not-equal.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2774920,"byte_end":2774929,"line_start":2310,"line_end":2310,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2774930,"byte_end":2774964,"line_start":2311,"line_end":2311,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2775006,"byte_end":2775055,"line_start":2313,"line_end":2313,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7979},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2775548,"byte_end":2775560,"line_start":2326,"line_end":2326,"column_start":15,"column_end":27},"name":"_mm_cvtpd_ps","qualname":"::core_arch::x86::sse2::_mm_cvtpd_ps","value":"fn (a: __m128d) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts packed double-precision (64-bit) floating-point elements in \"a\" to\n packed single-precision (32-bit) floating-point elements","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2775397,"byte_end":2775406,"line_start":2322,"line_end":2322,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2775407,"byte_end":2775441,"line_start":2323,"line_end":2323,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2775484,"byte_end":2775533,"line_start":2325,"line_end":2325,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7980},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2776014,"byte_end":2776026,"line_start":2339,"line_end":2339,"column_start":15,"column_end":27},"name":"_mm_cvtps_pd","qualname":"::core_arch::x86::sse2::_mm_cvtps_pd","value":"fn (a: __m128) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Converts packed single-precision (32-bit) floating-point elements in `a` to\n packed\n double-precision (64-bit) floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2775863,"byte_end":2775872,"line_start":2335,"line_end":2335,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2775873,"byte_end":2775907,"line_start":2336,"line_end":2336,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2775950,"byte_end":2775999,"line_start":2338,"line_end":2338,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7981},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2776445,"byte_end":2776460,"line_start":2351,"line_end":2351,"column_start":15,"column_end":30},"name":"_mm_cvtpd_epi32","qualname":"::core_arch::x86::sse2::_mm_cvtpd_epi32","value":"fn (a: __m128d) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed double-precision (64-bit) floating-point elements in `a` to\n packed 32-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2776294,"byte_end":2776303,"line_start":2347,"line_end":2347,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2776304,"byte_end":2776338,"line_start":2348,"line_end":2348,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2776381,"byte_end":2776430,"line_start":2350,"line_end":2350,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7982},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2776884,"byte_end":2776898,"line_start":2363,"line_end":2363,"column_start":15,"column_end":29},"name":"_mm_cvtsd_si32","qualname":"::core_arch::x86::sse2::_mm_cvtsd_si32","value":"fn (a: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Converts the lower double-precision (64-bit) floating-point element in a to\n a 32-bit integer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2776733,"byte_end":2776742,"line_start":2359,"line_end":2359,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2776743,"byte_end":2776777,"line_start":2360,"line_end":2360,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2776820,"byte_end":2776869,"line_start":2362,"line_end":2362,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7983},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2777485,"byte_end":2777497,"line_start":2377,"line_end":2377,"column_start":15,"column_end":27},"name":"_mm_cvtsd_ss","qualname":"::core_arch::x86::sse2::_mm_cvtsd_ss","value":"fn (a: __m128, b: __m128d) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts the lower double-precision (64-bit) floating-point element in `b`\n to a single-precision (32-bit) floating-point element, store the result in\n the lower element of the return value, and copies the upper element from `a`\n to the upper element the return value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2777334,"byte_end":2777343,"line_start":2373,"line_end":2373,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2777344,"byte_end":2777378,"line_start":2374,"line_end":2374,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2777421,"byte_end":2777470,"line_start":2376,"line_end":2376,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7984},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2777857,"byte_end":2777870,"line_start":2387,"line_end":2387,"column_start":15,"column_end":28},"name":"_mm_cvtsd_f64","qualname":"::core_arch::x86::sse2::_mm_cvtsd_f64","value":"fn (a: __m128d) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the lower double-precision (64-bit) floating-point element of \"a\".","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2777748,"byte_end":2777757,"line_start":2384,"line_end":2384,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2777758,"byte_end":2777792,"line_start":2385,"line_end":2385,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2777793,"byte_end":2777842,"line_start":2386,"line_end":2386,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7985},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2778464,"byte_end":2778476,"line_start":2401,"line_end":2401,"column_start":15,"column_end":27},"name":"_mm_cvtss_sd","qualname":"::core_arch::x86::sse2::_mm_cvtss_sd","value":"fn (a: __m128d, b: __m128) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Converts the lower single-precision (32-bit) floating-point element in `b`\n to a double-precision (64-bit) floating-point element, store the result in\n the lower element of the return value, and copies the upper element from `a`\n to the upper element the return value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2778313,"byte_end":2778322,"line_start":2397,"line_end":2397,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2778323,"byte_end":2778357,"line_start":2398,"line_end":2398,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2778400,"byte_end":2778449,"line_start":2400,"line_end":2400,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7986},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2778928,"byte_end":2778944,"line_start":2413,"line_end":2413,"column_start":15,"column_end":31},"name":"_mm_cvttpd_epi32","qualname":"::core_arch::x86::sse2::_mm_cvttpd_epi32","value":"fn (a: __m128d) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed double-precision (64-bit) floating-point elements in `a` to\n packed 32-bit integers with truncation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2778776,"byte_end":2778785,"line_start":2409,"line_end":2409,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2778786,"byte_end":2778820,"line_start":2410,"line_end":2410,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2778864,"byte_end":2778913,"line_start":2412,"line_end":2412,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7987},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2779389,"byte_end":2779404,"line_start":2425,"line_end":2425,"column_start":15,"column_end":30},"name":"_mm_cvttsd_si32","qualname":"::core_arch::x86::sse2::_mm_cvttsd_si32","value":"fn (a: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Converts the lower double-precision (64-bit) floating-point element in `a`\n to a 32-bit integer with truncation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2779237,"byte_end":2779246,"line_start":2421,"line_end":2421,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2779247,"byte_end":2779281,"line_start":2422,"line_end":2422,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2779325,"byte_end":2779374,"line_start":2424,"line_end":2424,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7988},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2779839,"byte_end":2779855,"line_start":2437,"line_end":2437,"column_start":15,"column_end":31},"name":"_mm_cvttps_epi32","qualname":"::core_arch::x86::sse2::_mm_cvttps_epi32","value":"fn (a: __m128) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed single-precision (32-bit) floating-point elements in `a` to\n packed 32-bit integers with truncation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2779687,"byte_end":2779696,"line_start":2433,"line_end":2433,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2779697,"byte_end":2779731,"line_start":2434,"line_end":2434,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2779775,"byte_end":2779824,"line_start":2436,"line_end":2436,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7989},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2780255,"byte_end":2780265,"line_start":2448,"line_end":2448,"column_start":15,"column_end":25},"name":"_mm_set_sd","qualname":"::core_arch::x86::sse2::_mm_set_sd","value":"fn (a: f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Copies double-precision (64-bit) floating-point element `a` to the lower\n element of the packed 64-bit return value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2780146,"byte_end":2780155,"line_start":2445,"line_end":2445,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2780156,"byte_end":2780190,"line_start":2446,"line_end":2446,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2780191,"byte_end":2780240,"line_start":2447,"line_end":2447,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7990},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2780639,"byte_end":2780650,"line_start":2459,"line_end":2459,"column_start":15,"column_end":26},"name":"_mm_set1_pd","qualname":"::core_arch::x86::sse2::_mm_set1_pd","value":"fn (a: f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts double-precision (64-bit) floating-point value a to all elements\n of the return value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2780530,"byte_end":2780539,"line_start":2456,"line_end":2456,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2780540,"byte_end":2780574,"line_start":2457,"line_end":2457,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2780575,"byte_end":2780624,"line_start":2458,"line_end":2458,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7991},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2781022,"byte_end":2781033,"line_start":2470,"line_end":2470,"column_start":15,"column_end":26},"name":"_mm_set_pd1","qualname":"::core_arch::x86::sse2::_mm_set_pd1","value":"fn (a: f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts double-precision (64-bit) floating-point value a to all elements\n of the return value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2780913,"byte_end":2780922,"line_start":2467,"line_end":2467,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2780923,"byte_end":2780957,"line_start":2468,"line_end":2468,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2780958,"byte_end":2781007,"line_start":2469,"line_end":2469,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7992},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2781415,"byte_end":2781425,"line_start":2481,"line_end":2481,"column_start":15,"column_end":25},"name":"_mm_set_pd","qualname":"::core_arch::x86::sse2::_mm_set_pd","value":"fn (a: f64, b: f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Sets packed double-precision (64-bit) floating-point elements in the return\n value with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2781306,"byte_end":2781315,"line_start":2478,"line_end":2478,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2781316,"byte_end":2781350,"line_start":2479,"line_end":2479,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2781351,"byte_end":2781400,"line_start":2480,"line_end":2480,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7993},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2781830,"byte_end":2781841,"line_start":2492,"line_end":2492,"column_start":15,"column_end":26},"name":"_mm_setr_pd","qualname":"::core_arch::x86::sse2::_mm_setr_pd","value":"fn (a: f64, b: f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Sets packed double-precision (64-bit) floating-point elements in the return\n value with the supplied values in reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2781721,"byte_end":2781730,"line_start":2489,"line_end":2489,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2781731,"byte_end":2781765,"line_start":2490,"line_end":2490,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2781766,"byte_end":2781815,"line_start":2491,"line_end":2491,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7994},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2782271,"byte_end":2782285,"line_start":2504,"line_end":2504,"column_start":15,"column_end":29},"name":"_mm_setzero_pd","qualname":"::core_arch::x86::sse2::_mm_setzero_pd","value":"fn () -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns packed double-precision (64-bit) floating-point elements with all\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2782099,"byte_end":2782108,"line_start":2500,"line_end":2500,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2782109,"byte_end":2782143,"line_start":2501,"line_end":2501,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2782207,"byte_end":2782256,"line_start":2503,"line_end":2503,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7995},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2782782,"byte_end":2782797,"line_start":2518,"line_end":2518,"column_start":15,"column_end":30},"name":"_mm_movemask_pd","qualname":"::core_arch::x86::sse2::_mm_movemask_pd","value":"fn (a: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Returns a mask of the most significant bit of each element in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2782631,"byte_end":2782640,"line_start":2514,"line_end":2514,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2782641,"byte_end":2782675,"line_start":2515,"line_end":2515,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2782718,"byte_end":2782767,"line_start":2517,"line_end":2517,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7996},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2783379,"byte_end":2783390,"line_start":2533,"line_end":2533,"column_start":15,"column_end":26},"name":"_mm_load_pd","qualname":"::core_arch::x86::sse2::_mm_load_pd","value":"fn (mem_addr: *const f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Loads 128-bits (composed of 2 packed double-precision (64-bit)\n floating-point elements) from memory into the returned vector.\n `mem_addr` must be aligned on a 16-byte boundary or a general-protection\n exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2783193,"byte_end":2783202,"line_start":2528,"line_end":2528,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2783203,"byte_end":2783237,"line_start":2529,"line_end":2529,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2783278,"byte_end":2783327,"line_start":2531,"line_end":2531,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2783328,"byte_end":2783364,"line_start":2532,"line_end":2532,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":7997},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2783846,"byte_end":2783857,"line_start":2545,"line_end":2545,"column_start":15,"column_end":26},"name":"_mm_load_sd","qualname":"::core_arch::x86::sse2::_mm_load_sd","value":"fn (mem_addr: *const f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Loads a 64-bit double-precision value to the low element of a\n 128-bit integer vector and clears the upper element.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2783698,"byte_end":2783707,"line_start":2541,"line_end":2541,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2783708,"byte_end":2783742,"line_start":2542,"line_end":2542,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2783782,"byte_end":2783831,"line_start":2544,"line_end":2544,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7998},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2784372,"byte_end":2784384,"line_start":2558,"line_end":2558,"column_start":15,"column_end":27},"name":"_mm_loadh_pd","qualname":"::core_arch::x86::sse2::_mm_loadh_pd","value":"fn (a: __m128d, mem_addr: *const f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Loads a double-precision value into the high-order bits of a 128-bit\n vector of `[2 x double]`. The low-order bits are copied from the low-order\n bits of the first operand.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2784223,"byte_end":2784232,"line_start":2554,"line_end":2554,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2784233,"byte_end":2784267,"line_start":2555,"line_end":2555,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2784308,"byte_end":2784357,"line_start":2557,"line_end":2557,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7999},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2784928,"byte_end":2784940,"line_start":2571,"line_end":2571,"column_start":15,"column_end":27},"name":"_mm_loadl_pd","qualname":"::core_arch::x86::sse2::_mm_loadl_pd","value":"fn (a: __m128d, mem_addr: *const f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Loads a double-precision value into the low-order bits of a 128-bit\n vector of `[2 x double]`. The high-order bits are copied from the\n high-order bits of the first operand.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2784779,"byte_end":2784788,"line_start":2567,"line_end":2567,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2784789,"byte_end":2784823,"line_start":2568,"line_end":2568,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2784864,"byte_end":2784913,"line_start":2570,"line_end":2570,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8000},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2785558,"byte_end":2785571,"line_start":2586,"line_end":2586,"column_start":15,"column_end":28},"name":"_mm_stream_pd","qualname":"::core_arch::x86::sse2::_mm_stream_pd","value":"fn (mem_addr: *mut f64, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores a 128-bit floating point vector of `[2 x double]` to a 128-bit\n aligned memory location.\n To minimize caching, the data is flagged as non-temporal (unlikely to be\n used again soon).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2785354,"byte_end":2785363,"line_start":2581,"line_end":2581,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2785364,"byte_end":2785398,"line_start":2582,"line_end":2582,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2785457,"byte_end":2785506,"line_start":2584,"line_end":2584,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2785507,"byte_end":2785543,"line_start":2585,"line_end":2585,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":8001},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2786061,"byte_end":2786073,"line_start":2598,"line_end":2598,"column_start":15,"column_end":27},"name":"_mm_store_sd","qualname":"::core_arch::x86::sse2::_mm_store_sd","value":"fn (mem_addr: *mut f64, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the lower 64 bits of a 128-bit vector of `[2 x double]` to a\n memory location.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2785879,"byte_end":2785888,"line_start":2594,"line_end":2594,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2785889,"byte_end":2785923,"line_start":2595,"line_end":2595,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2785997,"byte_end":2786046,"line_start":2597,"line_end":2597,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8002},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2786669,"byte_end":2786681,"line_start":2612,"line_end":2612,"column_start":15,"column_end":27},"name":"_mm_store_pd","qualname":"::core_arch::x86::sse2::_mm_store_pd","value":"fn (mem_addr: *mut f64, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 128-bits (composed of 2 packed double-precision (64-bit)\n floating-point elements) from `a` into memory. `mem_addr` must be aligned\n on a 16-byte boundary or a general-protection exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2786483,"byte_end":2786492,"line_start":2607,"line_end":2607,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2786493,"byte_end":2786527,"line_start":2608,"line_end":2608,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2786568,"byte_end":2786617,"line_start":2610,"line_end":2610,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2786618,"byte_end":2786654,"line_start":2611,"line_end":2611,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":8003},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2787234,"byte_end":2787247,"line_start":2625,"line_end":2625,"column_start":15,"column_end":28},"name":"_mm_storeu_pd","qualname":"::core_arch::x86::sse2::_mm_storeu_pd","value":"fn (mem_addr: *mut f64, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 128-bits (composed of 2 packed double-precision (64-bit)\n floating-point elements) from `a` into memory.\n `mem_addr` does not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2787060,"byte_end":2787069,"line_start":2621,"line_end":2621,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2787070,"byte_end":2787104,"line_start":2622,"line_end":2622,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2787170,"byte_end":2787219,"line_start":2624,"line_end":2624,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8004},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2787809,"byte_end":2787822,"line_start":2638,"line_end":2638,"column_start":15,"column_end":28},"name":"_mm_store1_pd","qualname":"::core_arch::x86::sse2::_mm_store1_pd","value":"fn (mem_addr: *mut f64, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the lower double-precision (64-bit) floating-point element from `a`\n into 2 contiguous elements in memory. `mem_addr` must be aligned on a\n 16-byte boundary or a general-protection exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2787663,"byte_end":2787672,"line_start":2634,"line_end":2634,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2787673,"byte_end":2787707,"line_start":2635,"line_end":2635,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2787708,"byte_end":2787757,"line_start":2636,"line_end":2636,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2787758,"byte_end":2787794,"line_start":2637,"line_end":2637,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":8005},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2788433,"byte_end":2788446,"line_start":2652,"line_end":2652,"column_start":15,"column_end":28},"name":"_mm_store_pd1","qualname":"::core_arch::x86::sse2::_mm_store_pd1","value":"fn (mem_addr: *mut f64, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the lower double-precision (64-bit) floating-point element from `a`\n into 2 contiguous elements in memory. `mem_addr` must be aligned on a\n 16-byte boundary or a general-protection exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2788287,"byte_end":2788296,"line_start":2648,"line_end":2648,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2788297,"byte_end":2788331,"line_start":2649,"line_end":2649,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2788332,"byte_end":2788381,"line_start":2650,"line_end":2650,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2788382,"byte_end":2788418,"line_start":2651,"line_end":2651,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":8006},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2789046,"byte_end":2789059,"line_start":2667,"line_end":2667,"column_start":15,"column_end":28},"name":"_mm_storer_pd","qualname":"::core_arch::x86::sse2::_mm_storer_pd","value":"fn (mem_addr: *mut f64, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 2 double-precision (64-bit) floating-point elements from `a` into\n memory in reverse order.\n `mem_addr` must be aligned on a 16-byte boundary or a general-protection\n exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2788900,"byte_end":2788909,"line_start":2663,"line_end":2663,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2788910,"byte_end":2788944,"line_start":2664,"line_end":2664,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2788945,"byte_end":2788994,"line_start":2665,"line_end":2665,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2788995,"byte_end":2789031,"line_start":2666,"line_end":2666,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":8007},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2789573,"byte_end":2789586,"line_start":2680,"line_end":2680,"column_start":15,"column_end":28},"name":"_mm_storeh_pd","qualname":"::core_arch::x86::sse2::_mm_storeh_pd","value":"fn (mem_addr: *mut f64, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the upper 64 bits of a 128-bit vector of `[2 x double]` to a\n memory location.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2789391,"byte_end":2789400,"line_start":2676,"line_end":2676,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2789401,"byte_end":2789435,"line_start":2677,"line_end":2677,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2789509,"byte_end":2789558,"line_start":2679,"line_end":2679,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8008},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2790049,"byte_end":2790062,"line_start":2692,"line_end":2692,"column_start":15,"column_end":28},"name":"_mm_storel_pd","qualname":"::core_arch::x86::sse2::_mm_storel_pd","value":"fn (mem_addr: *mut f64, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the lower 64 bits of a 128-bit vector of `[2 x double]` to a\n memory location.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2789867,"byte_end":2789876,"line_start":2688,"line_end":2688,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2789877,"byte_end":2789911,"line_start":2689,"line_end":2689,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2789985,"byte_end":2790034,"line_start":2691,"line_end":2691,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8009},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2790554,"byte_end":2790566,"line_start":2704,"line_end":2704,"column_start":15,"column_end":27},"name":"_mm_load1_pd","qualname":"::core_arch::x86::sse2::_mm_load1_pd","value":"fn (mem_addr: *const f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Loads a double-precision (64-bit) floating-point element from memory\n into both elements of returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2790365,"byte_end":2790374,"line_start":2700,"line_end":2700,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2790375,"byte_end":2790409,"line_start":2701,"line_end":2701,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2790490,"byte_end":2790539,"line_start":2703,"line_end":2703,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8010},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2791061,"byte_end":2791073,"line_start":2717,"line_end":2717,"column_start":15,"column_end":27},"name":"_mm_load_pd1","qualname":"::core_arch::x86::sse2::_mm_load_pd1","value":"fn (mem_addr: *const f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Loads a double-precision (64-bit) floating-point element from memory\n into both elements of returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2790879,"byte_end":2790888,"line_start":2713,"line_end":2713,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2790889,"byte_end":2790923,"line_start":2714,"line_end":2714,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2790997,"byte_end":2791046,"line_start":2716,"line_end":2716,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8011},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2791627,"byte_end":2791639,"line_start":2730,"line_end":2730,"column_start":15,"column_end":27},"name":"_mm_loadr_pd","qualname":"::core_arch::x86::sse2::_mm_loadr_pd","value":"fn (mem_addr: *const f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Loads 2 double-precision (64-bit) floating-point elements from memory into\n the returned vector in reverse order. `mem_addr` must be aligned on a\n 16-byte boundary or a general-protection exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2791478,"byte_end":2791487,"line_start":2726,"line_end":2726,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2791488,"byte_end":2791522,"line_start":2727,"line_end":2727,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2791563,"byte_end":2791612,"line_start":2729,"line_end":2729,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8012},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2792212,"byte_end":2792224,"line_start":2744,"line_end":2744,"column_start":15,"column_end":27},"name":"_mm_loadu_pd","qualname":"::core_arch::x86::sse2::_mm_loadu_pd","value":"fn (mem_addr: *const f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Loads 128-bits (composed of 2 packed double-precision (64-bit)\n floating-point elements) from memory into the returned vector.\n `mem_addr` does not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2792063,"byte_end":2792072,"line_start":2740,"line_end":2740,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2792073,"byte_end":2792107,"line_start":2741,"line_end":2741,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2792148,"byte_end":2792197,"line_start":2743,"line_end":2743,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8013},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2792942,"byte_end":2792956,"line_start":2764,"line_end":2764,"column_start":15,"column_end":29},"name":"_mm_shuffle_pd","qualname":"::core_arch::x86::sse2::_mm_shuffle_pd","value":"fn (a: __m128d, b: __m128d, imm8: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Constructs a 128-bit floating-point vector of `[2 x double]` from two\n 128-bit vector parameters of `[2 x double]`, using the immediate-value\n parameter as a specifier.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2792751,"byte_end":2792760,"line_start":2759,"line_end":2759,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2792761,"byte_end":2792795,"line_start":2760,"line_end":2760,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2792846,"byte_end":2792877,"line_start":2762,"line_end":2762,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2792878,"byte_end":2792927,"line_start":2763,"line_end":2763,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8014},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2793692,"byte_end":2793703,"line_start":2782,"line_end":2782,"column_start":15,"column_end":26},"name":"_mm_move_sd","qualname":"::core_arch::x86::sse2::_mm_move_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Constructs a 128-bit floating-point vector of `[2 x double]`. The lower\n 64 bits are set to the lower 64 bits of the second parameter. The upper\n 64 bits are set to the upper 64 bits of the first parameter.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2793544,"byte_end":2793553,"line_start":2778,"line_end":2778,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2793554,"byte_end":2793588,"line_start":2779,"line_end":2779,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2793628,"byte_end":2793677,"line_start":2781,"line_end":2781,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8015},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2794142,"byte_end":2794155,"line_start":2793,"line_end":2793,"column_start":15,"column_end":28},"name":"_mm_castpd_ps","qualname":"::core_arch::x86::sse2::_mm_castpd_ps","value":"fn (a: __m128d) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Casts a 128-bit floating-point vector of `[2 x double]` into a 128-bit\n floating-point vector of `[4 x float]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2794033,"byte_end":2794042,"line_start":2790,"line_end":2790,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2794043,"byte_end":2794077,"line_start":2791,"line_end":2791,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2794078,"byte_end":2794127,"line_start":2792,"line_end":2792,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8016},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2794521,"byte_end":2794537,"line_start":2804,"line_end":2804,"column_start":15,"column_end":31},"name":"_mm_castpd_si128","qualname":"::core_arch::x86::sse2::_mm_castpd_si128","value":"fn (a: __m128d) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Casts a 128-bit floating-point vector of `[2 x double]` into a 128-bit\n integer vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2794412,"byte_end":2794421,"line_start":2801,"line_end":2801,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2794422,"byte_end":2794456,"line_start":2802,"line_end":2802,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2794457,"byte_end":2794506,"line_start":2803,"line_end":2803,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8017},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2794925,"byte_end":2794938,"line_start":2815,"line_end":2815,"column_start":15,"column_end":28},"name":"_mm_castps_pd","qualname":"::core_arch::x86::sse2::_mm_castps_pd","value":"fn (a: __m128) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Casts a 128-bit floating-point vector of `[4 x float]` into a 128-bit\n floating-point vector of `[2 x double]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2794816,"byte_end":2794825,"line_start":2812,"line_end":2812,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2794826,"byte_end":2794860,"line_start":2813,"line_end":2813,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2794861,"byte_end":2794910,"line_start":2814,"line_end":2814,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8018},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2795303,"byte_end":2795319,"line_start":2826,"line_end":2826,"column_start":15,"column_end":31},"name":"_mm_castps_si128","qualname":"::core_arch::x86::sse2::_mm_castps_si128","value":"fn (a: __m128) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Casts a 128-bit floating-point vector of `[4 x float]` into a 128-bit\n integer vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2795194,"byte_end":2795203,"line_start":2823,"line_end":2823,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2795204,"byte_end":2795238,"line_start":2824,"line_end":2824,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2795239,"byte_end":2795288,"line_start":2825,"line_end":2825,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8019},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2795685,"byte_end":2795701,"line_start":2837,"line_end":2837,"column_start":15,"column_end":31},"name":"_mm_castsi128_pd","qualname":"::core_arch::x86::sse2::_mm_castsi128_pd","value":"fn (a: __m128i) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Casts a 128-bit integer vector into a 128-bit floating-point vector\n of `[2 x double]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2795576,"byte_end":2795585,"line_start":2834,"line_end":2834,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2795586,"byte_end":2795620,"line_start":2835,"line_end":2835,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2795621,"byte_end":2795670,"line_start":2836,"line_end":2836,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8020},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2796067,"byte_end":2796083,"line_start":2848,"line_end":2848,"column_start":15,"column_end":31},"name":"_mm_castsi128_ps","qualname":"::core_arch::x86::sse2::_mm_castsi128_ps","value":"fn (a: __m128i) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Casts a 128-bit integer vector into a 128-bit floating-point vector\n of `[4 x float]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2795958,"byte_end":2795967,"line_start":2845,"line_end":2845,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2795968,"byte_end":2796002,"line_start":2846,"line_end":2846,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2796003,"byte_end":2796052,"line_start":2847,"line_end":2847,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8021},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2796414,"byte_end":2796430,"line_start":2858,"line_end":2858,"column_start":15,"column_end":31},"name":"_mm_undefined_pd","qualname":"::core_arch::x86::sse2::_mm_undefined_pd","value":"fn () -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns vector of type __m128d with undefined elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2796305,"byte_end":2796314,"line_start":2855,"line_end":2855,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2796315,"byte_end":2796349,"line_start":2856,"line_end":2856,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2796350,"byte_end":2796399,"line_start":2857,"line_end":2857,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8022},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2796857,"byte_end":2796876,"line_start":2869,"line_end":2869,"column_start":15,"column_end":34},"name":"_mm_undefined_si128","qualname":"::core_arch::x86::sse2::_mm_undefined_si128","value":"fn () -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns vector of type __m128i with undefined elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2796748,"byte_end":2796757,"line_start":2866,"line_end":2866,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2796758,"byte_end":2796792,"line_start":2867,"line_end":2867,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2796793,"byte_end":2796842,"line_start":2868,"line_end":2868,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8023},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2797581,"byte_end":2797596,"line_start":2886,"line_end":2886,"column_start":15,"column_end":30},"name":"_mm_unpackhi_pd","qualname":"::core_arch::x86::sse2::_mm_unpackhi_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" The resulting `__m128d` element is composed by the low-order values of\n the two `__m128d` interleaved input elements, i.e.:","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2797430,"byte_end":2797439,"line_start":2882,"line_end":2882,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2797440,"byte_end":2797474,"line_start":2883,"line_end":2883,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2797517,"byte_end":2797566,"line_start":2885,"line_end":2885,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8024},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2798261,"byte_end":2798276,"line_start":2901,"line_end":2901,"column_start":15,"column_end":30},"name":"_mm_unpacklo_pd","qualname":"::core_arch::x86::sse2::_mm_unpacklo_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" The resulting `__m128d` element is composed by the high-order values of\n the two `__m128d` interleaved input elements, i.e.:","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2798078,"byte_end":2798087,"line_start":2897,"line_end":2897,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2798088,"byte_end":2798122,"line_start":2898,"line_end":2898,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2798197,"byte_end":2798246,"line_start":2900,"line_end":2900,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8025},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2798550,"byte_end":2798562,"line_start":2910,"line_end":2910,"column_start":15,"column_end":27},"name":"_mm_add_si64","qualname":"::core_arch::x86::sse2::_mm_add_si64","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds two signed or unsigned 64-bit integer values, returning the\n lower 64 bits of the sum.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2798448,"byte_end":2798457,"line_start":2907,"line_end":2907,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2798458,"byte_end":2798496,"line_start":2908,"line_end":2908,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":8026},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2798874,"byte_end":2798886,"line_start":2920,"line_end":2920,"column_start":15,"column_end":27},"name":"_mm_mul_su32","qualname":"::core_arch::x86::sse2::_mm_mul_su32","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Multiplies 32-bit unsigned integer values contained in the lower bits\n of the two 64-bit integer vectors and returns the 64-bit unsigned\n product.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2798770,"byte_end":2798779,"line_start":2917,"line_end":2917,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2798780,"byte_end":2798818,"line_start":2918,"line_end":2918,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":8027},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2799173,"byte_end":2799185,"line_start":2929,"line_end":2929,"column_start":15,"column_end":27},"name":"_mm_sub_si64","qualname":"::core_arch::x86::sse2::_mm_sub_si64","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtracts signed or unsigned 64-bit integer values and writes the\n difference to the corresponding bits in the destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2799071,"byte_end":2799080,"line_start":2926,"line_end":2926,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2799081,"byte_end":2799119,"line_start":2927,"line_end":2927,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":8028},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2799532,"byte_end":2799546,"line_start":2939,"line_end":2939,"column_start":15,"column_end":29},"name":"_mm_cvtpi32_pd","qualname":"::core_arch::x86::sse2::_mm_cvtpi32_pd","value":"fn (a: __m64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Converts the two signed 32-bit integer elements of a 64-bit vector of\n `[2 x i32]` into two double-precision floating-point values, returned in a\n 128-bit vector of `[2 x double]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2799427,"byte_end":2799436,"line_start":2936,"line_end":2936,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2799437,"byte_end":2799475,"line_start":2937,"line_end":2937,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":8029},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2799805,"byte_end":2799818,"line_start":2948,"line_end":2948,"column_start":15,"column_end":28},"name":"_mm_set_epi64","qualname":"::core_arch::x86::sse2::_mm_set_epi64","value":"fn (e1: __m64, e0: __m64) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Initializes both 64-bit values in a 128-bit vector of `[2 x i64]` with\n the specified 64-bit integer values.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2799705,"byte_end":2799714,"line_start":2945,"line_end":2945,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2799715,"byte_end":2799753,"line_start":2946,"line_end":2946,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":8030},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2800106,"byte_end":2800120,"line_start":2957,"line_end":2957,"column_start":15,"column_end":29},"name":"_mm_set1_epi64","qualname":"::core_arch::x86::sse2::_mm_set1_epi64","value":"fn (a: __m64) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Initializes both values in a 128-bit vector of `[2 x i64]` with the\n specified 64-bit value.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2800006,"byte_end":2800015,"line_start":2954,"line_end":2954,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2800016,"byte_end":2800054,"line_start":2955,"line_end":2955,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":8031},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2800411,"byte_end":2800425,"line_start":2966,"line_end":2966,"column_start":15,"column_end":29},"name":"_mm_setr_epi64","qualname":"::core_arch::x86::sse2::_mm_setr_epi64","value":"fn (e1: __m64, e0: __m64) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Constructs a 128-bit integer vector, initialized in reverse order\n with the specified 64-bit integral values.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2800311,"byte_end":2800320,"line_start":2963,"line_end":2963,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2800321,"byte_end":2800359,"line_start":2964,"line_end":2964,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":8032},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2800743,"byte_end":2800760,"line_start":2976,"line_end":2976,"column_start":15,"column_end":32},"name":"_mm_movepi64_pi64","qualname":"::core_arch::x86::sse2::_mm_movepi64_pi64","value":"fn (a: __m128i) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Returns the lower 64 bits of a 128-bit integer vector as a 64-bit\n integer.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2800596,"byte_end":2800605,"line_start":2972,"line_end":2972,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2800606,"byte_end":2800644,"line_start":2973,"line_end":2973,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":8033},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2801075,"byte_end":2801092,"line_start":2986,"line_end":2986,"column_start":15,"column_end":32},"name":"_mm_movpi64_epi64","qualname":"::core_arch::x86::sse2::_mm_movpi64_epi64","value":"fn (a: __m64) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Moves the 64-bit operand to a 128-bit integer vector, zeroing the\n upper bits.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2800928,"byte_end":2800937,"line_start":2982,"line_end":2982,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2800938,"byte_end":2800976,"line_start":2983,"line_end":2983,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":8034},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2801451,"byte_end":2801465,"line_start":2996,"line_end":2996,"column_start":15,"column_end":29},"name":"_mm_cvtpd_pi32","qualname":"::core_arch::x86::sse2::_mm_cvtpd_pi32","value":"fn (a: __m128d) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Converts the two double-precision floating-point elements of a\n 128-bit vector of `[2 x double]` into two signed 32-bit integer values,\n returned in a 64-bit vector of `[2 x i32]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2801346,"byte_end":2801355,"line_start":2993,"line_end":2993,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2801356,"byte_end":2801394,"line_start":2994,"line_end":2994,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":8035},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2801948,"byte_end":2801963,"line_start":3008,"line_end":3008,"column_start":15,"column_end":30},"name":"_mm_cvttpd_pi32","qualname":"::core_arch::x86::sse2::_mm_cvttpd_pi32","value":"fn (a: __m128d) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Converts the two double-precision floating-point elements of a\n 128-bit vector of `[2 x double]` into two signed 32-bit integer values,\n returned in a 64-bit vector of `[2 x i32]`.\n If the result of either conversion is inexact, the result is truncated\n (rounded towards zero) regardless of the current MXCSR setting.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2801842,"byte_end":2801851,"line_start":3005,"line_end":3005,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2801852,"byte_end":2801890,"line_start":3006,"line_end":3006,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":8131},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2874807,"byte_end":2874820,"line_start":23,"line_end":23,"column_start":15,"column_end":28},"name":"_mm_addsub_ps","qualname":"::core_arch::x86::sse3::_mm_addsub_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Alternatively add and subtract packed single-precision (32-bit)\n floating-point elements in `a` to/from packed elements in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2874656,"byte_end":2874665,"line_start":19,"line_end":19,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2874666,"byte_end":2874700,"line_start":20,"line_end":20,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2874743,"byte_end":2874792,"line_start":22,"line_end":22,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8132},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2875277,"byte_end":2875290,"line_start":35,"line_end":35,"column_start":15,"column_end":28},"name":"_mm_addsub_pd","qualname":"::core_arch::x86::sse3::_mm_addsub_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Alternatively add and subtract packed double-precision (64-bit)\n floating-point elements in `a` to/from packed elements in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2875126,"byte_end":2875135,"line_start":31,"line_end":31,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2875136,"byte_end":2875170,"line_start":32,"line_end":32,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2875213,"byte_end":2875262,"line_start":34,"line_end":34,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8133},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2875743,"byte_end":2875754,"line_start":47,"line_end":47,"column_start":15,"column_end":26},"name":"_mm_hadd_pd","qualname":"::core_arch::x86::sse3::_mm_hadd_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds adjacent pairs of double-precision (64-bit)\n floating-point elements in `a` and `b`, and pack the results.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2875594,"byte_end":2875603,"line_start":43,"line_end":43,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2875604,"byte_end":2875638,"line_start":44,"line_end":44,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2875679,"byte_end":2875728,"line_start":46,"line_end":46,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8134},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2876205,"byte_end":2876216,"line_start":59,"line_end":59,"column_start":15,"column_end":26},"name":"_mm_hadd_ps","qualname":"::core_arch::x86::sse3::_mm_hadd_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds adjacent pairs of single-precision (32-bit)\n floating-point elements in `a` and `b`, and pack the results.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2876056,"byte_end":2876065,"line_start":55,"line_end":55,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2876066,"byte_end":2876100,"line_start":56,"line_end":56,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2876141,"byte_end":2876190,"line_start":58,"line_end":58,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8135},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2876668,"byte_end":2876679,"line_start":71,"line_end":71,"column_start":15,"column_end":26},"name":"_mm_hsub_pd","qualname":"::core_arch::x86::sse3::_mm_hsub_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Horizontally subtract adjacent pairs of double-precision (64-bit)\n floating-point elements in `a` and `b`, and pack the results.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2876519,"byte_end":2876528,"line_start":67,"line_end":67,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2876529,"byte_end":2876563,"line_start":68,"line_end":68,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2876604,"byte_end":2876653,"line_start":70,"line_end":70,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8136},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2877130,"byte_end":2877141,"line_start":83,"line_end":83,"column_start":15,"column_end":26},"name":"_mm_hsub_ps","qualname":"::core_arch::x86::sse3::_mm_hsub_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds adjacent pairs of single-precision (32-bit)\n floating-point elements in `a` and `b`, and pack the results.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2876981,"byte_end":2876990,"line_start":79,"line_end":79,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2876991,"byte_end":2877025,"line_start":80,"line_end":80,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2877066,"byte_end":2877115,"line_start":82,"line_end":82,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8137},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2877628,"byte_end":2877643,"line_start":96,"line_end":96,"column_start":15,"column_end":30},"name":"_mm_lddqu_si128","qualname":"::core_arch::x86::sse3::_mm_lddqu_si128","value":"fn (mem_addr: *const __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Loads 128-bits of integer data from unaligned memory.\n This intrinsic may perform better than `_mm_loadu_si128`\n when the data crosses a cache line boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2877480,"byte_end":2877489,"line_start":92,"line_end":92,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2877490,"byte_end":2877524,"line_start":93,"line_end":93,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2877564,"byte_end":2877613,"line_start":95,"line_end":95,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8138},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2878079,"byte_end":2878093,"line_start":108,"line_end":108,"column_start":15,"column_end":29},"name":"_mm_movedup_pd","qualname":"::core_arch::x86::sse3::_mm_movedup_pd","value":"fn (a: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Duplicate the low double-precision (64-bit) floating-point element\n from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2877929,"byte_end":2877938,"line_start":104,"line_end":104,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2877939,"byte_end":2877973,"line_start":105,"line_end":105,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2878015,"byte_end":2878064,"line_start":107,"line_end":107,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8139},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2878533,"byte_end":2878547,"line_start":120,"line_end":120,"column_start":15,"column_end":29},"name":"_mm_loaddup_pd","qualname":"::core_arch::x86::sse3::_mm_loaddup_pd","value":"fn (mem_addr: *const f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Loads a double-precision (64-bit) floating-point element from memory\n into both elements of return vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2878383,"byte_end":2878392,"line_start":116,"line_end":116,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2878393,"byte_end":2878427,"line_start":117,"line_end":117,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2878469,"byte_end":2878518,"line_start":119,"line_end":119,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8140},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2878970,"byte_end":2878985,"line_start":132,"line_end":132,"column_start":15,"column_end":30},"name":"_mm_movehdup_ps","qualname":"::core_arch::x86::sse3::_mm_movehdup_ps","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Duplicate odd-indexed single-precision (32-bit) floating-point elements\n from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2878819,"byte_end":2878828,"line_start":128,"line_end":128,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2878829,"byte_end":2878863,"line_start":129,"line_end":129,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2878906,"byte_end":2878955,"line_start":131,"line_end":131,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8141},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2879408,"byte_end":2879423,"line_start":144,"line_end":144,"column_start":15,"column_end":30},"name":"_mm_moveldup_ps","qualname":"::core_arch::x86::sse3::_mm_moveldup_ps","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Duplicate even-indexed single-precision (32-bit) floating-point elements\n from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2879257,"byte_end":2879266,"line_start":140,"line_end":140,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2879267,"byte_end":2879301,"line_start":141,"line_end":141,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2879344,"byte_end":2879393,"line_start":143,"line_end":143,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8158},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2883580,"byte_end":2883592,"line_start":19,"line_end":19,"column_start":15,"column_end":27},"name":"_mm_abs_epi8","qualname":"::core_arch::x86::ssse3::_mm_abs_epi8","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute value of packed 8-bit signed integers in `a` and\n return the unsigned results.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2883431,"byte_end":2883440,"line_start":15,"line_end":15,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2883441,"byte_end":2883476,"line_start":16,"line_end":16,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2883516,"byte_end":2883565,"line_start":18,"line_end":18,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8159},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2884053,"byte_end":2884066,"line_start":32,"line_end":32,"column_start":15,"column_end":28},"name":"_mm_abs_epi16","qualname":"::core_arch::x86::ssse3::_mm_abs_epi16","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute value of each of the packed 16-bit signed integers in\n `a` and\n return the 16-bit unsigned integer","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2883904,"byte_end":2883913,"line_start":28,"line_end":28,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2883914,"byte_end":2883949,"line_start":29,"line_end":29,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2883989,"byte_end":2884038,"line_start":31,"line_end":31,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8160},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2884527,"byte_end":2884540,"line_start":45,"line_end":45,"column_start":15,"column_end":28},"name":"_mm_abs_epi32","qualname":"::core_arch::x86::ssse3::_mm_abs_epi32","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute value of each of the packed 32-bit signed integers in\n `a` and\n return the 32-bit unsigned integer","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2884378,"byte_end":2884387,"line_start":41,"line_end":41,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2884388,"byte_end":2884423,"line_start":42,"line_end":42,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2884463,"byte_end":2884512,"line_start":44,"line_end":44,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8161},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2885626,"byte_end":2885642,"line_start":79,"line_end":79,"column_start":15,"column_end":31},"name":"_mm_shuffle_epi8","qualname":"::core_arch::x86::ssse3::_mm_shuffle_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shuffles bytes from `a` according to the content of `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2885476,"byte_end":2885485,"line_start":75,"line_end":75,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2885486,"byte_end":2885521,"line_start":76,"line_end":76,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2885562,"byte_end":2885611,"line_start":78,"line_end":78,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8162},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2886193,"byte_end":2886208,"line_start":92,"line_end":92,"column_start":15,"column_end":30},"name":"_mm_alignr_epi8","qualname":"::core_arch::x86::ssse3::_mm_alignr_epi8","value":"fn (a: __m128i, b: __m128i, n: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Concatenate 16-byte blocks in `a` and `b` into a 32-byte temporary result,\n shift the result right by `n` bytes, and returns the low 16 bytes.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2886002,"byte_end":2886011,"line_start":87,"line_end":87,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2886012,"byte_end":2886047,"line_start":88,"line_end":88,"column_start":1,"column_end":36}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2886097,"byte_end":2886128,"line_start":90,"line_end":90,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2886129,"byte_end":2886178,"line_start":91,"line_end":91,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8164},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2888323,"byte_end":2888337,"line_start":165,"line_end":165,"column_start":15,"column_end":29},"name":"_mm_hadd_epi16","qualname":"::core_arch::x86::ssse3::_mm_hadd_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds the adjacent pairs of values contained in 2 packed\n 128-bit vectors of `[8 x i16]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2888173,"byte_end":2888182,"line_start":161,"line_end":161,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2888183,"byte_end":2888218,"line_start":162,"line_end":162,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2888259,"byte_end":2888308,"line_start":164,"line_end":164,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8165},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2888922,"byte_end":2888937,"line_start":178,"line_end":178,"column_start":15,"column_end":30},"name":"_mm_hadds_epi16","qualname":"::core_arch::x86::ssse3::_mm_hadds_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds the adjacent pairs of values contained in 2 packed\n 128-bit vectors of `[8 x i16]`. Positive sums greater than 7FFFh are\n saturated to 7FFFh. Negative sums less than 8000h are saturated to 8000h.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2888771,"byte_end":2888780,"line_start":174,"line_end":174,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2888781,"byte_end":2888816,"line_start":175,"line_end":175,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2888858,"byte_end":2888907,"line_start":177,"line_end":177,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8166},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2889406,"byte_end":2889420,"line_start":190,"line_end":190,"column_start":15,"column_end":29},"name":"_mm_hadd_epi32","qualname":"::core_arch::x86::ssse3::_mm_hadd_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds the adjacent pairs of values contained in 2 packed\n 128-bit vectors of `[4 x i32]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2889256,"byte_end":2889265,"line_start":186,"line_end":186,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2889266,"byte_end":2889301,"line_start":187,"line_end":187,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2889342,"byte_end":2889391,"line_start":189,"line_end":189,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8167},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2889892,"byte_end":2889906,"line_start":202,"line_end":202,"column_start":15,"column_end":29},"name":"_mm_hsub_epi16","qualname":"::core_arch::x86::ssse3::_mm_hsub_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally subtract the adjacent pairs of values contained in 2\n packed 128-bit vectors of `[8 x i16]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2889742,"byte_end":2889751,"line_start":198,"line_end":198,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2889752,"byte_end":2889787,"line_start":199,"line_end":199,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2889828,"byte_end":2889877,"line_start":201,"line_end":201,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8168},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2890513,"byte_end":2890528,"line_start":216,"line_end":216,"column_start":15,"column_end":30},"name":"_mm_hsubs_epi16","qualname":"::core_arch::x86::ssse3::_mm_hsubs_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally subtract the adjacent pairs of values contained in 2\n packed 128-bit vectors of `[8 x i16]`. Positive differences greater than\n 7FFFh are saturated to 7FFFh. Negative differences less than 8000h are\n saturated to 8000h.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2890362,"byte_end":2890371,"line_start":212,"line_end":212,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2890372,"byte_end":2890407,"line_start":213,"line_end":213,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2890449,"byte_end":2890498,"line_start":215,"line_end":215,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8169},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2891001,"byte_end":2891015,"line_start":228,"line_end":228,"column_start":15,"column_end":29},"name":"_mm_hsub_epi32","qualname":"::core_arch::x86::ssse3::_mm_hsub_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally subtract the adjacent pairs of values contained in 2\n packed 128-bit vectors of `[4 x i32]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2890851,"byte_end":2890860,"line_start":224,"line_end":224,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2890861,"byte_end":2890896,"line_start":225,"line_end":225,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2890937,"byte_end":2890986,"line_start":227,"line_end":227,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8170},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2891718,"byte_end":2891735,"line_start":243,"line_end":243,"column_start":15,"column_end":32},"name":"_mm_maddubs_epi16","qualname":"::core_arch::x86::ssse3::_mm_maddubs_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies corresponding pairs of packed 8-bit unsigned integer\n values contained in the first source operand and packed 8-bit signed\n integer values contained in the second source operand, add pairs of\n contiguous products with signed saturation, and writes the 16-bit sums to\n the corresponding bits in the destination.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2891565,"byte_end":2891574,"line_start":239,"line_end":239,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2891575,"byte_end":2891610,"line_start":240,"line_end":240,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2891654,"byte_end":2891703,"line_start":242,"line_end":242,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8171},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2892323,"byte_end":2892339,"line_start":256,"line_end":256,"column_start":15,"column_end":31},"name":"_mm_mulhrs_epi16","qualname":"::core_arch::x86::ssse3::_mm_mulhrs_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed 16-bit signed integer values, truncate the 32-bit\n product to the 18 most significant bits by right-shifting, round the\n truncated value by adding 1, and write bits `[16:1]` to the destination.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2892171,"byte_end":2892180,"line_start":252,"line_end":252,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2892181,"byte_end":2892216,"line_start":253,"line_end":253,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2892259,"byte_end":2892308,"line_start":255,"line_end":255,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8172},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2892921,"byte_end":2892934,"line_start":270,"line_end":270,"column_start":15,"column_end":28},"name":"_mm_sign_epi8","qualname":"::core_arch::x86::ssse3::_mm_sign_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Negates packed 8-bit integers in `a` when the corresponding signed 8-bit\n integer in `b` is negative, and returns the result.\n Elements in result are zeroed out when the corresponding element in `b`\n is zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2892771,"byte_end":2892780,"line_start":266,"line_end":266,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2892781,"byte_end":2892816,"line_start":267,"line_end":267,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2892857,"byte_end":2892906,"line_start":269,"line_end":269,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8173},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2893518,"byte_end":2893532,"line_start":284,"line_end":284,"column_start":15,"column_end":29},"name":"_mm_sign_epi16","qualname":"::core_arch::x86::ssse3::_mm_sign_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Negates packed 16-bit integers in `a` when the corresponding signed 16-bit\n integer in `b` is negative, and returns the results.\n Elements in result are zeroed out when the corresponding element in `b`\n is zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2893368,"byte_end":2893377,"line_start":280,"line_end":280,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2893378,"byte_end":2893413,"line_start":281,"line_end":281,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2893454,"byte_end":2893503,"line_start":283,"line_end":283,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8174},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2894115,"byte_end":2894129,"line_start":298,"line_end":298,"column_start":15,"column_end":29},"name":"_mm_sign_epi32","qualname":"::core_arch::x86::ssse3::_mm_sign_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Negates packed 32-bit integers in `a` when the corresponding signed 32-bit\n integer in `b` is negative, and returns the results.\n Element in result are zeroed out when the corresponding element in `b`\n is zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2893965,"byte_end":2893974,"line_start":294,"line_end":294,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2893975,"byte_end":2894010,"line_start":295,"line_end":295,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2894051,"byte_end":2894100,"line_start":297,"line_end":297,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8175},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2894427,"byte_end":2894438,"line_start":307,"line_end":307,"column_start":15,"column_end":26},"name":"_mm_abs_pi8","qualname":"::core_arch::x86::ssse3::_mm_abs_pi8","value":"fn (a: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute value of packed 8-bit integers in `a` and\n return the unsigned results.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2894324,"byte_end":2894333,"line_start":304,"line_end":304,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2894334,"byte_end":2894373,"line_start":305,"line_end":305,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":8176},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2894682,"byte_end":2894694,"line_start":316,"line_end":316,"column_start":15,"column_end":27},"name":"_mm_abs_pi16","qualname":"::core_arch::x86::ssse3::_mm_abs_pi16","value":"fn (a: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute value of packed 8-bit integers in `a`, and returns the\n unsigned results.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2894579,"byte_end":2894588,"line_start":313,"line_end":313,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2894589,"byte_end":2894628,"line_start":314,"line_end":314,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":8177},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2894939,"byte_end":2894951,"line_start":325,"line_end":325,"column_start":15,"column_end":27},"name":"_mm_abs_pi32","qualname":"::core_arch::x86::ssse3::_mm_abs_pi32","value":"fn (a: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute value of packed 32-bit integers in `a`, and returns the\n unsigned results.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2894836,"byte_end":2894845,"line_start":322,"line_end":322,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2894846,"byte_end":2894885,"line_start":323,"line_end":323,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":8178},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2895240,"byte_end":2895255,"line_start":334,"line_end":334,"column_start":15,"column_end":30},"name":"_mm_shuffle_pi8","qualname":"::core_arch::x86::ssse3::_mm_shuffle_pi8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Shuffles packed 8-bit integers in `a` according to shuffle control mask in\n the corresponding 8-bit element of `b`, and returns the results\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2895136,"byte_end":2895145,"line_start":331,"line_end":331,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2895146,"byte_end":2895185,"line_start":332,"line_end":332,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":8179},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2895600,"byte_end":2895614,"line_start":344,"line_end":344,"column_start":15,"column_end":29},"name":"_mm_alignr_pi8","qualname":"::core_arch::x86::ssse3::_mm_alignr_pi8","value":"fn (a: __m64, b: __m64, n: i32) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Concatenates the two 64-bit integer vector operands, and right-shifts\n the result by the number of bytes specified in the immediate operand.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2895455,"byte_end":2895464,"line_start":340,"line_end":340,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2895465,"byte_end":2895504,"line_start":341,"line_end":341,"column_start":1,"column_end":40}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2895554,"byte_end":2895585,"line_start":343,"line_end":343,"column_start":1,"column_end":32}}]},{"kind":"Function","id":{"krate":0,"index":8181},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2895998,"byte_end":2896011,"line_start":358,"line_end":358,"column_start":15,"column_end":28},"name":"_mm_hadd_pi16","qualname":"::core_arch::x86::ssse3::_mm_hadd_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds the adjacent pairs of values contained in 2 packed\n 64-bit vectors of `[4 x i16]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2895894,"byte_end":2895903,"line_start":355,"line_end":355,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2895904,"byte_end":2895943,"line_start":356,"line_end":356,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":8182},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2896275,"byte_end":2896288,"line_start":367,"line_end":367,"column_start":15,"column_end":28},"name":"_mm_hadd_pi32","qualname":"::core_arch::x86::ssse3::_mm_hadd_pi32","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds the adjacent pairs of values contained in 2 packed\n 64-bit vectors of `[2 x i32]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2896171,"byte_end":2896180,"line_start":364,"line_end":364,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2896181,"byte_end":2896220,"line_start":365,"line_end":365,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":8183},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2896668,"byte_end":2896682,"line_start":377,"line_end":377,"column_start":15,"column_end":29},"name":"_mm_hadds_pi16","qualname":"::core_arch::x86::ssse3::_mm_hadds_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds the adjacent pairs of values contained in 2 packed\n 64-bit vectors of `[4 x i16]`. Positive sums greater than 7FFFh are\n saturated to 7FFFh. Negative sums less than 8000h are saturated to 8000h.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2896563,"byte_end":2896572,"line_start":374,"line_end":374,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2896573,"byte_end":2896612,"line_start":375,"line_end":375,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":8184},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2896952,"byte_end":2896965,"line_start":386,"line_end":386,"column_start":15,"column_end":28},"name":"_mm_hsub_pi16","qualname":"::core_arch::x86::ssse3::_mm_hsub_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Horizontally subtracts the adjacent pairs of values contained in 2\n packed 64-bit vectors of `[4 x i16]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2896848,"byte_end":2896857,"line_start":383,"line_end":383,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2896858,"byte_end":2896897,"line_start":384,"line_end":384,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":8185},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2897234,"byte_end":2897247,"line_start":395,"line_end":395,"column_start":15,"column_end":28},"name":"_mm_hsub_pi32","qualname":"::core_arch::x86::ssse3::_mm_hsub_pi32","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Horizontally subtracts the adjacent pairs of values contained in 2\n packed 64-bit vectors of `[2 x i32]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2897130,"byte_end":2897139,"line_start":392,"line_end":392,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2897140,"byte_end":2897179,"line_start":393,"line_end":393,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":8186},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2897650,"byte_end":2897664,"line_start":406,"line_end":406,"column_start":15,"column_end":29},"name":"_mm_hsubs_pi16","qualname":"::core_arch::x86::ssse3::_mm_hsubs_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Horizontally subtracts the adjacent pairs of values contained in 2\n packed 64-bit vectors of `[4 x i16]`. Positive differences greater than\n 7FFFh are saturated to 7FFFh. Negative differences less than 8000h are\n saturated to 8000h.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2897545,"byte_end":2897554,"line_start":403,"line_end":403,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2897555,"byte_end":2897594,"line_start":404,"line_end":404,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":8187},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2898163,"byte_end":2898179,"line_start":418,"line_end":418,"column_start":15,"column_end":31},"name":"_mm_maddubs_pi16","qualname":"::core_arch::x86::ssse3::_mm_maddubs_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Multiplies corresponding pairs of packed 8-bit unsigned integer\n values contained in the first source operand and packed 8-bit signed\n integer values contained in the second source operand, adds pairs of\n contiguous products with signed saturation, and writes the 16-bit sums to\n the corresponding bits in the destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2898056,"byte_end":2898065,"line_start":415,"line_end":415,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2898066,"byte_end":2898105,"line_start":416,"line_end":416,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":8188},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2898566,"byte_end":2898581,"line_start":428,"line_end":428,"column_start":15,"column_end":30},"name":"_mm_mulhrs_pi16","qualname":"::core_arch::x86::ssse3::_mm_mulhrs_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed 16-bit signed integer values, truncates the 32-bit\n products to the 18 most significant bits by right-shifting, rounds the\n truncated value by adding 1, and writes bits `[16:1]` to the destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2898460,"byte_end":2898469,"line_start":425,"line_end":425,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2898470,"byte_end":2898509,"line_start":426,"line_end":426,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":8189},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2898961,"byte_end":2898973,"line_start":439,"line_end":439,"column_start":15,"column_end":27},"name":"_mm_sign_pi8","qualname":"::core_arch::x86::ssse3::_mm_sign_pi8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Negates packed 8-bit integers in `a` when the corresponding signed 8-bit\n integer in `b` is negative, and returns the results.\n Element in result are zeroed out when the corresponding element in `b` is\n zero.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2898857,"byte_end":2898866,"line_start":436,"line_end":436,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2898867,"byte_end":2898906,"line_start":437,"line_end":437,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":8190},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2899353,"byte_end":2899366,"line_start":450,"line_end":450,"column_start":15,"column_end":28},"name":"_mm_sign_pi16","qualname":"::core_arch::x86::ssse3::_mm_sign_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Negates packed 16-bit integers in `a` when the corresponding signed 16-bit\n integer in `b` is negative, and returns the results.\n Element in result are zeroed out when the corresponding element in `b` is\n zero.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2899249,"byte_end":2899258,"line_start":447,"line_end":447,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2899259,"byte_end":2899298,"line_start":448,"line_end":448,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":8191},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2899746,"byte_end":2899759,"line_start":461,"line_end":461,"column_start":15,"column_end":28},"name":"_mm_sign_pi32","qualname":"::core_arch::x86::ssse3::_mm_sign_pi32","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Negates packed 32-bit integers in `a` when the corresponding signed 32-bit\n integer in `b` is negative, and returns the results.\n Element in result are zeroed out when the corresponding element in `b` is\n zero.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2899642,"byte_end":2899651,"line_start":458,"line_end":458,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2899652,"byte_end":2899691,"line_start":459,"line_end":459,"column_start":1,"column_end":40}}]},{"kind":"Const","id":{"krate":0,"index":8232},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2913902,"byte_end":2913927,"line_start":14,"line_end":14,"column_start":11,"column_end":36},"name":"_MM_FROUND_TO_NEAREST_INT","qualname":"::core_arch::x86::sse41::_MM_FROUND_TO_NEAREST_INT","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" round to nearest\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2913842,"byte_end":2913891,"line_start":13,"line_end":13,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8233},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2914016,"byte_end":2914037,"line_start":17,"line_end":17,"column_start":11,"column_end":32},"name":"_MM_FROUND_TO_NEG_INF","qualname":"::core_arch::x86::sse41::_MM_FROUND_TO_NEG_INF","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" round down\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2913956,"byte_end":2914005,"line_start":16,"line_end":16,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8234},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2914124,"byte_end":2914145,"line_start":20,"line_end":20,"column_start":11,"column_end":32},"name":"_MM_FROUND_TO_POS_INF","qualname":"::core_arch::x86::sse41::_MM_FROUND_TO_POS_INF","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" round up\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2914064,"byte_end":2914113,"line_start":19,"line_end":19,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8235},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2914232,"byte_end":2914250,"line_start":23,"line_end":23,"column_start":11,"column_end":29},"name":"_MM_FROUND_TO_ZERO","qualname":"::core_arch::x86::sse41::_MM_FROUND_TO_ZERO","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" truncate\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2914172,"byte_end":2914221,"line_start":22,"line_end":22,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8236},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2914378,"byte_end":2914402,"line_start":26,"line_end":26,"column_start":11,"column_end":35},"name":"_MM_FROUND_CUR_DIRECTION","qualname":"::core_arch::x86::sse41::_MM_FROUND_CUR_DIRECTION","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" use MXCSR.RC; see `vendor::_MM_SET_ROUNDING_MODE`\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2914318,"byte_end":2914367,"line_start":25,"line_end":25,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8237},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2914507,"byte_end":2914527,"line_start":29,"line_end":29,"column_start":11,"column_end":31},"name":"_MM_FROUND_RAISE_EXC","qualname":"::core_arch::x86::sse41::_MM_FROUND_RAISE_EXC","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" do not suppress exceptions\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2914447,"byte_end":2914496,"line_start":28,"line_end":28,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8238},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2914625,"byte_end":2914642,"line_start":32,"line_end":32,"column_start":11,"column_end":28},"name":"_MM_FROUND_NO_EXC","qualname":"::core_arch::x86::sse41::_MM_FROUND_NO_EXC","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" suppress exceptions\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2914565,"byte_end":2914614,"line_start":31,"line_end":31,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8239},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2914768,"byte_end":2914783,"line_start":35,"line_end":35,"column_start":11,"column_end":26},"name":"_MM_FROUND_NINT","qualname":"::core_arch::x86::sse41::_MM_FROUND_NINT","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" round to nearest and do not suppress exceptions\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2914708,"byte_end":2914757,"line_start":34,"line_end":34,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8240},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2914903,"byte_end":2914919,"line_start":38,"line_end":38,"column_start":11,"column_end":27},"name":"_MM_FROUND_FLOOR","qualname":"::core_arch::x86::sse41::_MM_FROUND_FLOOR","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" round down and do not suppress exceptions\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2914843,"byte_end":2914892,"line_start":37,"line_end":37,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8241},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2915079,"byte_end":2915094,"line_start":41,"line_end":41,"column_start":11,"column_end":26},"name":"_MM_FROUND_CEIL","qualname":"::core_arch::x86::sse41::_MM_FROUND_CEIL","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" round up and do not suppress exceptions\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2915019,"byte_end":2915068,"line_start":40,"line_end":40,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8242},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2915254,"byte_end":2915270,"line_start":44,"line_end":44,"column_start":11,"column_end":27},"name":"_MM_FROUND_TRUNC","qualname":"::core_arch::x86::sse41::_MM_FROUND_TRUNC","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" truncate and do not suppress exceptions\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2915194,"byte_end":2915243,"line_start":43,"line_end":43,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8243},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2915472,"byte_end":2915487,"line_start":48,"line_end":48,"column_start":11,"column_end":26},"name":"_MM_FROUND_RINT","qualname":"::core_arch::x86::sse41::_MM_FROUND_RINT","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" use MXCSR.RC and do not suppress exceptions; see\n `vendor::_MM_SET_ROUNDING_MODE`\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2915412,"byte_end":2915461,"line_start":47,"line_end":47,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8244},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2915684,"byte_end":2915704,"line_start":51,"line_end":51,"column_start":11,"column_end":31},"name":"_MM_FROUND_NEARBYINT","qualname":"::core_arch::x86::sse41::_MM_FROUND_NEARBYINT","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" use MXCSR.RC and suppress exceptions; see `vendor::_MM_SET_ROUNDING_MODE`\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2915624,"byte_end":2915673,"line_start":50,"line_end":50,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8245},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2916276,"byte_end":2916291,"line_start":64,"line_end":64,"column_start":15,"column_end":30},"name":"_mm_blendv_epi8","qualname":"::core_arch::x86::sse41::_mm_blendv_epi8","value":"fn (a: __m128i, b: __m128i, mask: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Blend packed 8-bit integers from `a` and `b` using `mask`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2916123,"byte_end":2916132,"line_start":60,"line_end":60,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2916133,"byte_end":2916169,"line_start":61,"line_end":61,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2916212,"byte_end":2916261,"line_start":63,"line_end":63,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8246},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2917147,"byte_end":2917162,"line_start":83,"line_end":83,"column_start":15,"column_end":30},"name":"_mm_blend_epi16","qualname":"::core_arch::x86::sse41::_mm_blend_epi16","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Blend packed 16-bit integers from `a` and `b` using the mask `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2916762,"byte_end":2916771,"line_start":75,"line_end":75,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2916772,"byte_end":2916808,"line_start":76,"line_end":76,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2917051,"byte_end":2917082,"line_start":81,"line_end":81,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2917083,"byte_end":2917132,"line_start":82,"line_end":82,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8248},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2917776,"byte_end":2917789,"line_start":102,"line_end":102,"column_start":15,"column_end":28},"name":"_mm_blendv_pd","qualname":"::core_arch::x86::sse41::_mm_blendv_pd","value":"fn (a: __m128d, b: __m128d, mask: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Blend packed double-precision (64-bit) floating-point elements from `a`\n and `b` using `mask`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2917623,"byte_end":2917632,"line_start":98,"line_end":98,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2917633,"byte_end":2917669,"line_start":99,"line_end":99,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2917712,"byte_end":2917761,"line_start":101,"line_end":101,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8249},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2918238,"byte_end":2918251,"line_start":114,"line_end":114,"column_start":15,"column_end":28},"name":"_mm_blendv_ps","qualname":"::core_arch::x86::sse41::_mm_blendv_ps","value":"fn (a: __m128, b: __m128, mask: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Blend packed single-precision (32-bit) floating-point elements from `a`\n and `b` using `mask`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2918085,"byte_end":2918094,"line_start":110,"line_end":110,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2918095,"byte_end":2918131,"line_start":111,"line_end":111,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2918174,"byte_end":2918223,"line_start":113,"line_end":113,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8250},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2918940,"byte_end":2918952,"line_start":130,"line_end":130,"column_start":15,"column_end":27},"name":"_mm_blend_pd","qualname":"::core_arch::x86::sse41::_mm_blend_pd","value":"fn (a: __m128d, b: __m128d, imm2: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Blend packed double-precision (64-bit) floating-point elements from `a`\n and `b` using control mask `imm2`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2918555,"byte_end":2918564,"line_start":122,"line_end":122,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2918565,"byte_end":2918601,"line_start":123,"line_end":123,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2918844,"byte_end":2918875,"line_start":128,"line_end":128,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2918876,"byte_end":2918925,"line_start":129,"line_end":129,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8252},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2919553,"byte_end":2919565,"line_start":148,"line_end":148,"column_start":15,"column_end":27},"name":"_mm_blend_ps","qualname":"::core_arch::x86::sse41::_mm_blend_ps","value":"fn (a: __m128, b: __m128, imm4: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Blend packed single-precision (32-bit) floating-point elements from `a`\n and `b` using mask `imm4`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2919354,"byte_end":2919363,"line_start":143,"line_end":143,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2919364,"byte_end":2919400,"line_start":144,"line_end":144,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2919457,"byte_end":2919488,"line_start":146,"line_end":146,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2919489,"byte_end":2919538,"line_start":147,"line_end":147,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8254},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2920198,"byte_end":2920212,"line_start":169,"line_end":169,"column_start":15,"column_end":29},"name":"_mm_extract_ps","qualname":"::core_arch::x86::sse41::_mm_extract_ps","value":"fn (a: __m128, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Extracts a single-precision (32-bit) floating-point element from `a`,\n selected with `imm8`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2919959,"byte_end":2919968,"line_start":161,"line_end":161,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2919969,"byte_end":2920005,"line_start":162,"line_end":162,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2920102,"byte_end":2920133,"line_start":167,"line_end":167,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2920134,"byte_end":2920183,"line_start":168,"line_end":168,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8255},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2920819,"byte_end":2920835,"line_start":184,"line_end":184,"column_start":15,"column_end":31},"name":"_mm_extract_epi8","qualname":"::core_arch::x86::sse41::_mm_extract_epi8","value":"fn (a: __m128i, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Extracts an 8-bit integer from `a`, selected with `imm8`. Returns a 32-bit\n integer containing the zero-extended integer data.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2920626,"byte_end":2920635,"line_start":179,"line_end":179,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2920636,"byte_end":2920672,"line_start":180,"line_end":180,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2920723,"byte_end":2920754,"line_start":182,"line_end":182,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2920755,"byte_end":2920804,"line_start":183,"line_end":183,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8256},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2921377,"byte_end":2921394,"line_start":200,"line_end":200,"column_start":15,"column_end":32},"name":"_mm_extract_epi32","qualname":"::core_arch::x86::sse41::_mm_extract_epi32","value":"fn (a: __m128i, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Extracts an 32-bit integer from `a` selected with `imm8`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2921138,"byte_end":2921147,"line_start":192,"line_end":192,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2921148,"byte_end":2921184,"line_start":193,"line_end":193,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2921281,"byte_end":2921312,"line_start":198,"line_end":198,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2921313,"byte_end":2921362,"line_start":199,"line_end":199,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8257},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2922959,"byte_end":2922972,"line_start":234,"line_end":234,"column_start":15,"column_end":28},"name":"_mm_insert_ps","qualname":"::core_arch::x86::sse41::_mm_insert_ps","value":"fn (a: __m128, b: __m128, imm8: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Select a single value in `a` to store at some position in `b`,\n Then zero elements according to `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2922759,"byte_end":2922768,"line_start":229,"line_end":229,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2922769,"byte_end":2922805,"line_start":230,"line_end":230,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2922863,"byte_end":2922894,"line_start":232,"line_end":232,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2922895,"byte_end":2922944,"line_start":233,"line_end":233,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8259},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2923568,"byte_end":2923583,"line_start":252,"line_end":252,"column_start":15,"column_end":30},"name":"_mm_insert_epi8","qualname":"::core_arch::x86::sse41::_mm_insert_epi8","value":"fn (a: __m128i, i: i32, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns a copy of `a` with the 8-bit integer from `i` inserted at a\n location specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2923375,"byte_end":2923384,"line_start":247,"line_end":247,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2923385,"byte_end":2923421,"line_start":248,"line_end":248,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2923472,"byte_end":2923503,"line_start":250,"line_end":250,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2923504,"byte_end":2923553,"line_start":251,"line_end":251,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8260},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2924122,"byte_end":2924138,"line_start":265,"line_end":265,"column_start":15,"column_end":31},"name":"_mm_insert_epi32","qualname":"::core_arch::x86::sse41::_mm_insert_epi32","value":"fn (a: __m128i, i: i32, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns a copy of `a` with the 32-bit integer from `i` inserted at a\n location specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2923929,"byte_end":2923938,"line_start":260,"line_end":260,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2923939,"byte_end":2923975,"line_start":261,"line_end":261,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2924026,"byte_end":2924057,"line_start":263,"line_end":263,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2924058,"byte_end":2924107,"line_start":264,"line_end":264,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8261},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2924612,"byte_end":2924624,"line_start":277,"line_end":277,"column_start":15,"column_end":27},"name":"_mm_max_epi8","qualname":"::core_arch::x86::sse41::_mm_max_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 8-bit integers in `a` and `b` and returns packed maximum\n values in dst.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2924461,"byte_end":2924470,"line_start":273,"line_end":273,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2924471,"byte_end":2924507,"line_start":274,"line_end":274,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2924548,"byte_end":2924597,"line_start":276,"line_end":276,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8262},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2925073,"byte_end":2925086,"line_start":289,"line_end":289,"column_start":15,"column_end":28},"name":"_mm_max_epu16","qualname":"::core_arch::x86::sse41::_mm_max_epu16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 16-bit integers in `a` and `b`, and returns packed\n maximum.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2924922,"byte_end":2924931,"line_start":285,"line_end":285,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2924932,"byte_end":2924968,"line_start":286,"line_end":286,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2925009,"byte_end":2925058,"line_start":288,"line_end":288,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8263},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2925533,"byte_end":2925546,"line_start":301,"line_end":301,"column_start":15,"column_end":28},"name":"_mm_max_epi32","qualname":"::core_arch::x86::sse41::_mm_max_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 32-bit integers in `a` and `b`, and returns packed maximum\n values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2925382,"byte_end":2925391,"line_start":297,"line_end":297,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2925392,"byte_end":2925428,"line_start":298,"line_end":298,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2925469,"byte_end":2925518,"line_start":300,"line_end":300,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8264},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2926002,"byte_end":2926015,"line_start":313,"line_end":313,"column_start":15,"column_end":28},"name":"_mm_max_epu32","qualname":"::core_arch::x86::sse41::_mm_max_epu32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 32-bit integers in `a` and `b`, and returns packed\n maximum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2925851,"byte_end":2925860,"line_start":309,"line_end":309,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2925861,"byte_end":2925897,"line_start":310,"line_end":310,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2925938,"byte_end":2925987,"line_start":312,"line_end":312,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8265},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2926466,"byte_end":2926478,"line_start":325,"line_end":325,"column_start":15,"column_end":27},"name":"_mm_min_epi8","qualname":"::core_arch::x86::sse41::_mm_min_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 8-bit integers in `a` and `b` and returns packed minimum\n values in dst.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2926315,"byte_end":2926324,"line_start":321,"line_end":321,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2926325,"byte_end":2926361,"line_start":322,"line_end":322,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2926402,"byte_end":2926451,"line_start":324,"line_end":324,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8266},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2926927,"byte_end":2926940,"line_start":337,"line_end":337,"column_start":15,"column_end":28},"name":"_mm_min_epu16","qualname":"::core_arch::x86::sse41::_mm_min_epu16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 16-bit integers in `a` and `b`, and returns packed\n minimum.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2926776,"byte_end":2926785,"line_start":333,"line_end":333,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2926786,"byte_end":2926822,"line_start":334,"line_end":334,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2926863,"byte_end":2926912,"line_start":336,"line_end":336,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8267},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2927387,"byte_end":2927400,"line_start":349,"line_end":349,"column_start":15,"column_end":28},"name":"_mm_min_epi32","qualname":"::core_arch::x86::sse41::_mm_min_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 32-bit integers in `a` and `b`, and returns packed minimum\n values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2927236,"byte_end":2927245,"line_start":345,"line_end":345,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2927246,"byte_end":2927282,"line_start":346,"line_end":346,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2927323,"byte_end":2927372,"line_start":348,"line_end":348,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8268},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2927856,"byte_end":2927869,"line_start":361,"line_end":361,"column_start":15,"column_end":28},"name":"_mm_min_epu32","qualname":"::core_arch::x86::sse41::_mm_min_epu32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 32-bit integers in `a` and `b`, and returns packed\n minimum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2927705,"byte_end":2927714,"line_start":357,"line_end":357,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2927715,"byte_end":2927751,"line_start":358,"line_end":358,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2927792,"byte_end":2927841,"line_start":360,"line_end":360,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8269},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2928339,"byte_end":2928355,"line_start":373,"line_end":373,"column_start":15,"column_end":31},"name":"_mm_packus_epi32","qualname":"::core_arch::x86::sse41::_mm_packus_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers\n using unsigned saturation","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2928186,"byte_end":2928195,"line_start":369,"line_end":369,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2928196,"byte_end":2928232,"line_start":370,"line_end":370,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2928275,"byte_end":2928324,"line_start":372,"line_end":372,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8270},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2928780,"byte_end":2928795,"line_start":384,"line_end":384,"column_start":15,"column_end":30},"name":"_mm_cmpeq_epi64","qualname":"::core_arch::x86::sse41::_mm_cmpeq_epi64","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 64-bit integers in `a` and `b` for equality","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2928628,"byte_end":2928637,"line_start":380,"line_end":380,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2928638,"byte_end":2928674,"line_start":381,"line_end":381,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2928716,"byte_end":2928765,"line_start":383,"line_end":383,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8271},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2929241,"byte_end":2929258,"line_start":395,"line_end":395,"column_start":15,"column_end":32},"name":"_mm_cvtepi8_epi16","qualname":"::core_arch::x86::sse41::_mm_cvtepi8_epi16","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sign extend packed 8-bit integers in `a` to packed 16-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2929088,"byte_end":2929097,"line_start":391,"line_end":391,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2929098,"byte_end":2929134,"line_start":392,"line_end":392,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2929177,"byte_end":2929226,"line_start":394,"line_end":394,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8272},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2929765,"byte_end":2929782,"line_start":408,"line_end":408,"column_start":15,"column_end":32},"name":"_mm_cvtepi8_epi32","qualname":"::core_arch::x86::sse41::_mm_cvtepi8_epi32","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sign extend packed 8-bit integers in `a` to packed 32-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2929612,"byte_end":2929621,"line_start":404,"line_end":404,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2929622,"byte_end":2929658,"line_start":405,"line_end":405,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2929701,"byte_end":2929750,"line_start":407,"line_end":407,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8273},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2930300,"byte_end":2930317,"line_start":422,"line_end":422,"column_start":15,"column_end":32},"name":"_mm_cvtepi8_epi64","qualname":"::core_arch::x86::sse41::_mm_cvtepi8_epi64","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sign extend packed 8-bit integers in the low 8 bytes of `a` to packed\n 64-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2930147,"byte_end":2930156,"line_start":418,"line_end":418,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2930157,"byte_end":2930193,"line_start":419,"line_end":419,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2930236,"byte_end":2930285,"line_start":421,"line_end":421,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8274},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2930808,"byte_end":2930826,"line_start":435,"line_end":435,"column_start":15,"column_end":33},"name":"_mm_cvtepi16_epi32","qualname":"::core_arch::x86::sse41::_mm_cvtepi16_epi32","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sign extend packed 16-bit integers in `a` to packed 32-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2930655,"byte_end":2930664,"line_start":431,"line_end":431,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2930665,"byte_end":2930701,"line_start":432,"line_end":432,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2930744,"byte_end":2930793,"line_start":434,"line_end":434,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8275},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2931324,"byte_end":2931342,"line_start":448,"line_end":448,"column_start":15,"column_end":33},"name":"_mm_cvtepi16_epi64","qualname":"::core_arch::x86::sse41::_mm_cvtepi16_epi64","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sign extend packed 16-bit integers in `a` to packed 64-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2931171,"byte_end":2931180,"line_start":444,"line_end":444,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2931181,"byte_end":2931217,"line_start":445,"line_end":445,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2931260,"byte_end":2931309,"line_start":447,"line_end":447,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8276},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2931834,"byte_end":2931852,"line_start":461,"line_end":461,"column_start":15,"column_end":33},"name":"_mm_cvtepi32_epi64","qualname":"::core_arch::x86::sse41::_mm_cvtepi32_epi64","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sign extend packed 32-bit integers in `a` to packed 64-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2931681,"byte_end":2931690,"line_start":457,"line_end":457,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2931691,"byte_end":2931727,"line_start":458,"line_end":458,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2931770,"byte_end":2931819,"line_start":460,"line_end":460,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8277},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2932353,"byte_end":2932370,"line_start":474,"line_end":474,"column_start":15,"column_end":32},"name":"_mm_cvtepu8_epi16","qualname":"::core_arch::x86::sse41::_mm_cvtepu8_epi16","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Zeroes extend packed unsigned 8-bit integers in `a` to packed 16-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2932200,"byte_end":2932209,"line_start":470,"line_end":470,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2932210,"byte_end":2932246,"line_start":471,"line_end":471,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2932289,"byte_end":2932338,"line_start":473,"line_end":473,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8278},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2932888,"byte_end":2932905,"line_start":487,"line_end":487,"column_start":15,"column_end":32},"name":"_mm_cvtepu8_epi32","qualname":"::core_arch::x86::sse41::_mm_cvtepu8_epi32","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Zeroes extend packed unsigned 8-bit integers in `a` to packed 32-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2932735,"byte_end":2932744,"line_start":483,"line_end":483,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2932745,"byte_end":2932781,"line_start":484,"line_end":484,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2932824,"byte_end":2932873,"line_start":486,"line_end":486,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8279},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2933411,"byte_end":2933428,"line_start":500,"line_end":500,"column_start":15,"column_end":32},"name":"_mm_cvtepu8_epi64","qualname":"::core_arch::x86::sse41::_mm_cvtepu8_epi64","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Zeroes extend packed unsigned 8-bit integers in `a` to packed 64-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2933258,"byte_end":2933267,"line_start":496,"line_end":496,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2933268,"byte_end":2933304,"line_start":497,"line_end":497,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2933347,"byte_end":2933396,"line_start":499,"line_end":499,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8280},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2933934,"byte_end":2933952,"line_start":514,"line_end":514,"column_start":15,"column_end":33},"name":"_mm_cvtepu16_epi32","qualname":"::core_arch::x86::sse41::_mm_cvtepu16_epi32","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Zeroes extend packed unsigned 16-bit integers in `a`\n to packed 32-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2933781,"byte_end":2933790,"line_start":510,"line_end":510,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2933791,"byte_end":2933827,"line_start":511,"line_end":511,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2933870,"byte_end":2933919,"line_start":513,"line_end":513,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8281},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2934465,"byte_end":2934483,"line_start":528,"line_end":528,"column_start":15,"column_end":33},"name":"_mm_cvtepu16_epi64","qualname":"::core_arch::x86::sse41::_mm_cvtepu16_epi64","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Zeroes extend packed unsigned 16-bit integers in `a`\n to packed 64-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2934312,"byte_end":2934321,"line_start":524,"line_end":524,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2934322,"byte_end":2934358,"line_start":525,"line_end":525,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2934401,"byte_end":2934450,"line_start":527,"line_end":527,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8282},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2934990,"byte_end":2935008,"line_start":542,"line_end":542,"column_start":15,"column_end":33},"name":"_mm_cvtepu32_epi64","qualname":"::core_arch::x86::sse41::_mm_cvtepu32_epi64","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Zeroes extend packed unsigned 32-bit integers in `a`\n to packed 64-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2934837,"byte_end":2934846,"line_start":538,"line_end":538,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2934847,"byte_end":2934883,"line_start":539,"line_end":539,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2934926,"byte_end":2934975,"line_start":541,"line_end":541,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8283},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2935898,"byte_end":2935907,"line_start":562,"line_end":562,"column_start":15,"column_end":24},"name":"_mm_dp_pd","qualname":"::core_arch::x86::sse41::_mm_dp_pd","value":"fn (a: __m128d, b: __m128d, imm8: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns the dot product of two __m128d vectors.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2935707,"byte_end":2935716,"line_start":557,"line_end":557,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2935717,"byte_end":2935753,"line_start":558,"line_end":558,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2935802,"byte_end":2935833,"line_start":560,"line_end":560,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2935834,"byte_end":2935883,"line_start":561,"line_end":561,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8285},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2936828,"byte_end":2936837,"line_start":585,"line_end":585,"column_start":15,"column_end":24},"name":"_mm_dp_ps","qualname":"::core_arch::x86::sse41::_mm_dp_ps","value":"fn (a: __m128, b: __m128, imm8: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns the dot product of two __m128 vectors.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2936637,"byte_end":2936646,"line_start":580,"line_end":580,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2936647,"byte_end":2936683,"line_start":581,"line_end":581,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2936732,"byte_end":2936763,"line_start":583,"line_end":583,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2936764,"byte_end":2936813,"line_start":584,"line_end":584,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8287},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2937466,"byte_end":2937478,"line_start":603,"line_end":603,"column_start":15,"column_end":27},"name":"_mm_floor_pd","qualname":"::core_arch::x86::sse41::_mm_floor_pd","value":"fn (a: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Round the packed double-precision (64-bit) floating-point elements in `a`\n down to an integer value, and stores the results as packed double-precision\n floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2937314,"byte_end":2937323,"line_start":599,"line_end":599,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2937324,"byte_end":2937360,"line_start":600,"line_end":600,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2937402,"byte_end":2937451,"line_start":602,"line_end":602,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8288},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2937992,"byte_end":2938004,"line_start":616,"line_end":616,"column_start":15,"column_end":27},"name":"_mm_floor_ps","qualname":"::core_arch::x86::sse41::_mm_floor_ps","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Round the packed single-precision (32-bit) floating-point elements in `a`\n down to an integer value, and stores the results as packed single-precision\n floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2937840,"byte_end":2937849,"line_start":612,"line_end":612,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2937850,"byte_end":2937886,"line_start":613,"line_end":613,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2937928,"byte_end":2937977,"line_start":615,"line_end":615,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8289},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2938639,"byte_end":2938651,"line_start":631,"line_end":631,"column_start":15,"column_end":27},"name":"_mm_floor_sd","qualname":"::core_arch::x86::sse41::_mm_floor_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Round the lower double-precision (64-bit) floating-point element in `b`\n down to an integer value, store the result as a double-precision\n floating-point element in the lower element of the intrinsic result,\n and copies the upper element from `a` to the upper element of the intrinsic\n result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2938487,"byte_end":2938496,"line_start":627,"line_end":627,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2938497,"byte_end":2938533,"line_start":628,"line_end":628,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2938575,"byte_end":2938624,"line_start":630,"line_end":630,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8290},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2939314,"byte_end":2939326,"line_start":646,"line_end":646,"column_start":15,"column_end":27},"name":"_mm_floor_ss","qualname":"::core_arch::x86::sse41::_mm_floor_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Round the lower single-precision (32-bit) floating-point element in `b`\n down to an integer value, store the result as a single-precision\n floating-point element in the lower element of the intrinsic result,\n and copies the upper 3 packed elements from `a` to the upper elements\n of the intrinsic result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2939162,"byte_end":2939171,"line_start":642,"line_end":642,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2939172,"byte_end":2939208,"line_start":643,"line_end":643,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2939250,"byte_end":2939299,"line_start":645,"line_end":645,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8291},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2939849,"byte_end":2939860,"line_start":659,"line_end":659,"column_start":15,"column_end":26},"name":"_mm_ceil_pd","qualname":"::core_arch::x86::sse41::_mm_ceil_pd","value":"fn (a: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Round the packed double-precision (64-bit) floating-point elements in `a`\n up to an integer value, and stores the results as packed double-precision\n floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2939697,"byte_end":2939706,"line_start":655,"line_end":655,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2939707,"byte_end":2939743,"line_start":656,"line_end":656,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2939785,"byte_end":2939834,"line_start":658,"line_end":658,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8292},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2940370,"byte_end":2940381,"line_start":672,"line_end":672,"column_start":15,"column_end":26},"name":"_mm_ceil_ps","qualname":"::core_arch::x86::sse41::_mm_ceil_ps","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Round the packed single-precision (32-bit) floating-point elements in `a`\n up to an integer value, and stores the results as packed single-precision\n floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2940218,"byte_end":2940227,"line_start":668,"line_end":668,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2940228,"byte_end":2940264,"line_start":669,"line_end":669,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2940306,"byte_end":2940355,"line_start":671,"line_end":671,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8293},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2941011,"byte_end":2941022,"line_start":687,"line_end":687,"column_start":15,"column_end":26},"name":"_mm_ceil_sd","qualname":"::core_arch::x86::sse41::_mm_ceil_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Round the lower double-precision (64-bit) floating-point element in `b`\n up to an integer value, store the result as a double-precision\n floating-point element in the lower element of the intrisic result,\n and copies the upper element from `a` to the upper element\n of the intrinsic result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2940859,"byte_end":2940868,"line_start":683,"line_end":683,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2940869,"byte_end":2940905,"line_start":684,"line_end":684,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2940947,"byte_end":2940996,"line_start":686,"line_end":686,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8294},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2941681,"byte_end":2941692,"line_start":702,"line_end":702,"column_start":15,"column_end":26},"name":"_mm_ceil_ss","qualname":"::core_arch::x86::sse41::_mm_ceil_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Round the lower single-precision (32-bit) floating-point element in `b`\n up to an integer value, store the result as a single-precision\n floating-point element in the lower element of the intrinsic result,\n and copies the upper 3 packed elements from `a` to the upper elements\n of the intrinsic result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2941529,"byte_end":2941538,"line_start":698,"line_end":698,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2941539,"byte_end":2941575,"line_start":699,"line_end":699,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2941617,"byte_end":2941666,"line_start":701,"line_end":701,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8295},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2943044,"byte_end":2943056,"line_start":742,"line_end":742,"column_start":15,"column_end":27},"name":"_mm_round_pd","qualname":"::core_arch::x86::sse41::_mm_round_pd","value":"fn (a: __m128d, rounding: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Round the packed double-precision (64-bit) floating-point elements in `a`\n using the `rounding` parameter, and stores the results as packed\n double-precision floating-point elements.\n Rounding is done according to the rounding parameter, which can be one of:","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2942846,"byte_end":2942855,"line_start":737,"line_end":737,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2942856,"byte_end":2942892,"line_start":738,"line_end":738,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2942948,"byte_end":2942979,"line_start":740,"line_end":740,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2942980,"byte_end":2943029,"line_start":741,"line_end":741,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8297},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2944511,"byte_end":2944523,"line_start":787,"line_end":787,"column_start":15,"column_end":27},"name":"_mm_round_ps","qualname":"::core_arch::x86::sse41::_mm_round_ps","value":"fn (a: __m128, rounding: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Round the packed single-precision (32-bit) floating-point elements in `a`\n using the `rounding` parameter, and stores the results as packed\n single-precision floating-point elements.\n Rounding is done according to the rounding parameter, which can be one of:","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2944313,"byte_end":2944322,"line_start":782,"line_end":782,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2944323,"byte_end":2944359,"line_start":783,"line_end":783,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2944415,"byte_end":2944446,"line_start":785,"line_end":785,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2944447,"byte_end":2944496,"line_start":786,"line_end":786,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8299},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2946099,"byte_end":2946111,"line_start":834,"line_end":834,"column_start":15,"column_end":27},"name":"_mm_round_sd","qualname":"::core_arch::x86::sse41::_mm_round_sd","value":"fn (a: __m128d, b: __m128d, rounding: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Round the lower double-precision (64-bit) floating-point element in `b`\n using the `rounding` parameter, store the result as a double-precision\n floating-point element in the lower element of the intrinsic result,\n and copies the upper element from `a` to the upper element of the intrinsic\n result.\n Rounding is done according to the rounding parameter, which can be one of:","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2945901,"byte_end":2945910,"line_start":829,"line_end":829,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2945911,"byte_end":2945947,"line_start":830,"line_end":830,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2946003,"byte_end":2946034,"line_start":832,"line_end":832,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2946035,"byte_end":2946084,"line_start":833,"line_end":833,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8301},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2947716,"byte_end":2947728,"line_start":881,"line_end":881,"column_start":15,"column_end":27},"name":"_mm_round_ss","qualname":"::core_arch::x86::sse41::_mm_round_ss","value":"fn (a: __m128, b: __m128, rounding: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Round the lower single-precision (32-bit) floating-point element in `b`\n using the `rounding` parameter, store the result as a single-precision\n floating-point element in the lower element of the intrinsic result,\n and copies the upper 3 packed elements from `a` to the upper elements\n of the instrinsic result.\n Rounding is done according to the rounding parameter, which can be one of:","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2947518,"byte_end":2947527,"line_start":876,"line_end":876,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2947528,"byte_end":2947564,"line_start":877,"line_end":877,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2947620,"byte_end":2947651,"line_start":879,"line_end":879,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2947652,"byte_end":2947701,"line_start":880,"line_end":880,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8303},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2948801,"byte_end":2948817,"line_start":915,"line_end":915,"column_start":15,"column_end":31},"name":"_mm_minpos_epu16","qualname":"::core_arch::x86::sse41::_mm_minpos_epu16","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Finds the minimum unsigned 16-bit element in the 128-bit __m128i vector,\n returning a vector containing its value in its first position, and its\n index\n in its second position; all other elements are set to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2948646,"byte_end":2948655,"line_start":911,"line_end":911,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2948656,"byte_end":2948692,"line_start":912,"line_end":912,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2948737,"byte_end":2948786,"line_start":914,"line_end":914,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8304},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2949280,"byte_end":2949293,"line_start":927,"line_end":927,"column_start":15,"column_end":28},"name":"_mm_mul_epi32","qualname":"::core_arch::x86::sse41::_mm_mul_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the low 32-bit integers from each packed 64-bit\n element in `a` and `b`, and returns the signed 64-bit result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2949129,"byte_end":2949138,"line_start":923,"line_end":923,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2949139,"byte_end":2949175,"line_start":924,"line_end":924,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2949216,"byte_end":2949265,"line_start":926,"line_end":926,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8305},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2950064,"byte_end":2950079,"line_start":943,"line_end":943,"column_start":15,"column_end":30},"name":"_mm_mullo_epi32","qualname":"::core_arch::x86::sse41::_mm_mullo_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the packed 32-bit integers in `a` and `b`, producing intermediate\n 64-bit integers, and returns the lowest 32-bit, whatever they might be,\n reinterpreted as a signed integer. While `pmulld __m128i::splat(2),\n __m128i::splat(2)` returns the obvious `__m128i::splat(4)`, due to wrapping\n arithmetic `pmulld __m128i::splat(i32::MAX), __m128i::splat(2)` would\n return a negative number.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2949913,"byte_end":2949922,"line_start":939,"line_end":939,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2949923,"byte_end":2949959,"line_start":940,"line_end":940,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2950000,"byte_end":2950049,"line_start":942,"line_end":942,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8306},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2951551,"byte_end":2951567,"line_start":985,"line_end":985,"column_start":15,"column_end":31},"name":"_mm_mpsadbw_epu8","qualname":"::core_arch::x86::sse41::_mm_mpsadbw_epu8","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Subtracts 8-bit unsigned integer values and computes the absolute\n values of the differences to the corresponding bits in the destination.\n Then sums of the absolute differences are returned according to the bit\n fields in the immediate operand.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2951357,"byte_end":2951366,"line_start":980,"line_end":980,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2951367,"byte_end":2951403,"line_start":981,"line_end":981,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2951455,"byte_end":2951486,"line_start":983,"line_end":983,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2951487,"byte_end":2951536,"line_start":984,"line_end":984,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8308},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2952441,"byte_end":2952456,"line_start":1015,"line_end":1015,"column_start":15,"column_end":30},"name":"_mm_testz_si128","qualname":"::core_arch::x86::sse41::_mm_testz_si128","value":"fn (a: __m128i, mask: __m128i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Tests whether the specified bits in a 128-bit integer vector are all\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2952291,"byte_end":2952300,"line_start":1011,"line_end":1011,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2952301,"byte_end":2952337,"line_start":1012,"line_end":1012,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2952377,"byte_end":2952426,"line_start":1014,"line_end":1014,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8309},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2953164,"byte_end":2953179,"line_start":1038,"line_end":1038,"column_start":15,"column_end":30},"name":"_mm_testc_si128","qualname":"::core_arch::x86::sse41::_mm_testc_si128","value":"fn (a: __m128i, mask: __m128i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Tests whether the specified bits in a 128-bit integer vector are all\n ones.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2953014,"byte_end":2953023,"line_start":1034,"line_end":1034,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2953024,"byte_end":2953060,"line_start":1035,"line_end":1035,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2953100,"byte_end":2953149,"line_start":1037,"line_end":1037,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8310},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2953933,"byte_end":2953950,"line_start":1061,"line_end":1061,"column_start":15,"column_end":32},"name":"_mm_testnzc_si128","qualname":"::core_arch::x86::sse41::_mm_testnzc_si128","value":"fn (a: __m128i, mask: __m128i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Tests whether the specified bits in a 128-bit integer vector are\n neither all zeros nor all ones.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2953783,"byte_end":2953792,"line_start":1057,"line_end":1057,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2953793,"byte_end":2953829,"line_start":1058,"line_end":1058,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2953869,"byte_end":2953918,"line_start":1060,"line_end":1060,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8311},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2954665,"byte_end":2954683,"line_start":1084,"line_end":1084,"column_start":15,"column_end":33},"name":"_mm_test_all_zeros","qualname":"::core_arch::x86::sse41::_mm_test_all_zeros","value":"fn (a: __m128i, mask: __m128i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Tests whether the specified bits in a 128-bit integer vector are all\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2954515,"byte_end":2954524,"line_start":1080,"line_end":1080,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2954525,"byte_end":2954561,"line_start":1081,"line_end":1081,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2954601,"byte_end":2954650,"line_start":1083,"line_end":1083,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8312},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2955350,"byte_end":2955367,"line_start":1106,"line_end":1106,"column_start":15,"column_end":32},"name":"_mm_test_all_ones","qualname":"::core_arch::x86::sse41::_mm_test_all_ones","value":"fn (a: __m128i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Tests whether the specified bits in `a` 128-bit integer vector are all\n ones.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2955159,"byte_end":2955168,"line_start":1101,"line_end":1101,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2955169,"byte_end":2955205,"line_start":1102,"line_end":1102,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2955286,"byte_end":2955335,"line_start":1105,"line_end":1105,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8313},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2956116,"byte_end":2956139,"line_start":1129,"line_end":1129,"column_start":15,"column_end":38},"name":"_mm_test_mix_ones_zeros","qualname":"::core_arch::x86::sse41::_mm_test_mix_ones_zeros","value":"fn (a: __m128i, mask: __m128i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Tests whether the specified bits in a 128-bit integer vector are\n neither all zeros nor all ones.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2955966,"byte_end":2955975,"line_start":1125,"line_end":1125,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2955976,"byte_end":2956012,"line_start":1126,"line_end":1126,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2956052,"byte_end":2956101,"line_start":1128,"line_end":1128,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8351},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2981806,"byte_end":2981821,"line_start":15,"line_end":15,"column_start":11,"column_end":26},"name":"_SIDD_UBYTE_OPS","qualname":"::core_arch::x86::sse42::_SIDD_UBYTE_OPS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" String contains unsigned 8-bit characters *(Default)*\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2981746,"byte_end":2981795,"line_start":14,"line_end":14,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8352},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2981949,"byte_end":2981964,"line_start":18,"line_end":18,"column_start":11,"column_end":26},"name":"_SIDD_UWORD_OPS","qualname":"::core_arch::x86::sse42::_SIDD_UWORD_OPS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" String contains unsigned 16-bit characters\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2981889,"byte_end":2981938,"line_start":17,"line_end":17,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8353},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2982089,"byte_end":2982104,"line_start":21,"line_end":21,"column_start":11,"column_end":26},"name":"_SIDD_SBYTE_OPS","qualname":"::core_arch::x86::sse42::_SIDD_SBYTE_OPS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" String contains signed 8-bit characters\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2982029,"byte_end":2982078,"line_start":20,"line_end":20,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8354},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2982232,"byte_end":2982247,"line_start":24,"line_end":24,"column_start":11,"column_end":26},"name":"_SIDD_SWORD_OPS","qualname":"::core_arch::x86::sse42::_SIDD_SWORD_OPS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" String contains unsigned 16-bit characters\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2982172,"byte_end":2982221,"line_start":23,"line_end":23,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8355},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2982393,"byte_end":2982412,"line_start":28,"line_end":28,"column_start":11,"column_end":30},"name":"_SIDD_CMP_EQUAL_ANY","qualname":"::core_arch::x86::sse42::_SIDD_CMP_EQUAL_ANY","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" For each character in `a`, find if it is in `b` *(Default)*\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2982333,"byte_end":2982382,"line_start":27,"line_end":27,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8356},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2982585,"byte_end":2982601,"line_start":32,"line_end":32,"column_start":11,"column_end":27},"name":"_SIDD_CMP_RANGES","qualname":"::core_arch::x86::sse42::_SIDD_CMP_RANGES","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" For each character in `a`, determine if\n `b[0] <= c <= b[1] or b[1] <= c <= b[2]...`\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2982525,"byte_end":2982574,"line_start":31,"line_end":31,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8357},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2982731,"byte_end":2982751,"line_start":35,"line_end":35,"column_start":11,"column_end":31},"name":"_SIDD_CMP_EQUAL_EACH","qualname":"::core_arch::x86::sse42::_SIDD_CMP_EQUAL_EACH","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" The strings defined by `a` and `b` are equal\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2982671,"byte_end":2982720,"line_start":34,"line_end":34,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8358},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2982883,"byte_end":2982906,"line_start":38,"line_end":38,"column_start":11,"column_end":34},"name":"_SIDD_CMP_EQUAL_ORDERED","qualname":"::core_arch::x86::sse42::_SIDD_CMP_EQUAL_ORDERED","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Search for the defined substring in the target\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2982823,"byte_end":2982872,"line_start":37,"line_end":37,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8359},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2983026,"byte_end":2983049,"line_start":42,"line_end":42,"column_start":11,"column_end":34},"name":"_SIDD_POSITIVE_POLARITY","qualname":"::core_arch::x86::sse42::_SIDD_POSITIVE_POLARITY","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Do not negate results *(Default)*\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2982966,"byte_end":2983015,"line_start":41,"line_end":41,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8360},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2983150,"byte_end":2983173,"line_start":45,"line_end":45,"column_start":11,"column_end":34},"name":"_SIDD_NEGATIVE_POLARITY","qualname":"::core_arch::x86::sse42::_SIDD_NEGATIVE_POLARITY","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Negates results\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2983090,"byte_end":2983139,"line_start":44,"line_end":44,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8361},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2983309,"byte_end":2983339,"line_start":48,"line_end":48,"column_start":11,"column_end":41},"name":"_SIDD_MASKED_POSITIVE_POLARITY","qualname":"::core_arch::x86::sse42::_SIDD_MASKED_POSITIVE_POLARITY","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Do not negate results before the end of the string\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2983249,"byte_end":2983298,"line_start":47,"line_end":47,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8362},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2983474,"byte_end":2983504,"line_start":51,"line_end":51,"column_start":11,"column_end":41},"name":"_SIDD_MASKED_NEGATIVE_POLARITY","qualname":"::core_arch::x86::sse42::_SIDD_MASKED_NEGATIVE_POLARITY","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Negates results only before the end of the string\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2983414,"byte_end":2983463,"line_start":50,"line_end":50,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8363},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2983651,"byte_end":2983674,"line_start":55,"line_end":55,"column_start":11,"column_end":34},"name":"_SIDD_LEAST_SIGNIFICANT","qualname":"::core_arch::x86::sse42::_SIDD_LEAST_SIGNIFICANT","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" **Index only**: return the least significant bit *(Default)*\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2983591,"byte_end":2983640,"line_start":54,"line_end":54,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8364},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2983807,"byte_end":2983829,"line_start":58,"line_end":58,"column_start":11,"column_end":33},"name":"_SIDD_MOST_SIGNIFICANT","qualname":"::core_arch::x86::sse42::_SIDD_MOST_SIGNIFICANT","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" **Index only**: return the most significant bit\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2983747,"byte_end":2983796,"line_start":57,"line_end":57,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8365},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2983950,"byte_end":2983964,"line_start":62,"line_end":62,"column_start":11,"column_end":25},"name":"_SIDD_BIT_MASK","qualname":"::core_arch::x86::sse42::_SIDD_BIT_MASK","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" **Mask only**: return the bit mask\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2983890,"byte_end":2983939,"line_start":61,"line_end":61,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8366},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2984085,"byte_end":2984100,"line_start":65,"line_end":65,"column_start":11,"column_end":26},"name":"_SIDD_UNIT_MASK","qualname":"::core_arch::x86::sse42::_SIDD_UNIT_MASK","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" **Mask only**: return the byte mask\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2984025,"byte_end":2984074,"line_start":64,"line_end":64,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8367},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2984560,"byte_end":2984572,"line_start":76,"line_end":76,"column_start":15,"column_end":27},"name":"_mm_cmpistrm","qualname":"::core_arch::x86::sse42::_mm_cmpistrm","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings with implicit lengths in `a` and `b` using the\n control in `imm8`, and return the generated mask.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2984364,"byte_end":2984373,"line_start":71,"line_end":71,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2984374,"byte_end":2984410,"line_start":72,"line_end":72,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2984464,"byte_end":2984495,"line_start":74,"line_end":74,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2984496,"byte_end":2984545,"line_start":75,"line_end":75,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8369},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2991480,"byte_end":2991492,"line_start":284,"line_end":284,"column_start":15,"column_end":27},"name":"_mm_cmpistri","qualname":"::core_arch::x86::sse42::_mm_cmpistri","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings with implicit lengths in `a` and `b` using the\n control in `imm8` and return the generated index. Similar to\n [`_mm_cmpestri`] with the exception that [`_mm_cmpestri`] requires the\n lengths of `a` and `b` to be explicitly specified.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2991284,"byte_end":2991293,"line_start":279,"line_end":279,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2991294,"byte_end":2991330,"line_start":280,"line_end":280,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2991384,"byte_end":2991415,"line_start":282,"line_end":282,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2991416,"byte_end":2991465,"line_start":283,"line_end":283,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8371},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2992207,"byte_end":2992219,"line_start":305,"line_end":305,"column_start":15,"column_end":27},"name":"_mm_cmpistrz","qualname":"::core_arch::x86::sse42::_mm_cmpistrz","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings with implicit lengths in `a` and `b` using the\n control in `imm8`, and return `1` if any character in `b` was null.\n and `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2992011,"byte_end":2992020,"line_start":300,"line_end":300,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2992021,"byte_end":2992057,"line_start":301,"line_end":301,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2992111,"byte_end":2992142,"line_start":303,"line_end":303,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2992143,"byte_end":2992192,"line_start":304,"line_end":304,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8373},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2992937,"byte_end":2992949,"line_start":326,"line_end":326,"column_start":15,"column_end":27},"name":"_mm_cmpistrc","qualname":"::core_arch::x86::sse42::_mm_cmpistrc","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings with implicit lengths in `a` and `b` using the\n control in `imm8`, and return `1` if the resulting mask was non-zero,\n and `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2992741,"byte_end":2992750,"line_start":321,"line_end":321,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2992751,"byte_end":2992787,"line_start":322,"line_end":322,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2992841,"byte_end":2992872,"line_start":324,"line_end":324,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2992873,"byte_end":2992922,"line_start":325,"line_end":325,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8375},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2993666,"byte_end":2993678,"line_start":347,"line_end":347,"column_start":15,"column_end":27},"name":"_mm_cmpistrs","qualname":"::core_arch::x86::sse42::_mm_cmpistrs","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings with implicit lengths in `a` and `b` using the\n control in `imm8`, and returns `1` if any character in `a` was null,\n and `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2993470,"byte_end":2993479,"line_start":342,"line_end":342,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2993480,"byte_end":2993516,"line_start":343,"line_end":343,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2993570,"byte_end":2993601,"line_start":345,"line_end":345,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2993602,"byte_end":2993651,"line_start":346,"line_end":346,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8377},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2994368,"byte_end":2994380,"line_start":367,"line_end":367,"column_start":15,"column_end":27},"name":"_mm_cmpistro","qualname":"::core_arch::x86::sse42::_mm_cmpistro","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings with implicit lengths in `a` and `b` using the\n control in `imm8`, and return bit `0` of the resulting bit mask.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2994172,"byte_end":2994181,"line_start":362,"line_end":362,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2994182,"byte_end":2994218,"line_start":363,"line_end":363,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2994272,"byte_end":2994303,"line_start":365,"line_end":365,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2994304,"byte_end":2994353,"line_start":366,"line_end":366,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8379},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2995135,"byte_end":2995147,"line_start":388,"line_end":388,"column_start":15,"column_end":27},"name":"_mm_cmpistra","qualname":"::core_arch::x86::sse42::_mm_cmpistra","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings with implicit lengths in `a` and `b` using the\n control in `imm8`, and return `1` if `b` did not contain a null\n character and the resulting mask was zero, and `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2994939,"byte_end":2994948,"line_start":383,"line_end":383,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2994949,"byte_end":2994985,"line_start":384,"line_end":384,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2995039,"byte_end":2995070,"line_start":386,"line_end":386,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2995071,"byte_end":2995120,"line_start":387,"line_end":387,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8381},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2995827,"byte_end":2995839,"line_start":408,"line_end":408,"column_start":15,"column_end":27},"name":"_mm_cmpestrm","qualname":"::core_arch::x86::sse42::_mm_cmpestrm","value":"fn (a: __m128i, la: i32, b: __m128i, lb: i32, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings in `a` and `b` with lengths `la` and `lb`\n using the control in `imm8`, and return the generated mask.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2995631,"byte_end":2995640,"line_start":403,"line_end":403,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2995641,"byte_end":2995677,"line_start":404,"line_end":404,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2995731,"byte_end":2995762,"line_start":406,"line_end":406,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2995763,"byte_end":2995812,"line_start":407,"line_end":407,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8383},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2999076,"byte_end":2999088,"line_start":503,"line_end":503,"column_start":15,"column_end":27},"name":"_mm_cmpestri","qualname":"::core_arch::x86::sse42::_mm_cmpestri","value":"fn (a: __m128i, la: i32, b: __m128i, lb: i32, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings `a` and `b` with lengths `la` and `lb` using the\n control in `imm8` and return the generated index. Similar to\n [`_mm_cmpistri`] with the exception that [`_mm_cmpistri`] implicitly\n determines the length of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2998880,"byte_end":2998889,"line_start":498,"line_end":498,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2998890,"byte_end":2998926,"line_start":499,"line_end":499,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2998980,"byte_end":2999011,"line_start":501,"line_end":501,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2999012,"byte_end":2999061,"line_start":502,"line_end":502,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8385},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2999834,"byte_end":2999846,"line_start":524,"line_end":524,"column_start":15,"column_end":27},"name":"_mm_cmpestrz","qualname":"::core_arch::x86::sse42::_mm_cmpestrz","value":"fn (a: __m128i, la: i32, b: __m128i, lb: i32, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings in `a` and `b` with lengths `la` and `lb`\n using the control in `imm8`, and return `1` if any character in\n `b` was null, and `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2999638,"byte_end":2999647,"line_start":519,"line_end":519,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2999648,"byte_end":2999684,"line_start":520,"line_end":520,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2999738,"byte_end":2999769,"line_start":522,"line_end":522,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2999770,"byte_end":2999819,"line_start":523,"line_end":523,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8387},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3000595,"byte_end":3000607,"line_start":545,"line_end":545,"column_start":15,"column_end":27},"name":"_mm_cmpestrc","qualname":"::core_arch::x86::sse42::_mm_cmpestrc","value":"fn (a: __m128i, la: i32, b: __m128i, lb: i32, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings in `a` and `b` with lengths `la` and `lb`\n using the control in `imm8`, and return `1` if the resulting mask\n was non-zero, and `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3000399,"byte_end":3000408,"line_start":540,"line_end":540,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3000409,"byte_end":3000445,"line_start":541,"line_end":541,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3000499,"byte_end":3000530,"line_start":543,"line_end":543,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3000531,"byte_end":3000580,"line_start":544,"line_end":544,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8389},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3001352,"byte_end":3001364,"line_start":566,"line_end":566,"column_start":15,"column_end":27},"name":"_mm_cmpestrs","qualname":"::core_arch::x86::sse42::_mm_cmpestrs","value":"fn (a: __m128i, la: i32, b: __m128i, lb: i32, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings in `a` and `b` with lengths `la` and `lb`\n using the control in `imm8`, and return `1` if any character in\n a was null, and `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3001156,"byte_end":3001165,"line_start":561,"line_end":561,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3001166,"byte_end":3001202,"line_start":562,"line_end":562,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3001256,"byte_end":3001287,"line_start":564,"line_end":564,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3001288,"byte_end":3001337,"line_start":565,"line_end":565,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8391},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3002089,"byte_end":3002101,"line_start":587,"line_end":587,"column_start":15,"column_end":27},"name":"_mm_cmpestro","qualname":"::core_arch::x86::sse42::_mm_cmpestro","value":"fn (a: __m128i, la: i32, b: __m128i, lb: i32, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings in `a` and `b` with lengths `la` and `lb`\n using the control in `imm8`, and return bit `0` of the resulting\n bit mask.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3001893,"byte_end":3001902,"line_start":582,"line_end":582,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3001903,"byte_end":3001939,"line_start":583,"line_end":583,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3001993,"byte_end":3002024,"line_start":585,"line_end":585,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3002025,"byte_end":3002074,"line_start":586,"line_end":586,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8393},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3002891,"byte_end":3002903,"line_start":609,"line_end":609,"column_start":15,"column_end":27},"name":"_mm_cmpestra","qualname":"::core_arch::x86::sse42::_mm_cmpestra","value":"fn (a: __m128i, la: i32, b: __m128i, lb: i32, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings in `a` and `b` with lengths `la` and `lb`\n using the control in `imm8`, and return `1` if `b` did not\n contain a null character and the resulting mask was zero, and `0`\n otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3002695,"byte_end":3002704,"line_start":604,"line_end":604,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3002705,"byte_end":3002741,"line_start":605,"line_end":605,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3002795,"byte_end":3002826,"line_start":607,"line_end":607,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3002827,"byte_end":3002876,"line_start":608,"line_end":608,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8395},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3003546,"byte_end":3003558,"line_start":628,"line_end":628,"column_start":15,"column_end":27},"name":"_mm_crc32_u8","qualname":"::core_arch::x86::sse42::_mm_crc32_u8","value":"fn (crc: u32, v: u8) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Starting with the initial value in `crc`, return the accumulated\n CRC32 value for unsigned 8-bit integer `v`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3003396,"byte_end":3003405,"line_start":624,"line_end":624,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3003406,"byte_end":3003442,"line_start":625,"line_end":625,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3003482,"byte_end":3003531,"line_start":627,"line_end":627,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8396},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3003993,"byte_end":3004006,"line_start":640,"line_end":640,"column_start":15,"column_end":28},"name":"_mm_crc32_u16","qualname":"::core_arch::x86::sse42::_mm_crc32_u16","value":"fn (crc: u32, v: u16) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Starting with the initial value in `crc`, return the accumulated\n CRC32 value for unsigned 16-bit integer `v`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3003843,"byte_end":3003852,"line_start":636,"line_end":636,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3003853,"byte_end":3003889,"line_start":637,"line_end":637,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3003929,"byte_end":3003978,"line_start":639,"line_end":639,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8397},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3004443,"byte_end":3004456,"line_start":652,"line_end":652,"column_start":15,"column_end":28},"name":"_mm_crc32_u32","qualname":"::core_arch::x86::sse42::_mm_crc32_u32","value":"fn (crc: u32, v: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Starting with the initial value in `crc`, return the accumulated\n CRC32 value for unsigned 32-bit integer `v`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3004293,"byte_end":3004302,"line_start":648,"line_end":648,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3004303,"byte_end":3004339,"line_start":649,"line_end":649,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3004379,"byte_end":3004428,"line_start":651,"line_end":651,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8398},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3004872,"byte_end":3004887,"line_start":664,"line_end":664,"column_start":15,"column_end":30},"name":"_mm_cmpgt_epi64","qualname":"::core_arch::x86::sse42::_mm_cmpgt_epi64","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 64-bit integers in `a` and `b` for greater-than,\n return the results.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3004720,"byte_end":3004729,"line_start":660,"line_end":660,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3004730,"byte_end":3004766,"line_start":661,"line_end":661,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":3004808,"byte_end":3004857,"line_start":663,"line_end":663,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8429},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3014389,"byte_end":3014402,"line_start":34,"line_end":34,"column_start":15,"column_end":28},"name":"_mm256_add_pd","qualname":"::core_arch::x86::avx::_mm256_add_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Adds packed double-precision (64-bit) floating-point elements\n in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3014241,"byte_end":3014250,"line_start":30,"line_end":30,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3014251,"byte_end":3014284,"line_start":31,"line_end":31,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3014325,"byte_end":3014374,"line_start":33,"line_end":33,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8430},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3014810,"byte_end":3014823,"line_start":46,"line_end":46,"column_start":15,"column_end":28},"name":"_mm256_add_ps","qualname":"::core_arch::x86::avx::_mm256_add_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Adds packed single-precision (32-bit) floating-point elements in `a` and\n `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3014662,"byte_end":3014671,"line_start":42,"line_end":42,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3014672,"byte_end":3014705,"line_start":43,"line_end":43,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3014746,"byte_end":3014795,"line_start":45,"line_end":45,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8431},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3015356,"byte_end":3015369,"line_start":60,"line_end":60,"column_start":15,"column_end":28},"name":"_mm256_and_pd","qualname":"::core_arch::x86::avx::_mm256_and_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of a packed double-precision (64-bit)\n floating-point elements in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3015105,"byte_end":3015114,"line_start":54,"line_end":54,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3015115,"byte_end":3015148,"line_start":55,"line_end":55,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3015292,"byte_end":3015341,"line_start":59,"line_end":59,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8432},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3015877,"byte_end":3015890,"line_start":74,"line_end":74,"column_start":15,"column_end":28},"name":"_mm256_and_ps","qualname":"::core_arch::x86::avx::_mm256_and_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of packed single-precision (32-bit) floating-point\n elements in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3015729,"byte_end":3015738,"line_start":70,"line_end":70,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3015739,"byte_end":3015772,"line_start":71,"line_end":71,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3015813,"byte_end":3015862,"line_start":73,"line_end":73,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8433},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3016494,"byte_end":3016506,"line_start":90,"line_end":90,"column_start":15,"column_end":27},"name":"_mm256_or_pd","qualname":"::core_arch::x86::avx::_mm256_or_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise OR packed double-precision (64-bit) floating-point\n elements in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3016242,"byte_end":3016251,"line_start":84,"line_end":84,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3016252,"byte_end":3016285,"line_start":85,"line_end":85,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3016430,"byte_end":3016479,"line_start":89,"line_end":89,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8434},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3017007,"byte_end":3017019,"line_start":104,"line_end":104,"column_start":15,"column_end":27},"name":"_mm256_or_ps","qualname":"::core_arch::x86::avx::_mm256_or_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise OR packed single-precision (32-bit) floating-point\n elements in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3016860,"byte_end":3016869,"line_start":100,"line_end":100,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3016870,"byte_end":3016903,"line_start":101,"line_end":101,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3016943,"byte_end":3016992,"line_start":103,"line_end":103,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8435},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3017580,"byte_end":3017597,"line_start":119,"line_end":119,"column_start":15,"column_end":32},"name":"_mm256_shuffle_pd","qualname":"::core_arch::x86::avx::_mm256_shuffle_pd","value":"fn (a: __m256d, b: __m256d, imm8: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Shuffles double-precision (64-bit) floating-point elements within 128-bit\n lanes using the control in `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3017387,"byte_end":3017396,"line_start":114,"line_end":114,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3017397,"byte_end":3017430,"line_start":115,"line_end":115,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3017484,"byte_end":3017515,"line_start":117,"line_end":117,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3017516,"byte_end":3017565,"line_start":118,"line_end":118,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8440},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3018994,"byte_end":3019011,"line_start":165,"line_end":165,"column_start":15,"column_end":32},"name":"_mm256_shuffle_ps","qualname":"::core_arch::x86::avx::_mm256_shuffle_ps","value":"fn (a: __m256, b: __m256, imm8: i32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Shuffles single-precision (32-bit) floating-point elements in `a` within\n 128-bit lanes using the control in `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3018801,"byte_end":3018810,"line_start":160,"line_end":160,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3018811,"byte_end":3018844,"line_start":161,"line_end":161,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3018898,"byte_end":3018929,"line_start":163,"line_end":163,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3018930,"byte_end":3018979,"line_start":164,"line_end":164,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8445},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3021083,"byte_end":3021099,"line_start":228,"line_end":228,"column_start":15,"column_end":31},"name":"_mm256_andnot_pd","qualname":"::core_arch::x86::avx::_mm256_andnot_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise NOT of packed double-precision (64-bit) floating-point\n elements in `a`, and then AND with `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3020891,"byte_end":3020900,"line_start":223,"line_end":223,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3020901,"byte_end":3020934,"line_start":224,"line_end":224,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3021019,"byte_end":3021068,"line_start":227,"line_end":227,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8446},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3021663,"byte_end":3021679,"line_start":243,"line_end":243,"column_start":15,"column_end":31},"name":"_mm256_andnot_ps","qualname":"::core_arch::x86::avx::_mm256_andnot_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise NOT of packed single-precision (32-bit) floating-point\n elements in `a`\n and then AND with `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3021514,"byte_end":3021523,"line_start":239,"line_end":239,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3021524,"byte_end":3021557,"line_start":240,"line_end":240,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3021599,"byte_end":3021648,"line_start":242,"line_end":242,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8447},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3022233,"byte_end":3022246,"line_start":257,"line_end":257,"column_start":15,"column_end":28},"name":"_mm256_max_pd","qualname":"::core_arch::x86::avx::_mm256_max_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Compares packed double-precision (64-bit) floating-point elements\n in `a` and `b`, and returns packed maximum values","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3022085,"byte_end":3022094,"line_start":253,"line_end":253,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3022095,"byte_end":3022128,"line_start":254,"line_end":254,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3022169,"byte_end":3022218,"line_start":256,"line_end":256,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8448},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3022692,"byte_end":3022705,"line_start":269,"line_end":269,"column_start":15,"column_end":28},"name":"_mm256_max_ps","qualname":"::core_arch::x86::avx::_mm256_max_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Compares packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and returns packed maximum values","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3022544,"byte_end":3022553,"line_start":265,"line_end":265,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3022554,"byte_end":3022587,"line_start":266,"line_end":266,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3022628,"byte_end":3022677,"line_start":268,"line_end":268,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8449},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3023148,"byte_end":3023161,"line_start":281,"line_end":281,"column_start":15,"column_end":28},"name":"_mm256_min_pd","qualname":"::core_arch::x86::avx::_mm256_min_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Compares packed double-precision (64-bit) floating-point elements\n in `a` and `b`, and returns packed minimum values","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3023000,"byte_end":3023009,"line_start":277,"line_end":277,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3023010,"byte_end":3023043,"line_start":278,"line_end":278,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3023084,"byte_end":3023133,"line_start":280,"line_end":280,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8450},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3023607,"byte_end":3023620,"line_start":293,"line_end":293,"column_start":15,"column_end":28},"name":"_mm256_min_ps","qualname":"::core_arch::x86::avx::_mm256_min_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Compares packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and returns packed minimum values","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3023459,"byte_end":3023468,"line_start":289,"line_end":289,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3023469,"byte_end":3023502,"line_start":290,"line_end":290,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3023543,"byte_end":3023592,"line_start":292,"line_end":292,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8451},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3024031,"byte_end":3024044,"line_start":305,"line_end":305,"column_start":15,"column_end":28},"name":"_mm256_mul_pd","qualname":"::core_arch::x86::avx::_mm256_mul_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements\n in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3023883,"byte_end":3023892,"line_start":301,"line_end":301,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3023893,"byte_end":3023926,"line_start":302,"line_end":302,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3023967,"byte_end":3024016,"line_start":304,"line_end":304,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8452},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3024458,"byte_end":3024471,"line_start":317,"line_end":317,"column_start":15,"column_end":28},"name":"_mm256_mul_ps","qualname":"::core_arch::x86::avx::_mm256_mul_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a` and\n `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3024310,"byte_end":3024319,"line_start":313,"line_end":313,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3024320,"byte_end":3024353,"line_start":314,"line_end":314,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3024394,"byte_end":3024443,"line_start":316,"line_end":316,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8453},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3024933,"byte_end":3024949,"line_start":329,"line_end":329,"column_start":15,"column_end":31},"name":"_mm256_addsub_pd","qualname":"::core_arch::x86::avx::_mm256_addsub_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Alternatively adds and subtracts packed double-precision (64-bit)\n floating-point elements in `a` to/from packed elements in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3024782,"byte_end":3024791,"line_start":325,"line_end":325,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3024792,"byte_end":3024825,"line_start":326,"line_end":326,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3024869,"byte_end":3024918,"line_start":328,"line_end":328,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8454},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3025417,"byte_end":3025433,"line_start":341,"line_end":341,"column_start":15,"column_end":31},"name":"_mm256_addsub_ps","qualname":"::core_arch::x86::avx::_mm256_addsub_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Alternatively adds and subtracts packed single-precision (32-bit)\n floating-point elements in `a` to/from packed elements in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3025266,"byte_end":3025275,"line_start":337,"line_end":337,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3025276,"byte_end":3025309,"line_start":338,"line_end":338,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3025353,"byte_end":3025402,"line_start":340,"line_end":340,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8455},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3025866,"byte_end":3025879,"line_start":353,"line_end":353,"column_start":15,"column_end":28},"name":"_mm256_sub_pd","qualname":"::core_arch::x86::avx::_mm256_sub_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Subtracts packed double-precision (64-bit) floating-point elements in `b`\n from packed elements in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3025718,"byte_end":3025727,"line_start":349,"line_end":349,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3025728,"byte_end":3025761,"line_start":350,"line_end":350,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3025802,"byte_end":3025851,"line_start":352,"line_end":352,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8456},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3026312,"byte_end":3026325,"line_start":365,"line_end":365,"column_start":15,"column_end":28},"name":"_mm256_sub_ps","qualname":"::core_arch::x86::avx::_mm256_sub_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Subtracts packed single-precision (32-bit) floating-point elements in `b`\n from packed elements in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3026164,"byte_end":3026173,"line_start":361,"line_end":361,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3026174,"byte_end":3026207,"line_start":362,"line_end":362,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3026248,"byte_end":3026297,"line_start":364,"line_end":364,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8457},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3026781,"byte_end":3026794,"line_start":377,"line_end":377,"column_start":15,"column_end":28},"name":"_mm256_div_ps","qualname":"::core_arch::x86::avx::_mm256_div_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Computes the division of each of the 8 packed 32-bit floating-point elements\n in `a` by the corresponding packed elements in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3026633,"byte_end":3026642,"line_start":373,"line_end":373,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3026643,"byte_end":3026676,"line_start":374,"line_end":374,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3026717,"byte_end":3026766,"line_start":376,"line_end":376,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8458},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3027250,"byte_end":3027263,"line_start":389,"line_end":389,"column_start":15,"column_end":28},"name":"_mm256_div_pd","qualname":"::core_arch::x86::avx::_mm256_div_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Computes the division of each of the 4 packed 64-bit floating-point elements\n in `a` by the corresponding packed elements in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3027102,"byte_end":3027111,"line_start":385,"line_end":385,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3027112,"byte_end":3027145,"line_start":386,"line_end":386,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3027186,"byte_end":3027235,"line_start":388,"line_end":388,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8459},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3028169,"byte_end":3028184,"line_start":411,"line_end":411,"column_start":15,"column_end":30},"name":"_mm256_round_pd","qualname":"::core_arch::x86::avx::_mm256_round_pd","value":"fn (a: __m256d, b: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Rounds packed double-precision (64-bit) floating point elements in `a`\n according to the flag `b`. The value of `b` may be as follows:","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3027978,"byte_end":3027987,"line_start":406,"line_end":406,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3027988,"byte_end":3028021,"line_start":407,"line_end":407,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3028073,"byte_end":3028104,"line_start":409,"line_end":409,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3028105,"byte_end":3028154,"line_start":410,"line_end":410,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8461},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3028719,"byte_end":3028733,"line_start":428,"line_end":428,"column_start":15,"column_end":29},"name":"_mm256_ceil_pd","qualname":"::core_arch::x86::avx::_mm256_ceil_pd","value":"fn (a: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Rounds packed double-precision (64-bit) floating point elements in `a`\n toward positive infinity.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3028569,"byte_end":3028578,"line_start":424,"line_end":424,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3028579,"byte_end":3028612,"line_start":425,"line_end":425,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3028655,"byte_end":3028704,"line_start":427,"line_end":427,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8462},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3029157,"byte_end":3029172,"line_start":440,"line_end":440,"column_start":15,"column_end":30},"name":"_mm256_floor_pd","qualname":"::core_arch::x86::avx::_mm256_floor_pd","value":"fn (a: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Rounds packed double-precision (64-bit) floating point elements in `a`\n toward negative infinity.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3029007,"byte_end":3029016,"line_start":436,"line_end":436,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3029017,"byte_end":3029050,"line_start":437,"line_end":437,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3029093,"byte_end":3029142,"line_start":439,"line_end":439,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8463},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3030072,"byte_end":3030087,"line_start":462,"line_end":462,"column_start":15,"column_end":30},"name":"_mm256_round_ps","qualname":"::core_arch::x86::avx::_mm256_round_ps","value":"fn (a: __m256, b: i32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Rounds packed single-precision (32-bit) floating point elements in `a`\n according to the flag `b`. The value of `b` may be as follows:","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3029880,"byte_end":3029889,"line_start":457,"line_end":457,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3029890,"byte_end":3029923,"line_start":458,"line_end":458,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3029976,"byte_end":3030007,"line_start":460,"line_end":460,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3030008,"byte_end":3030057,"line_start":461,"line_end":461,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8465},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3030620,"byte_end":3030634,"line_start":479,"line_end":479,"column_start":15,"column_end":29},"name":"_mm256_ceil_ps","qualname":"::core_arch::x86::avx::_mm256_ceil_ps","value":"fn (a: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Rounds packed single-precision (32-bit) floating point elements in `a`\n toward positive infinity.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3030470,"byte_end":3030479,"line_start":475,"line_end":475,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3030480,"byte_end":3030513,"line_start":476,"line_end":476,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3030556,"byte_end":3030605,"line_start":478,"line_end":478,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8466},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3031056,"byte_end":3031071,"line_start":491,"line_end":491,"column_start":15,"column_end":30},"name":"_mm256_floor_ps","qualname":"::core_arch::x86::avx::_mm256_floor_ps","value":"fn (a: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Rounds packed single-precision (32-bit) floating point elements in `a`\n toward negative infinity.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3030906,"byte_end":3030915,"line_start":487,"line_end":487,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3030916,"byte_end":3030949,"line_start":488,"line_end":488,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3030992,"byte_end":3031041,"line_start":490,"line_end":490,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8467},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3031486,"byte_end":3031500,"line_start":503,"line_end":503,"column_start":15,"column_end":29},"name":"_mm256_sqrt_ps","qualname":"::core_arch::x86::avx::_mm256_sqrt_ps","value":"fn (a: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Returns the square root of packed single-precision (32-bit) floating point\n elements in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3031337,"byte_end":3031346,"line_start":499,"line_end":499,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3031347,"byte_end":3031380,"line_start":500,"line_end":500,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3031422,"byte_end":3031471,"line_start":502,"line_end":502,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8468},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3031908,"byte_end":3031922,"line_start":515,"line_end":515,"column_start":15,"column_end":29},"name":"_mm256_sqrt_pd","qualname":"::core_arch::x86::avx::_mm256_sqrt_pd","value":"fn (a: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Returns the square root of packed double-precision (64-bit) floating point\n elements in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3031759,"byte_end":3031768,"line_start":511,"line_end":511,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3031769,"byte_end":3031802,"line_start":512,"line_end":512,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3031844,"byte_end":3031893,"line_start":514,"line_end":514,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8469},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3032573,"byte_end":3032588,"line_start":531,"line_end":531,"column_start":15,"column_end":30},"name":"_mm256_blend_pd","qualname":"::core_arch::x86::avx::_mm256_blend_pd","value":"fn (a: __m256d, b: __m256d, imm8: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Blends packed double-precision (64-bit) floating-point elements from\n `a` and `b` using control mask `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3032200,"byte_end":3032209,"line_start":523,"line_end":523,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3032210,"byte_end":3032243,"line_start":524,"line_end":524,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3032477,"byte_end":3032508,"line_start":529,"line_end":529,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3032509,"byte_end":3032558,"line_start":530,"line_end":530,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8474},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3033929,"byte_end":3033944,"line_start":577,"line_end":577,"column_start":15,"column_end":30},"name":"_mm256_blend_ps","qualname":"::core_arch::x86::avx::_mm256_blend_ps","value":"fn (a: __m256, b: __m256, imm8: i32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Blends packed single-precision (32-bit) floating-point elements from\n `a` and `b` using control mask `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3033737,"byte_end":3033746,"line_start":572,"line_end":572,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3033747,"byte_end":3033780,"line_start":573,"line_end":573,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3033833,"byte_end":3033864,"line_start":575,"line_end":575,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3033865,"byte_end":3033914,"line_start":576,"line_end":576,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8479},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3035961,"byte_end":3035977,"line_start":639,"line_end":639,"column_start":15,"column_end":31},"name":"_mm256_blendv_pd","qualname":"::core_arch::x86::avx::_mm256_blendv_pd","value":"fn (a: __m256d, b: __m256d, c: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Blends packed double-precision (64-bit) floating-point elements from\n `a` and `b` using `c` as a mask.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3035810,"byte_end":3035819,"line_start":635,"line_end":635,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3035820,"byte_end":3035853,"line_start":636,"line_end":636,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3035897,"byte_end":3035946,"line_start":638,"line_end":638,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8480},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3036431,"byte_end":3036447,"line_start":651,"line_end":651,"column_start":15,"column_end":31},"name":"_mm256_blendv_ps","qualname":"::core_arch::x86::avx::_mm256_blendv_ps","value":"fn (a: __m256, b: __m256, c: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Blends packed single-precision (32-bit) floating-point elements from\n `a` and `b` using `c` as a mask.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3036280,"byte_end":3036289,"line_start":647,"line_end":647,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3036290,"byte_end":3036323,"line_start":648,"line_end":648,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3036367,"byte_end":3036416,"line_start":650,"line_end":650,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8481},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3037062,"byte_end":3037074,"line_start":666,"line_end":666,"column_start":15,"column_end":27},"name":"_mm256_dp_ps","qualname":"::core_arch::x86::avx::_mm256_dp_ps","value":"fn (a: __m256, b: __m256, imm8: i32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Conditionally multiplies the packed single-precision (32-bit) floating-point\n elements in `a` and `b` using the high 4 bits in `imm8`,\n sum the four products, and conditionally return the sum\n  using the low 4 bits of `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3036871,"byte_end":3036880,"line_start":661,"line_end":661,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3036881,"byte_end":3036914,"line_start":662,"line_end":662,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3036966,"byte_end":3036997,"line_start":664,"line_end":664,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3036998,"byte_end":3037047,"line_start":665,"line_end":665,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8483},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3037773,"byte_end":3037787,"line_start":685,"line_end":685,"column_start":15,"column_end":29},"name":"_mm256_hadd_pd","qualname":"::core_arch::x86::avx::_mm256_hadd_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Horizontal addition of adjacent pairs in the two packed vectors\n of 4 64-bit floating points `a` and `b`.\n In the result, sums of elements from `a` are returned in even locations,\n while sums of elements from `b` are returned in odd locations.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3037624,"byte_end":3037633,"line_start":681,"line_end":681,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3037634,"byte_end":3037667,"line_start":682,"line_end":682,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3037709,"byte_end":3037758,"line_start":684,"line_end":684,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8484},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3038383,"byte_end":3038397,"line_start":700,"line_end":700,"column_start":15,"column_end":29},"name":"_mm256_hadd_ps","qualname":"::core_arch::x86::avx::_mm256_hadd_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Horizontal addition of adjacent pairs in the two packed vectors\n of 8 32-bit floating points `a` and `b`.\n In the result, sums of elements from `a` are returned in locations of\n indices 0, 1, 4, 5; while sums of elements from `b` are locations\n 2, 3, 6, 7.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3038234,"byte_end":3038243,"line_start":696,"line_end":696,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3038244,"byte_end":3038277,"line_start":697,"line_end":697,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3038319,"byte_end":3038368,"line_start":699,"line_end":699,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8485},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3038977,"byte_end":3038991,"line_start":714,"line_end":714,"column_start":15,"column_end":29},"name":"_mm256_hsub_pd","qualname":"::core_arch::x86::avx::_mm256_hsub_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Horizontal subtraction of adjacent pairs in the two packed vectors\n of 4 64-bit floating points `a` and `b`.\n In the result, sums of elements from `a` are returned in even locations,\n while sums of elements from `b` are returned in odd locations.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3038828,"byte_end":3038837,"line_start":710,"line_end":710,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3038838,"byte_end":3038871,"line_start":711,"line_end":711,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3038913,"byte_end":3038962,"line_start":713,"line_end":713,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8486},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3039590,"byte_end":3039604,"line_start":729,"line_end":729,"column_start":15,"column_end":29},"name":"_mm256_hsub_ps","qualname":"::core_arch::x86::avx::_mm256_hsub_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Horizontal subtraction of adjacent pairs in the two packed vectors\n of 8 32-bit floating points `a` and `b`.\n In the result, sums of elements from `a` are returned in locations of\n indices 0, 1, 4, 5; while sums of elements from `b` are locations\n 2, 3, 6, 7.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3039441,"byte_end":3039450,"line_start":725,"line_end":725,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3039451,"byte_end":3039484,"line_start":726,"line_end":726,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3039526,"byte_end":3039575,"line_start":728,"line_end":728,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8487},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3040072,"byte_end":3040085,"line_start":742,"line_end":742,"column_start":15,"column_end":28},"name":"_mm256_xor_pd","qualname":"::core_arch::x86::avx::_mm256_xor_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise XOR of packed double-precision (64-bit) floating-point\n elements in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3039883,"byte_end":3039892,"line_start":737,"line_end":737,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3039893,"byte_end":3039926,"line_start":738,"line_end":738,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3040008,"byte_end":3040057,"line_start":741,"line_end":741,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8488},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3040593,"byte_end":3040606,"line_start":756,"line_end":756,"column_start":15,"column_end":28},"name":"_mm256_xor_ps","qualname":"::core_arch::x86::avx::_mm256_xor_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise XOR of packed single-precision (32-bit) floating-point\n elements in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3040445,"byte_end":3040454,"line_start":752,"line_end":752,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3040455,"byte_end":3040488,"line_start":753,"line_end":753,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3040529,"byte_end":3040578,"line_start":755,"line_end":755,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8489},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3040835,"byte_end":3040845,"line_start":764,"line_end":764,"column_start":11,"column_end":21},"name":"_CMP_EQ_OQ","qualname":"::core_arch::x86::avx::_CMP_EQ_OQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Equal (ordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3040775,"byte_end":3040824,"line_start":763,"line_end":763,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8490},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3040954,"byte_end":3040964,"line_start":767,"line_end":767,"column_start":11,"column_end":21},"name":"_CMP_LT_OS","qualname":"::core_arch::x86::avx::_CMP_LT_OS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Less-than (ordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3040894,"byte_end":3040943,"line_start":766,"line_end":766,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8491},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3041082,"byte_end":3041092,"line_start":770,"line_end":770,"column_start":11,"column_end":21},"name":"_CMP_LE_OS","qualname":"::core_arch::x86::avx::_CMP_LE_OS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Less-than-or-equal (ordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3041022,"byte_end":3041071,"line_start":769,"line_end":769,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8492},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3041196,"byte_end":3041208,"line_start":773,"line_end":773,"column_start":11,"column_end":23},"name":"_CMP_UNORD_Q","qualname":"::core_arch::x86::avx::_CMP_UNORD_Q","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Unordered (non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3041136,"byte_end":3041185,"line_start":772,"line_end":772,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8493},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3041323,"byte_end":3041334,"line_start":776,"line_end":776,"column_start":11,"column_end":22},"name":"_CMP_NEQ_UQ","qualname":"::core_arch::x86::avx::_CMP_NEQ_UQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-equal (unordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3041263,"byte_end":3041312,"line_start":775,"line_end":775,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8494},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3041449,"byte_end":3041460,"line_start":779,"line_end":779,"column_start":11,"column_end":22},"name":"_CMP_NLT_US","qualname":"::core_arch::x86::avx::_CMP_NLT_US","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-less-than (unordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3041389,"byte_end":3041438,"line_start":778,"line_end":778,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8495},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3041584,"byte_end":3041595,"line_start":782,"line_end":782,"column_start":11,"column_end":22},"name":"_CMP_NLE_US","qualname":"::core_arch::x86::avx::_CMP_NLE_US","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-less-than-or-equal (unordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3041524,"byte_end":3041573,"line_start":781,"line_end":781,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8496},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3041697,"byte_end":3041707,"line_start":785,"line_end":785,"column_start":11,"column_end":21},"name":"_CMP_ORD_Q","qualname":"::core_arch::x86::avx::_CMP_ORD_Q","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Ordered (non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3041637,"byte_end":3041686,"line_start":784,"line_end":784,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8497},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3041818,"byte_end":3041828,"line_start":788,"line_end":788,"column_start":11,"column_end":21},"name":"_CMP_EQ_UQ","qualname":"::core_arch::x86::avx::_CMP_EQ_UQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Equal (unordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3041758,"byte_end":3041807,"line_start":787,"line_end":787,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8498},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3041955,"byte_end":3041966,"line_start":791,"line_end":791,"column_start":11,"column_end":22},"name":"_CMP_NGE_US","qualname":"::core_arch::x86::avx::_CMP_NGE_US","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-greater-than-or-equal (unordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3041895,"byte_end":3041944,"line_start":790,"line_end":790,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8499},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042084,"byte_end":3042095,"line_start":794,"line_end":794,"column_start":11,"column_end":22},"name":"_CMP_NGT_US","qualname":"::core_arch::x86::avx::_CMP_NGT_US","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-greater-than (unordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042024,"byte_end":3042073,"line_start":793,"line_end":793,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8500},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042204,"byte_end":3042217,"line_start":797,"line_end":797,"column_start":11,"column_end":24},"name":"_CMP_FALSE_OQ","qualname":"::core_arch::x86::avx::_CMP_FALSE_OQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" False (ordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042144,"byte_end":3042193,"line_start":796,"line_end":796,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8501},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042330,"byte_end":3042341,"line_start":800,"line_end":800,"column_start":11,"column_end":22},"name":"_CMP_NEQ_OQ","qualname":"::core_arch::x86::avx::_CMP_NEQ_OQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-equal (ordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042270,"byte_end":3042319,"line_start":799,"line_end":799,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8502},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042462,"byte_end":3042472,"line_start":803,"line_end":803,"column_start":11,"column_end":21},"name":"_CMP_GE_OS","qualname":"::core_arch::x86::avx::_CMP_GE_OS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Greater-than-or-equal (ordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042402,"byte_end":3042451,"line_start":802,"line_end":802,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8503},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042584,"byte_end":3042594,"line_start":806,"line_end":806,"column_start":11,"column_end":21},"name":"_CMP_GT_OS","qualname":"::core_arch::x86::avx::_CMP_GT_OS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Greater-than (ordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042524,"byte_end":3042573,"line_start":805,"line_end":805,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8504},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042704,"byte_end":3042716,"line_start":809,"line_end":809,"column_start":11,"column_end":23},"name":"_CMP_TRUE_UQ","qualname":"::core_arch::x86::avx::_CMP_TRUE_UQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" True (unordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042644,"byte_end":3042693,"line_start":808,"line_end":808,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8505},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042821,"byte_end":3042831,"line_start":812,"line_end":812,"column_start":11,"column_end":21},"name":"_CMP_EQ_OS","qualname":"::core_arch::x86::avx::_CMP_EQ_OS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Equal (ordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042761,"byte_end":3042810,"line_start":811,"line_end":811,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8506},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042944,"byte_end":3042954,"line_start":815,"line_end":815,"column_start":11,"column_end":21},"name":"_CMP_LT_OQ","qualname":"::core_arch::x86::avx::_CMP_LT_OQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Less-than (ordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042884,"byte_end":3042933,"line_start":814,"line_end":814,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8507},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043076,"byte_end":3043086,"line_start":818,"line_end":818,"column_start":11,"column_end":21},"name":"_CMP_LE_OQ","qualname":"::core_arch::x86::avx::_CMP_LE_OQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Less-than-or-equal (ordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043016,"byte_end":3043065,"line_start":817,"line_end":817,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8508},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043186,"byte_end":3043198,"line_start":821,"line_end":821,"column_start":11,"column_end":23},"name":"_CMP_UNORD_S","qualname":"::core_arch::x86::avx::_CMP_UNORD_S","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Unordered (signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043126,"byte_end":3043175,"line_start":820,"line_end":820,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8509},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043309,"byte_end":3043320,"line_start":824,"line_end":824,"column_start":11,"column_end":22},"name":"_CMP_NEQ_US","qualname":"::core_arch::x86::avx::_CMP_NEQ_US","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-equal (unordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043249,"byte_end":3043298,"line_start":823,"line_end":823,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8510},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043439,"byte_end":3043450,"line_start":827,"line_end":827,"column_start":11,"column_end":22},"name":"_CMP_NLT_UQ","qualname":"::core_arch::x86::avx::_CMP_NLT_UQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-less-than (unordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043379,"byte_end":3043428,"line_start":826,"line_end":826,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8511},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043578,"byte_end":3043589,"line_start":830,"line_end":830,"column_start":11,"column_end":22},"name":"_CMP_NLE_UQ","qualname":"::core_arch::x86::avx::_CMP_NLE_UQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-less-than-or-equal (unordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043518,"byte_end":3043567,"line_start":829,"line_end":829,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8512},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043687,"byte_end":3043697,"line_start":833,"line_end":833,"column_start":11,"column_end":21},"name":"_CMP_ORD_S","qualname":"::core_arch::x86::avx::_CMP_ORD_S","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Ordered (signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043627,"byte_end":3043676,"line_start":832,"line_end":832,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8513},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043804,"byte_end":3043814,"line_start":836,"line_end":836,"column_start":11,"column_end":21},"name":"_CMP_EQ_US","qualname":"::core_arch::x86::avx::_CMP_EQ_US","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Equal (unordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043744,"byte_end":3043793,"line_start":835,"line_end":835,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8514},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043945,"byte_end":3043956,"line_start":839,"line_end":839,"column_start":11,"column_end":22},"name":"_CMP_NGE_UQ","qualname":"::core_arch::x86::avx::_CMP_NGE_UQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-greater-than-or-equal (unordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043885,"byte_end":3043934,"line_start":838,"line_end":838,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8515},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044078,"byte_end":3044089,"line_start":842,"line_end":842,"column_start":11,"column_end":22},"name":"_CMP_NGT_UQ","qualname":"::core_arch::x86::avx::_CMP_NGT_UQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-greater-than (unordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044018,"byte_end":3044067,"line_start":841,"line_end":841,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8516},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044194,"byte_end":3044207,"line_start":845,"line_end":845,"column_start":11,"column_end":24},"name":"_CMP_FALSE_OS","qualname":"::core_arch::x86::avx::_CMP_FALSE_OS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" False (ordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044134,"byte_end":3044183,"line_start":844,"line_end":844,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8517},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044316,"byte_end":3044327,"line_start":848,"line_end":848,"column_start":11,"column_end":22},"name":"_CMP_NEQ_OS","qualname":"::core_arch::x86::avx::_CMP_NEQ_OS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-equal (ordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044256,"byte_end":3044305,"line_start":847,"line_end":847,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8518},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044452,"byte_end":3044462,"line_start":851,"line_end":851,"column_start":11,"column_end":21},"name":"_CMP_GE_OQ","qualname":"::core_arch::x86::avx::_CMP_GE_OQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Greater-than-or-equal (ordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044392,"byte_end":3044441,"line_start":850,"line_end":850,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8519},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044578,"byte_end":3044588,"line_start":854,"line_end":854,"column_start":11,"column_end":21},"name":"_CMP_GT_OQ","qualname":"::core_arch::x86::avx::_CMP_GT_OQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Greater-than (ordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044518,"byte_end":3044567,"line_start":853,"line_end":853,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":8520},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044694,"byte_end":3044706,"line_start":857,"line_end":857,"column_start":11,"column_end":23},"name":"_CMP_TRUE_US","qualname":"::core_arch::x86::avx::_CMP_TRUE_US","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" True (unordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044634,"byte_end":3044683,"line_start":856,"line_end":856,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8521},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3045199,"byte_end":3045209,"line_start":869,"line_end":869,"column_start":15,"column_end":25},"name":"_mm_cmp_pd","qualname":"::core_arch::x86::avx::_mm_cmp_pd","value":"fn (a: __m128d, b: __m128d, imm8: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares packed double-precision (64-bit) floating-point\n elements in `a` and `b` based on the comparison operand\n specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044978,"byte_end":3044987,"line_start":864,"line_end":864,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044988,"byte_end":3045026,"line_start":865,"line_end":865,"column_start":1,"column_end":39}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3045103,"byte_end":3045134,"line_start":867,"line_end":867,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3045135,"byte_end":3045184,"line_start":868,"line_end":868,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8523},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3045867,"byte_end":3045880,"line_start":888,"line_end":888,"column_start":15,"column_end":28},"name":"_mm256_cmp_pd","qualname":"::core_arch::x86::avx::_mm256_cmp_pd","value":"fn (a: __m256d, b: __m256d, imm8: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Compares packed double-precision (64-bit) floating-point\n elements in `a` and `b` based on the comparison operand\n specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3045651,"byte_end":3045660,"line_start":883,"line_end":883,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3045661,"byte_end":3045694,"line_start":884,"line_end":884,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3045771,"byte_end":3045802,"line_start":886,"line_end":886,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3045803,"byte_end":3045852,"line_start":887,"line_end":887,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8525},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3046542,"byte_end":3046552,"line_start":907,"line_end":907,"column_start":15,"column_end":25},"name":"_mm_cmp_ps","qualname":"::core_arch::x86::avx::_mm_cmp_ps","value":"fn (a: __m128, b: __m128, imm8: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares packed single-precision (32-bit) floating-point\n elements in `a` and `b` based on the comparison operand\n specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3046322,"byte_end":3046331,"line_start":902,"line_end":902,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3046332,"byte_end":3046369,"line_start":903,"line_end":903,"column_start":1,"column_end":38}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3046446,"byte_end":3046477,"line_start":905,"line_end":905,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3046478,"byte_end":3046527,"line_start":906,"line_end":906,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8527},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3047207,"byte_end":3047220,"line_start":926,"line_end":926,"column_start":15,"column_end":28},"name":"_mm256_cmp_ps","qualname":"::core_arch::x86::avx::_mm256_cmp_ps","value":"fn (a: __m256, b: __m256, imm8: i32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Compares packed single-precision (32-bit) floating-point\n elements in `a` and `b` based on the comparison operand\n specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3046991,"byte_end":3047000,"line_start":921,"line_end":921,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3047001,"byte_end":3047034,"line_start":922,"line_end":922,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3047111,"byte_end":3047142,"line_start":924,"line_end":924,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3047143,"byte_end":3047192,"line_start":925,"line_end":925,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8529},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3048027,"byte_end":3048037,"line_start":947,"line_end":947,"column_start":15,"column_end":25},"name":"_mm_cmp_sd","qualname":"::core_arch::x86::avx::_mm_cmp_sd","value":"fn (a: __m128d, b: __m128d, imm8: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower double-precision (64-bit) floating-point element in\n `a` and `b` based on the comparison operand specified by `imm8`,\n store the result in the lower element of returned vector,\n and copies the upper element from `a` to the upper element of returned\n vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3047806,"byte_end":3047815,"line_start":942,"line_end":942,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3047816,"byte_end":3047854,"line_start":943,"line_end":943,"column_start":1,"column_end":39}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3047931,"byte_end":3047962,"line_start":945,"line_end":945,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3047963,"byte_end":3048012,"line_start":946,"line_end":946,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8531},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3048854,"byte_end":3048864,"line_start":968,"line_end":968,"column_start":15,"column_end":25},"name":"_mm_cmp_ss","qualname":"::core_arch::x86::avx::_mm_cmp_ss","value":"fn (a: __m128, b: __m128, imm8: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower single-precision (32-bit) floating-point element in\n `a` and `b` based on the comparison operand specified by `imm8`,\n store the result in the lower element of returned vector,\n and copies the upper 3 packed elements from `a` to the upper elements of\n returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3048634,"byte_end":3048643,"line_start":963,"line_end":963,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3048644,"byte_end":3048681,"line_start":964,"line_end":964,"column_start":1,"column_end":38}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3048758,"byte_end":3048789,"line_start":966,"line_end":966,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3048790,"byte_end":3048839,"line_start":967,"line_end":967,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8533},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3049421,"byte_end":3049439,"line_start":985,"line_end":985,"column_start":15,"column_end":33},"name":"_mm256_cvtepi32_pd","qualname":"::core_arch::x86::avx::_mm256_cvtepi32_pd","value":"fn (a: __m128i) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 32-bit integers in `a` to packed double-precision (64-bit)\n floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3049270,"byte_end":3049279,"line_start":981,"line_end":981,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3049280,"byte_end":3049313,"line_start":982,"line_end":982,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3049357,"byte_end":3049406,"line_start":984,"line_end":984,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8534},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3049874,"byte_end":3049892,"line_start":997,"line_end":997,"column_start":15,"column_end":33},"name":"_mm256_cvtepi32_ps","qualname":"::core_arch::x86::avx::_mm256_cvtepi32_ps","value":"fn (a: __m256i) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 32-bit integers in `a` to packed single-precision (32-bit)\n floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3049723,"byte_end":3049732,"line_start":993,"line_end":993,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3049733,"byte_end":3049766,"line_start":994,"line_end":994,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3049810,"byte_end":3049859,"line_start":996,"line_end":996,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8535},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3050357,"byte_end":3050372,"line_start":1009,"line_end":1009,"column_start":15,"column_end":30},"name":"_mm256_cvtpd_ps","qualname":"::core_arch::x86::avx::_mm256_cvtpd_ps","value":"fn (a: __m256d) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts packed double-precision (64-bit) floating-point elements in `a`\n to packed single-precision (32-bit) floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3050206,"byte_end":3050215,"line_start":1005,"line_end":1005,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3050216,"byte_end":3050249,"line_start":1006,"line_end":1006,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3050293,"byte_end":3050342,"line_start":1008,"line_end":1008,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8536},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3050795,"byte_end":3050813,"line_start":1021,"line_end":1021,"column_start":15,"column_end":33},"name":"_mm256_cvtps_epi32","qualname":"::core_arch::x86::avx::_mm256_cvtps_epi32","value":"fn (a: __m256) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed single-precision (32-bit) floating-point elements in `a`\n to packed 32-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3050644,"byte_end":3050653,"line_start":1017,"line_end":1017,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3050654,"byte_end":3050687,"line_start":1018,"line_end":1018,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3050731,"byte_end":3050780,"line_start":1020,"line_end":1020,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8537},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3051278,"byte_end":3051293,"line_start":1033,"line_end":1033,"column_start":15,"column_end":30},"name":"_mm256_cvtps_pd","qualname":"::core_arch::x86::avx::_mm256_cvtps_pd","value":"fn (a: __m128) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Converts packed single-precision (32-bit) floating-point elements in `a`\n to packed double-precision (64-bit) floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3051127,"byte_end":3051136,"line_start":1029,"line_end":1029,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3051137,"byte_end":3051170,"line_start":1030,"line_end":1030,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3051214,"byte_end":3051263,"line_start":1032,"line_end":1032,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8538},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3051734,"byte_end":3051753,"line_start":1045,"line_end":1045,"column_start":15,"column_end":34},"name":"_mm256_cvttpd_epi32","qualname":"::core_arch::x86::avx::_mm256_cvttpd_epi32","value":"fn (a: __m256d) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed double-precision (64-bit) floating-point elements in `a`\n to packed 32-bit integers with truncation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3051582,"byte_end":3051591,"line_start":1041,"line_end":1041,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3051592,"byte_end":3051625,"line_start":1042,"line_end":1042,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3051670,"byte_end":3051719,"line_start":1044,"line_end":1044,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8539},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3052189,"byte_end":3052207,"line_start":1057,"line_end":1057,"column_start":15,"column_end":33},"name":"_mm256_cvtpd_epi32","qualname":"::core_arch::x86::avx::_mm256_cvtpd_epi32","value":"fn (a: __m256d) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed double-precision (64-bit) floating-point elements in `a`\n to packed 32-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3052038,"byte_end":3052047,"line_start":1053,"line_end":1053,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3052048,"byte_end":3052081,"line_start":1054,"line_end":1054,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3052125,"byte_end":3052174,"line_start":1056,"line_end":1056,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8540},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3052660,"byte_end":3052679,"line_start":1069,"line_end":1069,"column_start":15,"column_end":34},"name":"_mm256_cvttps_epi32","qualname":"::core_arch::x86::avx::_mm256_cvttps_epi32","value":"fn (a: __m256) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed single-precision (32-bit) floating-point elements in `a`\n to packed 32-bit integers with truncation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3052508,"byte_end":3052517,"line_start":1065,"line_end":1065,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3052518,"byte_end":3052551,"line_start":1066,"line_end":1066,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3052596,"byte_end":3052645,"line_start":1068,"line_end":1068,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8541},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3053228,"byte_end":3053249,"line_start":1085,"line_end":1085,"column_start":15,"column_end":36},"name":"_mm256_extractf128_ps","qualname":"::core_arch::x86::avx::_mm256_extractf128_ps","value":"fn (a: __m256, imm8: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Extracts 128 bits (composed of 4 packed single-precision (32-bit)\n floating-point elements) from `a`, selected with `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3052989,"byte_end":3052998,"line_start":1077,"line_end":1077,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3052999,"byte_end":3053032,"line_start":1078,"line_end":1078,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3053132,"byte_end":3053163,"line_start":1083,"line_end":1083,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3053164,"byte_end":3053213,"line_start":1084,"line_end":1084,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8542},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3053942,"byte_end":3053963,"line_start":1104,"line_end":1104,"column_start":15,"column_end":36},"name":"_mm256_extractf128_pd","qualname":"::core_arch::x86::avx::_mm256_extractf128_pd","value":"fn (a: __m256d, imm8: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Extracts 128 bits (composed of 2 packed double-precision (64-bit)\n floating-point elements) from `a`, selected with `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3053703,"byte_end":3053712,"line_start":1096,"line_end":1096,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3053713,"byte_end":3053746,"line_start":1097,"line_end":1097,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3053846,"byte_end":3053877,"line_start":1102,"line_end":1102,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3053878,"byte_end":3053927,"line_start":1103,"line_end":1103,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8543},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3054599,"byte_end":3054623,"line_start":1122,"line_end":1122,"column_start":15,"column_end":39},"name":"_mm256_extractf128_si256","qualname":"::core_arch::x86::avx::_mm256_extractf128_si256","value":"fn (a: __m256i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Extracts 128 bits (composed of integer data) from `a`, selected with `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3054360,"byte_end":3054369,"line_start":1114,"line_end":1114,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3054370,"byte_end":3054403,"line_start":1115,"line_end":1115,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3054503,"byte_end":3054534,"line_start":1120,"line_end":1120,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3054535,"byte_end":3054584,"line_start":1121,"line_end":1121,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8544},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3055200,"byte_end":3055214,"line_start":1138,"line_end":1138,"column_start":15,"column_end":29},"name":"_mm256_zeroall","qualname":"::core_arch::x86::avx::_mm256_zeroall","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Zeroes the contents of all XMM or YMM registers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3055050,"byte_end":3055059,"line_start":1134,"line_end":1134,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3055060,"byte_end":3055093,"line_start":1135,"line_end":1135,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3055136,"byte_end":3055185,"line_start":1137,"line_end":1137,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8545},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3055614,"byte_end":3055630,"line_start":1150,"line_end":1150,"column_start":15,"column_end":31},"name":"_mm256_zeroupper","qualname":"::core_arch::x86::avx::_mm256_zeroupper","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Zeroes the upper 128 bits of all YMM registers;\n the lower 128-bits of the registers are unmodified.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3055462,"byte_end":3055471,"line_start":1146,"line_end":1146,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3055472,"byte_end":3055505,"line_start":1147,"line_end":1147,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3055550,"byte_end":3055599,"line_start":1149,"line_end":1149,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8546},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3056048,"byte_end":3056068,"line_start":1162,"line_end":1162,"column_start":15,"column_end":35},"name":"_mm256_permutevar_ps","qualname":"::core_arch::x86::avx::_mm256_permutevar_ps","value":"fn (a: __m256, b: __m256i) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Shuffles single-precision (32-bit) floating-point elements in `a`\n within 128-bit lanes using the control in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3055897,"byte_end":3055906,"line_start":1158,"line_end":1158,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3055907,"byte_end":3055940,"line_start":1159,"line_end":1159,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3055984,"byte_end":3056033,"line_start":1161,"line_end":1161,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8547},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3056510,"byte_end":3056527,"line_start":1174,"line_end":1174,"column_start":15,"column_end":32},"name":"_mm_permutevar_ps","qualname":"::core_arch::x86::avx::_mm_permutevar_ps","value":"fn (a: __m128, b: __m128i) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Shuffles single-precision (32-bit) floating-point elements in `a`\n using the control in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3056359,"byte_end":3056368,"line_start":1170,"line_end":1170,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3056369,"byte_end":3056402,"line_start":1171,"line_end":1171,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3056446,"byte_end":3056495,"line_start":1173,"line_end":1173,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8548},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3057032,"byte_end":3057049,"line_start":1187,"line_end":1187,"column_start":15,"column_end":32},"name":"_mm256_permute_ps","qualname":"::core_arch::x86::avx::_mm256_permute_ps","value":"fn (a: __m256, imm8: i32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Shuffles single-precision (32-bit) floating-point elements in `a`\n within 128-bit lanes using the control in `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3056839,"byte_end":3056848,"line_start":1182,"line_end":1182,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3056849,"byte_end":3056882,"line_start":1183,"line_end":1183,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3056936,"byte_end":3056967,"line_start":1185,"line_end":1185,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3056968,"byte_end":3057017,"line_start":1186,"line_end":1186,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8553},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3058878,"byte_end":3058892,"line_start":1245,"line_end":1245,"column_start":15,"column_end":29},"name":"_mm_permute_ps","qualname":"::core_arch::x86::avx::_mm_permute_ps","value":"fn (a: __m128, imm8: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Shuffles single-precision (32-bit) floating-point elements in `a`\n using the control in `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3058681,"byte_end":3058690,"line_start":1240,"line_end":1240,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3058691,"byte_end":3058728,"line_start":1241,"line_end":1241,"column_start":1,"column_end":38}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3058782,"byte_end":3058813,"line_start":1243,"line_end":1243,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3058814,"byte_end":3058863,"line_start":1244,"line_end":1244,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8558},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3060601,"byte_end":3060621,"line_start":1298,"line_end":1298,"column_start":15,"column_end":35},"name":"_mm256_permutevar_pd","qualname":"::core_arch::x86::avx::_mm256_permutevar_pd","value":"fn (a: __m256d, b: __m256i) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Shuffles double-precision (64-bit) floating-point elements in `a`\n within 256-bit lanes using the control in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3060450,"byte_end":3060459,"line_start":1294,"line_end":1294,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3060460,"byte_end":3060493,"line_start":1295,"line_end":1295,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3060537,"byte_end":3060586,"line_start":1297,"line_end":1297,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8559},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3061065,"byte_end":3061082,"line_start":1310,"line_end":1310,"column_start":15,"column_end":32},"name":"_mm_permutevar_pd","qualname":"::core_arch::x86::avx::_mm_permutevar_pd","value":"fn (a: __m128d, b: __m128i) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Shuffles double-precision (64-bit) floating-point elements in `a`\n using the control in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3060914,"byte_end":3060923,"line_start":1306,"line_end":1306,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3060924,"byte_end":3060957,"line_start":1307,"line_end":1307,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3061001,"byte_end":3061050,"line_start":1309,"line_end":1309,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8560},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3061591,"byte_end":3061608,"line_start":1323,"line_end":1323,"column_start":15,"column_end":32},"name":"_mm256_permute_pd","qualname":"::core_arch::x86::avx::_mm256_permute_pd","value":"fn (a: __m256d, imm8: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Shuffles double-precision (64-bit) floating-point elements in `a`\n within 128-bit lanes using the control in `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3061396,"byte_end":3061405,"line_start":1318,"line_end":1318,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3061406,"byte_end":3061439,"line_start":1319,"line_end":1319,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3061495,"byte_end":3061526,"line_start":1321,"line_end":1321,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3061527,"byte_end":3061576,"line_start":1322,"line_end":1322,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8565},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3062996,"byte_end":3063010,"line_start":1369,"line_end":1369,"column_start":15,"column_end":29},"name":"_mm_permute_pd","qualname":"::core_arch::x86::avx::_mm_permute_pd","value":"fn (a: __m128d, imm8: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Shuffles double-precision (64-bit) floating-point elements in `a`\n using the control in `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3062796,"byte_end":3062805,"line_start":1364,"line_end":1364,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3062806,"byte_end":3062844,"line_start":1365,"line_end":1365,"column_start":1,"column_end":39}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3062900,"byte_end":3062931,"line_start":1367,"line_end":1367,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3062932,"byte_end":3062981,"line_start":1368,"line_end":1368,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8568},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3063959,"byte_end":3063981,"line_start":1399,"line_end":1399,"column_start":15,"column_end":37},"name":"_mm256_permute2f128_ps","qualname":"::core_arch::x86::avx::_mm256_permute2f128_ps","value":"fn (a: __m256, b: __m256, imm8: i32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 256 bits (composed of 8 packed single-precision (32-bit)\n floating-point elements) selected by `imm8` from `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3063763,"byte_end":3063772,"line_start":1394,"line_end":1394,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3063773,"byte_end":3063806,"line_start":1395,"line_end":1395,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3063863,"byte_end":3063894,"line_start":1397,"line_end":1397,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3063895,"byte_end":3063944,"line_start":1398,"line_end":1398,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8570},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3064625,"byte_end":3064647,"line_start":1417,"line_end":1417,"column_start":15,"column_end":37},"name":"_mm256_permute2f128_pd","qualname":"::core_arch::x86::avx::_mm256_permute2f128_pd","value":"fn (a: __m256d, b: __m256d, imm8: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 256 bits (composed of 4 packed double-precision (64-bit)\n floating-point elements) selected by `imm8` from `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3064428,"byte_end":3064437,"line_start":1412,"line_end":1412,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3064438,"byte_end":3064471,"line_start":1413,"line_end":1413,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3064529,"byte_end":3064560,"line_start":1415,"line_end":1415,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3064561,"byte_end":3064610,"line_start":1416,"line_end":1416,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8572},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3065251,"byte_end":3065276,"line_start":1435,"line_end":1435,"column_start":15,"column_end":40},"name":"_mm256_permute2f128_si256","qualname":"::core_arch::x86::avx::_mm256_permute2f128_si256","value":"fn (a: __m256i, b: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 258-bits (composed of integer data) selected by `imm8`\n from `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3065054,"byte_end":3065063,"line_start":1430,"line_end":1430,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3065064,"byte_end":3065097,"line_start":1431,"line_end":1431,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3065155,"byte_end":3065186,"line_start":1433,"line_end":1433,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3065187,"byte_end":3065236,"line_start":1434,"line_end":1434,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8574},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3065986,"byte_end":3066005,"line_start":1456,"line_end":1456,"column_start":15,"column_end":34},"name":"_mm256_broadcast_ss","qualname":"::core_arch::x86::avx::_mm256_broadcast_ss","value":"fn (f: &f32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts a single-precision (32-bit) floating-point element from memory\n to all elements of the returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3065787,"byte_end":3065796,"line_start":1451,"line_end":1451,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3065797,"byte_end":3065830,"line_start":1452,"line_end":1452,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3065877,"byte_end":3065926,"line_start":1454,"line_end":1454,"column_start":1,"column_end":50}},{"value":"allow(clippy::trivially_copy_pass_by_ref)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3065927,"byte_end":3065971,"line_start":1455,"line_end":1455,"column_start":1,"column_end":45}}]},{"kind":"Function","id":{"krate":0,"index":8575},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3066491,"byte_end":3066507,"line_start":1469,"line_end":1469,"column_start":15,"column_end":31},"name":"_mm_broadcast_ss","qualname":"::core_arch::x86::avx::_mm_broadcast_ss","value":"fn (f: &f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts a single-precision (32-bit) floating-point element from memory\n to all elements of the returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3066292,"byte_end":3066301,"line_start":1464,"line_end":1464,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3066302,"byte_end":3066335,"line_start":1465,"line_end":1465,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3066382,"byte_end":3066431,"line_start":1467,"line_end":1467,"column_start":1,"column_end":50}},{"value":"allow(clippy::trivially_copy_pass_by_ref)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3066432,"byte_end":3066476,"line_start":1468,"line_end":1468,"column_start":1,"column_end":45}}]},{"kind":"Function","id":{"krate":0,"index":8576},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3066993,"byte_end":3067012,"line_start":1482,"line_end":1482,"column_start":15,"column_end":34},"name":"_mm256_broadcast_sd","qualname":"::core_arch::x86::avx::_mm256_broadcast_sd","value":"fn (f: &f64) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts a double-precision (64-bit) floating-point element from memory\n to all elements of the returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3066794,"byte_end":3066803,"line_start":1477,"line_end":1477,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3066804,"byte_end":3066837,"line_start":1478,"line_end":1478,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3066884,"byte_end":3066933,"line_start":1480,"line_end":1480,"column_start":1,"column_end":50}},{"value":"allow(clippy::trivially_copy_pass_by_ref)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3066934,"byte_end":3066978,"line_start":1481,"line_end":1481,"column_start":1,"column_end":45}}]},{"kind":"Function","id":{"krate":0,"index":8577},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3067490,"byte_end":3067509,"line_start":1494,"line_end":1494,"column_start":15,"column_end":34},"name":"_mm256_broadcast_ps","qualname":"::core_arch::x86::avx::_mm256_broadcast_ps","value":"fn (a: &__m128) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 128 bits from memory (composed of 4 packed single-precision\n (32-bit) floating-point elements) to all elements of the returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3067334,"byte_end":3067343,"line_start":1490,"line_end":1490,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3067344,"byte_end":3067377,"line_start":1491,"line_end":1491,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3067426,"byte_end":3067475,"line_start":1493,"line_end":1493,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8578},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3067993,"byte_end":3068012,"line_start":1506,"line_end":1506,"column_start":15,"column_end":34},"name":"_mm256_broadcast_pd","qualname":"::core_arch::x86::avx::_mm256_broadcast_pd","value":"fn (a: &__m128d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 128 bits from memory (composed of 2 packed double-precision\n (64-bit) floating-point elements) to all elements of the returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3067837,"byte_end":3067846,"line_start":1502,"line_end":1502,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3067847,"byte_end":3067880,"line_start":1503,"line_end":1503,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3067929,"byte_end":3067978,"line_start":1505,"line_end":1505,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8579},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3068615,"byte_end":3068635,"line_start":1523,"line_end":1523,"column_start":15,"column_end":35},"name":"_mm256_insertf128_ps","qualname":"::core_arch::x86::avx::_mm256_insertf128_ps","value":"fn (a: __m256, b: __m128, imm8: i32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Copies `a` to result, then inserts 128 bits (composed of 4 packed\n single-precision (32-bit) floating-point elements) from `b` into result\n at the location specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3068377,"byte_end":3068386,"line_start":1515,"line_end":1515,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3068387,"byte_end":3068420,"line_start":1516,"line_end":1516,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3068519,"byte_end":3068550,"line_start":1521,"line_end":1521,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3068551,"byte_end":3068600,"line_start":1522,"line_end":1522,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8580},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3069420,"byte_end":3069440,"line_start":1544,"line_end":1544,"column_start":15,"column_end":35},"name":"_mm256_insertf128_pd","qualname":"::core_arch::x86::avx::_mm256_insertf128_pd","value":"fn (a: __m256d, b: __m128d, imm8: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Copies `a` to result, then inserts 128 bits (composed of 2 packed\n double-precision (64-bit) floating-point elements) from `b` into result\n at the location specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3069182,"byte_end":3069191,"line_start":1536,"line_end":1536,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3069192,"byte_end":3069225,"line_start":1537,"line_end":1537,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3069324,"byte_end":3069355,"line_start":1542,"line_end":1542,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3069356,"byte_end":3069405,"line_start":1543,"line_end":1543,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8581},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3070135,"byte_end":3070158,"line_start":1563,"line_end":1563,"column_start":15,"column_end":38},"name":"_mm256_insertf128_si256","qualname":"::core_arch::x86::avx::_mm256_insertf128_si256","value":"fn (a: __m256i, b: __m128i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Copies `a` to result, then inserts 128 bits from `b` into result\n at the location specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3069897,"byte_end":3069906,"line_start":1555,"line_end":1555,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3069907,"byte_end":3069940,"line_start":1556,"line_end":1556,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3070039,"byte_end":3070070,"line_start":1561,"line_end":1561,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3070071,"byte_end":3070120,"line_start":1562,"line_end":1562,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8582},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3070867,"byte_end":3070885,"line_start":1581,"line_end":1581,"column_start":15,"column_end":33},"name":"_mm256_insert_epi8","qualname":"::core_arch::x86::avx::_mm256_insert_epi8","value":"fn (a: __m256i, i: i8, index: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Copies `a` to result, and inserts the 8-bit integer `i` into result\n at the location specified by `index`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3070675,"byte_end":3070684,"line_start":1576,"line_end":1576,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3070685,"byte_end":3070718,"line_start":1577,"line_end":1577,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3070771,"byte_end":3070802,"line_start":1579,"line_end":1579,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3070803,"byte_end":3070852,"line_start":1580,"line_end":1580,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8583},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3071425,"byte_end":3071444,"line_start":1594,"line_end":1594,"column_start":15,"column_end":34},"name":"_mm256_insert_epi16","qualname":"::core_arch::x86::avx::_mm256_insert_epi16","value":"fn (a: __m256i, i: i16, index: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Copies `a` to result, and inserts the 16-bit integer `i` into result\n at the location specified by `index`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3071233,"byte_end":3071242,"line_start":1589,"line_end":1589,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3071243,"byte_end":3071276,"line_start":1590,"line_end":1590,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3071329,"byte_end":3071360,"line_start":1592,"line_end":1592,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3071361,"byte_end":3071410,"line_start":1593,"line_end":1593,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8584},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3071986,"byte_end":3072005,"line_start":1607,"line_end":1607,"column_start":15,"column_end":34},"name":"_mm256_insert_epi32","qualname":"::core_arch::x86::avx::_mm256_insert_epi32","value":"fn (a: __m256i, i: i32, index: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Copies `a` to result, and inserts the 32-bit integer `i` into result\n at the location specified by `index`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3071794,"byte_end":3071803,"line_start":1602,"line_end":1602,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3071804,"byte_end":3071837,"line_start":1603,"line_end":1603,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3071890,"byte_end":3071921,"line_start":1605,"line_end":1605,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3071922,"byte_end":3071971,"line_start":1606,"line_end":1606,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8585},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3072675,"byte_end":3072689,"line_start":1622,"line_end":1622,"column_start":15,"column_end":29},"name":"_mm256_load_pd","qualname":"::core_arch::x86::avx::_mm256_load_pd","value":"fn (mem_addr: *const f64) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Loads 256-bits (composed of 4 packed double-precision (64-bit)\n floating-point elements) from memory into result.\n `mem_addr` must be aligned on a 32-byte boundary or a\n general-protection exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3072463,"byte_end":3072472,"line_start":1617,"line_end":1617,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3072473,"byte_end":3072506,"line_start":1618,"line_end":1618,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3072574,"byte_end":3072623,"line_start":1620,"line_end":1620,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3072624,"byte_end":3072660,"line_start":1621,"line_end":1621,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":8586},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3073318,"byte_end":3073333,"line_start":1637,"line_end":1637,"column_start":15,"column_end":30},"name":"_mm256_store_pd","qualname":"::core_arch::x86::avx::_mm256_store_pd","value":"fn (mem_addr: *const f64, a: __m256d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 256-bits (composed of 4 packed double-precision (64-bit)\n floating-point elements) from `a` into memory.\n `mem_addr` must be aligned on a 32-byte boundary or a\n general-protection exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3073106,"byte_end":3073115,"line_start":1632,"line_end":1632,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3073116,"byte_end":3073149,"line_start":1633,"line_end":1633,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3073217,"byte_end":3073266,"line_start":1635,"line_end":1635,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3073267,"byte_end":3073303,"line_start":1636,"line_end":1636,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":8587},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3073941,"byte_end":3073955,"line_start":1652,"line_end":1652,"column_start":15,"column_end":29},"name":"_mm256_load_ps","qualname":"::core_arch::x86::avx::_mm256_load_ps","value":"fn (mem_addr: *const f32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Loads 256-bits (composed of 8 packed single-precision (32-bit)\n floating-point elements) from memory into result.\n `mem_addr` must be aligned on a 32-byte boundary or a\n general-protection exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3073755,"byte_end":3073764,"line_start":1647,"line_end":1647,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3073765,"byte_end":3073798,"line_start":1648,"line_end":1648,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3073840,"byte_end":3073889,"line_start":1650,"line_end":1650,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3073890,"byte_end":3073926,"line_start":1651,"line_end":1651,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":8588},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3074556,"byte_end":3074571,"line_start":1667,"line_end":1667,"column_start":15,"column_end":30},"name":"_mm256_store_ps","qualname":"::core_arch::x86::avx::_mm256_store_ps","value":"fn (mem_addr: *const f32, a: __m256) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 256-bits (composed of 8 packed single-precision (32-bit)\n floating-point elements) from `a` into memory.\n `mem_addr` must be aligned on a 32-byte boundary or a\n general-protection exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3074370,"byte_end":3074379,"line_start":1662,"line_end":1662,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3074380,"byte_end":3074413,"line_start":1663,"line_end":1663,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3074455,"byte_end":3074504,"line_start":1665,"line_end":1665,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3074505,"byte_end":3074541,"line_start":1666,"line_end":1666,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":8589},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3075129,"byte_end":3075144,"line_start":1680,"line_end":1680,"column_start":15,"column_end":30},"name":"_mm256_loadu_pd","qualname":"::core_arch::x86::avx::_mm256_loadu_pd","value":"fn (mem_addr: *const f64) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Loads 256-bits (composed of 4 packed double-precision (64-bit)\n floating-point elements) from memory into result.\n `mem_addr` does not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3074954,"byte_end":3074963,"line_start":1676,"line_end":1676,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3074964,"byte_end":3074997,"line_start":1677,"line_end":1677,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3075065,"byte_end":3075114,"line_start":1679,"line_end":1679,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8590},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3075862,"byte_end":3075878,"line_start":1699,"line_end":1699,"column_start":15,"column_end":31},"name":"_mm256_storeu_pd","qualname":"::core_arch::x86::avx::_mm256_storeu_pd","value":"fn (mem_addr: *mut f64, a: __m256d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 256-bits (composed of 4 packed double-precision (64-bit)\n floating-point elements) from `a` into memory.\n `mem_addr` does not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3075687,"byte_end":3075696,"line_start":1695,"line_end":1695,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3075697,"byte_end":3075730,"line_start":1696,"line_end":1696,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3075798,"byte_end":3075847,"line_start":1698,"line_end":1698,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8591},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3076403,"byte_end":3076418,"line_start":1712,"line_end":1712,"column_start":15,"column_end":30},"name":"_mm256_loadu_ps","qualname":"::core_arch::x86::avx::_mm256_loadu_ps","value":"fn (mem_addr: *const f32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Loads 256-bits (composed of 8 packed single-precision (32-bit)\n floating-point elements) from memory into result.\n `mem_addr` does not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3076254,"byte_end":3076263,"line_start":1708,"line_end":1708,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3076264,"byte_end":3076297,"line_start":1709,"line_end":1709,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3076339,"byte_end":3076388,"line_start":1711,"line_end":1711,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8592},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3077107,"byte_end":3077123,"line_start":1731,"line_end":1731,"column_start":15,"column_end":31},"name":"_mm256_storeu_ps","qualname":"::core_arch::x86::avx::_mm256_storeu_ps","value":"fn (mem_addr: *mut f32, a: __m256) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 256-bits (composed of 8 packed single-precision (32-bit)\n floating-point elements) from `a` into memory.\n `mem_addr` does not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3076958,"byte_end":3076967,"line_start":1727,"line_end":1727,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3076968,"byte_end":3077001,"line_start":1728,"line_end":1728,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3077043,"byte_end":3077092,"line_start":1730,"line_end":1730,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8593},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3077652,"byte_end":3077669,"line_start":1744,"line_end":1744,"column_start":15,"column_end":32},"name":"_mm256_load_si256","qualname":"::core_arch::x86::avx::_mm256_load_si256","value":"fn (mem_addr: *const __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Loads 256-bits of integer data from memory into result.\n `mem_addr` must be aligned on a 32-byte boundary or a\n general-protection exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3077477,"byte_end":3077486,"line_start":1740,"line_end":1740,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3077487,"byte_end":3077520,"line_start":1741,"line_end":1741,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3077588,"byte_end":3077637,"line_start":1743,"line_end":1743,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8594},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3078187,"byte_end":3078205,"line_start":1757,"line_end":1757,"column_start":15,"column_end":33},"name":"_mm256_store_si256","qualname":"::core_arch::x86::avx::_mm256_store_si256","value":"fn (mem_addr: *mut __m256i, a: __m256i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 256-bits of integer data from `a` into memory.\n `mem_addr` must be aligned on a 32-byte boundary or a\n general-protection exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3078012,"byte_end":3078021,"line_start":1753,"line_end":1753,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3078022,"byte_end":3078055,"line_start":1754,"line_end":1754,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3078123,"byte_end":3078172,"line_start":1756,"line_end":1756,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8595},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3078691,"byte_end":3078709,"line_start":1769,"line_end":1769,"column_start":15,"column_end":33},"name":"_mm256_loadu_si256","qualname":"::core_arch::x86::avx::_mm256_loadu_si256","value":"fn (mem_addr: *const __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Loads 256-bits of integer data from memory into result.\n `mem_addr` does not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3078516,"byte_end":3078525,"line_start":1765,"line_end":1765,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3078526,"byte_end":3078559,"line_start":1766,"line_end":1766,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3078627,"byte_end":3078676,"line_start":1768,"line_end":1768,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8596},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3079377,"byte_end":3079396,"line_start":1787,"line_end":1787,"column_start":15,"column_end":34},"name":"_mm256_storeu_si256","qualname":"::core_arch::x86::avx::_mm256_storeu_si256","value":"fn (mem_addr: *mut __m256i, a: __m256i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 256-bits of integer data from `a` into memory.\n \t`mem_addr` does not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3079202,"byte_end":3079211,"line_start":1783,"line_end":1783,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3079212,"byte_end":3079245,"line_start":1784,"line_end":1784,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3079313,"byte_end":3079362,"line_start":1786,"line_end":1786,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8597},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3079958,"byte_end":3079976,"line_start":1800,"line_end":1800,"column_start":15,"column_end":33},"name":"_mm256_maskload_pd","qualname":"::core_arch::x86::avx::_mm256_maskload_pd","value":"fn (mem_addr: *const f64, mask: __m256i) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Loads packed double-precision (64-bit) floating-point elements from memory\n into result using `mask` (elements are zeroed out when the high bit of the\n corresponding element is not set).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3079806,"byte_end":3079815,"line_start":1796,"line_end":1796,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3079816,"byte_end":3079849,"line_start":1797,"line_end":1797,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3079894,"byte_end":3079943,"line_start":1799,"line_end":1799,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8598},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3080467,"byte_end":3080486,"line_start":1812,"line_end":1812,"column_start":15,"column_end":34},"name":"_mm256_maskstore_pd","qualname":"::core_arch::x86::avx::_mm256_maskstore_pd","value":"fn (mem_addr: *mut f64, mask: __m256i, a: __m256d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores packed double-precision (64-bit) floating-point elements from `a`\n into memory using `mask`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3080315,"byte_end":3080324,"line_start":1808,"line_end":1808,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3080325,"byte_end":3080358,"line_start":1809,"line_end":1809,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3080403,"byte_end":3080452,"line_start":1811,"line_end":1811,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8599},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3081065,"byte_end":3081080,"line_start":1825,"line_end":1825,"column_start":15,"column_end":30},"name":"_mm_maskload_pd","qualname":"::core_arch::x86::avx::_mm_maskload_pd","value":"fn (mem_addr: *const f64, mask: __m128i) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Loads packed double-precision (64-bit) floating-point elements from memory\n into result using `mask` (elements are zeroed out when the high bit of the\n corresponding element is not set).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3080913,"byte_end":3080922,"line_start":1821,"line_end":1821,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3080923,"byte_end":3080956,"line_start":1822,"line_end":1822,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3081001,"byte_end":3081050,"line_start":1824,"line_end":1824,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8600},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3081565,"byte_end":3081581,"line_start":1837,"line_end":1837,"column_start":15,"column_end":31},"name":"_mm_maskstore_pd","qualname":"::core_arch::x86::avx::_mm_maskstore_pd","value":"fn (mem_addr: *mut f64, mask: __m128i, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores packed double-precision (64-bit) floating-point elements from `a`\n into memory using `mask`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3081413,"byte_end":3081422,"line_start":1833,"line_end":1833,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3081423,"byte_end":3081456,"line_start":1834,"line_end":1834,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3081501,"byte_end":3081550,"line_start":1836,"line_end":1836,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8601},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3082160,"byte_end":3082178,"line_start":1850,"line_end":1850,"column_start":15,"column_end":33},"name":"_mm256_maskload_ps","qualname":"::core_arch::x86::avx::_mm256_maskload_ps","value":"fn (mem_addr: *const f32, mask: __m256i) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Loads packed single-precision (32-bit) floating-point elements from memory\n into result using `mask` (elements are zeroed out when the high bit of the\n corresponding element is not set).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3082008,"byte_end":3082017,"line_start":1846,"line_end":1846,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3082018,"byte_end":3082051,"line_start":1847,"line_end":1847,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3082096,"byte_end":3082145,"line_start":1849,"line_end":1849,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8602},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3082668,"byte_end":3082687,"line_start":1862,"line_end":1862,"column_start":15,"column_end":34},"name":"_mm256_maskstore_ps","qualname":"::core_arch::x86::avx::_mm256_maskstore_ps","value":"fn (mem_addr: *mut f32, mask: __m256i, a: __m256) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores packed single-precision (32-bit) floating-point elements from `a`\n into memory using `mask`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3082516,"byte_end":3082525,"line_start":1858,"line_end":1858,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3082526,"byte_end":3082559,"line_start":1859,"line_end":1859,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3082604,"byte_end":3082653,"line_start":1861,"line_end":1861,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8603},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3083265,"byte_end":3083280,"line_start":1875,"line_end":1875,"column_start":15,"column_end":30},"name":"_mm_maskload_ps","qualname":"::core_arch::x86::avx::_mm_maskload_ps","value":"fn (mem_addr: *const f32, mask: __m128i) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Loads packed single-precision (32-bit) floating-point elements from memory\n into result using `mask` (elements are zeroed out when the high bit of the\n corresponding element is not set).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3083113,"byte_end":3083122,"line_start":1871,"line_end":1871,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3083123,"byte_end":3083156,"line_start":1872,"line_end":1872,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3083201,"byte_end":3083250,"line_start":1874,"line_end":1874,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8604},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3083764,"byte_end":3083780,"line_start":1887,"line_end":1887,"column_start":15,"column_end":31},"name":"_mm_maskstore_ps","qualname":"::core_arch::x86::avx::_mm_maskstore_ps","value":"fn (mem_addr: *mut f32, mask: __m128i, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores packed single-precision (32-bit) floating-point elements from `a`\n into memory using `mask`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3083612,"byte_end":3083621,"line_start":1883,"line_end":1883,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3083622,"byte_end":3083655,"line_start":1884,"line_end":1884,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3083700,"byte_end":3083749,"line_start":1886,"line_end":1886,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8605},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3084275,"byte_end":3084293,"line_start":1899,"line_end":1899,"column_start":15,"column_end":33},"name":"_mm256_movehdup_ps","qualname":"::core_arch::x86::avx::_mm256_movehdup_ps","value":"fn (a: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Duplicate odd-indexed single-precision (32-bit) floating-point elements\n from `a`, and returns the results.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3084124,"byte_end":3084133,"line_start":1895,"line_end":1895,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3084134,"byte_end":3084167,"line_start":1896,"line_end":1896,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3084211,"byte_end":3084260,"line_start":1898,"line_end":1898,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8606},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3084756,"byte_end":3084774,"line_start":1911,"line_end":1911,"column_start":15,"column_end":33},"name":"_mm256_moveldup_ps","qualname":"::core_arch::x86::avx::_mm256_moveldup_ps","value":"fn (a: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Duplicate even-indexed single-precision (32-bit) floating-point elements\n from `a`, and returns the results.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3084605,"byte_end":3084614,"line_start":1907,"line_end":1907,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3084615,"byte_end":3084648,"line_start":1908,"line_end":1908,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3084692,"byte_end":3084741,"line_start":1910,"line_end":1910,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8607},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3085235,"byte_end":3085252,"line_start":1923,"line_end":1923,"column_start":15,"column_end":32},"name":"_mm256_movedup_pd","qualname":"::core_arch::x86::avx::_mm256_movedup_pd","value":"fn (a: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Duplicate even-indexed double-precision (64-bit) floating-point elements\n from \"a\", and returns the results.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3085085,"byte_end":3085094,"line_start":1919,"line_end":1919,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3085095,"byte_end":3085128,"line_start":1920,"line_end":1920,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3085171,"byte_end":3085220,"line_start":1922,"line_end":1922,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8608},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3085769,"byte_end":3085787,"line_start":1936,"line_end":1936,"column_start":15,"column_end":33},"name":"_mm256_lddqu_si256","qualname":"::core_arch::x86::avx::_mm256_lddqu_si256","value":"fn (mem_addr: *const __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Loads 256-bits of integer data from unaligned memory into result.\n This intrinsic may perform better than `_mm256_loadu_si256` when the\n data crosses a cache line boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3085621,"byte_end":3085630,"line_start":1932,"line_end":1932,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3085631,"byte_end":3085664,"line_start":1933,"line_end":1933,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3085705,"byte_end":3085754,"line_start":1935,"line_end":1935,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8609},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3086352,"byte_end":3086371,"line_start":1949,"line_end":1949,"column_start":15,"column_end":34},"name":"_mm256_stream_si256","qualname":"::core_arch::x86::avx::_mm256_stream_si256","value":"fn (mem_addr: *mut __m256i, a: __m256i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Moves integer data from a 256-bit integer vector to a 32-byte\n aligned memory location. To minimize caching, the data is flagged as\n non-temporal (unlikely to be used again soon)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3086184,"byte_end":3086193,"line_start":1945,"line_end":1945,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3086194,"byte_end":3086227,"line_start":1946,"line_end":1946,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3086288,"byte_end":3086337,"line_start":1948,"line_end":1948,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8610},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3086994,"byte_end":3087010,"line_start":1963,"line_end":1963,"column_start":15,"column_end":31},"name":"_mm256_stream_pd","qualname":"::core_arch::x86::avx::_mm256_stream_pd","value":"fn (mem_addr: *mut f64, a: __m256d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Moves double-precision values from a 256-bit vector of `[4 x double]`\n to a 32-byte aligned memory location. To minimize caching, the data is\n flagged as non-temporal (unlikely to be used again soon).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3086789,"byte_end":3086798,"line_start":1958,"line_end":1958,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3086799,"byte_end":3086832,"line_start":1959,"line_end":1959,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3086893,"byte_end":3086942,"line_start":1961,"line_end":1961,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3086943,"byte_end":3086979,"line_start":1962,"line_end":1962,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":8611},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3087645,"byte_end":3087661,"line_start":1978,"line_end":1978,"column_start":15,"column_end":31},"name":"_mm256_stream_ps","qualname":"::core_arch::x86::avx::_mm256_stream_ps","value":"fn (mem_addr: *mut f32, a: __m256) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Moves single-precision floating point values from a 256-bit vector\n of `[8 x float]` to a 32-byte aligned memory location. To minimize\n caching, the data is flagged as non-temporal (unlikely to be used again\n soon).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3087458,"byte_end":3087467,"line_start":1973,"line_end":1973,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3087468,"byte_end":3087501,"line_start":1974,"line_end":1974,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3087544,"byte_end":3087593,"line_start":1976,"line_end":1976,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3087594,"byte_end":3087630,"line_start":1977,"line_end":1977,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":8612},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3088238,"byte_end":3088251,"line_start":1991,"line_end":1991,"column_start":15,"column_end":28},"name":"_mm256_rcp_ps","qualname":"::core_arch::x86::avx::_mm256_rcp_ps","value":"fn (a: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Computes the approximate reciprocal of packed single-precision (32-bit)\n floating-point elements in `a`, and returns the results. The maximum\n relative error for this approximation is less than 1.5*2^-12.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3088090,"byte_end":3088099,"line_start":1987,"line_end":1987,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3088100,"byte_end":3088133,"line_start":1988,"line_end":1988,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3088174,"byte_end":3088223,"line_start":1990,"line_end":1990,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8613},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3088785,"byte_end":3088800,"line_start":2004,"line_end":2004,"column_start":15,"column_end":30},"name":"_mm256_rsqrt_ps","qualname":"::core_arch::x86::avx::_mm256_rsqrt_ps","value":"fn (a: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Computes the approximate reciprocal square root of packed single-precision\n (32-bit) floating-point elements in `a`, and returns the results.\n The maximum relative error for this approximation is less than 1.5*2^-12.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3088635,"byte_end":3088644,"line_start":2000,"line_end":2000,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3088645,"byte_end":3088678,"line_start":2001,"line_end":2001,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3088721,"byte_end":3088770,"line_start":2003,"line_end":2003,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8614},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3089250,"byte_end":3089268,"line_start":2016,"line_end":2016,"column_start":15,"column_end":33},"name":"_mm256_unpackhi_pd","qualname":"::core_arch::x86::avx::_mm256_unpackhi_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave double-precision (64-bit) floating-point elements\n from the high half of each 128-bit lane in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3089099,"byte_end":3089108,"line_start":2012,"line_end":2012,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3089109,"byte_end":3089142,"line_start":2013,"line_end":2013,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3089186,"byte_end":3089235,"line_start":2015,"line_end":2015,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8615},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3089754,"byte_end":3089772,"line_start":2028,"line_end":2028,"column_start":15,"column_end":33},"name":"_mm256_unpackhi_ps","qualname":"::core_arch::x86::avx::_mm256_unpackhi_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave single-precision (32-bit) floating-point elements\n from the high half of each 128-bit lane in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3089603,"byte_end":3089612,"line_start":2024,"line_end":2024,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3089613,"byte_end":3089646,"line_start":2025,"line_end":2025,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3089690,"byte_end":3089739,"line_start":2027,"line_end":2027,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8616},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3090270,"byte_end":3090288,"line_start":2040,"line_end":2040,"column_start":15,"column_end":33},"name":"_mm256_unpacklo_pd","qualname":"::core_arch::x86::avx::_mm256_unpacklo_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave double-precision (64-bit) floating-point elements\n from the low half of each 128-bit lane in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3090119,"byte_end":3090128,"line_start":2036,"line_end":2036,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3090129,"byte_end":3090162,"line_start":2037,"line_end":2037,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3090206,"byte_end":3090255,"line_start":2039,"line_end":2039,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8617},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3090773,"byte_end":3090791,"line_start":2052,"line_end":2052,"column_start":15,"column_end":33},"name":"_mm256_unpacklo_ps","qualname":"::core_arch::x86::avx::_mm256_unpacklo_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave single-precision (32-bit) floating-point elements\n from the low half of each 128-bit lane in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3090622,"byte_end":3090631,"line_start":2048,"line_end":2048,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3090632,"byte_end":3090665,"line_start":2049,"line_end":2049,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3090709,"byte_end":3090758,"line_start":2051,"line_end":2051,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8618},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3091455,"byte_end":3091473,"line_start":2066,"line_end":2066,"column_start":15,"column_end":33},"name":"_mm256_testz_si256","qualname":"::core_arch::x86::avx::_mm256_testz_si256","value":"fn (a: __m256i, b: __m256i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 256 bits (representing integer data) in `a` and\n `b`, and set `ZF` to 1 if the result is zero, otherwise set `ZF` to 0.\n Computes the bitwise NOT of `a` and then AND with `b`, and set `CF` to 1 if\n the result is zero, otherwise set `CF` to 0. Return the `ZF` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3091307,"byte_end":3091316,"line_start":2062,"line_end":2062,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3091317,"byte_end":3091350,"line_start":2063,"line_end":2063,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3091391,"byte_end":3091440,"line_start":2065,"line_end":2065,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8619},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3092126,"byte_end":3092144,"line_start":2080,"line_end":2080,"column_start":15,"column_end":33},"name":"_mm256_testc_si256","qualname":"::core_arch::x86::avx::_mm256_testc_si256","value":"fn (a: __m256i, b: __m256i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 256 bits (representing integer data) in `a` and\n `b`, and set `ZF` to 1 if the result is zero, otherwise set `ZF` to 0.\n Computes the bitwise NOT of `a` and then AND with `b`, and set `CF` to 1 if\n the result is zero, otherwise set `CF` to 0. Return the `CF` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3091978,"byte_end":3091987,"line_start":2076,"line_end":2076,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3091988,"byte_end":3092021,"line_start":2077,"line_end":2077,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3092062,"byte_end":3092111,"line_start":2079,"line_end":2079,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8620},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3092852,"byte_end":3092872,"line_start":2095,"line_end":2095,"column_start":15,"column_end":35},"name":"_mm256_testnzc_si256","qualname":"::core_arch::x86::avx::_mm256_testnzc_si256","value":"fn (a: __m256i, b: __m256i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 256 bits (representing integer data) in `a` and\n `b`, and set `ZF` to 1 if the result is zero, otherwise set `ZF` to 0.\n Computes the bitwise NOT of `a` and then AND with `b`, and set `CF` to 1 if\n the result is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and\n `CF` values are zero, otherwise return 0.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3092704,"byte_end":3092713,"line_start":2091,"line_end":2091,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3092714,"byte_end":3092747,"line_start":2092,"line_end":2092,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3092788,"byte_end":3092837,"line_start":2094,"line_end":2094,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8621},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3093749,"byte_end":3093764,"line_start":2112,"line_end":2112,"column_start":15,"column_end":30},"name":"_mm256_testz_pd","qualname":"::core_arch::x86::avx::_mm256_testz_pd","value":"fn (a: __m256d, b: __m256d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 256 bits (representing double-precision (64-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 256-bit\n value, and set `ZF` to 1 if the sign bit of each 64-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 64-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return the `ZF` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3093600,"byte_end":3093609,"line_start":2108,"line_end":2108,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3093610,"byte_end":3093643,"line_start":2109,"line_end":2109,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3093685,"byte_end":3093734,"line_start":2111,"line_end":2111,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8622},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3094619,"byte_end":3094634,"line_start":2129,"line_end":2129,"column_start":15,"column_end":30},"name":"_mm256_testc_pd","qualname":"::core_arch::x86::avx::_mm256_testc_pd","value":"fn (a: __m256d, b: __m256d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 256 bits (representing double-precision (64-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 256-bit\n value, and set `ZF` to 1 if the sign bit of each 64-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 64-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return the `CF` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3094470,"byte_end":3094479,"line_start":2125,"line_end":2125,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3094480,"byte_end":3094513,"line_start":2126,"line_end":2126,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3094555,"byte_end":3094604,"line_start":2128,"line_end":2128,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8623},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3095544,"byte_end":3095561,"line_start":2147,"line_end":2147,"column_start":15,"column_end":32},"name":"_mm256_testnzc_pd","qualname":"::core_arch::x86::avx::_mm256_testnzc_pd","value":"fn (a: __m256d, b: __m256d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 256 bits (representing double-precision (64-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 256-bit\n value, and set `ZF` to 1 if the sign bit of each 64-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 64-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values\n are zero, otherwise return 0.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3095395,"byte_end":3095404,"line_start":2143,"line_end":2143,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3095405,"byte_end":3095438,"line_start":2144,"line_end":2144,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3095480,"byte_end":3095529,"line_start":2146,"line_end":2146,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8624},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3096415,"byte_end":3096427,"line_start":2164,"line_end":2164,"column_start":15,"column_end":27},"name":"_mm_testz_pd","qualname":"::core_arch::x86::avx::_mm_testz_pd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 128 bits (representing double-precision (64-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 128-bit\n value, and set `ZF` to 1 if the sign bit of each 64-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 64-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return the `ZF` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3096266,"byte_end":3096275,"line_start":2160,"line_end":2160,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3096276,"byte_end":3096309,"line_start":2161,"line_end":2161,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3096351,"byte_end":3096400,"line_start":2163,"line_end":2163,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8625},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3097276,"byte_end":3097288,"line_start":2181,"line_end":2181,"column_start":15,"column_end":27},"name":"_mm_testc_pd","qualname":"::core_arch::x86::avx::_mm_testc_pd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 128 bits (representing double-precision (64-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 128-bit\n value, and set `ZF` to 1 if the sign bit of each 64-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 64-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return the `CF` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3097127,"byte_end":3097136,"line_start":2177,"line_end":2177,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3097137,"byte_end":3097170,"line_start":2178,"line_end":2178,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3097212,"byte_end":3097261,"line_start":2180,"line_end":2180,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8626},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3098192,"byte_end":3098206,"line_start":2199,"line_end":2199,"column_start":15,"column_end":29},"name":"_mm_testnzc_pd","qualname":"::core_arch::x86::avx::_mm_testnzc_pd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 128 bits (representing double-precision (64-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 128-bit\n value, and set `ZF` to 1 if the sign bit of each 64-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 64-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values\n are zero, otherwise return 0.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3098043,"byte_end":3098052,"line_start":2195,"line_end":2195,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3098053,"byte_end":3098086,"line_start":2196,"line_end":2196,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3098128,"byte_end":3098177,"line_start":2198,"line_end":2198,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8627},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3099060,"byte_end":3099075,"line_start":2216,"line_end":2216,"column_start":15,"column_end":30},"name":"_mm256_testz_ps","qualname":"::core_arch::x86::avx::_mm256_testz_ps","value":"fn (a: __m256, b: __m256) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 256 bits (representing single-precision (32-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 256-bit\n value, and set `ZF` to 1 if the sign bit of each 32-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 32-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return the `ZF` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3098911,"byte_end":3098920,"line_start":2212,"line_end":2212,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3098921,"byte_end":3098954,"line_start":2213,"line_end":2213,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3098996,"byte_end":3099045,"line_start":2215,"line_end":2215,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8628},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3099928,"byte_end":3099943,"line_start":2233,"line_end":2233,"column_start":15,"column_end":30},"name":"_mm256_testc_ps","qualname":"::core_arch::x86::avx::_mm256_testc_ps","value":"fn (a: __m256, b: __m256) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 256 bits (representing single-precision (32-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 256-bit\n value, and set `ZF` to 1 if the sign bit of each 32-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 32-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return the `CF` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3099779,"byte_end":3099788,"line_start":2229,"line_end":2229,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3099789,"byte_end":3099822,"line_start":2230,"line_end":2230,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3099864,"byte_end":3099913,"line_start":2232,"line_end":2232,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8629},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3100851,"byte_end":3100868,"line_start":2251,"line_end":2251,"column_start":15,"column_end":32},"name":"_mm256_testnzc_ps","qualname":"::core_arch::x86::avx::_mm256_testnzc_ps","value":"fn (a: __m256, b: __m256) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 256 bits (representing single-precision (32-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 256-bit\n value, and set `ZF` to 1 if the sign bit of each 32-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 32-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values\n are zero, otherwise return 0.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3100702,"byte_end":3100711,"line_start":2247,"line_end":2247,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3100712,"byte_end":3100745,"line_start":2248,"line_end":2248,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3100787,"byte_end":3100836,"line_start":2250,"line_end":2250,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8630},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3101720,"byte_end":3101732,"line_start":2268,"line_end":2268,"column_start":15,"column_end":27},"name":"_mm_testz_ps","qualname":"::core_arch::x86::avx::_mm_testz_ps","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 128 bits (representing single-precision (32-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 128-bit\n value, and set `ZF` to 1 if the sign bit of each 32-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 32-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return the `ZF` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3101571,"byte_end":3101580,"line_start":2264,"line_end":2264,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3101581,"byte_end":3101614,"line_start":2265,"line_end":2265,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3101656,"byte_end":3101705,"line_start":2267,"line_end":2267,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8631},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3102579,"byte_end":3102591,"line_start":2285,"line_end":2285,"column_start":15,"column_end":27},"name":"_mm_testc_ps","qualname":"::core_arch::x86::avx::_mm_testc_ps","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 128 bits (representing single-precision (32-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 128-bit\n value, and set `ZF` to 1 if the sign bit of each 32-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 32-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return the `CF` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3102430,"byte_end":3102439,"line_start":2281,"line_end":2281,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3102440,"byte_end":3102473,"line_start":2282,"line_end":2282,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3102515,"byte_end":3102564,"line_start":2284,"line_end":2284,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8632},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3103493,"byte_end":3103507,"line_start":2303,"line_end":2303,"column_start":15,"column_end":29},"name":"_mm_testnzc_ps","qualname":"::core_arch::x86::avx::_mm_testnzc_ps","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 128 bits (representing single-precision (32-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 128-bit\n value, and set `ZF` to 1 if the sign bit of each 32-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 32-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values\n are zero, otherwise return 0.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3103344,"byte_end":3103353,"line_start":2299,"line_end":2299,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3103354,"byte_end":3103387,"line_start":2300,"line_end":2300,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3103429,"byte_end":3103478,"line_start":2302,"line_end":2302,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8633},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3103999,"byte_end":3104017,"line_start":2316,"line_end":2316,"column_start":15,"column_end":33},"name":"_mm256_movemask_pd","qualname":"::core_arch::x86::avx::_mm256_movemask_pd","value":"fn (a: __m256d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Sets each bit of the returned mask based on the most significant bit of the\n corresponding packed double-precision (64-bit) floating-point element in\n `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3103848,"byte_end":3103857,"line_start":2312,"line_end":2312,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3103858,"byte_end":3103891,"line_start":2313,"line_end":2313,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3103935,"byte_end":3103984,"line_start":2315,"line_end":2315,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8634},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3104497,"byte_end":3104515,"line_start":2329,"line_end":2329,"column_start":15,"column_end":33},"name":"_mm256_movemask_ps","qualname":"::core_arch::x86::avx::_mm256_movemask_ps","value":"fn (a: __m256) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Sets each bit of the returned mask based on the most significant bit of the\n corresponding packed single-precision (32-bit) floating-point element in\n `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3104346,"byte_end":3104355,"line_start":2325,"line_end":2325,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3104356,"byte_end":3104389,"line_start":2326,"line_end":2326,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3104433,"byte_end":3104482,"line_start":2328,"line_end":2328,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8635},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3104915,"byte_end":3104932,"line_start":2340,"line_end":2340,"column_start":15,"column_end":32},"name":"_mm256_setzero_pd","qualname":"::core_arch::x86::avx::_mm256_setzero_pd","value":"fn () -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Returns vector of type __m256d with all elements set to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3104742,"byte_end":3104751,"line_start":2336,"line_end":2336,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3104752,"byte_end":3104785,"line_start":2337,"line_end":2337,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3104851,"byte_end":3104900,"line_start":2339,"line_end":2339,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8636},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3105306,"byte_end":3105323,"line_start":2351,"line_end":2351,"column_start":15,"column_end":32},"name":"_mm256_setzero_ps","qualname":"::core_arch::x86::avx::_mm256_setzero_ps","value":"fn () -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Returns vector of type __m256 with all elements set to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3105158,"byte_end":3105167,"line_start":2347,"line_end":2347,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3105168,"byte_end":3105201,"line_start":2348,"line_end":2348,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3105242,"byte_end":3105291,"line_start":2350,"line_end":2350,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8637},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3105698,"byte_end":3105718,"line_start":2362,"line_end":2362,"column_start":15,"column_end":35},"name":"_mm256_setzero_si256","qualname":"::core_arch::x86::avx::_mm256_setzero_si256","value":"fn () -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Returns vector of type __m256i with all elements set to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3105552,"byte_end":3105561,"line_start":2358,"line_end":2358,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3105562,"byte_end":3105595,"line_start":2359,"line_end":2359,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3105634,"byte_end":3105683,"line_start":2361,"line_end":2361,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8638},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3106195,"byte_end":3106208,"line_start":2375,"line_end":2375,"column_start":15,"column_end":28},"name":"_mm256_set_pd","qualname":"::core_arch::x86::avx::_mm256_set_pd","value":"fn (a: f64, b: f64, c: f64, d: f64) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Sets packed double-precision (64-bit) floating-point elements in returned\n vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3105990,"byte_end":3105999,"line_start":2370,"line_end":2370,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3106000,"byte_end":3106033,"line_start":2371,"line_end":2371,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3106131,"byte_end":3106180,"line_start":2374,"line_end":2374,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8639},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3106677,"byte_end":3106690,"line_start":2387,"line_end":2387,"column_start":15,"column_end":28},"name":"_mm256_set_ps","qualname":"::core_arch::x86::avx::_mm256_set_ps","value":"fn (a: f32, b: f32, c: f32, d: f32, e: f32, f: f32, g: f32, h: f32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Sets packed single-precision (32-bit) floating-point elements in returned\n vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3106517,"byte_end":3106526,"line_start":2383,"line_end":2383,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3106527,"byte_end":3106560,"line_start":2384,"line_end":2384,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3106613,"byte_end":3106662,"line_start":2386,"line_end":2386,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8640},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3107221,"byte_end":3107236,"line_start":2408,"line_end":2408,"column_start":15,"column_end":30},"name":"_mm256_set_epi8","qualname":"::core_arch::x86::avx::_mm256_set_epi8","value":"fn (e00: i8, e01: i8, e02: i8, e03: i8, e04: i8, e05: i8, e06: i8, e07: i8, e08: i8, e09: i8, e10: i8, e11: i8, e12: i8, e13: i8, e14: i8, e15: i8, e16: i8, e17: i8, e18: i8, e19: i8, e20: i8, e21: i8, e22: i8, e23: i8, e24: i8, e25: i8, e26: i8, e27: i8, e28: i8, e29: i8, e30: i8, e31: i8) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 8-bit integers in returned vector with the supplied values in\n reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3107061,"byte_end":3107070,"line_start":2404,"line_end":2404,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3107071,"byte_end":3107104,"line_start":2405,"line_end":2405,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3107157,"byte_end":3107206,"line_start":2407,"line_end":2407,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8641},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3108267,"byte_end":3108283,"line_start":2458,"line_end":2458,"column_start":15,"column_end":31},"name":"_mm256_set_epi16","qualname":"::core_arch::x86::avx::_mm256_set_epi16","value":"fn (e00: i16, e01: i16, e02: i16, e03: i16, e04: i16, e05: i16, e06: i16, e07: i16, e08: i16, e09: i16, e10: i16, e11: i16, e12: i16, e13: i16, e14: i16, e15: i16) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 16-bit integers in returned vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3108107,"byte_end":3108116,"line_start":2454,"line_end":2454,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3108117,"byte_end":3108150,"line_start":2455,"line_end":2455,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3108203,"byte_end":3108252,"line_start":2457,"line_end":2457,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8642},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3109043,"byte_end":3109059,"line_start":2492,"line_end":2492,"column_start":15,"column_end":31},"name":"_mm256_set_epi32","qualname":"::core_arch::x86::avx::_mm256_set_epi32","value":"fn (e0: i32, e1: i32, e2: i32, e3: i32, e4: i32, e5: i32, e6: i32, e7: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 32-bit integers in returned vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3108883,"byte_end":3108892,"line_start":2488,"line_end":2488,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3108893,"byte_end":3108926,"line_start":2489,"line_end":2489,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3108979,"byte_end":3109028,"line_start":2491,"line_end":2491,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8643},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3109592,"byte_end":3109609,"line_start":2512,"line_end":2512,"column_start":15,"column_end":32},"name":"_mm256_set_epi64x","qualname":"::core_arch::x86::avx::_mm256_set_epi64x","value":"fn (a: i64, b: i64, c: i64, d: i64) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 64-bit integers in returned vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3109432,"byte_end":3109441,"line_start":2508,"line_end":2508,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3109442,"byte_end":3109475,"line_start":2509,"line_end":2509,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3109528,"byte_end":3109577,"line_start":2511,"line_end":2511,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8644},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3110100,"byte_end":3110114,"line_start":2524,"line_end":2524,"column_start":15,"column_end":29},"name":"_mm256_setr_pd","qualname":"::core_arch::x86::avx::_mm256_setr_pd","value":"fn (a: f64, b: f64, c: f64, d: f64) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Sets packed double-precision (64-bit) floating-point elements in returned\n vector with the supplied values in reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3109940,"byte_end":3109949,"line_start":2520,"line_end":2520,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3109950,"byte_end":3109983,"line_start":2521,"line_end":2521,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3110036,"byte_end":3110085,"line_start":2523,"line_end":2523,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8645},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3110594,"byte_end":3110608,"line_start":2536,"line_end":2536,"column_start":15,"column_end":29},"name":"_mm256_setr_ps","qualname":"::core_arch::x86::avx::_mm256_setr_ps","value":"fn (a: f32, b: f32, c: f32, d: f32, e: f32, f: f32, g: f32, h: f32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Sets packed single-precision (32-bit) floating-point elements in returned\n vector with the supplied values in reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3110434,"byte_end":3110443,"line_start":2532,"line_end":2532,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3110444,"byte_end":3110477,"line_start":2533,"line_end":2533,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3110530,"byte_end":3110579,"line_start":2535,"line_end":2535,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8646},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3111132,"byte_end":3111148,"line_start":2557,"line_end":2557,"column_start":15,"column_end":31},"name":"_mm256_setr_epi8","qualname":"::core_arch::x86::avx::_mm256_setr_epi8","value":"fn (e00: i8, e01: i8, e02: i8, e03: i8, e04: i8, e05: i8, e06: i8, e07: i8, e08: i8, e09: i8, e10: i8, e11: i8, e12: i8, e13: i8, e14: i8, e15: i8, e16: i8, e17: i8, e18: i8, e19: i8, e20: i8, e21: i8, e22: i8, e23: i8, e24: i8, e25: i8, e26: i8, e27: i8, e28: i8, e29: i8, e30: i8, e31: i8) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 8-bit integers in returned vector with the supplied values in\n reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3110972,"byte_end":3110981,"line_start":2553,"line_end":2553,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3110982,"byte_end":3111015,"line_start":2554,"line_end":2554,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3111068,"byte_end":3111117,"line_start":2556,"line_end":2556,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8647},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3112206,"byte_end":3112223,"line_start":2608,"line_end":2608,"column_start":15,"column_end":32},"name":"_mm256_setr_epi16","qualname":"::core_arch::x86::avx::_mm256_setr_epi16","value":"fn (e00: i16, e01: i16, e02: i16, e03: i16, e04: i16, e05: i16, e06: i16, e07: i16, e08: i16, e09: i16, e10: i16, e11: i16, e12: i16, e13: i16, e14: i16, e15: i16) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 16-bit integers in returned vector with the supplied values in\n reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3112046,"byte_end":3112055,"line_start":2604,"line_end":2604,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3112056,"byte_end":3112089,"line_start":2605,"line_end":2605,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3112142,"byte_end":3112191,"line_start":2607,"line_end":2607,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8648},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3113010,"byte_end":3113027,"line_start":2643,"line_end":2643,"column_start":15,"column_end":32},"name":"_mm256_setr_epi32","qualname":"::core_arch::x86::avx::_mm256_setr_epi32","value":"fn (e0: i32, e1: i32, e2: i32, e3: i32, e4: i32, e5: i32, e6: i32, e7: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 32-bit integers in returned vector with the supplied values in\n reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3112850,"byte_end":3112859,"line_start":2639,"line_end":2639,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3112860,"byte_end":3112893,"line_start":2640,"line_end":2640,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3112946,"byte_end":3112995,"line_start":2642,"line_end":2642,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8649},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3113586,"byte_end":3113604,"line_start":2664,"line_end":2664,"column_start":15,"column_end":33},"name":"_mm256_setr_epi64x","qualname":"::core_arch::x86::avx::_mm256_setr_epi64x","value":"fn (a: i64, b: i64, c: i64, d: i64) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 64-bit integers in returned vector with the supplied values in\n reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3113426,"byte_end":3113435,"line_start":2660,"line_end":2660,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3113436,"byte_end":3113469,"line_start":2661,"line_end":2661,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3113522,"byte_end":3113571,"line_start":2663,"line_end":2663,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8650},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3114072,"byte_end":3114086,"line_start":2676,"line_end":2676,"column_start":15,"column_end":29},"name":"_mm256_set1_pd","qualname":"::core_arch::x86::avx::_mm256_set1_pd","value":"fn (a: f64) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts double-precision (64-bit) floating-point value `a` to all\n elements of returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3113912,"byte_end":3113921,"line_start":2672,"line_end":2672,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3113922,"byte_end":3113955,"line_start":2673,"line_end":2673,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3114008,"byte_end":3114057,"line_start":2675,"line_end":2675,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8651},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3114523,"byte_end":3114537,"line_start":2688,"line_end":2688,"column_start":15,"column_end":29},"name":"_mm256_set1_ps","qualname":"::core_arch::x86::avx::_mm256_set1_ps","value":"fn (a: f32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts single-precision (32-bit) floating-point value `a` to all\n elements of returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3114363,"byte_end":3114372,"line_start":2684,"line_end":2684,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3114373,"byte_end":3114406,"line_start":2685,"line_end":2685,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3114459,"byte_end":3114508,"line_start":2687,"line_end":2687,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8652},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3115088,"byte_end":3115104,"line_start":2702,"line_end":2702,"column_start":15,"column_end":31},"name":"_mm256_set1_epi8","qualname":"::core_arch::x86::avx::_mm256_set1_epi8","value":"fn (a: i8) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 8-bit integer `a` to all elements of returned vector.\n This intrinsic may generate the `vpbroadcastb`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3114842,"byte_end":3114851,"line_start":2696,"line_end":2696,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3114852,"byte_end":3114885,"line_start":2697,"line_end":2697,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3115024,"byte_end":3115073,"line_start":2701,"line_end":2701,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8653},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3115797,"byte_end":3115814,"line_start":2722,"line_end":2722,"column_start":15,"column_end":32},"name":"_mm256_set1_epi16","qualname":"::core_arch::x86::avx::_mm256_set1_epi16","value":"fn (a: i16) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 16-bit integer `a` to all all elements of returned vector.\n This intrinsic may generate the `vpbroadcastw`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3115549,"byte_end":3115558,"line_start":2716,"line_end":2716,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3115559,"byte_end":3115592,"line_start":2717,"line_end":2717,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3115733,"byte_end":3115782,"line_start":2721,"line_end":2721,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8654},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3116309,"byte_end":3116326,"line_start":2734,"line_end":2734,"column_start":15,"column_end":32},"name":"_mm256_set1_epi32","qualname":"::core_arch::x86::avx::_mm256_set1_epi32","value":"fn (a: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 32-bit integer `a` to all elements of returned vector.\n This intrinsic may generate the `vpbroadcastd`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3116149,"byte_end":3116158,"line_start":2730,"line_end":2730,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3116159,"byte_end":3116192,"line_start":2731,"line_end":2731,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3116245,"byte_end":3116294,"line_start":2733,"line_end":2733,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8655},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3116887,"byte_end":3116905,"line_start":2748,"line_end":2748,"column_start":15,"column_end":33},"name":"_mm256_set1_epi64x","qualname":"::core_arch::x86::avx::_mm256_set1_epi64x","value":"fn (a: i64) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 64-bit integer `a` to all elements of returned vector.\n This intrinsic may generate the `vpbroadcastq`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3116638,"byte_end":3116647,"line_start":2742,"line_end":2742,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3116648,"byte_end":3116681,"line_start":2743,"line_end":2743,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3116823,"byte_end":3116872,"line_start":2747,"line_end":2747,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8656},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3117354,"byte_end":3117370,"line_start":2760,"line_end":2760,"column_start":15,"column_end":31},"name":"_mm256_castpd_ps","qualname":"::core_arch::x86::avx::_mm256_castpd_ps","value":"fn (a: __m256d) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Cast vector of type __m256d to type __m256.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3117130,"byte_end":3117139,"line_start":2755,"line_end":2755,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3117140,"byte_end":3117173,"line_start":2756,"line_end":2756,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3117290,"byte_end":3117339,"line_start":2759,"line_end":2759,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8657},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3117804,"byte_end":3117820,"line_start":2772,"line_end":2772,"column_start":15,"column_end":31},"name":"_mm256_castps_pd","qualname":"::core_arch::x86::avx::_mm256_castps_pd","value":"fn (a: __m256) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Cast vector of type __m256 to type __m256d.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3117580,"byte_end":3117589,"line_start":2767,"line_end":2767,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3117590,"byte_end":3117623,"line_start":2768,"line_end":2768,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3117740,"byte_end":3117789,"line_start":2771,"line_end":2771,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8658},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3118258,"byte_end":3118277,"line_start":2784,"line_end":2784,"column_start":15,"column_end":34},"name":"_mm256_castps_si256","qualname":"::core_arch::x86::avx::_mm256_castps_si256","value":"fn (a: __m256) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Casts vector of type __m256 to type __m256i.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3118034,"byte_end":3118043,"line_start":2779,"line_end":2779,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3118044,"byte_end":3118077,"line_start":2780,"line_end":2780,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3118194,"byte_end":3118243,"line_start":2783,"line_end":2783,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8659},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3118715,"byte_end":3118734,"line_start":2796,"line_end":2796,"column_start":15,"column_end":34},"name":"_mm256_castsi256_ps","qualname":"::core_arch::x86::avx::_mm256_castsi256_ps","value":"fn (a: __m256i) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Casts vector of type __m256i to type __m256.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3118491,"byte_end":3118500,"line_start":2791,"line_end":2791,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3118501,"byte_end":3118534,"line_start":2792,"line_end":2792,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3118651,"byte_end":3118700,"line_start":2795,"line_end":2795,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8660},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3119173,"byte_end":3119192,"line_start":2808,"line_end":2808,"column_start":15,"column_end":34},"name":"_mm256_castpd_si256","qualname":"::core_arch::x86::avx::_mm256_castpd_si256","value":"fn (a: __m256d) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Casts vector of type __m256d to type __m256i.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3118949,"byte_end":3118958,"line_start":2803,"line_end":2803,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3118959,"byte_end":3118992,"line_start":2804,"line_end":2804,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3119109,"byte_end":3119158,"line_start":2807,"line_end":2807,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8661},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3119632,"byte_end":3119651,"line_start":2820,"line_end":2820,"column_start":15,"column_end":34},"name":"_mm256_castsi256_pd","qualname":"::core_arch::x86::avx::_mm256_castsi256_pd","value":"fn (a: __m256i) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Casts vector of type __m256i to type __m256d.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3119408,"byte_end":3119417,"line_start":2815,"line_end":2815,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3119418,"byte_end":3119451,"line_start":2816,"line_end":2816,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3119568,"byte_end":3119617,"line_start":2819,"line_end":2819,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8662},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3120092,"byte_end":3120114,"line_start":2832,"line_end":2832,"column_start":15,"column_end":37},"name":"_mm256_castps256_ps128","qualname":"::core_arch::x86::avx::_mm256_castps256_ps128","value":"fn (a: __m256) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Casts vector of type __m256 to type __m128.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3119868,"byte_end":3119877,"line_start":2827,"line_end":2827,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3119878,"byte_end":3119911,"line_start":2828,"line_end":2828,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3120028,"byte_end":3120077,"line_start":2831,"line_end":2831,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8663},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3120576,"byte_end":3120598,"line_start":2844,"line_end":2844,"column_start":15,"column_end":37},"name":"_mm256_castpd256_pd128","qualname":"::core_arch::x86::avx::_mm256_castpd256_pd128","value":"fn (a: __m256d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Casts vector of type __m256d to type __m128d.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3120352,"byte_end":3120361,"line_start":2839,"line_end":2839,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3120362,"byte_end":3120395,"line_start":2840,"line_end":2840,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3120512,"byte_end":3120561,"line_start":2843,"line_end":2843,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8664},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3121056,"byte_end":3121078,"line_start":2856,"line_end":2856,"column_start":15,"column_end":37},"name":"_mm256_castsi256_si128","qualname":"::core_arch::x86::avx::_mm256_castsi256_si128","value":"fn (a: __m256i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Casts vector of type __m256i to type __m128i.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3120832,"byte_end":3120841,"line_start":2851,"line_end":2851,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3120842,"byte_end":3120875,"line_start":2852,"line_end":2852,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3120992,"byte_end":3121041,"line_start":2855,"line_end":2855,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8665},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3121649,"byte_end":3121671,"line_start":2871,"line_end":2871,"column_start":15,"column_end":37},"name":"_mm256_castps128_ps256","qualname":"::core_arch::x86::avx::_mm256_castps128_ps256","value":"fn (a: __m128) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Casts vector of type __m128 to type __m256;\n the upper 128 bits of the result are undefined.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3121425,"byte_end":3121434,"line_start":2866,"line_end":2866,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3121435,"byte_end":3121468,"line_start":2867,"line_end":2867,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3121585,"byte_end":3121634,"line_start":2870,"line_end":2870,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8666},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3122260,"byte_end":3122282,"line_start":2885,"line_end":2885,"column_start":15,"column_end":37},"name":"_mm256_castpd128_pd256","qualname":"::core_arch::x86::avx::_mm256_castpd128_pd256","value":"fn (a: __m128d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Casts vector of type __m128d to type __m256d;\n the upper 128 bits of the result are undefined.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3122036,"byte_end":3122045,"line_start":2880,"line_end":2880,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3122046,"byte_end":3122079,"line_start":2881,"line_end":2881,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3122196,"byte_end":3122245,"line_start":2884,"line_end":2884,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8667},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3122847,"byte_end":3122869,"line_start":2899,"line_end":2899,"column_start":15,"column_end":37},"name":"_mm256_castsi128_si256","qualname":"::core_arch::x86::avx::_mm256_castsi128_si256","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Casts vector of type __m128i to type __m256i;\n the upper 128 bits of the result are undefined.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3122623,"byte_end":3122632,"line_start":2894,"line_end":2894,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3122633,"byte_end":3122666,"line_start":2895,"line_end":2895,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3122783,"byte_end":3122832,"line_start":2898,"line_end":2898,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8668},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3123621,"byte_end":3123643,"line_start":2916,"line_end":2916,"column_start":15,"column_end":37},"name":"_mm256_zextps128_ps256","qualname":"::core_arch::x86::avx::_mm256_zextps128_ps256","value":"fn (a: __m128) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Constructs a 256-bit floating-point vector of `[8 x float]` from a\n 128-bit floating-point vector of `[4 x float]`. The lower 128 bits contain\n the value of the source vector. The upper 128 bits are set to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3123393,"byte_end":3123402,"line_start":2911,"line_end":2911,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3123403,"byte_end":3123440,"line_start":2912,"line_end":2912,"column_start":1,"column_end":38}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3123557,"byte_end":3123606,"line_start":2915,"line_end":2915,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8669},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3124261,"byte_end":3124283,"line_start":2930,"line_end":2930,"column_start":15,"column_end":37},"name":"_mm256_zextsi128_si256","qualname":"::core_arch::x86::avx::_mm256_zextsi128_si256","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Constructs a 256-bit integer vector from a 128-bit integer vector.\n The lower 128 bits contain the value of the source vector. The upper\n 128 bits are set to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3124032,"byte_end":3124041,"line_start":2925,"line_end":2925,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3124042,"byte_end":3124080,"line_start":2926,"line_end":2926,"column_start":1,"column_end":39}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3124197,"byte_end":3124246,"line_start":2929,"line_end":2929,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8670},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3125022,"byte_end":3125044,"line_start":2947,"line_end":2947,"column_start":15,"column_end":37},"name":"_mm256_zextpd128_pd256","qualname":"::core_arch::x86::avx::_mm256_zextpd128_pd256","value":"fn (a: __m128d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Constructs a 256-bit floating-point vector of `[4 x double]` from a\n 128-bit floating-point vector of `[2 x double]`. The lower 128 bits\n contain the value of the source vector. The upper 128 bits are set\n to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3124793,"byte_end":3124802,"line_start":2942,"line_end":2942,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3124803,"byte_end":3124841,"line_start":2943,"line_end":2943,"column_start":1,"column_end":39}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3124958,"byte_end":3125007,"line_start":2946,"line_end":2946,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8671},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3125467,"byte_end":3125486,"line_start":2958,"line_end":2958,"column_start":15,"column_end":34},"name":"_mm256_undefined_ps","qualname":"::core_arch::x86::avx::_mm256_undefined_ps","value":"fn () -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Returns vector of type `__m256` with undefined elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3125307,"byte_end":3125316,"line_start":2954,"line_end":2954,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3125317,"byte_end":3125350,"line_start":2955,"line_end":2955,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3125403,"byte_end":3125452,"line_start":2957,"line_end":2957,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8672},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3125963,"byte_end":3125982,"line_start":2970,"line_end":2970,"column_start":15,"column_end":34},"name":"_mm256_undefined_pd","qualname":"::core_arch::x86::avx::_mm256_undefined_pd","value":"fn () -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Returns vector of type `__m256d` with undefined elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3125803,"byte_end":3125812,"line_start":2966,"line_end":2966,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3125813,"byte_end":3125846,"line_start":2967,"line_end":2967,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3125899,"byte_end":3125948,"line_start":2969,"line_end":2969,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8673},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3126463,"byte_end":3126485,"line_start":2982,"line_end":2982,"column_start":15,"column_end":37},"name":"_mm256_undefined_si256","qualname":"::core_arch::x86::avx::_mm256_undefined_si256","value":"fn () -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Returns vector of type __m256i with undefined elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3126303,"byte_end":3126312,"line_start":2978,"line_end":2978,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3126313,"byte_end":3126346,"line_start":2979,"line_end":2979,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3126399,"byte_end":3126448,"line_start":2981,"line_end":2981,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8674},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3126957,"byte_end":3126972,"line_start":2994,"line_end":2994,"column_start":15,"column_end":30},"name":"_mm256_set_m128","qualname":"::core_arch::x86::avx::_mm256_set_m128","value":"fn (hi: __m128, lo: __m128) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Sets packed __m256 returned vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3126804,"byte_end":3126813,"line_start":2990,"line_end":2990,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3126814,"byte_end":3126847,"line_start":2991,"line_end":2991,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3126893,"byte_end":3126942,"line_start":2993,"line_end":2993,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8675},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3127400,"byte_end":3127416,"line_start":3005,"line_end":3005,"column_start":15,"column_end":31},"name":"_mm256_set_m128d","qualname":"::core_arch::x86::avx::_mm256_set_m128d","value":"fn (hi: __m128d, lo: __m128d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Sets packed __m256d returned vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3127247,"byte_end":3127256,"line_start":3001,"line_end":3001,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3127257,"byte_end":3127290,"line_start":3002,"line_end":3002,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3127336,"byte_end":3127385,"line_start":3004,"line_end":3004,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8676},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3127906,"byte_end":3127922,"line_start":3018,"line_end":3018,"column_start":15,"column_end":31},"name":"_mm256_set_m128i","qualname":"::core_arch::x86::avx::_mm256_set_m128i","value":"fn (hi: __m128i, lo: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed __m256i returned vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3127753,"byte_end":3127762,"line_start":3014,"line_end":3014,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3127763,"byte_end":3127796,"line_start":3015,"line_end":3015,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3127842,"byte_end":3127891,"line_start":3017,"line_end":3017,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8677},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3128411,"byte_end":3128427,"line_start":3031,"line_end":3031,"column_start":15,"column_end":31},"name":"_mm256_setr_m128","qualname":"::core_arch::x86::avx::_mm256_setr_m128","value":"fn (lo: __m128, hi: __m128) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Sets packed __m256 returned vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3128258,"byte_end":3128267,"line_start":3027,"line_end":3027,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3128268,"byte_end":3128301,"line_start":3028,"line_end":3028,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3128347,"byte_end":3128396,"line_start":3030,"line_end":3030,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8678},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3128832,"byte_end":3128849,"line_start":3042,"line_end":3042,"column_start":15,"column_end":32},"name":"_mm256_setr_m128d","qualname":"::core_arch::x86::avx::_mm256_setr_m128d","value":"fn (lo: __m128d, hi: __m128d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Sets packed __m256d returned vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3128679,"byte_end":3128688,"line_start":3038,"line_end":3038,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3128689,"byte_end":3128722,"line_start":3039,"line_end":3039,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3128768,"byte_end":3128817,"line_start":3041,"line_end":3041,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8679},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3129258,"byte_end":3129275,"line_start":3053,"line_end":3053,"column_start":15,"column_end":32},"name":"_mm256_setr_m128i","qualname":"::core_arch::x86::avx::_mm256_setr_m128i","value":"fn (lo: __m128i, hi: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed __m256i returned vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3129105,"byte_end":3129114,"line_start":3049,"line_end":3049,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3129115,"byte_end":3129148,"line_start":3050,"line_end":3050,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3129194,"byte_end":3129243,"line_start":3052,"line_end":3052,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8680},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3129872,"byte_end":3129890,"line_start":3067,"line_end":3067,"column_start":15,"column_end":33},"name":"_mm256_loadu2_m128","qualname":"::core_arch::x86::avx::_mm256_loadu2_m128","value":"fn (hiaddr: *const f32, loaddr: *const f32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Loads two 128-bit values (composed of 4 packed single-precision (32-bit)\n floating-point elements) from memory, and combine them into a 256-bit\n value.\n `hiaddr` and `loaddr` do not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3129708,"byte_end":3129717,"line_start":3063,"line_end":3063,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3129718,"byte_end":3129755,"line_start":3064,"line_end":3064,"column_start":1,"column_end":38}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3129808,"byte_end":3129857,"line_start":3066,"line_end":3066,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8681},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3130584,"byte_end":3130603,"line_start":3082,"line_end":3082,"column_start":15,"column_end":34},"name":"_mm256_loadu2_m128d","qualname":"::core_arch::x86::avx::_mm256_loadu2_m128d","value":"fn (hiaddr: *const f64, loaddr: *const f64) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Loads two 128-bit values (composed of 2 packed double-precision (64-bit)\n floating-point elements) from memory, and combine them into a 256-bit\n value.\n `hiaddr` and `loaddr` do not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3130419,"byte_end":3130428,"line_start":3078,"line_end":3078,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3130429,"byte_end":3130467,"line_start":3079,"line_end":3079,"column_start":1,"column_end":39}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3130520,"byte_end":3130569,"line_start":3081,"line_end":3081,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8682},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3131248,"byte_end":3131267,"line_start":3096,"line_end":3096,"column_start":15,"column_end":34},"name":"_mm256_loadu2_m128i","qualname":"::core_arch::x86::avx::_mm256_loadu2_m128i","value":"fn (hiaddr: *const __m128i, loaddr: *const __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Loads two 128-bit values (composed of integer data) from memory, and combine\n them into a 256-bit value.\n `hiaddr` and `loaddr` do not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3131083,"byte_end":3131092,"line_start":3092,"line_end":3092,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3131093,"byte_end":3131131,"line_start":3093,"line_end":3093,"column_start":1,"column_end":39}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3131184,"byte_end":3131233,"line_start":3095,"line_end":3095,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8683},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3131999,"byte_end":3132018,"line_start":3111,"line_end":3111,"column_start":15,"column_end":34},"name":"_mm256_storeu2_m128","qualname":"::core_arch::x86::avx::_mm256_storeu2_m128","value":"fn (hiaddr: *mut f32, loaddr: *mut f32, a: __m256) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the high and low 128-bit halves (each composed of 4 packed\n single-precision (32-bit) floating-point elements) from `a` into memory two\n different 128-bit locations.\n `hiaddr` and `loaddr` do not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3131835,"byte_end":3131844,"line_start":3107,"line_end":3107,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3131845,"byte_end":3131882,"line_start":3108,"line_end":3108,"column_start":1,"column_end":38}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3131935,"byte_end":3131984,"line_start":3110,"line_end":3110,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8684},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3132764,"byte_end":3132784,"line_start":3128,"line_end":3128,"column_start":15,"column_end":35},"name":"_mm256_storeu2_m128d","qualname":"::core_arch::x86::avx::_mm256_storeu2_m128d","value":"fn (hiaddr: *mut f64, loaddr: *mut f64, a: __m256d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the high and low 128-bit halves (each composed of 2 packed\n double-precision (64-bit) floating-point elements) from `a` into memory two\n different 128-bit locations.\n `hiaddr` and `loaddr` do not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3132599,"byte_end":3132608,"line_start":3124,"line_end":3124,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3132609,"byte_end":3132647,"line_start":3125,"line_end":3125,"column_start":1,"column_end":39}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3132700,"byte_end":3132749,"line_start":3127,"line_end":3127,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8685},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3133481,"byte_end":3133501,"line_start":3144,"line_end":3144,"column_start":15,"column_end":35},"name":"_mm256_storeu2_m128i","qualname":"::core_arch::x86::avx::_mm256_storeu2_m128i","value":"fn (hiaddr: *mut __m128i, loaddr: *mut __m128i, a: __m256i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the high and low 128-bit halves (each composed of integer data) from\n `a` into memory two different 128-bit locations.\n `hiaddr` and `loaddr` do not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3133316,"byte_end":3133325,"line_start":3140,"line_end":3140,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3133326,"byte_end":3133364,"line_start":3141,"line_end":3141,"column_start":1,"column_end":39}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3133417,"byte_end":3133466,"line_start":3143,"line_end":3143,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8686},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3134056,"byte_end":3134072,"line_start":3158,"line_end":3158,"column_start":15,"column_end":31},"name":"_mm256_cvtss_f32","qualname":"::core_arch::x86::avx::_mm256_cvtss_f32","value":"fn (a: __m256) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the first element of the input vector of `[8 x float]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3133901,"byte_end":3133910,"line_start":3154,"line_end":3154,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3133911,"byte_end":3133944,"line_start":3155,"line_end":3155,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3133992,"byte_end":3134041,"line_start":3157,"line_end":3157,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8767},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3199877,"byte_end":3199893,"line_start":36,"line_end":36,"column_start":15,"column_end":31},"name":"_mm256_abs_epi32","qualname":"::core_arch::x86::avx2::_mm256_abs_epi32","value":"fn (a: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute values of packed 32-bit integers in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3199728,"byte_end":3199737,"line_start":32,"line_end":32,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3199738,"byte_end":3199772,"line_start":33,"line_end":33,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3199813,"byte_end":3199862,"line_start":35,"line_end":35,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8768},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3200290,"byte_end":3200306,"line_start":47,"line_end":47,"column_start":15,"column_end":31},"name":"_mm256_abs_epi16","qualname":"::core_arch::x86::avx2::_mm256_abs_epi16","value":"fn (a: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute values of packed 16-bit integers in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3200141,"byte_end":3200150,"line_start":43,"line_end":43,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3200151,"byte_end":3200185,"line_start":44,"line_end":44,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3200226,"byte_end":3200275,"line_start":46,"line_end":46,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8769},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3200702,"byte_end":3200717,"line_start":58,"line_end":58,"column_start":15,"column_end":30},"name":"_mm256_abs_epi8","qualname":"::core_arch::x86::avx2::_mm256_abs_epi8","value":"fn (a: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute values of packed 8-bit integers in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3200553,"byte_end":3200562,"line_start":54,"line_end":54,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3200563,"byte_end":3200597,"line_start":55,"line_end":55,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3200638,"byte_end":3200687,"line_start":57,"line_end":57,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8770},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3201095,"byte_end":3201111,"line_start":69,"line_end":69,"column_start":15,"column_end":31},"name":"_mm256_add_epi64","qualname":"::core_arch::x86::avx2::_mm256_add_epi64","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 64-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3200946,"byte_end":3200955,"line_start":65,"line_end":65,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3200956,"byte_end":3200990,"line_start":66,"line_end":66,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3201031,"byte_end":3201080,"line_start":68,"line_end":68,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8771},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3201518,"byte_end":3201534,"line_start":80,"line_end":80,"column_start":15,"column_end":31},"name":"_mm256_add_epi32","qualname":"::core_arch::x86::avx2::_mm256_add_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 32-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3201369,"byte_end":3201378,"line_start":76,"line_end":76,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3201379,"byte_end":3201413,"line_start":77,"line_end":77,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3201454,"byte_end":3201503,"line_start":79,"line_end":79,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8772},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3201941,"byte_end":3201957,"line_start":91,"line_end":91,"column_start":15,"column_end":31},"name":"_mm256_add_epi16","qualname":"::core_arch::x86::avx2::_mm256_add_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 16-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3201792,"byte_end":3201801,"line_start":87,"line_end":87,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3201802,"byte_end":3201836,"line_start":88,"line_end":88,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3201877,"byte_end":3201926,"line_start":90,"line_end":90,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8773},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3202364,"byte_end":3202379,"line_start":102,"line_end":102,"column_start":15,"column_end":30},"name":"_mm256_add_epi8","qualname":"::core_arch::x86::avx2::_mm256_add_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 8-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3202215,"byte_end":3202224,"line_start":98,"line_end":98,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3202225,"byte_end":3202259,"line_start":99,"line_end":99,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3202300,"byte_end":3202349,"line_start":101,"line_end":101,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8774},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3202803,"byte_end":3202819,"line_start":113,"line_end":113,"column_start":15,"column_end":31},"name":"_mm256_adds_epi8","qualname":"::core_arch::x86::avx2::_mm256_adds_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 8-bit integers in `a` and `b` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3202653,"byte_end":3202662,"line_start":109,"line_end":109,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3202663,"byte_end":3202697,"line_start":110,"line_end":110,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3202739,"byte_end":3202788,"line_start":112,"line_end":112,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8775},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3203243,"byte_end":3203260,"line_start":124,"line_end":124,"column_start":15,"column_end":32},"name":"_mm256_adds_epi16","qualname":"::core_arch::x86::avx2::_mm256_adds_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 16-bit integers in `a` and `b` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3203093,"byte_end":3203102,"line_start":120,"line_end":120,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3203103,"byte_end":3203137,"line_start":121,"line_end":121,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3203179,"byte_end":3203228,"line_start":123,"line_end":123,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8776},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3203694,"byte_end":3203710,"line_start":135,"line_end":135,"column_start":15,"column_end":31},"name":"_mm256_adds_epu8","qualname":"::core_arch::x86::avx2::_mm256_adds_epu8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed unsigned 8-bit integers in `a` and `b` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3203543,"byte_end":3203552,"line_start":131,"line_end":131,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3203553,"byte_end":3203587,"line_start":132,"line_end":132,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3203630,"byte_end":3203679,"line_start":134,"line_end":134,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8777},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3204145,"byte_end":3204162,"line_start":146,"line_end":146,"column_start":15,"column_end":32},"name":"_mm256_adds_epu16","qualname":"::core_arch::x86::avx2::_mm256_adds_epu16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed unsigned 16-bit integers in `a` and `b` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3203994,"byte_end":3204003,"line_start":142,"line_end":142,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3204004,"byte_end":3204038,"line_start":143,"line_end":143,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3204081,"byte_end":3204130,"line_start":145,"line_end":145,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8778},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3204726,"byte_end":3204744,"line_start":159,"line_end":159,"column_start":15,"column_end":33},"name":"_mm256_alignr_epi8","qualname":"::core_arch::x86::avx2::_mm256_alignr_epi8","value":"fn (a: __m256i, b: __m256i, n: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Concatenates pairs of 16-byte blocks in `a` and `b` into a 32-byte temporary\n result, shifts the result right by `n` bytes, and returns the low 16 bytes.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3204536,"byte_end":3204545,"line_start":154,"line_end":154,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3204546,"byte_end":3204580,"line_start":155,"line_end":155,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3204630,"byte_end":3204661,"line_start":157,"line_end":157,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3204662,"byte_end":3204711,"line_start":158,"line_end":158,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8779},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3209801,"byte_end":3209817,"line_start":319,"line_end":319,"column_start":15,"column_end":31},"name":"_mm256_and_si256","qualname":"::core_arch::x86::avx2::_mm256_and_si256","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 256 bits (representing integer data)\n in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3209652,"byte_end":3209661,"line_start":315,"line_end":315,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3209662,"byte_end":3209696,"line_start":316,"line_end":316,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3209737,"byte_end":3209786,"line_start":318,"line_end":318,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8780},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3210283,"byte_end":3210302,"line_start":331,"line_end":331,"column_start":15,"column_end":34},"name":"_mm256_andnot_si256","qualname":"::core_arch::x86::avx2::_mm256_andnot_si256","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise NOT of 256 bits (representing integer data)\n in `a` and then AND with `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3210133,"byte_end":3210142,"line_start":327,"line_end":327,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3210143,"byte_end":3210177,"line_start":328,"line_end":328,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3210219,"byte_end":3210268,"line_start":330,"line_end":330,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8781},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3210817,"byte_end":3210833,"line_start":346,"line_end":346,"column_start":15,"column_end":31},"name":"_mm256_avg_epu16","qualname":"::core_arch::x86::avx2::_mm256_avg_epu16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Averages packed unsigned 16-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3210668,"byte_end":3210677,"line_start":342,"line_end":342,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3210678,"byte_end":3210712,"line_start":343,"line_end":343,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3210753,"byte_end":3210802,"line_start":345,"line_end":345,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8782},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3211250,"byte_end":3211265,"line_start":357,"line_end":357,"column_start":15,"column_end":30},"name":"_mm256_avg_epu8","qualname":"::core_arch::x86::avx2::_mm256_avg_epu8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Averages packed unsigned 8-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3211101,"byte_end":3211110,"line_start":353,"line_end":353,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3211111,"byte_end":3211145,"line_start":354,"line_end":354,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3211186,"byte_end":3211235,"line_start":356,"line_end":356,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8783},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3211742,"byte_end":3211757,"line_start":369,"line_end":369,"column_start":15,"column_end":30},"name":"_mm_blend_epi32","qualname":"::core_arch::x86::avx2::_mm_blend_epi32","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Blends packed 32-bit integers from `a` and `b` using control mask `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3211549,"byte_end":3211558,"line_start":364,"line_end":364,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3211559,"byte_end":3211593,"line_start":365,"line_end":365,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3211646,"byte_end":3211677,"line_start":367,"line_end":367,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3211678,"byte_end":3211727,"line_start":368,"line_end":368,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8786},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3212928,"byte_end":3212946,"line_start":405,"line_end":405,"column_start":15,"column_end":33},"name":"_mm256_blend_epi32","qualname":"::core_arch::x86::avx2::_mm256_blend_epi32","value":"fn (a: __m256i, b: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Blends packed 32-bit integers from `a` and `b` using control mask `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3212735,"byte_end":3212744,"line_start":400,"line_end":400,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3212745,"byte_end":3212779,"line_start":401,"line_end":401,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3212832,"byte_end":3212863,"line_start":403,"line_end":403,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3212864,"byte_end":3212913,"line_start":404,"line_end":404,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8791},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3215063,"byte_end":3215081,"line_start":470,"line_end":470,"column_start":15,"column_end":33},"name":"_mm256_blend_epi16","qualname":"::core_arch::x86::avx2::_mm256_blend_epi16","value":"fn (a: __m256i, b: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Blends packed 16-bit integers from `a` and `b` using control mask `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3214870,"byte_end":3214879,"line_start":465,"line_end":465,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3214880,"byte_end":3214914,"line_start":466,"line_end":466,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3214967,"byte_end":3214998,"line_start":468,"line_end":468,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3214999,"byte_end":3215048,"line_start":469,"line_end":469,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8796},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3218284,"byte_end":3218302,"line_start":574,"line_end":574,"column_start":15,"column_end":33},"name":"_mm256_blendv_epi8","qualname":"::core_arch::x86::avx2::_mm256_blendv_epi8","value":"fn (a: __m256i, b: __m256i, mask: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Blends packed 8-bit integers from `a` and `b` using `mask`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3218132,"byte_end":3218141,"line_start":570,"line_end":570,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3218142,"byte_end":3218176,"line_start":571,"line_end":571,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3218220,"byte_end":3218269,"line_start":573,"line_end":573,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8797},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3218806,"byte_end":3218825,"line_start":586,"line_end":586,"column_start":15,"column_end":34},"name":"_mm_broadcastb_epi8","qualname":"::core_arch::x86::avx2::_mm_broadcastb_epi8","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low packed 8-bit integer from `a` to all elements of\n the 128-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3218651,"byte_end":3218660,"line_start":582,"line_end":582,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3218661,"byte_end":3218695,"line_start":583,"line_end":583,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3218742,"byte_end":3218791,"line_start":585,"line_end":585,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8799},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3219377,"byte_end":3219399,"line_start":600,"line_end":600,"column_start":15,"column_end":37},"name":"_mm256_broadcastb_epi8","qualname":"::core_arch::x86::avx2::_mm256_broadcastb_epi8","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low packed 8-bit integer from `a` to all elements of\n the 256-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3219222,"byte_end":3219231,"line_start":596,"line_end":596,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3219232,"byte_end":3219266,"line_start":597,"line_end":597,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3219313,"byte_end":3219362,"line_start":599,"line_end":599,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8801},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3220055,"byte_end":3220075,"line_start":616,"line_end":616,"column_start":15,"column_end":35},"name":"_mm_broadcastd_epi32","qualname":"::core_arch::x86::avx2::_mm_broadcastd_epi32","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low packed 32-bit integer from `a` to all elements of\n the 128-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3219900,"byte_end":3219909,"line_start":612,"line_end":612,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3219910,"byte_end":3219944,"line_start":613,"line_end":613,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3219991,"byte_end":3220040,"line_start":615,"line_end":615,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8803},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3220733,"byte_end":3220756,"line_start":632,"line_end":632,"column_start":15,"column_end":38},"name":"_mm256_broadcastd_epi32","qualname":"::core_arch::x86::avx2::_mm256_broadcastd_epi32","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low packed 32-bit integer from `a` to all elements of\n the 256-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3220578,"byte_end":3220587,"line_start":628,"line_end":628,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3220588,"byte_end":3220622,"line_start":629,"line_end":629,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3220669,"byte_end":3220718,"line_start":631,"line_end":631,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8805},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3221305,"byte_end":3221325,"line_start":646,"line_end":646,"column_start":15,"column_end":35},"name":"_mm_broadcastq_epi64","qualname":"::core_arch::x86::avx2::_mm_broadcastq_epi64","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low packed 64-bit integer from `a` to all elements of\n the 128-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3221150,"byte_end":3221159,"line_start":642,"line_end":642,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3221160,"byte_end":3221194,"line_start":643,"line_end":643,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3221241,"byte_end":3221290,"line_start":645,"line_end":645,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8807},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3221981,"byte_end":3222004,"line_start":662,"line_end":662,"column_start":15,"column_end":38},"name":"_mm256_broadcastq_epi64","qualname":"::core_arch::x86::avx2::_mm256_broadcastq_epi64","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low packed 64-bit integer from `a` to all elements of\n the 256-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3221826,"byte_end":3221835,"line_start":658,"line_end":658,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3221836,"byte_end":3221870,"line_start":659,"line_end":659,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3221917,"byte_end":3221966,"line_start":661,"line_end":661,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8809},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3222574,"byte_end":3222592,"line_start":676,"line_end":676,"column_start":15,"column_end":33},"name":"_mm_broadcastsd_pd","qualname":"::core_arch::x86::avx2::_mm_broadcastsd_pd","value":"fn (a: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low double-precision (64-bit) floating-point element\n from `a` to all elements of the 128-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3222423,"byte_end":3222432,"line_start":672,"line_end":672,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3222433,"byte_end":3222467,"line_start":673,"line_end":673,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3222510,"byte_end":3222559,"line_start":675,"line_end":675,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8811},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3223081,"byte_end":3223102,"line_start":688,"line_end":688,"column_start":15,"column_end":36},"name":"_mm256_broadcastsd_pd","qualname":"::core_arch::x86::avx2::_mm256_broadcastsd_pd","value":"fn (a: __m128d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low double-precision (64-bit) floating-point element\n from `a` to all elements of the 256-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3222926,"byte_end":3222935,"line_start":684,"line_end":684,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3222936,"byte_end":3222970,"line_start":685,"line_end":685,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3223017,"byte_end":3223066,"line_start":687,"line_end":687,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8813},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3223613,"byte_end":3223640,"line_start":701,"line_end":701,"column_start":15,"column_end":42},"name":"_mm256_broadcastsi128_si256","qualname":"::core_arch::x86::avx2::_mm256_broadcastsi128_si256","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 128 bits of integer data from a to all 128-bit lanes in\n the 256-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3223504,"byte_end":3223513,"line_start":698,"line_end":698,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3223514,"byte_end":3223548,"line_start":699,"line_end":699,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3223549,"byte_end":3223598,"line_start":700,"line_end":700,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8814},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3224216,"byte_end":3224234,"line_start":715,"line_end":715,"column_start":15,"column_end":33},"name":"_mm_broadcastss_ps","qualname":"::core_arch::x86::avx2::_mm_broadcastss_ps","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low single-precision (32-bit) floating-point element\n from `a` to all elements of the 128-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3224061,"byte_end":3224070,"line_start":711,"line_end":711,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3224071,"byte_end":3224105,"line_start":712,"line_end":712,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3224152,"byte_end":3224201,"line_start":714,"line_end":714,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8816},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3224721,"byte_end":3224742,"line_start":727,"line_end":727,"column_start":15,"column_end":36},"name":"_mm256_broadcastss_ps","qualname":"::core_arch::x86::avx2::_mm256_broadcastss_ps","value":"fn (a: __m128) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low single-precision (32-bit) floating-point element\n from `a` to all elements of the 256-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3224566,"byte_end":3224575,"line_start":723,"line_end":723,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3224576,"byte_end":3224610,"line_start":724,"line_end":724,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3224657,"byte_end":3224706,"line_start":726,"line_end":726,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8818},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3225198,"byte_end":3225218,"line_start":739,"line_end":739,"column_start":15,"column_end":35},"name":"_mm_broadcastw_epi16","qualname":"::core_arch::x86::avx2::_mm_broadcastw_epi16","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low packed 16-bit integer from a to all elements of\n the 128-bit returned value","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3225043,"byte_end":3225052,"line_start":735,"line_end":735,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3225053,"byte_end":3225087,"line_start":736,"line_end":736,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3225134,"byte_end":3225183,"line_start":738,"line_end":738,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8820},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3225767,"byte_end":3225790,"line_start":753,"line_end":753,"column_start":15,"column_end":38},"name":"_mm256_broadcastw_epi16","qualname":"::core_arch::x86::avx2::_mm256_broadcastw_epi16","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low packed 16-bit integer from a to all elements of\n the 256-bit returned value","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3225612,"byte_end":3225621,"line_start":749,"line_end":749,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3225622,"byte_end":3225656,"line_start":750,"line_end":750,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3225703,"byte_end":3225752,"line_start":752,"line_end":752,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8822},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3226296,"byte_end":3226314,"line_start":766,"line_end":766,"column_start":15,"column_end":33},"name":"_mm256_cmpeq_epi64","qualname":"::core_arch::x86::avx2::_mm256_cmpeq_epi64","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 64-bit integers in `a` and `b` for equality.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3226145,"byte_end":3226154,"line_start":762,"line_end":762,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3226155,"byte_end":3226189,"line_start":763,"line_end":763,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3226232,"byte_end":3226281,"line_start":765,"line_end":765,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8823},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3226753,"byte_end":3226771,"line_start":777,"line_end":777,"column_start":15,"column_end":33},"name":"_mm256_cmpeq_epi32","qualname":"::core_arch::x86::avx2::_mm256_cmpeq_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 32-bit integers in `a` and `b` for equality.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3226602,"byte_end":3226611,"line_start":773,"line_end":773,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3226612,"byte_end":3226646,"line_start":774,"line_end":774,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3226689,"byte_end":3226738,"line_start":776,"line_end":776,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8824},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3227210,"byte_end":3227228,"line_start":788,"line_end":788,"column_start":15,"column_end":33},"name":"_mm256_cmpeq_epi16","qualname":"::core_arch::x86::avx2::_mm256_cmpeq_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 16-bit integers in `a` and `b` for equality.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3227059,"byte_end":3227068,"line_start":784,"line_end":784,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3227069,"byte_end":3227103,"line_start":785,"line_end":785,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3227146,"byte_end":3227195,"line_start":787,"line_end":787,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8825},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3227668,"byte_end":3227685,"line_start":799,"line_end":799,"column_start":15,"column_end":32},"name":"_mm256_cmpeq_epi8","qualname":"::core_arch::x86::avx2::_mm256_cmpeq_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 8-bit integers in `a` and `b` for equality.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3227517,"byte_end":3227526,"line_start":795,"line_end":795,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3227527,"byte_end":3227561,"line_start":796,"line_end":796,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3227604,"byte_end":3227653,"line_start":798,"line_end":798,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8826},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3228128,"byte_end":3228146,"line_start":810,"line_end":810,"column_start":15,"column_end":33},"name":"_mm256_cmpgt_epi64","qualname":"::core_arch::x86::avx2::_mm256_cmpgt_epi64","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 64-bit integers in `a` and `b` for greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3227977,"byte_end":3227986,"line_start":806,"line_end":806,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3227987,"byte_end":3228021,"line_start":807,"line_end":807,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3228064,"byte_end":3228113,"line_start":809,"line_end":809,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8827},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3228589,"byte_end":3228607,"line_start":821,"line_end":821,"column_start":15,"column_end":33},"name":"_mm256_cmpgt_epi32","qualname":"::core_arch::x86::avx2::_mm256_cmpgt_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 32-bit integers in `a` and `b` for greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3228438,"byte_end":3228447,"line_start":817,"line_end":817,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3228448,"byte_end":3228482,"line_start":818,"line_end":818,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3228525,"byte_end":3228574,"line_start":820,"line_end":820,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8828},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3229050,"byte_end":3229068,"line_start":832,"line_end":832,"column_start":15,"column_end":33},"name":"_mm256_cmpgt_epi16","qualname":"::core_arch::x86::avx2::_mm256_cmpgt_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 16-bit integers in `a` and `b` for greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3228899,"byte_end":3228908,"line_start":828,"line_end":828,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3228909,"byte_end":3228943,"line_start":829,"line_end":829,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3228986,"byte_end":3229035,"line_start":831,"line_end":831,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8829},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3229512,"byte_end":3229529,"line_start":843,"line_end":843,"column_start":15,"column_end":32},"name":"_mm256_cmpgt_epi8","qualname":"::core_arch::x86::avx2::_mm256_cmpgt_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 8-bit integers in `a` and `b` for greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3229361,"byte_end":3229370,"line_start":839,"line_end":839,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3229371,"byte_end":3229405,"line_start":840,"line_end":840,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3229448,"byte_end":3229497,"line_start":842,"line_end":842,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8830},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3229959,"byte_end":3229980,"line_start":854,"line_end":854,"column_start":15,"column_end":36},"name":"_mm256_cvtepi16_epi32","qualname":"::core_arch::x86::avx2::_mm256_cvtepi16_epi32","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sign-extend 16-bit integers to 32-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3229807,"byte_end":3229816,"line_start":850,"line_end":850,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3229817,"byte_end":3229851,"line_start":851,"line_end":851,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3229895,"byte_end":3229944,"line_start":853,"line_end":853,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8831},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3230386,"byte_end":3230407,"line_start":865,"line_end":865,"column_start":15,"column_end":36},"name":"_mm256_cvtepi16_epi64","qualname":"::core_arch::x86::avx2::_mm256_cvtepi16_epi64","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sign-extend 16-bit integers to 64-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3230234,"byte_end":3230243,"line_start":861,"line_end":861,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3230244,"byte_end":3230278,"line_start":862,"line_end":862,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3230322,"byte_end":3230371,"line_start":864,"line_end":864,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8832},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3230886,"byte_end":3230907,"line_start":878,"line_end":878,"column_start":15,"column_end":36},"name":"_mm256_cvtepi32_epi64","qualname":"::core_arch::x86::avx2::_mm256_cvtepi32_epi64","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sign-extend 32-bit integers to 64-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3230734,"byte_end":3230743,"line_start":874,"line_end":874,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3230744,"byte_end":3230778,"line_start":875,"line_end":875,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3230822,"byte_end":3230871,"line_start":877,"line_end":877,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8833},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3231311,"byte_end":3231331,"line_start":889,"line_end":889,"column_start":15,"column_end":35},"name":"_mm256_cvtepi8_epi16","qualname":"::core_arch::x86::avx2::_mm256_cvtepi8_epi16","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sign-extend 8-bit integers to 16-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3231159,"byte_end":3231168,"line_start":885,"line_end":885,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3231169,"byte_end":3231203,"line_start":886,"line_end":886,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3231247,"byte_end":3231296,"line_start":888,"line_end":888,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8834},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3231736,"byte_end":3231756,"line_start":900,"line_end":900,"column_start":15,"column_end":35},"name":"_mm256_cvtepi8_epi32","qualname":"::core_arch::x86::avx2::_mm256_cvtepi8_epi32","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sign-extend 8-bit integers to 32-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3231584,"byte_end":3231593,"line_start":896,"line_end":896,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3231594,"byte_end":3231628,"line_start":897,"line_end":897,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3231672,"byte_end":3231721,"line_start":899,"line_end":899,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8835},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3232244,"byte_end":3232264,"line_start":913,"line_end":913,"column_start":15,"column_end":35},"name":"_mm256_cvtepi8_epi64","qualname":"::core_arch::x86::avx2::_mm256_cvtepi8_epi64","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sign-extend 8-bit integers to 64-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3232092,"byte_end":3232101,"line_start":909,"line_end":909,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3232102,"byte_end":3232136,"line_start":910,"line_end":910,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3232180,"byte_end":3232229,"line_start":912,"line_end":912,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8836},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3232811,"byte_end":3232832,"line_start":927,"line_end":927,"column_start":15,"column_end":36},"name":"_mm256_cvtepu16_epi32","qualname":"::core_arch::x86::avx2::_mm256_cvtepu16_epi32","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Zeroes extend packed unsigned 16-bit integers in `a` to packed 32-bit\n integers, and stores the results in `dst`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3232659,"byte_end":3232668,"line_start":923,"line_end":923,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3232669,"byte_end":3232703,"line_start":924,"line_end":924,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3232747,"byte_end":3232796,"line_start":926,"line_end":926,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8837},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3233316,"byte_end":3233337,"line_start":939,"line_end":939,"column_start":15,"column_end":36},"name":"_mm256_cvtepu16_epi64","qualname":"::core_arch::x86::avx2::_mm256_cvtepu16_epi64","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Zero-extend the lower four unsigned 16-bit integers in `a` to 64-bit\n integers. The upper four elements of `a` are unused.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3233164,"byte_end":3233173,"line_start":935,"line_end":935,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3233174,"byte_end":3233208,"line_start":936,"line_end":936,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3233252,"byte_end":3233301,"line_start":938,"line_end":938,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8838},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3233832,"byte_end":3233853,"line_start":952,"line_end":952,"column_start":15,"column_end":36},"name":"_mm256_cvtepu32_epi64","qualname":"::core_arch::x86::avx2::_mm256_cvtepu32_epi64","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Zero-extend unsigned 32-bit integers in `a` to 64-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3233680,"byte_end":3233689,"line_start":948,"line_end":948,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3233690,"byte_end":3233724,"line_start":949,"line_end":949,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3233768,"byte_end":3233817,"line_start":951,"line_end":951,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8839},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3234273,"byte_end":3234293,"line_start":963,"line_end":963,"column_start":15,"column_end":35},"name":"_mm256_cvtepu8_epi16","qualname":"::core_arch::x86::avx2::_mm256_cvtepu8_epi16","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Zero-extend unsigned 8-bit integers in `a` to 16-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3234121,"byte_end":3234130,"line_start":959,"line_end":959,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3234131,"byte_end":3234165,"line_start":960,"line_end":960,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3234209,"byte_end":3234258,"line_start":962,"line_end":962,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8840},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3234778,"byte_end":3234798,"line_start":975,"line_end":975,"column_start":15,"column_end":35},"name":"_mm256_cvtepu8_epi32","qualname":"::core_arch::x86::avx2::_mm256_cvtepu8_epi32","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Zero-extend the lower eight unsigned 8-bit integers in `a` to 32-bit\n integers. The upper eight elements of `a` are unused.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3234626,"byte_end":3234635,"line_start":971,"line_end":971,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3234636,"byte_end":3234670,"line_start":972,"line_end":972,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3234714,"byte_end":3234763,"line_start":974,"line_end":974,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8841},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3235366,"byte_end":3235386,"line_start":989,"line_end":989,"column_start":15,"column_end":35},"name":"_mm256_cvtepu8_epi64","qualname":"::core_arch::x86::avx2::_mm256_cvtepu8_epi64","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Zero-extend the lower four unsigned 8-bit integers in `a` to 64-bit\n integers. The upper twelve elements of `a` are unused.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3235214,"byte_end":3235223,"line_start":985,"line_end":985,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3235224,"byte_end":3235258,"line_start":986,"line_end":986,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3235302,"byte_end":3235351,"line_start":988,"line_end":988,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8842},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3235974,"byte_end":3235998,"line_start":1006,"line_end":1006,"column_start":15,"column_end":39},"name":"_mm256_extracti128_si256","qualname":"::core_arch::x86::avx2::_mm256_extracti128_si256","value":"fn (a: __m256i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Extracts 128 bits (of integer data) from `a` selected with `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3235734,"byte_end":3235743,"line_start":998,"line_end":998,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3235744,"byte_end":3235778,"line_start":999,"line_end":999,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3235878,"byte_end":3235909,"line_start":1004,"line_end":1004,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3235910,"byte_end":3235959,"line_start":1005,"line_end":1005,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8843},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3236604,"byte_end":3236621,"line_start":1023,"line_end":1023,"column_start":15,"column_end":32},"name":"_mm256_hadd_epi16","qualname":"::core_arch::x86::avx2::_mm256_hadd_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds adjacent pairs of 16-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3236454,"byte_end":3236463,"line_start":1019,"line_end":1019,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3236464,"byte_end":3236498,"line_start":1020,"line_end":1020,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3236540,"byte_end":3236589,"line_start":1022,"line_end":1022,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8844},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3237054,"byte_end":3237071,"line_start":1034,"line_end":1034,"column_start":15,"column_end":32},"name":"_mm256_hadd_epi32","qualname":"::core_arch::x86::avx2::_mm256_hadd_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds adjacent pairs of 32-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3236904,"byte_end":3236913,"line_start":1030,"line_end":1030,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3236914,"byte_end":3236948,"line_start":1031,"line_end":1031,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3236990,"byte_end":3237039,"line_start":1033,"line_end":1033,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8845},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3237525,"byte_end":3237543,"line_start":1046,"line_end":1046,"column_start":15,"column_end":33},"name":"_mm256_hadds_epi16","qualname":"::core_arch::x86::avx2::_mm256_hadds_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds adjacent pairs of 16-bit integers in `a` and `b`\n using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3237374,"byte_end":3237383,"line_start":1042,"line_end":1042,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3237384,"byte_end":3237418,"line_start":1043,"line_end":1043,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3237461,"byte_end":3237510,"line_start":1045,"line_end":1045,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8846},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3237981,"byte_end":3237998,"line_start":1057,"line_end":1057,"column_start":15,"column_end":32},"name":"_mm256_hsub_epi16","qualname":"::core_arch::x86::avx2::_mm256_hsub_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally subtract adjacent pairs of 16-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3237831,"byte_end":3237840,"line_start":1053,"line_end":1053,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3237841,"byte_end":3237875,"line_start":1054,"line_end":1054,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3237917,"byte_end":3237966,"line_start":1056,"line_end":1056,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8847},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3238435,"byte_end":3238452,"line_start":1068,"line_end":1068,"column_start":15,"column_end":32},"name":"_mm256_hsub_epi32","qualname":"::core_arch::x86::avx2::_mm256_hsub_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally subtract adjacent pairs of 32-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3238285,"byte_end":3238294,"line_start":1064,"line_end":1064,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3238295,"byte_end":3238329,"line_start":1065,"line_end":1065,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3238371,"byte_end":3238420,"line_start":1067,"line_end":1067,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8848},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3238910,"byte_end":3238928,"line_start":1080,"line_end":1080,"column_start":15,"column_end":33},"name":"_mm256_hsubs_epi16","qualname":"::core_arch::x86::avx2::_mm256_hsubs_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally subtract adjacent pairs of 16-bit integers in `a` and `b`\n using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3238759,"byte_end":3238768,"line_start":1076,"line_end":1076,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3238769,"byte_end":3238803,"line_start":1077,"line_end":1077,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3238846,"byte_end":3238895,"line_start":1079,"line_end":1079,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8849},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3239456,"byte_end":3239475,"line_start":1094,"line_end":1094,"column_start":15,"column_end":34},"name":"_mm_i32gather_epi32","qualname":"::core_arch::x86::avx2::_mm_i32gather_epi32","value":"fn (slice: *const i32, offsets: __m128i, scale: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3239260,"byte_end":3239269,"line_start":1089,"line_end":1089,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3239270,"byte_end":3239304,"line_start":1090,"line_end":1090,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3239360,"byte_end":3239391,"line_start":1092,"line_end":1092,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3239392,"byte_end":3239441,"line_start":1093,"line_end":1093,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8851},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3240407,"byte_end":3240431,"line_start":1119,"line_end":1119,"column_start":15,"column_end":39},"name":"_mm_mask_i32gather_epi32","qualname":"::core_arch::x86::avx2::_mm_mask_i32gather_epi32","value":"fn (src: __m128i, slice: *const i32, offsets: __m128i, mask: __m128i, scale: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3240211,"byte_end":3240220,"line_start":1114,"line_end":1114,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3240221,"byte_end":3240255,"line_start":1115,"line_end":1115,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3240311,"byte_end":3240342,"line_start":1117,"line_end":1117,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3240343,"byte_end":3240392,"line_start":1118,"line_end":1118,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8853},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3241303,"byte_end":3241325,"line_start":1149,"line_end":1149,"column_start":15,"column_end":37},"name":"_mm256_i32gather_epi32","qualname":"::core_arch::x86::avx2::_mm256_i32gather_epi32","value":"fn (slice: *const i32, offsets: __m256i, scale: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3241107,"byte_end":3241116,"line_start":1144,"line_end":1144,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3241117,"byte_end":3241151,"line_start":1145,"line_end":1145,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3241207,"byte_end":3241238,"line_start":1147,"line_end":1147,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3241239,"byte_end":3241288,"line_start":1148,"line_end":1148,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8855},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3242267,"byte_end":3242294,"line_start":1174,"line_end":1174,"column_start":15,"column_end":42},"name":"_mm256_mask_i32gather_epi32","qualname":"::core_arch::x86::avx2::_mm256_mask_i32gather_epi32","value":"fn (src: __m256i, slice: *const i32, offsets: __m256i, mask: __m256i, scale: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3242071,"byte_end":3242080,"line_start":1169,"line_end":1169,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3242081,"byte_end":3242115,"line_start":1170,"line_end":1170,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3242171,"byte_end":3242202,"line_start":1172,"line_end":1172,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3242203,"byte_end":3242252,"line_start":1173,"line_end":1173,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8857},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3243161,"byte_end":3243177,"line_start":1204,"line_end":1204,"column_start":15,"column_end":31},"name":"_mm_i32gather_ps","qualname":"::core_arch::x86::avx2::_mm_i32gather_ps","value":"fn (slice: *const f32, offsets: __m128i, scale: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3242965,"byte_end":3242974,"line_start":1199,"line_end":1199,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3242975,"byte_end":3243009,"line_start":1200,"line_end":1200,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3243065,"byte_end":3243096,"line_start":1202,"line_end":1202,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3243097,"byte_end":3243146,"line_start":1203,"line_end":1203,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8859},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3244054,"byte_end":3244075,"line_start":1228,"line_end":1228,"column_start":15,"column_end":36},"name":"_mm_mask_i32gather_ps","qualname":"::core_arch::x86::avx2::_mm_mask_i32gather_ps","value":"fn (src: __m128, slice: *const f32, offsets: __m128i, mask: __m128, scale: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3243858,"byte_end":3243867,"line_start":1223,"line_end":1223,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3243868,"byte_end":3243902,"line_start":1224,"line_end":1224,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3243958,"byte_end":3243989,"line_start":1226,"line_end":1226,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3243990,"byte_end":3244039,"line_start":1227,"line_end":1227,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8861},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3244854,"byte_end":3244873,"line_start":1255,"line_end":1255,"column_start":15,"column_end":34},"name":"_mm256_i32gather_ps","qualname":"::core_arch::x86::avx2::_mm256_i32gather_ps","value":"fn (slice: *const f32, offsets: __m256i, scale: i32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3244658,"byte_end":3244667,"line_start":1250,"line_end":1250,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3244668,"byte_end":3244702,"line_start":1251,"line_end":1251,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3244758,"byte_end":3244789,"line_start":1253,"line_end":1253,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3244790,"byte_end":3244839,"line_start":1254,"line_end":1254,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8863},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3245760,"byte_end":3245784,"line_start":1279,"line_end":1279,"column_start":15,"column_end":39},"name":"_mm256_mask_i32gather_ps","qualname":"::core_arch::x86::avx2::_mm256_mask_i32gather_ps","value":"fn (src: __m256, slice: *const f32, offsets: __m256i, mask: __m256, scale: i32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3245564,"byte_end":3245573,"line_start":1274,"line_end":1274,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3245574,"byte_end":3245608,"line_start":1275,"line_end":1275,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3245664,"byte_end":3245695,"line_start":1277,"line_end":1277,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3245696,"byte_end":3245745,"line_start":1278,"line_end":1278,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8865},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3246564,"byte_end":3246583,"line_start":1306,"line_end":1306,"column_start":15,"column_end":34},"name":"_mm_i32gather_epi64","qualname":"::core_arch::x86::avx2::_mm_i32gather_epi64","value":"fn (slice: *const i64, offsets: __m128i, scale: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3246368,"byte_end":3246377,"line_start":1301,"line_end":1301,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3246378,"byte_end":3246412,"line_start":1302,"line_end":1302,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3246468,"byte_end":3246499,"line_start":1304,"line_end":1304,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3246500,"byte_end":3246549,"line_start":1305,"line_end":1305,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8867},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3247516,"byte_end":3247540,"line_start":1331,"line_end":1331,"column_start":15,"column_end":39},"name":"_mm_mask_i32gather_epi64","qualname":"::core_arch::x86::avx2::_mm_mask_i32gather_epi64","value":"fn (src: __m128i, slice: *const i64, offsets: __m128i, mask: __m128i, scale: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3247320,"byte_end":3247329,"line_start":1326,"line_end":1326,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3247330,"byte_end":3247364,"line_start":1327,"line_end":1327,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3247420,"byte_end":3247451,"line_start":1329,"line_end":1329,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3247452,"byte_end":3247501,"line_start":1330,"line_end":1330,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8869},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3248412,"byte_end":3248434,"line_start":1361,"line_end":1361,"column_start":15,"column_end":37},"name":"_mm256_i32gather_epi64","qualname":"::core_arch::x86::avx2::_mm256_i32gather_epi64","value":"fn (slice: *const i64, offsets: __m128i, scale: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3248216,"byte_end":3248225,"line_start":1356,"line_end":1356,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3248226,"byte_end":3248260,"line_start":1357,"line_end":1357,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3248316,"byte_end":3248347,"line_start":1359,"line_end":1359,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3248348,"byte_end":3248397,"line_start":1360,"line_end":1360,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8871},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3249377,"byte_end":3249404,"line_start":1386,"line_end":1386,"column_start":15,"column_end":42},"name":"_mm256_mask_i32gather_epi64","qualname":"::core_arch::x86::avx2::_mm256_mask_i32gather_epi64","value":"fn (src: __m256i, slice: *const i64, offsets: __m128i, mask: __m256i, scale: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3249181,"byte_end":3249190,"line_start":1381,"line_end":1381,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3249191,"byte_end":3249225,"line_start":1382,"line_end":1382,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3249281,"byte_end":3249312,"line_start":1384,"line_end":1384,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3249313,"byte_end":3249362,"line_start":1385,"line_end":1385,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8873},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3250271,"byte_end":3250287,"line_start":1416,"line_end":1416,"column_start":15,"column_end":31},"name":"_mm_i32gather_pd","qualname":"::core_arch::x86::avx2::_mm_i32gather_pd","value":"fn (slice: *const f64, offsets: __m128i, scale: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3250075,"byte_end":3250084,"line_start":1411,"line_end":1411,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3250085,"byte_end":3250119,"line_start":1412,"line_end":1412,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3250175,"byte_end":3250206,"line_start":1414,"line_end":1414,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3250207,"byte_end":3250256,"line_start":1415,"line_end":1415,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8875},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3251165,"byte_end":3251186,"line_start":1440,"line_end":1440,"column_start":15,"column_end":36},"name":"_mm_mask_i32gather_pd","qualname":"::core_arch::x86::avx2::_mm_mask_i32gather_pd","value":"fn (src: __m128d, slice: *const f64, offsets: __m128i, mask: __m128d, scale: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3250969,"byte_end":3250978,"line_start":1435,"line_end":1435,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3250979,"byte_end":3251013,"line_start":1436,"line_end":1436,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3251069,"byte_end":3251100,"line_start":1438,"line_end":1438,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3251101,"byte_end":3251150,"line_start":1439,"line_end":1439,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8877},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3251968,"byte_end":3251987,"line_start":1467,"line_end":1467,"column_start":15,"column_end":34},"name":"_mm256_i32gather_pd","qualname":"::core_arch::x86::avx2::_mm256_i32gather_pd","value":"fn (slice: *const f64, offsets: __m128i, scale: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3251772,"byte_end":3251781,"line_start":1462,"line_end":1462,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3251782,"byte_end":3251816,"line_start":1463,"line_end":1463,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3251872,"byte_end":3251903,"line_start":1465,"line_end":1465,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3251904,"byte_end":3251953,"line_start":1466,"line_end":1466,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8879},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3252875,"byte_end":3252899,"line_start":1491,"line_end":1491,"column_start":15,"column_end":39},"name":"_mm256_mask_i32gather_pd","qualname":"::core_arch::x86::avx2::_mm256_mask_i32gather_pd","value":"fn (src: __m256d, slice: *const f64, offsets: __m128i, mask: __m256d, scale: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3252679,"byte_end":3252688,"line_start":1486,"line_end":1486,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3252689,"byte_end":3252723,"line_start":1487,"line_end":1487,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3252779,"byte_end":3252810,"line_start":1489,"line_end":1489,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3252811,"byte_end":3252860,"line_start":1490,"line_end":1490,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8881},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3253682,"byte_end":3253701,"line_start":1518,"line_end":1518,"column_start":15,"column_end":34},"name":"_mm_i64gather_epi32","qualname":"::core_arch::x86::avx2::_mm_i64gather_epi32","value":"fn (slice: *const i32, offsets: __m128i, scale: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3253486,"byte_end":3253495,"line_start":1513,"line_end":1513,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3253496,"byte_end":3253530,"line_start":1514,"line_end":1514,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3253586,"byte_end":3253617,"line_start":1516,"line_end":1516,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3253618,"byte_end":3253667,"line_start":1517,"line_end":1517,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8883},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3254634,"byte_end":3254658,"line_start":1543,"line_end":1543,"column_start":15,"column_end":39},"name":"_mm_mask_i64gather_epi32","qualname":"::core_arch::x86::avx2::_mm_mask_i64gather_epi32","value":"fn (src: __m128i, slice: *const i32, offsets: __m128i, mask: __m128i, scale: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3254438,"byte_end":3254447,"line_start":1538,"line_end":1538,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3254448,"byte_end":3254482,"line_start":1539,"line_end":1539,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3254538,"byte_end":3254569,"line_start":1541,"line_end":1541,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3254570,"byte_end":3254619,"line_start":1542,"line_end":1542,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8885},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3255530,"byte_end":3255552,"line_start":1573,"line_end":1573,"column_start":15,"column_end":37},"name":"_mm256_i64gather_epi32","qualname":"::core_arch::x86::avx2::_mm256_i64gather_epi32","value":"fn (slice: *const i32, offsets: __m256i, scale: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3255334,"byte_end":3255343,"line_start":1568,"line_end":1568,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3255344,"byte_end":3255378,"line_start":1569,"line_end":1569,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3255434,"byte_end":3255465,"line_start":1571,"line_end":1571,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3255466,"byte_end":3255515,"line_start":1572,"line_end":1572,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8887},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3256489,"byte_end":3256516,"line_start":1598,"line_end":1598,"column_start":15,"column_end":42},"name":"_mm256_mask_i64gather_epi32","qualname":"::core_arch::x86::avx2::_mm256_mask_i64gather_epi32","value":"fn (src: __m128i, slice: *const i32, offsets: __m256i, mask: __m128i, scale: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3256293,"byte_end":3256302,"line_start":1593,"line_end":1593,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3256303,"byte_end":3256337,"line_start":1594,"line_end":1594,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3256393,"byte_end":3256424,"line_start":1596,"line_end":1596,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3256425,"byte_end":3256474,"line_start":1597,"line_end":1597,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8889},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3257383,"byte_end":3257399,"line_start":1628,"line_end":1628,"column_start":15,"column_end":31},"name":"_mm_i64gather_ps","qualname":"::core_arch::x86::avx2::_mm_i64gather_ps","value":"fn (slice: *const f32, offsets: __m128i, scale: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3257187,"byte_end":3257196,"line_start":1623,"line_end":1623,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3257197,"byte_end":3257231,"line_start":1624,"line_end":1624,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3257287,"byte_end":3257318,"line_start":1626,"line_end":1626,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3257319,"byte_end":3257368,"line_start":1627,"line_end":1627,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8891},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3258276,"byte_end":3258297,"line_start":1652,"line_end":1652,"column_start":15,"column_end":36},"name":"_mm_mask_i64gather_ps","qualname":"::core_arch::x86::avx2::_mm_mask_i64gather_ps","value":"fn (src: __m128, slice: *const f32, offsets: __m128i, mask: __m128, scale: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3258080,"byte_end":3258089,"line_start":1647,"line_end":1647,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3258090,"byte_end":3258124,"line_start":1648,"line_end":1648,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3258180,"byte_end":3258211,"line_start":1650,"line_end":1650,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3258212,"byte_end":3258261,"line_start":1651,"line_end":1651,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8893},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3259076,"byte_end":3259095,"line_start":1679,"line_end":1679,"column_start":15,"column_end":34},"name":"_mm256_i64gather_ps","qualname":"::core_arch::x86::avx2::_mm256_i64gather_ps","value":"fn (slice: *const f32, offsets: __m256i, scale: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3258880,"byte_end":3258889,"line_start":1674,"line_end":1674,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3258890,"byte_end":3258924,"line_start":1675,"line_end":1675,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3258980,"byte_end":3259011,"line_start":1677,"line_end":1677,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3259012,"byte_end":3259061,"line_start":1678,"line_end":1678,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8895},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3259976,"byte_end":3260000,"line_start":1703,"line_end":1703,"column_start":15,"column_end":39},"name":"_mm256_mask_i64gather_ps","qualname":"::core_arch::x86::avx2::_mm256_mask_i64gather_ps","value":"fn (src: __m128, slice: *const f32, offsets: __m256i, mask: __m128, scale: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3259780,"byte_end":3259789,"line_start":1698,"line_end":1698,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3259790,"byte_end":3259824,"line_start":1699,"line_end":1699,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3259880,"byte_end":3259911,"line_start":1701,"line_end":1701,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3259912,"byte_end":3259961,"line_start":1702,"line_end":1702,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8897},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3260780,"byte_end":3260799,"line_start":1730,"line_end":1730,"column_start":15,"column_end":34},"name":"_mm_i64gather_epi64","qualname":"::core_arch::x86::avx2::_mm_i64gather_epi64","value":"fn (slice: *const i64, offsets: __m128i, scale: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3260584,"byte_end":3260593,"line_start":1725,"line_end":1725,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3260594,"byte_end":3260628,"line_start":1726,"line_end":1726,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3260684,"byte_end":3260715,"line_start":1728,"line_end":1728,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3260716,"byte_end":3260765,"line_start":1729,"line_end":1729,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8899},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3261732,"byte_end":3261756,"line_start":1755,"line_end":1755,"column_start":15,"column_end":39},"name":"_mm_mask_i64gather_epi64","qualname":"::core_arch::x86::avx2::_mm_mask_i64gather_epi64","value":"fn (src: __m128i, slice: *const i64, offsets: __m128i, mask: __m128i, scale: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3261536,"byte_end":3261545,"line_start":1750,"line_end":1750,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3261546,"byte_end":3261580,"line_start":1751,"line_end":1751,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3261636,"byte_end":3261667,"line_start":1753,"line_end":1753,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3261668,"byte_end":3261717,"line_start":1754,"line_end":1754,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8901},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3262628,"byte_end":3262650,"line_start":1785,"line_end":1785,"column_start":15,"column_end":37},"name":"_mm256_i64gather_epi64","qualname":"::core_arch::x86::avx2::_mm256_i64gather_epi64","value":"fn (slice: *const i64, offsets: __m256i, scale: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3262432,"byte_end":3262441,"line_start":1780,"line_end":1780,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3262442,"byte_end":3262476,"line_start":1781,"line_end":1781,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3262532,"byte_end":3262563,"line_start":1783,"line_end":1783,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3262564,"byte_end":3262613,"line_start":1784,"line_end":1784,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8903},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3263593,"byte_end":3263620,"line_start":1810,"line_end":1810,"column_start":15,"column_end":42},"name":"_mm256_mask_i64gather_epi64","qualname":"::core_arch::x86::avx2::_mm256_mask_i64gather_epi64","value":"fn (src: __m256i, slice: *const i64, offsets: __m256i, mask: __m256i, scale: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3263397,"byte_end":3263406,"line_start":1805,"line_end":1805,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3263407,"byte_end":3263441,"line_start":1806,"line_end":1806,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3263497,"byte_end":3263528,"line_start":1808,"line_end":1808,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3263529,"byte_end":3263578,"line_start":1809,"line_end":1809,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8905},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3264487,"byte_end":3264503,"line_start":1840,"line_end":1840,"column_start":15,"column_end":31},"name":"_mm_i64gather_pd","qualname":"::core_arch::x86::avx2::_mm_i64gather_pd","value":"fn (slice: *const f64, offsets: __m128i, scale: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3264291,"byte_end":3264300,"line_start":1835,"line_end":1835,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3264301,"byte_end":3264335,"line_start":1836,"line_end":1836,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3264391,"byte_end":3264422,"line_start":1838,"line_end":1838,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3264423,"byte_end":3264472,"line_start":1839,"line_end":1839,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8907},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3265381,"byte_end":3265402,"line_start":1864,"line_end":1864,"column_start":15,"column_end":36},"name":"_mm_mask_i64gather_pd","qualname":"::core_arch::x86::avx2::_mm_mask_i64gather_pd","value":"fn (src: __m128d, slice: *const f64, offsets: __m128i, mask: __m128d, scale: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3265185,"byte_end":3265194,"line_start":1859,"line_end":1859,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3265195,"byte_end":3265229,"line_start":1860,"line_end":1860,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3265285,"byte_end":3265316,"line_start":1862,"line_end":1862,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3265317,"byte_end":3265366,"line_start":1863,"line_end":1863,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8909},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3266184,"byte_end":3266203,"line_start":1891,"line_end":1891,"column_start":15,"column_end":34},"name":"_mm256_i64gather_pd","qualname":"::core_arch::x86::avx2::_mm256_i64gather_pd","value":"fn (slice: *const f64, offsets: __m256i, scale: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3265988,"byte_end":3265997,"line_start":1886,"line_end":1886,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3265998,"byte_end":3266032,"line_start":1887,"line_end":1887,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3266088,"byte_end":3266119,"line_start":1889,"line_end":1889,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3266120,"byte_end":3266169,"line_start":1890,"line_end":1890,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8911},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3267091,"byte_end":3267115,"line_start":1915,"line_end":1915,"column_start":15,"column_end":39},"name":"_mm256_mask_i64gather_pd","qualname":"::core_arch::x86::avx2::_mm256_mask_i64gather_pd","value":"fn (src: __m256d, slice: *const f64, offsets: __m256i, mask: __m256d, scale: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3266895,"byte_end":3266904,"line_start":1910,"line_end":1910,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3266905,"byte_end":3266939,"line_start":1911,"line_end":1911,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3266995,"byte_end":3267026,"line_start":1913,"line_end":1913,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3267027,"byte_end":3267076,"line_start":1914,"line_end":1914,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8913},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3267941,"byte_end":3267964,"line_start":1944,"line_end":1944,"column_start":15,"column_end":38},"name":"_mm256_inserti128_si256","qualname":"::core_arch::x86::avx2::_mm256_inserti128_si256","value":"fn (a: __m256i, b: __m128i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Copies `a` to `dst`, then insert 128 bits (of integer data) from `b` at the\n location specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3267702,"byte_end":3267711,"line_start":1936,"line_end":1936,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3267712,"byte_end":3267746,"line_start":1937,"line_end":1937,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3267845,"byte_end":3267876,"line_start":1942,"line_end":1942,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3267877,"byte_end":3267926,"line_start":1943,"line_end":1943,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8914},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3268705,"byte_end":3268722,"line_start":1963,"line_end":1963,"column_start":15,"column_end":32},"name":"_mm256_madd_epi16","qualname":"::core_arch::x86::avx2::_mm256_madd_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed signed 16-bit integers in `a` and `b`, producing\n intermediate signed 32-bit integers. Horizontally add adjacent pairs\n of intermediate 32-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3268554,"byte_end":3268563,"line_start":1959,"line_end":1959,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3268564,"byte_end":3268598,"line_start":1960,"line_end":1960,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3268641,"byte_end":3268690,"line_start":1962,"line_end":1962,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8915},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3269337,"byte_end":3269357,"line_start":1977,"line_end":1977,"column_start":15,"column_end":35},"name":"_mm256_maddubs_epi16","qualname":"::core_arch::x86::avx2::_mm256_maddubs_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Vertically multiplies each unsigned 8-bit integer from `a` with the\n corresponding signed 8-bit integer from `b`, producing intermediate\n signed 16-bit integers. Horizontally add adjacent pairs of intermediate\n signed 16-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3269184,"byte_end":3269193,"line_start":1973,"line_end":1973,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3269194,"byte_end":3269228,"line_start":1974,"line_end":1974,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3269273,"byte_end":3269322,"line_start":1976,"line_end":1976,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8916},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3269899,"byte_end":3269917,"line_start":1990,"line_end":1990,"column_start":15,"column_end":33},"name":"_mm_maskload_epi32","qualname":"::core_arch::x86::avx2::_mm_maskload_epi32","value":"fn (mem_addr: *const i32, mask: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Loads packed 32-bit integers from memory pointed by `mem_addr` using `mask`\n (elements are zeroed out when the highest bit is not set in the\n corresponding element).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3269746,"byte_end":3269755,"line_start":1986,"line_end":1986,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3269756,"byte_end":3269790,"line_start":1987,"line_end":1987,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3269835,"byte_end":3269884,"line_start":1989,"line_end":1989,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8917},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3270487,"byte_end":3270508,"line_start":2003,"line_end":2003,"column_start":15,"column_end":36},"name":"_mm256_maskload_epi32","qualname":"::core_arch::x86::avx2::_mm256_maskload_epi32","value":"fn (mem_addr: *const i32, mask: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Loads packed 32-bit integers from memory pointed by `mem_addr` using `mask`\n (elements are zeroed out when the highest bit is not set in the\n corresponding element).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3270334,"byte_end":3270343,"line_start":1999,"line_end":1999,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3270344,"byte_end":3270378,"line_start":2000,"line_end":2000,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3270423,"byte_end":3270472,"line_start":2002,"line_end":2002,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8918},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3271078,"byte_end":3271096,"line_start":2016,"line_end":2016,"column_start":15,"column_end":33},"name":"_mm_maskload_epi64","qualname":"::core_arch::x86::avx2::_mm_maskload_epi64","value":"fn (mem_addr: *const i64, mask: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Loads packed 64-bit integers from memory pointed by `mem_addr` using `mask`\n (elements are zeroed out when the highest bit is not set in the\n corresponding element).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3270925,"byte_end":3270934,"line_start":2012,"line_end":2012,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3270935,"byte_end":3270969,"line_start":2013,"line_end":2013,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3271014,"byte_end":3271063,"line_start":2015,"line_end":2015,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8919},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3271666,"byte_end":3271687,"line_start":2029,"line_end":2029,"column_start":15,"column_end":36},"name":"_mm256_maskload_epi64","qualname":"::core_arch::x86::avx2::_mm256_maskload_epi64","value":"fn (mem_addr: *const i64, mask: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Loads packed 64-bit integers from memory pointed by `mem_addr` using `mask`\n (elements are zeroed out when the highest bit is not set in the\n corresponding element).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3271513,"byte_end":3271522,"line_start":2025,"line_end":2025,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3271523,"byte_end":3271557,"line_start":2026,"line_end":2026,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3271602,"byte_end":3271651,"line_start":2028,"line_end":2028,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8920},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3272268,"byte_end":3272287,"line_start":2042,"line_end":2042,"column_start":15,"column_end":34},"name":"_mm_maskstore_epi32","qualname":"::core_arch::x86::avx2::_mm_maskstore_epi32","value":"fn (mem_addr: *mut i32, mask: __m128i, a: __m128i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores packed 32-bit integers from `a` into memory pointed by `mem_addr`\n using `mask` (elements are not stored when the highest bit is not set\n in the corresponding element).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3272115,"byte_end":3272124,"line_start":2038,"line_end":2038,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3272125,"byte_end":3272159,"line_start":2039,"line_end":2039,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3272204,"byte_end":3272253,"line_start":2041,"line_end":2041,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8921},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3272869,"byte_end":3272891,"line_start":2055,"line_end":2055,"column_start":15,"column_end":37},"name":"_mm256_maskstore_epi32","qualname":"::core_arch::x86::avx2::_mm256_maskstore_epi32","value":"fn (mem_addr: *mut i32, mask: __m256i, a: __m256i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores packed 32-bit integers from `a` into memory pointed by `mem_addr`\n using `mask` (elements are not stored when the highest bit is not set\n in the corresponding element).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3272716,"byte_end":3272725,"line_start":2051,"line_end":2051,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3272726,"byte_end":3272760,"line_start":2052,"line_end":2052,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3272805,"byte_end":3272854,"line_start":2054,"line_end":2054,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8922},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3273473,"byte_end":3273492,"line_start":2068,"line_end":2068,"column_start":15,"column_end":34},"name":"_mm_maskstore_epi64","qualname":"::core_arch::x86::avx2::_mm_maskstore_epi64","value":"fn (mem_addr: *mut i64, mask: __m128i, a: __m128i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores packed 64-bit integers from `a` into memory pointed by `mem_addr`\n using `mask` (elements are not stored when the highest bit is not set\n in the corresponding element).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3273320,"byte_end":3273329,"line_start":2064,"line_end":2064,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3273330,"byte_end":3273364,"line_start":2065,"line_end":2065,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3273409,"byte_end":3273458,"line_start":2067,"line_end":2067,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8923},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3274074,"byte_end":3274096,"line_start":2081,"line_end":2081,"column_start":15,"column_end":37},"name":"_mm256_maskstore_epi64","qualname":"::core_arch::x86::avx2::_mm256_maskstore_epi64","value":"fn (mem_addr: *mut i64, mask: __m256i, a: __m256i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores packed 64-bit integers from `a` into memory pointed by `mem_addr`\n using `mask` (elements are not stored when the highest bit is not set\n in the corresponding element).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3273921,"byte_end":3273930,"line_start":2077,"line_end":2077,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3273931,"byte_end":3273965,"line_start":2078,"line_end":2078,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3274010,"byte_end":3274059,"line_start":2080,"line_end":2080,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8924},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3274581,"byte_end":3274597,"line_start":2093,"line_end":2093,"column_start":15,"column_end":31},"name":"_mm256_max_epi16","qualname":"::core_arch::x86::avx2::_mm256_max_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 16-bit integers in `a` and `b`, and returns the packed\n maximum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3274431,"byte_end":3274440,"line_start":2089,"line_end":2089,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3274441,"byte_end":3274475,"line_start":2090,"line_end":2090,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3274517,"byte_end":3274566,"line_start":2092,"line_end":2092,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8925},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3275052,"byte_end":3275068,"line_start":2105,"line_end":2105,"column_start":15,"column_end":31},"name":"_mm256_max_epi32","qualname":"::core_arch::x86::avx2::_mm256_max_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 32-bit integers in `a` and `b`, and returns the packed\n maximum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3274902,"byte_end":3274911,"line_start":2101,"line_end":2101,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3274912,"byte_end":3274946,"line_start":2102,"line_end":2102,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3274988,"byte_end":3275037,"line_start":2104,"line_end":2104,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8926},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3275519,"byte_end":3275534,"line_start":2117,"line_end":2117,"column_start":15,"column_end":30},"name":"_mm256_max_epi8","qualname":"::core_arch::x86::avx2::_mm256_max_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 8-bit integers in `a` and `b`, and returns the packed\n maximum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3275369,"byte_end":3275378,"line_start":2113,"line_end":2113,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3275379,"byte_end":3275413,"line_start":2114,"line_end":2114,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3275455,"byte_end":3275504,"line_start":2116,"line_end":2116,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8927},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3275996,"byte_end":3276012,"line_start":2129,"line_end":2129,"column_start":15,"column_end":31},"name":"_mm256_max_epu16","qualname":"::core_arch::x86::avx2::_mm256_max_epu16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 16-bit integers in `a` and `b`, and returns\n the packed maximum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3275846,"byte_end":3275855,"line_start":2125,"line_end":2125,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3275856,"byte_end":3275890,"line_start":2126,"line_end":2126,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3275932,"byte_end":3275981,"line_start":2128,"line_end":2128,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8928},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3276476,"byte_end":3276492,"line_start":2141,"line_end":2141,"column_start":15,"column_end":31},"name":"_mm256_max_epu32","qualname":"::core_arch::x86::avx2::_mm256_max_epu32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 32-bit integers in `a` and `b`, and returns\n the packed maximum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3276326,"byte_end":3276335,"line_start":2137,"line_end":2137,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3276336,"byte_end":3276370,"line_start":2138,"line_end":2138,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3276412,"byte_end":3276461,"line_start":2140,"line_end":2140,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8929},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3276952,"byte_end":3276967,"line_start":2153,"line_end":2153,"column_start":15,"column_end":30},"name":"_mm256_max_epu8","qualname":"::core_arch::x86::avx2::_mm256_max_epu8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 8-bit integers in `a` and `b`, and returns\n the packed maximum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3276802,"byte_end":3276811,"line_start":2149,"line_end":2149,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3276812,"byte_end":3276846,"line_start":2150,"line_end":2150,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3276888,"byte_end":3276937,"line_start":2152,"line_end":2152,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8930},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3277420,"byte_end":3277436,"line_start":2165,"line_end":2165,"column_start":15,"column_end":31},"name":"_mm256_min_epi16","qualname":"::core_arch::x86::avx2::_mm256_min_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 16-bit integers in `a` and `b`, and returns the packed\n minimum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3277270,"byte_end":3277279,"line_start":2161,"line_end":2161,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3277280,"byte_end":3277314,"line_start":2162,"line_end":2162,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3277356,"byte_end":3277405,"line_start":2164,"line_end":2164,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8931},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3277891,"byte_end":3277907,"line_start":2177,"line_end":2177,"column_start":15,"column_end":31},"name":"_mm256_min_epi32","qualname":"::core_arch::x86::avx2::_mm256_min_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 32-bit integers in `a` and `b`, and returns the packed\n minimum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3277741,"byte_end":3277750,"line_start":2173,"line_end":2173,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3277751,"byte_end":3277785,"line_start":2174,"line_end":2174,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3277827,"byte_end":3277876,"line_start":2176,"line_end":2176,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8932},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3278358,"byte_end":3278373,"line_start":2189,"line_end":2189,"column_start":15,"column_end":30},"name":"_mm256_min_epi8","qualname":"::core_arch::x86::avx2::_mm256_min_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 8-bit integers in `a` and `b`, and returns the packed\n minimum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3278208,"byte_end":3278217,"line_start":2185,"line_end":2185,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3278218,"byte_end":3278252,"line_start":2186,"line_end":2186,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3278294,"byte_end":3278343,"line_start":2188,"line_end":2188,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8933},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3278835,"byte_end":3278851,"line_start":2201,"line_end":2201,"column_start":15,"column_end":31},"name":"_mm256_min_epu16","qualname":"::core_arch::x86::avx2::_mm256_min_epu16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 16-bit integers in `a` and `b`, and returns\n the packed minimum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3278685,"byte_end":3278694,"line_start":2197,"line_end":2197,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3278695,"byte_end":3278729,"line_start":2198,"line_end":2198,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3278771,"byte_end":3278820,"line_start":2200,"line_end":2200,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8934},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3279315,"byte_end":3279331,"line_start":2213,"line_end":2213,"column_start":15,"column_end":31},"name":"_mm256_min_epu32","qualname":"::core_arch::x86::avx2::_mm256_min_epu32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 32-bit integers in `a` and `b`, and returns\n the packed minimum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3279165,"byte_end":3279174,"line_start":2209,"line_end":2209,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3279175,"byte_end":3279209,"line_start":2210,"line_end":2210,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3279251,"byte_end":3279300,"line_start":2212,"line_end":2212,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8935},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3279791,"byte_end":3279806,"line_start":2225,"line_end":2225,"column_start":15,"column_end":30},"name":"_mm256_min_epu8","qualname":"::core_arch::x86::avx2::_mm256_min_epu8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 8-bit integers in `a` and `b`, and returns\n the packed minimum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3279641,"byte_end":3279650,"line_start":2221,"line_end":2221,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3279651,"byte_end":3279685,"line_start":2222,"line_end":2222,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3279727,"byte_end":3279776,"line_start":2224,"line_end":2224,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8936},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3280270,"byte_end":3280290,"line_start":2237,"line_end":2237,"column_start":15,"column_end":35},"name":"_mm256_movemask_epi8","qualname":"::core_arch::x86::avx2::_mm256_movemask_epi8","value":"fn (a: __m256i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Creates mask from the most significant bit of each 8-bit element in `a`,\n return the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3280118,"byte_end":3280127,"line_start":2233,"line_end":2233,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3280128,"byte_end":3280162,"line_start":2234,"line_end":2234,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3280206,"byte_end":3280255,"line_start":2236,"line_end":2236,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8937},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3281158,"byte_end":3281177,"line_start":2255,"line_end":2255,"column_start":15,"column_end":34},"name":"_mm256_mpsadbw_epu8","qualname":"::core_arch::x86::avx2::_mm256_mpsadbw_epu8","value":"fn (a: __m256i, b: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Computes the sum of absolute differences (SADs) of quadruplets of unsigned\n 8-bit integers in `a` compared to those in `b`, and stores the 16-bit\n results in dst. Eight SADs are performed for each 128-bit lane using one\n quadruplet from `b` and eight quadruplets from `a`. One quadruplet is\n selected from `b` starting at on the offset specified in `imm8`. Eight\n quadruplets are formed from sequential 8-bit integers selected from `a`\n starting at the offset specified in `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3280965,"byte_end":3280974,"line_start":2250,"line_end":2250,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3280975,"byte_end":3281009,"line_start":2251,"line_end":2251,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3281062,"byte_end":3281093,"line_start":2253,"line_end":2253,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3281094,"byte_end":3281143,"line_start":2254,"line_end":2254,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8939},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3281831,"byte_end":3281847,"line_start":2277,"line_end":2277,"column_start":15,"column_end":31},"name":"_mm256_mul_epi32","qualname":"::core_arch::x86::avx2::_mm256_mul_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the low 32-bit integers from each packed 64-bit element in\n `a` and `b`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3281681,"byte_end":3281690,"line_start":2273,"line_end":2273,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3281691,"byte_end":3281725,"line_start":2274,"line_end":2274,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3281767,"byte_end":3281816,"line_start":2276,"line_end":2276,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8940},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3282350,"byte_end":3282366,"line_start":2291,"line_end":2291,"column_start":15,"column_end":31},"name":"_mm256_mul_epu32","qualname":"::core_arch::x86::avx2::_mm256_mul_epu32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the low unsigned 32-bit integers from each packed 64-bit\n element in `a` and `b`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3282199,"byte_end":3282208,"line_start":2287,"line_end":2287,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3282209,"byte_end":3282243,"line_start":2288,"line_end":2288,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3282286,"byte_end":3282335,"line_start":2290,"line_end":2290,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8941},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3282893,"byte_end":3282911,"line_start":2304,"line_end":2304,"column_start":15,"column_end":33},"name":"_mm256_mulhi_epi16","qualname":"::core_arch::x86::avx2::_mm256_mulhi_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the packed 16-bit integers in `a` and `b`, producing\n intermediate 32-bit integers and returning the high 16 bits of the\n intermediate integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3282743,"byte_end":3282752,"line_start":2300,"line_end":2300,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3282753,"byte_end":3282787,"line_start":2301,"line_end":2301,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3282829,"byte_end":3282878,"line_start":2303,"line_end":2303,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8942},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3283449,"byte_end":3283467,"line_start":2317,"line_end":2317,"column_start":15,"column_end":33},"name":"_mm256_mulhi_epu16","qualname":"::core_arch::x86::avx2::_mm256_mulhi_epu16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the packed unsigned 16-bit integers in `a` and `b`, producing\n intermediate 32-bit integers and returning the high 16 bits of the\n intermediate integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3283298,"byte_end":3283307,"line_start":2313,"line_end":2313,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3283308,"byte_end":3283342,"line_start":2314,"line_end":2314,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3283385,"byte_end":3283434,"line_start":2316,"line_end":2316,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8943},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3283993,"byte_end":3284011,"line_start":2330,"line_end":2330,"column_start":15,"column_end":33},"name":"_mm256_mullo_epi16","qualname":"::core_arch::x86::avx2::_mm256_mullo_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the packed 16-bit integers in `a` and `b`, producing\n intermediate 32-bit integers, and returns the low 16 bits of the\n intermediate integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3283843,"byte_end":3283852,"line_start":2326,"line_end":2326,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3283853,"byte_end":3283887,"line_start":2327,"line_end":2327,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3283929,"byte_end":3283978,"line_start":2329,"line_end":2329,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8944},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3284538,"byte_end":3284556,"line_start":2343,"line_end":2343,"column_start":15,"column_end":33},"name":"_mm256_mullo_epi32","qualname":"::core_arch::x86::avx2::_mm256_mullo_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the packed 32-bit integers in `a` and `b`, producing\n intermediate 64-bit integers, and returns the low 16 bits of the\n intermediate integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3284388,"byte_end":3284397,"line_start":2339,"line_end":2339,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3284398,"byte_end":3284432,"line_start":2340,"line_end":2340,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3284474,"byte_end":3284523,"line_start":2342,"line_end":2342,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8945},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3285147,"byte_end":3285166,"line_start":2357,"line_end":2357,"column_start":15,"column_end":34},"name":"_mm256_mulhrs_epi16","qualname":"::core_arch::x86::avx2::_mm256_mulhrs_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed 16-bit integers in `a` and `b`, producing\n intermediate signed 32-bit integers. Truncate each intermediate\n integer to the 18 most significant bits, round by adding 1, and\n return bits `[16:1]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3284995,"byte_end":3285004,"line_start":2353,"line_end":2353,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3285005,"byte_end":3285039,"line_start":2354,"line_end":2354,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3285083,"byte_end":3285132,"line_start":2356,"line_end":2356,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8946},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3285612,"byte_end":3285627,"line_start":2369,"line_end":2369,"column_start":15,"column_end":30},"name":"_mm256_or_si256","qualname":"::core_arch::x86::avx2::_mm256_or_si256","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise OR of 256 bits (representing integer data) in `a`\n and `b`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3285464,"byte_end":3285473,"line_start":2365,"line_end":2365,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3285474,"byte_end":3285508,"line_start":2366,"line_end":2366,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3285548,"byte_end":3285597,"line_start":2368,"line_end":2368,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8947},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3286096,"byte_end":3286114,"line_start":2381,"line_end":2381,"column_start":15,"column_end":33},"name":"_mm256_packs_epi16","qualname":"::core_arch::x86::avx2::_mm256_packs_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers\n using signed saturation","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3285944,"byte_end":3285953,"line_start":2377,"line_end":2377,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3285954,"byte_end":3285988,"line_start":2378,"line_end":2378,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3286032,"byte_end":3286081,"line_start":2380,"line_end":2380,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8948},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3286587,"byte_end":3286605,"line_start":2393,"line_end":2393,"column_start":15,"column_end":33},"name":"_mm256_packs_epi32","qualname":"::core_arch::x86::avx2::_mm256_packs_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers\n using signed saturation","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3286435,"byte_end":3286444,"line_start":2389,"line_end":2389,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3286445,"byte_end":3286479,"line_start":2390,"line_end":2390,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3286523,"byte_end":3286572,"line_start":2392,"line_end":2392,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8949},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3287078,"byte_end":3287097,"line_start":2405,"line_end":2405,"column_start":15,"column_end":34},"name":"_mm256_packus_epi16","qualname":"::core_arch::x86::avx2::_mm256_packus_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers\n using unsigned saturation","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3286926,"byte_end":3286935,"line_start":2401,"line_end":2401,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3286936,"byte_end":3286970,"line_start":2402,"line_end":2402,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3287014,"byte_end":3287063,"line_start":2404,"line_end":2404,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8950},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3287573,"byte_end":3287592,"line_start":2417,"line_end":2417,"column_start":15,"column_end":34},"name":"_mm256_packus_epi32","qualname":"::core_arch::x86::avx2::_mm256_packus_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers\n using unsigned saturation","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3287421,"byte_end":3287430,"line_start":2413,"line_end":2413,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3287431,"byte_end":3287465,"line_start":2414,"line_end":2414,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3287509,"byte_end":3287558,"line_start":2416,"line_end":2416,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8951},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3288142,"byte_end":3288169,"line_start":2431,"line_end":2431,"column_start":15,"column_end":42},"name":"_mm256_permutevar8x32_epi32","qualname":"::core_arch::x86::avx2::_mm256_permutevar8x32_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Permutes packed 32-bit integers from `a` according to the content of `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3287992,"byte_end":3288001,"line_start":2427,"line_end":2427,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3288002,"byte_end":3288036,"line_start":2428,"line_end":2428,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3288078,"byte_end":3288127,"line_start":2430,"line_end":2430,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8952},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3288641,"byte_end":3288665,"line_start":2443,"line_end":2443,"column_start":15,"column_end":39},"name":"_mm256_permute4x64_epi64","qualname":"::core_arch::x86::avx2::_mm256_permute4x64_epi64","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Permutes 64-bit integers from `a` using control mask `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3288449,"byte_end":3288458,"line_start":2438,"line_end":2438,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3288459,"byte_end":3288493,"line_start":2439,"line_end":2439,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3288545,"byte_end":3288576,"line_start":2441,"line_end":2441,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3288577,"byte_end":3288626,"line_start":2442,"line_end":2442,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8957},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3290475,"byte_end":3290500,"line_start":2499,"line_end":2499,"column_start":15,"column_end":40},"name":"_mm256_permute2x128_si256","qualname":"::core_arch::x86::avx2::_mm256_permute2x128_si256","value":"fn (a: __m256i, b: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 128-bits of integer data selected by `imm8` from `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3290280,"byte_end":3290289,"line_start":2494,"line_end":2494,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3290290,"byte_end":3290324,"line_start":2495,"line_end":2495,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3290379,"byte_end":3290410,"line_start":2497,"line_end":2497,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3290411,"byte_end":3290460,"line_start":2498,"line_end":2498,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8959},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3291160,"byte_end":3291181,"line_start":2519,"line_end":2519,"column_start":15,"column_end":36},"name":"_mm256_permute4x64_pd","qualname":"::core_arch::x86::avx2::_mm256_permute4x64_pd","value":"fn (a: __m256d, imm8: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 64-bit floating-point elements in `a` across lanes using the\n control in `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3290968,"byte_end":3290977,"line_start":2514,"line_end":2514,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3290978,"byte_end":3291012,"line_start":2515,"line_end":2515,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3291064,"byte_end":3291095,"line_start":2517,"line_end":2517,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3291096,"byte_end":3291145,"line_start":2518,"line_end":2518,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8964},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3293069,"byte_end":3293093,"line_start":2573,"line_end":2573,"column_start":15,"column_end":39},"name":"_mm256_permutevar8x32_ps","qualname":"::core_arch::x86::avx2::_mm256_permutevar8x32_ps","value":"fn (a: __m256, idx: __m256i) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Shuffles eight 32-bit foating-point elements in `a` across lanes using\n the corresponding 32-bit integer index in `idx`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3292919,"byte_end":3292928,"line_start":2569,"line_end":2569,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3292929,"byte_end":3292963,"line_start":2570,"line_end":2570,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3293005,"byte_end":3293054,"line_start":2572,"line_end":2572,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8965},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3293711,"byte_end":3293726,"line_start":2587,"line_end":2587,"column_start":15,"column_end":30},"name":"_mm256_sad_epu8","qualname":"::core_arch::x86::avx2::_mm256_sad_epu8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute differences of packed unsigned 8-bit integers in `a`\n and `b`, then horizontally sum each consecutive 8 differences to\n produce four unsigned 16-bit integers, and pack these unsigned 16-bit\n integers in the low 16 bits of the 64-bit return value","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3293561,"byte_end":3293570,"line_start":2583,"line_end":2583,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3293571,"byte_end":3293605,"line_start":2584,"line_end":2584,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3293647,"byte_end":3293696,"line_start":2586,"line_end":2586,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8966},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3295033,"byte_end":3295052,"line_start":2626,"line_end":2626,"column_start":15,"column_end":34},"name":"_mm256_shuffle_epi8","qualname":"::core_arch::x86::avx2::_mm256_shuffle_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shuffles bytes from `a` according to the content of `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3294883,"byte_end":3294892,"line_start":2622,"line_end":2622,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3294893,"byte_end":3294927,"line_start":2623,"line_end":2623,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3294969,"byte_end":3295018,"line_start":2625,"line_end":2625,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8967},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3296368,"byte_end":3296388,"line_start":2665,"line_end":2665,"column_start":15,"column_end":35},"name":"_mm256_shuffle_epi32","qualname":"::core_arch::x86::avx2::_mm256_shuffle_epi32","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 32-bit integers in 128-bit lanes of `a` using the control in\n `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3296174,"byte_end":3296183,"line_start":2660,"line_end":2660,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3296184,"byte_end":3296218,"line_start":2661,"line_end":2661,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3296272,"byte_end":3296303,"line_start":2663,"line_end":2663,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3296304,"byte_end":3296353,"line_start":2664,"line_end":2664,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8972},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3299091,"byte_end":3299113,"line_start":2743,"line_end":2743,"column_start":15,"column_end":37},"name":"_mm256_shufflehi_epi16","qualname":"::core_arch::x86::avx2::_mm256_shufflehi_epi16","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 16-bit integers in the high 64 bits of 128-bit lanes of `a` using\n the control in `imm8`. The low 64 bits of 128-bit lanes of `a` are copied\n to the output.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3298898,"byte_end":3298907,"line_start":2738,"line_end":2738,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3298908,"byte_end":3298942,"line_start":2739,"line_end":2739,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3298995,"byte_end":3299026,"line_start":2741,"line_end":2741,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3299027,"byte_end":3299076,"line_start":2742,"line_end":2742,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8977},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3301303,"byte_end":3301325,"line_start":2804,"line_end":2804,"column_start":15,"column_end":37},"name":"_mm256_shufflelo_epi16","qualname":"::core_arch::x86::avx2::_mm256_shufflelo_epi16","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 16-bit integers in the low 64 bits of 128-bit lanes of `a` using\n the control in `imm8`. The high 64 bits of 128-bit lanes of `a` are copied\n to the output.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3301110,"byte_end":3301119,"line_start":2799,"line_end":2799,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3301120,"byte_end":3301154,"line_start":2800,"line_end":2800,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3301207,"byte_end":3301238,"line_start":2802,"line_end":2802,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3301239,"byte_end":3301288,"line_start":2803,"line_end":2803,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8982},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3303504,"byte_end":3303521,"line_start":2864,"line_end":2864,"column_start":15,"column_end":32},"name":"_mm256_sign_epi16","qualname":"::core_arch::x86::avx2::_mm256_sign_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Negates packed 16-bit integers in `a` when the corresponding signed\n 16-bit integer in `b` is negative, and returns the results.\n Results are zeroed out when the corresponding element in `b` is zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3303354,"byte_end":3303363,"line_start":2860,"line_end":2860,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3303364,"byte_end":3303398,"line_start":2861,"line_end":2861,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3303440,"byte_end":3303489,"line_start":2863,"line_end":2863,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8983},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3304092,"byte_end":3304109,"line_start":2877,"line_end":2877,"column_start":15,"column_end":32},"name":"_mm256_sign_epi32","qualname":"::core_arch::x86::avx2::_mm256_sign_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Negates packed 32-bit integers in `a` when the corresponding signed\n 32-bit integer in `b` is negative, and returns the results.\n Results are zeroed out when the corresponding element in `b` is zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3303942,"byte_end":3303951,"line_start":2873,"line_end":2873,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3303952,"byte_end":3303986,"line_start":2874,"line_end":2874,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3304028,"byte_end":3304077,"line_start":2876,"line_end":2876,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8984},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3304675,"byte_end":3304691,"line_start":2890,"line_end":2890,"column_start":15,"column_end":31},"name":"_mm256_sign_epi8","qualname":"::core_arch::x86::avx2::_mm256_sign_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Negates packed 8-bit integers in `a` when the corresponding signed\n 8-bit integer in `b` is negative, and returns the results.\n Results are zeroed out when the corresponding element in `b` is zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3304525,"byte_end":3304534,"line_start":2886,"line_end":2886,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3304535,"byte_end":3304569,"line_start":2887,"line_end":2887,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3304611,"byte_end":3304660,"line_start":2889,"line_end":2889,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8985},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3305157,"byte_end":3305173,"line_start":2902,"line_end":2902,"column_start":15,"column_end":31},"name":"_mm256_sll_epi16","qualname":"::core_arch::x86::avx2::_mm256_sll_epi16","value":"fn (a: __m256i, count: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` left by `count` while\n shifting in zeros, and returns the result","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3305008,"byte_end":3305017,"line_start":2898,"line_end":2898,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3305018,"byte_end":3305052,"line_start":2899,"line_end":2899,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3305093,"byte_end":3305142,"line_start":2901,"line_end":2901,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8986},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3305647,"byte_end":3305663,"line_start":2914,"line_end":2914,"column_start":15,"column_end":31},"name":"_mm256_sll_epi32","qualname":"::core_arch::x86::avx2::_mm256_sll_epi32","value":"fn (a: __m256i, count: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` left by `count` while\n shifting in zeros, and returns the result","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3305498,"byte_end":3305507,"line_start":2910,"line_end":2910,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3305508,"byte_end":3305542,"line_start":2911,"line_end":2911,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3305583,"byte_end":3305632,"line_start":2913,"line_end":2913,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8987},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3306136,"byte_end":3306152,"line_start":2926,"line_end":2926,"column_start":15,"column_end":31},"name":"_mm256_sll_epi64","qualname":"::core_arch::x86::avx2::_mm256_sll_epi64","value":"fn (a: __m256i, count: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` left by `count` while\n shifting in zeros, and returns the result","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3305987,"byte_end":3305996,"line_start":2922,"line_end":2922,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3305997,"byte_end":3306031,"line_start":2923,"line_end":2923,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3306072,"byte_end":3306121,"line_start":2925,"line_end":2925,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8988},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3306622,"byte_end":3306639,"line_start":2938,"line_end":2938,"column_start":15,"column_end":32},"name":"_mm256_slli_epi16","qualname":"::core_arch::x86::avx2::_mm256_slli_epi16","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` left by `imm8` while\n shifting in zeros, return the results;","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3306473,"byte_end":3306482,"line_start":2934,"line_end":2934,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3306483,"byte_end":3306517,"line_start":2935,"line_end":2935,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3306558,"byte_end":3306607,"line_start":2937,"line_end":2937,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8989},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3307094,"byte_end":3307111,"line_start":2950,"line_end":2950,"column_start":15,"column_end":32},"name":"_mm256_slli_epi32","qualname":"::core_arch::x86::avx2::_mm256_slli_epi32","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` left by `imm8` while\n shifting in zeros, return the results;","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3306945,"byte_end":3306954,"line_start":2946,"line_end":2946,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3306955,"byte_end":3306989,"line_start":2947,"line_end":2947,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3307030,"byte_end":3307079,"line_start":2949,"line_end":2949,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8990},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3307565,"byte_end":3307582,"line_start":2962,"line_end":2962,"column_start":15,"column_end":32},"name":"_mm256_slli_epi64","qualname":"::core_arch::x86::avx2::_mm256_slli_epi64","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` left by `imm8` while\n shifting in zeros, return the results;","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3307416,"byte_end":3307425,"line_start":2958,"line_end":2958,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3307426,"byte_end":3307460,"line_start":2959,"line_end":2959,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3307501,"byte_end":3307550,"line_start":2961,"line_end":2961,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8991},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3308052,"byte_end":3308069,"line_start":2974,"line_end":2974,"column_start":15,"column_end":32},"name":"_mm256_slli_si256","qualname":"::core_arch::x86::avx2::_mm256_slli_si256","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts 128-bit lanes in `a` left by `imm8` bytes while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3307860,"byte_end":3307869,"line_start":2969,"line_end":2969,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3307870,"byte_end":3307904,"line_start":2970,"line_end":2970,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3307956,"byte_end":3307987,"line_start":2972,"line_end":2972,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3307988,"byte_end":3308037,"line_start":2973,"line_end":2973,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8993},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3308668,"byte_end":3308687,"line_start":2992,"line_end":2992,"column_start":15,"column_end":34},"name":"_mm256_bslli_epi128","qualname":"::core_arch::x86::avx2::_mm256_bslli_epi128","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts 128-bit lanes in `a` left by `imm8` bytes while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3308476,"byte_end":3308485,"line_start":2987,"line_end":2987,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3308486,"byte_end":3308520,"line_start":2988,"line_end":2988,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3308572,"byte_end":3308603,"line_start":2990,"line_end":2990,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3308604,"byte_end":3308653,"line_start":2991,"line_end":2991,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8995},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3309328,"byte_end":3309342,"line_start":3011,"line_end":3011,"column_start":15,"column_end":29},"name":"_mm_sllv_epi32","qualname":"::core_arch::x86::avx2::_mm_sllv_epi32","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` left by the amount\n specified by the corresponding element in `count` while\n shifting in zeros, and returns the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3309178,"byte_end":3309187,"line_start":3007,"line_end":3007,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3309188,"byte_end":3309222,"line_start":3008,"line_end":3008,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3309264,"byte_end":3309313,"line_start":3010,"line_end":3010,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8996},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3309876,"byte_end":3309893,"line_start":3024,"line_end":3024,"column_start":15,"column_end":32},"name":"_mm256_sllv_epi32","qualname":"::core_arch::x86::avx2::_mm256_sllv_epi32","value":"fn (a: __m256i, count: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` left by the amount\n specified by the corresponding element in `count` while\n shifting in zeros, and returns the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3309726,"byte_end":3309735,"line_start":3020,"line_end":3020,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3309736,"byte_end":3309770,"line_start":3021,"line_end":3021,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3309812,"byte_end":3309861,"line_start":3023,"line_end":3023,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8997},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3310427,"byte_end":3310441,"line_start":3037,"line_end":3037,"column_start":15,"column_end":29},"name":"_mm_sllv_epi64","qualname":"::core_arch::x86::avx2::_mm_sllv_epi64","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` left by the amount\n specified by the corresponding element in `count` while\n shifting in zeros, and returns the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3310277,"byte_end":3310286,"line_start":3033,"line_end":3033,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3310287,"byte_end":3310321,"line_start":3034,"line_end":3034,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3310363,"byte_end":3310412,"line_start":3036,"line_end":3036,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8998},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3310975,"byte_end":3310992,"line_start":3050,"line_end":3050,"column_start":15,"column_end":32},"name":"_mm256_sllv_epi64","qualname":"::core_arch::x86::avx2::_mm256_sllv_epi64","value":"fn (a: __m256i, count: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` left by the amount\n specified by the corresponding element in `count` while\n shifting in zeros, and returns the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3310825,"byte_end":3310834,"line_start":3046,"line_end":3046,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3310835,"byte_end":3310869,"line_start":3047,"line_end":3047,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3310911,"byte_end":3310960,"line_start":3049,"line_end":3049,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8999},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3311451,"byte_end":3311467,"line_start":3062,"line_end":3062,"column_start":15,"column_end":31},"name":"_mm256_sra_epi16","qualname":"::core_arch::x86::avx2::_mm256_sra_epi16","value":"fn (a: __m256i, count: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` right by `count` while\n shifting in sign bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3311302,"byte_end":3311311,"line_start":3058,"line_end":3058,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3311312,"byte_end":3311346,"line_start":3059,"line_end":3059,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3311387,"byte_end":3311436,"line_start":3061,"line_end":3061,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9000},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3311923,"byte_end":3311939,"line_start":3074,"line_end":3074,"column_start":15,"column_end":31},"name":"_mm256_sra_epi32","qualname":"::core_arch::x86::avx2::_mm256_sra_epi32","value":"fn (a: __m256i, count: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by `count` while\n shifting in sign bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3311774,"byte_end":3311783,"line_start":3070,"line_end":3070,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3311784,"byte_end":3311818,"line_start":3071,"line_end":3071,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3311859,"byte_end":3311908,"line_start":3073,"line_end":3073,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9001},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3312394,"byte_end":3312411,"line_start":3086,"line_end":3086,"column_start":15,"column_end":32},"name":"_mm256_srai_epi16","qualname":"::core_arch::x86::avx2::_mm256_srai_epi16","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` right by `imm8` while\n shifting in sign bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3312245,"byte_end":3312254,"line_start":3082,"line_end":3082,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3312255,"byte_end":3312289,"line_start":3083,"line_end":3083,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3312330,"byte_end":3312379,"line_start":3085,"line_end":3085,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9002},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3312851,"byte_end":3312868,"line_start":3098,"line_end":3098,"column_start":15,"column_end":32},"name":"_mm256_srai_epi32","qualname":"::core_arch::x86::avx2::_mm256_srai_epi32","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by `imm8` while\n shifting in sign bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3312702,"byte_end":3312711,"line_start":3094,"line_end":3094,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3312712,"byte_end":3312746,"line_start":3095,"line_end":3095,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3312787,"byte_end":3312836,"line_start":3097,"line_end":3097,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9003},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3313359,"byte_end":3313373,"line_start":3110,"line_end":3110,"column_start":15,"column_end":29},"name":"_mm_srav_epi32","qualname":"::core_arch::x86::avx2::_mm_srav_epi32","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by the amount specified by the\n corresponding element in `count` while shifting in sign bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3313209,"byte_end":3313218,"line_start":3106,"line_end":3106,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3313219,"byte_end":3313253,"line_start":3107,"line_end":3107,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3313295,"byte_end":3313344,"line_start":3109,"line_end":3109,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9004},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3313884,"byte_end":3313901,"line_start":3122,"line_end":3122,"column_start":15,"column_end":32},"name":"_mm256_srav_epi32","qualname":"::core_arch::x86::avx2::_mm256_srav_epi32","value":"fn (a: __m256i, count: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by the amount specified by the\n corresponding element in `count` while shifting in sign bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3313734,"byte_end":3313743,"line_start":3118,"line_end":3118,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3313744,"byte_end":3313778,"line_start":3119,"line_end":3119,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3313820,"byte_end":3313869,"line_start":3121,"line_end":3121,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9005},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3314392,"byte_end":3314409,"line_start":3134,"line_end":3134,"column_start":15,"column_end":32},"name":"_mm256_srli_si256","qualname":"::core_arch::x86::avx2::_mm256_srli_si256","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts 128-bit lanes in `a` right by `imm8` bytes while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3314200,"byte_end":3314209,"line_start":3129,"line_end":3129,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3314210,"byte_end":3314244,"line_start":3130,"line_end":3130,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3314296,"byte_end":3314327,"line_start":3132,"line_end":3132,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3314328,"byte_end":3314377,"line_start":3133,"line_end":3133,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9007},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3315009,"byte_end":3315028,"line_start":3152,"line_end":3152,"column_start":15,"column_end":34},"name":"_mm256_bsrli_epi128","qualname":"::core_arch::x86::avx2::_mm256_bsrli_epi128","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts 128-bit lanes in `a` right by `imm8` bytes while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3314817,"byte_end":3314826,"line_start":3147,"line_end":3147,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3314827,"byte_end":3314861,"line_start":3148,"line_end":3148,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3314913,"byte_end":3314944,"line_start":3150,"line_end":3150,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3314945,"byte_end":3314994,"line_start":3151,"line_end":3151,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9009},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3315590,"byte_end":3315606,"line_start":3170,"line_end":3170,"column_start":15,"column_end":31},"name":"_mm256_srl_epi16","qualname":"::core_arch::x86::avx2::_mm256_srl_epi16","value":"fn (a: __m256i, count: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` right by `count` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3315441,"byte_end":3315450,"line_start":3166,"line_end":3166,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3315451,"byte_end":3315485,"line_start":3167,"line_end":3167,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3315526,"byte_end":3315575,"line_start":3169,"line_end":3169,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9010},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3316058,"byte_end":3316074,"line_start":3182,"line_end":3182,"column_start":15,"column_end":31},"name":"_mm256_srl_epi32","qualname":"::core_arch::x86::avx2::_mm256_srl_epi32","value":"fn (a: __m256i, count: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by `count` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3315909,"byte_end":3315918,"line_start":3178,"line_end":3178,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3315919,"byte_end":3315953,"line_start":3179,"line_end":3179,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3315994,"byte_end":3316043,"line_start":3181,"line_end":3181,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9011},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3316525,"byte_end":3316541,"line_start":3194,"line_end":3194,"column_start":15,"column_end":31},"name":"_mm256_srl_epi64","qualname":"::core_arch::x86::avx2::_mm256_srl_epi64","value":"fn (a: __m256i, count: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` right by `count` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3316376,"byte_end":3316385,"line_start":3190,"line_end":3190,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3316386,"byte_end":3316420,"line_start":3191,"line_end":3191,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3316461,"byte_end":3316510,"line_start":3193,"line_end":3193,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9012},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3316991,"byte_end":3317008,"line_start":3206,"line_end":3206,"column_start":15,"column_end":32},"name":"_mm256_srli_epi16","qualname":"::core_arch::x86::avx2::_mm256_srli_epi16","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` right by `imm8` while shifting in\n zeros","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3316842,"byte_end":3316851,"line_start":3202,"line_end":3202,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3316852,"byte_end":3316886,"line_start":3203,"line_end":3203,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3316927,"byte_end":3316976,"line_start":3205,"line_end":3205,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9013},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3317443,"byte_end":3317460,"line_start":3218,"line_end":3218,"column_start":15,"column_end":32},"name":"_mm256_srli_epi32","qualname":"::core_arch::x86::avx2::_mm256_srli_epi32","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by `imm8` while shifting in\n zeros","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3317294,"byte_end":3317303,"line_start":3214,"line_end":3214,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3317304,"byte_end":3317338,"line_start":3215,"line_end":3215,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3317379,"byte_end":3317428,"line_start":3217,"line_end":3217,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9014},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3317894,"byte_end":3317911,"line_start":3230,"line_end":3230,"column_start":15,"column_end":32},"name":"_mm256_srli_epi64","qualname":"::core_arch::x86::avx2::_mm256_srli_epi64","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` right by `imm8` while shifting in\n zeros","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3317745,"byte_end":3317754,"line_start":3226,"line_end":3226,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3317755,"byte_end":3317789,"line_start":3227,"line_end":3227,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3317830,"byte_end":3317879,"line_start":3229,"line_end":3229,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9015},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3318398,"byte_end":3318412,"line_start":3242,"line_end":3242,"column_start":15,"column_end":29},"name":"_mm_srlv_epi32","qualname":"::core_arch::x86::avx2::_mm_srlv_epi32","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by the amount specified by\n the corresponding element in `count` while shifting in zeros,","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3318248,"byte_end":3318257,"line_start":3238,"line_end":3238,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3318258,"byte_end":3318292,"line_start":3239,"line_end":3239,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3318334,"byte_end":3318383,"line_start":3241,"line_end":3241,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9016},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3318919,"byte_end":3318936,"line_start":3254,"line_end":3254,"column_start":15,"column_end":32},"name":"_mm256_srlv_epi32","qualname":"::core_arch::x86::avx2::_mm256_srlv_epi32","value":"fn (a: __m256i, count: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by the amount specified by\n the corresponding element in `count` while shifting in zeros,","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3318769,"byte_end":3318778,"line_start":3250,"line_end":3250,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3318779,"byte_end":3318813,"line_start":3251,"line_end":3251,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3318855,"byte_end":3318904,"line_start":3253,"line_end":3253,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9017},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3319443,"byte_end":3319457,"line_start":3266,"line_end":3266,"column_start":15,"column_end":29},"name":"_mm_srlv_epi64","qualname":"::core_arch::x86::avx2::_mm_srlv_epi64","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` right by the amount specified by\n the corresponding element in `count` while shifting in zeros,","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3319293,"byte_end":3319302,"line_start":3262,"line_end":3262,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3319303,"byte_end":3319337,"line_start":3263,"line_end":3263,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3319379,"byte_end":3319428,"line_start":3265,"line_end":3265,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9018},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3319964,"byte_end":3319981,"line_start":3278,"line_end":3278,"column_start":15,"column_end":32},"name":"_mm256_srlv_epi64","qualname":"::core_arch::x86::avx2::_mm256_srlv_epi64","value":"fn (a: __m256i, count: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` right by the amount specified by\n the corresponding element in `count` while shifting in zeros,","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3319814,"byte_end":3319823,"line_start":3274,"line_end":3274,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3319824,"byte_end":3319858,"line_start":3275,"line_end":3275,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3319900,"byte_end":3319949,"line_start":3277,"line_end":3277,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9019},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3320487,"byte_end":3320503,"line_start":3291,"line_end":3291,"column_start":15,"column_end":31},"name":"_mm256_sub_epi16","qualname":"::core_arch::x86::avx2::_mm256_sub_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3320338,"byte_end":3320347,"line_start":3287,"line_end":3287,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3320348,"byte_end":3320382,"line_start":3288,"line_end":3288,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3320423,"byte_end":3320472,"line_start":3290,"line_end":3290,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9020},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3320942,"byte_end":3320958,"line_start":3302,"line_end":3302,"column_start":15,"column_end":31},"name":"_mm256_sub_epi32","qualname":"::core_arch::x86::avx2::_mm256_sub_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 32-bit integers in `b` from packed 16-bit integers in `a`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3320793,"byte_end":3320802,"line_start":3298,"line_end":3298,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3320803,"byte_end":3320837,"line_start":3299,"line_end":3299,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3320878,"byte_end":3320927,"line_start":3301,"line_end":3301,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9021},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3321395,"byte_end":3321411,"line_start":3313,"line_end":3313,"column_start":15,"column_end":31},"name":"_mm256_sub_epi64","qualname":"::core_arch::x86::avx2::_mm256_sub_epi64","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 64-bit integers in `b` from packed 16-bit integers in `a`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3321246,"byte_end":3321255,"line_start":3309,"line_end":3309,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3321256,"byte_end":3321290,"line_start":3310,"line_end":3310,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3321331,"byte_end":3321380,"line_start":3312,"line_end":3312,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9022},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3321846,"byte_end":3321861,"line_start":3324,"line_end":3324,"column_start":15,"column_end":30},"name":"_mm256_sub_epi8","qualname":"::core_arch::x86::avx2::_mm256_sub_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 8-bit integers in `b` from packed 16-bit integers in `a`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3321697,"byte_end":3321706,"line_start":3320,"line_end":3320,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3321707,"byte_end":3321741,"line_start":3321,"line_end":3321,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3321782,"byte_end":3321831,"line_start":3323,"line_end":3323,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9023},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3322322,"byte_end":3322339,"line_start":3336,"line_end":3336,"column_start":15,"column_end":32},"name":"_mm256_subs_epi16","qualname":"::core_arch::x86::avx2::_mm256_subs_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 16-bit integers in `b` from packed 16-bit integers in\n `a` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3322172,"byte_end":3322181,"line_start":3332,"line_end":3332,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3322182,"byte_end":3322216,"line_start":3333,"line_end":3333,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3322258,"byte_end":3322307,"line_start":3335,"line_end":3335,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9024},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3322797,"byte_end":3322813,"line_start":3348,"line_end":3348,"column_start":15,"column_end":31},"name":"_mm256_subs_epi8","qualname":"::core_arch::x86::avx2::_mm256_subs_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 8-bit integers in `b` from packed 8-bit integers in\n `a` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3322647,"byte_end":3322656,"line_start":3344,"line_end":3344,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3322657,"byte_end":3322691,"line_start":3345,"line_end":3345,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3322733,"byte_end":3322782,"line_start":3347,"line_end":3347,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9025},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3323282,"byte_end":3323299,"line_start":3360,"line_end":3360,"column_start":15,"column_end":32},"name":"_mm256_subs_epu16","qualname":"::core_arch::x86::avx2::_mm256_subs_epu16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed unsigned 16-bit integers in `b` from packed 16-bit\n integers in `a` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3323131,"byte_end":3323140,"line_start":3356,"line_end":3356,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3323141,"byte_end":3323175,"line_start":3357,"line_end":3357,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3323218,"byte_end":3323267,"line_start":3359,"line_end":3359,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9026},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3323768,"byte_end":3323784,"line_start":3372,"line_end":3372,"column_start":15,"column_end":31},"name":"_mm256_subs_epu8","qualname":"::core_arch::x86::avx2::_mm256_subs_epu8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed unsigned 8-bit integers in `b` from packed 8-bit\n integers in `a` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3323617,"byte_end":3323626,"line_start":3368,"line_end":3368,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3323627,"byte_end":3323661,"line_start":3369,"line_end":3369,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3323704,"byte_end":3323753,"line_start":3371,"line_end":3371,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9027},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3325340,"byte_end":3325360,"line_start":3419,"line_end":3419,"column_start":15,"column_end":35},"name":"_mm256_unpackhi_epi8","qualname":"::core_arch::x86::avx2::_mm256_unpackhi_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 8-bit integers from the high half of each\n 128-bit lane in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3325187,"byte_end":3325196,"line_start":3415,"line_end":3415,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3325197,"byte_end":3325231,"line_start":3416,"line_end":3416,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3325276,"byte_end":3325325,"line_start":3418,"line_end":3418,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9028},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3327127,"byte_end":3327147,"line_start":3472,"line_end":3472,"column_start":15,"column_end":35},"name":"_mm256_unpacklo_epi8","qualname":"::core_arch::x86::avx2::_mm256_unpacklo_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 8-bit integers from the low half of each\n 128-bit lane of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3326974,"byte_end":3326983,"line_start":3468,"line_end":3468,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3326984,"byte_end":3327018,"line_start":3469,"line_end":3469,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3327063,"byte_end":3327112,"line_start":3471,"line_end":3471,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9029},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3328660,"byte_end":3328681,"line_start":3521,"line_end":3521,"column_start":15,"column_end":36},"name":"_mm256_unpackhi_epi16","qualname":"::core_arch::x86::avx2::_mm256_unpackhi_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 16-bit integers from the high half of each\n 128-bit lane of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3328507,"byte_end":3328516,"line_start":3517,"line_end":3517,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3328517,"byte_end":3328551,"line_start":3518,"line_end":3518,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3328596,"byte_end":3328645,"line_start":3520,"line_end":3520,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9030},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3330106,"byte_end":3330127,"line_start":3569,"line_end":3569,"column_start":15,"column_end":36},"name":"_mm256_unpacklo_epi16","qualname":"::core_arch::x86::avx2::_mm256_unpacklo_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 16-bit integers from the low half of each\n 128-bit lane of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3329953,"byte_end":3329962,"line_start":3565,"line_end":3565,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3329963,"byte_end":3329997,"line_start":3566,"line_end":3566,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3330042,"byte_end":3330091,"line_start":3568,"line_end":3568,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9031},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3331402,"byte_end":3331423,"line_start":3610,"line_end":3610,"column_start":15,"column_end":36},"name":"_mm256_unpackhi_epi32","qualname":"::core_arch::x86::avx2::_mm256_unpackhi_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 32-bit integers from the high half of each\n 128-bit lane of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3331250,"byte_end":3331259,"line_start":3606,"line_end":3606,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3331260,"byte_end":3331294,"line_start":3607,"line_end":3607,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3331338,"byte_end":3331387,"line_start":3609,"line_end":3609,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9032},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3332631,"byte_end":3332652,"line_start":3647,"line_end":3647,"column_start":15,"column_end":36},"name":"_mm256_unpacklo_epi32","qualname":"::core_arch::x86::avx2::_mm256_unpacklo_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 32-bit integers from the low half of each\n 128-bit lane of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3332479,"byte_end":3332488,"line_start":3643,"line_end":3643,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3332489,"byte_end":3332523,"line_start":3644,"line_end":3644,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3332567,"byte_end":3332616,"line_start":3646,"line_end":3646,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9033},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3333821,"byte_end":3333842,"line_start":3684,"line_end":3684,"column_start":15,"column_end":36},"name":"_mm256_unpackhi_epi64","qualname":"::core_arch::x86::avx2::_mm256_unpackhi_epi64","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 64-bit integers from the high half of each\n 128-bit lane of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3333669,"byte_end":3333678,"line_start":3680,"line_end":3680,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3333679,"byte_end":3333713,"line_start":3681,"line_end":3681,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3333757,"byte_end":3333806,"line_start":3683,"line_end":3683,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9034},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3334995,"byte_end":3335016,"line_start":3721,"line_end":3721,"column_start":15,"column_end":36},"name":"_mm256_unpacklo_epi64","qualname":"::core_arch::x86::avx2::_mm256_unpacklo_epi64","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 64-bit integers from the low half of each\n 128-bit lane of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3334843,"byte_end":3334852,"line_start":3717,"line_end":3717,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3334853,"byte_end":3334887,"line_start":3718,"line_end":3718,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3334931,"byte_end":3334980,"line_start":3720,"line_end":3720,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9035},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3335504,"byte_end":3335520,"line_start":3734,"line_end":3734,"column_start":15,"column_end":31},"name":"_mm256_xor_si256","qualname":"::core_arch::x86::avx2::_mm256_xor_si256","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise XOR of 256 bits (representing integer data)\n in `a` and `b`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3335355,"byte_end":3335364,"line_start":3730,"line_end":3730,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3335365,"byte_end":3335399,"line_start":3731,"line_end":3731,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3335440,"byte_end":3335489,"line_start":3733,"line_end":3733,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9036},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3336127,"byte_end":3336146,"line_start":3749,"line_end":3749,"column_start":15,"column_end":34},"name":"_mm256_extract_epi8","qualname":"::core_arch::x86::avx2::_mm256_extract_epi8","value":"fn (a: __m256i, imm8: i32) -> i8","parent":null,"children":[],"decl_id":null,"docs":" Extracts an 8-bit integer from `a`, selected with `imm8`. Returns a 32-bit\n integer containing the zero-extended integer data.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3335934,"byte_end":3335943,"line_start":3744,"line_end":3744,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3335944,"byte_end":3335978,"line_start":3745,"line_end":3745,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3336031,"byte_end":3336062,"line_start":3747,"line_end":3747,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3336063,"byte_end":3336112,"line_start":3748,"line_end":3748,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9037},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3336768,"byte_end":3336788,"line_start":3765,"line_end":3765,"column_start":15,"column_end":35},"name":"_mm256_extract_epi16","qualname":"::core_arch::x86::avx2::_mm256_extract_epi16","value":"fn (a: __m256i, imm8: i32) -> i16","parent":null,"children":[],"decl_id":null,"docs":" Extracts a 16-bit integer from `a`, selected with `imm8`. Returns a 32-bit\n integer containing the zero-extended integer data.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3336575,"byte_end":3336584,"line_start":3760,"line_end":3760,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3336585,"byte_end":3336619,"line_start":3761,"line_end":3761,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3336672,"byte_end":3336703,"line_start":3763,"line_end":3763,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3336704,"byte_end":3336753,"line_start":3764,"line_end":3764,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9038},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3337273,"byte_end":3337293,"line_start":3778,"line_end":3778,"column_start":15,"column_end":35},"name":"_mm256_extract_epi32","qualname":"::core_arch::x86::avx2::_mm256_extract_epi32","value":"fn (a: __m256i, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Extracts a 32-bit integer from `a`, selected with `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3337080,"byte_end":3337089,"line_start":3773,"line_end":3773,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3337090,"byte_end":3337124,"line_start":3774,"line_end":3774,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3337177,"byte_end":3337208,"line_start":3776,"line_end":3776,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3337209,"byte_end":3337258,"line_start":3777,"line_end":3777,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9039},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3337742,"byte_end":3337758,"line_start":3790,"line_end":3790,"column_start":15,"column_end":31},"name":"_mm256_cvtsd_f64","qualname":"::core_arch::x86::avx2::_mm256_cvtsd_f64","value":"fn (a: __m256d) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the first element of the input vector of `[4 x double]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3337586,"byte_end":3337595,"line_start":3786,"line_end":3786,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3337596,"byte_end":3337630,"line_start":3787,"line_end":3787,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3337678,"byte_end":3337727,"line_start":3789,"line_end":3789,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9040},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3338148,"byte_end":3338168,"line_start":3801,"line_end":3801,"column_start":15,"column_end":35},"name":"_mm256_cvtsi256_si32","qualname":"::core_arch::x86::avx2::_mm256_cvtsi256_si32","value":"fn (a: __m256i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Returns the first element of the input vector of `[8 x i32]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3337993,"byte_end":3338002,"line_start":3797,"line_end":3797,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3338003,"byte_end":3338037,"line_start":3798,"line_end":3798,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3338084,"byte_end":3338133,"line_start":3800,"line_end":3800,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9150},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3417783,"byte_end":3417795,"line_start":34,"line_end":34,"column_start":15,"column_end":27},"name":"_mm_fmadd_pd","qualname":"::core_arch::x86::fma::_mm_fmadd_pd","value":"fn (a: __m128d, b: __m128d, c: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and add the intermediate result to packed elements in `c`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3417635,"byte_end":3417644,"line_start":30,"line_end":30,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3417645,"byte_end":3417678,"line_start":31,"line_end":31,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3417719,"byte_end":3417768,"line_start":33,"line_end":33,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9151},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3418285,"byte_end":3418300,"line_start":46,"line_end":46,"column_start":15,"column_end":30},"name":"_mm256_fmadd_pd","qualname":"::core_arch::x86::fma::_mm256_fmadd_pd","value":"fn (a: __m256d, b: __m256d, c: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and add the intermediate result to packed elements in `c`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3418137,"byte_end":3418146,"line_start":42,"line_end":42,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3418147,"byte_end":3418180,"line_start":43,"line_end":43,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3418221,"byte_end":3418270,"line_start":45,"line_end":45,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9152},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3418790,"byte_end":3418802,"line_start":58,"line_end":58,"column_start":15,"column_end":27},"name":"_mm_fmadd_ps","qualname":"::core_arch::x86::fma::_mm_fmadd_ps","value":"fn (a: __m128, b: __m128, c: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and add the intermediate result to packed elements in `c`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3418642,"byte_end":3418651,"line_start":54,"line_end":54,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3418652,"byte_end":3418685,"line_start":55,"line_end":55,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3418726,"byte_end":3418775,"line_start":57,"line_end":57,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9153},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3419288,"byte_end":3419303,"line_start":70,"line_end":70,"column_start":15,"column_end":30},"name":"_mm256_fmadd_ps","qualname":"::core_arch::x86::fma::_mm256_fmadd_ps","value":"fn (a: __m256, b: __m256, c: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and add the intermediate result to packed elements in `c`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3419140,"byte_end":3419149,"line_start":66,"line_end":66,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3419150,"byte_end":3419183,"line_start":67,"line_end":67,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3419224,"byte_end":3419273,"line_start":69,"line_end":69,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9154},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3419937,"byte_end":3419949,"line_start":84,"line_end":84,"column_start":15,"column_end":27},"name":"_mm_fmadd_sd","qualname":"::core_arch::x86::fma::_mm_fmadd_sd","value":"fn (a: __m128d, b: __m128d, c: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the lower double-precision (64-bit) floating-point elements in\n `a` and `b`, and add the intermediate result to the lower element in `c`.\n Stores the result in the lower element of the returned value, and copy the\n upper element from `a` to the upper elements of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3419789,"byte_end":3419798,"line_start":80,"line_end":80,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3419799,"byte_end":3419832,"line_start":81,"line_end":81,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3419873,"byte_end":3419922,"line_start":83,"line_end":83,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9155},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3420587,"byte_end":3420599,"line_start":98,"line_end":98,"column_start":15,"column_end":27},"name":"_mm_fmadd_ss","qualname":"::core_arch::x86::fma::_mm_fmadd_ss","value":"fn (a: __m128, b: __m128, c: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the lower single-precision (32-bit) floating-point elements in\n `a` and `b`, and add the intermediate result to the lower element in `c`.\n Stores the result in the lower element of the returned value, and copy the\n 3 upper elements from `a` to the upper elements of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3420439,"byte_end":3420448,"line_start":94,"line_end":94,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3420449,"byte_end":3420482,"line_start":95,"line_end":95,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3420523,"byte_end":3420572,"line_start":97,"line_end":97,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9156},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3421124,"byte_end":3421139,"line_start":111,"line_end":111,"column_start":15,"column_end":30},"name":"_mm_fmaddsub_pd","qualname":"::core_arch::x86::fma::_mm_fmaddsub_pd","value":"fn (a: __m128d, b: __m128d, c: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and alternatively add and subtract packed elements in `c` to/from\n the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3420973,"byte_end":3420982,"line_start":107,"line_end":107,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3420983,"byte_end":3421016,"line_start":108,"line_end":108,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3421060,"byte_end":3421109,"line_start":110,"line_end":110,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9157},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3421674,"byte_end":3421692,"line_start":124,"line_end":124,"column_start":15,"column_end":33},"name":"_mm256_fmaddsub_pd","qualname":"::core_arch::x86::fma::_mm256_fmaddsub_pd","value":"fn (a: __m256d, b: __m256d, c: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and alternatively add and subtract packed elements in `c` to/from\n the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3421523,"byte_end":3421532,"line_start":120,"line_end":120,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3421533,"byte_end":3421566,"line_start":121,"line_end":121,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3421610,"byte_end":3421659,"line_start":123,"line_end":123,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9158},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3422227,"byte_end":3422242,"line_start":137,"line_end":137,"column_start":15,"column_end":30},"name":"_mm_fmaddsub_ps","qualname":"::core_arch::x86::fma::_mm_fmaddsub_ps","value":"fn (a: __m128, b: __m128, c: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and alternatively add and subtract packed elements in `c` to/from\n the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3422076,"byte_end":3422085,"line_start":133,"line_end":133,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3422086,"byte_end":3422119,"line_start":134,"line_end":134,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3422163,"byte_end":3422212,"line_start":136,"line_end":136,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9159},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3422773,"byte_end":3422791,"line_start":150,"line_end":150,"column_start":15,"column_end":33},"name":"_mm256_fmaddsub_ps","qualname":"::core_arch::x86::fma::_mm256_fmaddsub_ps","value":"fn (a: __m256, b: __m256, c: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and alternatively add and subtract packed elements in `c` to/from\n the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3422622,"byte_end":3422631,"line_start":146,"line_end":146,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3422632,"byte_end":3422665,"line_start":147,"line_end":147,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3422709,"byte_end":3422758,"line_start":149,"line_end":149,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9160},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3423287,"byte_end":3423299,"line_start":162,"line_end":162,"column_start":15,"column_end":27},"name":"_mm_fmsub_pd","qualname":"::core_arch::x86::fma::_mm_fmsub_pd","value":"fn (a: __m128d, b: __m128d, c: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and subtract packed elements in `c` from the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3423139,"byte_end":3423148,"line_start":158,"line_end":158,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3423149,"byte_end":3423182,"line_start":159,"line_end":159,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3423223,"byte_end":3423272,"line_start":161,"line_end":161,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9161},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3423796,"byte_end":3423811,"line_start":174,"line_end":174,"column_start":15,"column_end":30},"name":"_mm256_fmsub_pd","qualname":"::core_arch::x86::fma::_mm256_fmsub_pd","value":"fn (a: __m256d, b: __m256d, c: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and subtract packed elements in `c` from the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3423648,"byte_end":3423657,"line_start":170,"line_end":170,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3423658,"byte_end":3423691,"line_start":171,"line_end":171,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3423732,"byte_end":3423781,"line_start":173,"line_end":173,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9162},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3424313,"byte_end":3424325,"line_start":186,"line_end":186,"column_start":15,"column_end":27},"name":"_mm_fmsub_ps","qualname":"::core_arch::x86::fma::_mm_fmsub_ps","value":"fn (a: __m128, b: __m128, c: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and subtract packed elements in `c` from the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3424160,"byte_end":3424169,"line_start":182,"line_end":182,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3424170,"byte_end":3424203,"line_start":183,"line_end":183,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3424249,"byte_end":3424298,"line_start":185,"line_end":185,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9163},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3424823,"byte_end":3424838,"line_start":198,"line_end":198,"column_start":15,"column_end":30},"name":"_mm256_fmsub_ps","qualname":"::core_arch::x86::fma::_mm256_fmsub_ps","value":"fn (a: __m256, b: __m256, c: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and subtract packed elements in `c` from the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3424670,"byte_end":3424679,"line_start":194,"line_end":194,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3424680,"byte_end":3424713,"line_start":195,"line_end":195,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3424759,"byte_end":3424808,"line_start":197,"line_end":197,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9164},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3425478,"byte_end":3425490,"line_start":212,"line_end":212,"column_start":15,"column_end":27},"name":"_mm_fmsub_sd","qualname":"::core_arch::x86::fma::_mm_fmsub_sd","value":"fn (a: __m128d, b: __m128d, c: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the lower double-precision (64-bit) floating-point elements in\n `a` and `b`, and subtract the lower element in `c` from the intermediate\n result. Store the result in the lower element of the returned value, and\n copy the upper element from `a` to the upper elements of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3425330,"byte_end":3425339,"line_start":208,"line_end":208,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3425340,"byte_end":3425373,"line_start":209,"line_end":209,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3425414,"byte_end":3425463,"line_start":211,"line_end":211,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9165},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3426135,"byte_end":3426147,"line_start":226,"line_end":226,"column_start":15,"column_end":27},"name":"_mm_fmsub_ss","qualname":"::core_arch::x86::fma::_mm_fmsub_ss","value":"fn (a: __m128, b: __m128, c: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the lower single-precision (32-bit) floating-point elements in\n `a` and `b`,  and subtract the lower element in `c` from the intermediate\n result. Store the result in the lower element of the returned value, and\n copy the 3 upper elements from `a` to the upper elements of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3425987,"byte_end":3425996,"line_start":222,"line_end":222,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3425997,"byte_end":3426030,"line_start":223,"line_end":223,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3426071,"byte_end":3426120,"line_start":225,"line_end":225,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9166},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3426672,"byte_end":3426687,"line_start":239,"line_end":239,"column_start":15,"column_end":30},"name":"_mm_fmsubadd_pd","qualname":"::core_arch::x86::fma::_mm_fmsubadd_pd","value":"fn (a: __m128d, b: __m128d, c: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and alternatively subtract and add packed elements in `c` from/to\n the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3426521,"byte_end":3426530,"line_start":235,"line_end":235,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3426531,"byte_end":3426564,"line_start":236,"line_end":236,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3426608,"byte_end":3426657,"line_start":238,"line_end":238,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9167},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3427222,"byte_end":3427240,"line_start":252,"line_end":252,"column_start":15,"column_end":33},"name":"_mm256_fmsubadd_pd","qualname":"::core_arch::x86::fma::_mm256_fmsubadd_pd","value":"fn (a: __m256d, b: __m256d, c: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and alternatively subtract and add packed elements in `c` from/to\n the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3427071,"byte_end":3427080,"line_start":248,"line_end":248,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3427081,"byte_end":3427114,"line_start":249,"line_end":249,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3427158,"byte_end":3427207,"line_start":251,"line_end":251,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9168},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3427775,"byte_end":3427790,"line_start":265,"line_end":265,"column_start":15,"column_end":30},"name":"_mm_fmsubadd_ps","qualname":"::core_arch::x86::fma::_mm_fmsubadd_ps","value":"fn (a: __m128, b: __m128, c: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and alternatively subtract and add packed elements in `c` from/to\n the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3427624,"byte_end":3427633,"line_start":261,"line_end":261,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3427634,"byte_end":3427667,"line_start":262,"line_end":262,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3427711,"byte_end":3427760,"line_start":264,"line_end":264,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9169},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3428321,"byte_end":3428339,"line_start":278,"line_end":278,"column_start":15,"column_end":33},"name":"_mm256_fmsubadd_ps","qualname":"::core_arch::x86::fma::_mm256_fmsubadd_ps","value":"fn (a: __m256, b: __m256, c: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and alternatively subtract and add packed elements in `c` from/to\n the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3428170,"byte_end":3428179,"line_start":274,"line_end":274,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3428180,"byte_end":3428213,"line_start":275,"line_end":275,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3428257,"byte_end":3428306,"line_start":277,"line_end":277,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9170},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3428838,"byte_end":3428851,"line_start":290,"line_end":290,"column_start":15,"column_end":28},"name":"_mm_fnmadd_pd","qualname":"::core_arch::x86::fma::_mm_fnmadd_pd","value":"fn (a: __m128d, b: __m128d, c: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and add the negated intermediate result to packed elements in `c`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3428689,"byte_end":3428698,"line_start":286,"line_end":286,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3428699,"byte_end":3428732,"line_start":287,"line_end":287,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3428774,"byte_end":3428823,"line_start":289,"line_end":289,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9171},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3429352,"byte_end":3429368,"line_start":302,"line_end":302,"column_start":15,"column_end":31},"name":"_mm256_fnmadd_pd","qualname":"::core_arch::x86::fma::_mm256_fnmadd_pd","value":"fn (a: __m256d, b: __m256d, c: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and add the negated intermediate result to packed elements in `c`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3429203,"byte_end":3429212,"line_start":298,"line_end":298,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3429213,"byte_end":3429246,"line_start":299,"line_end":299,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3429288,"byte_end":3429337,"line_start":301,"line_end":301,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9172},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3429869,"byte_end":3429882,"line_start":314,"line_end":314,"column_start":15,"column_end":28},"name":"_mm_fnmadd_ps","qualname":"::core_arch::x86::fma::_mm_fnmadd_ps","value":"fn (a: __m128, b: __m128, c: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and add the negated intermediate result to packed elements in `c`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3429720,"byte_end":3429729,"line_start":310,"line_end":310,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3429730,"byte_end":3429763,"line_start":311,"line_end":311,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3429805,"byte_end":3429854,"line_start":313,"line_end":313,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9173},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3430379,"byte_end":3430395,"line_start":326,"line_end":326,"column_start":15,"column_end":31},"name":"_mm256_fnmadd_ps","qualname":"::core_arch::x86::fma::_mm256_fnmadd_ps","value":"fn (a: __m256, b: __m256, c: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and add the negated intermediate result to packed elements in `c`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3430230,"byte_end":3430239,"line_start":322,"line_end":322,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3430240,"byte_end":3430273,"line_start":323,"line_end":323,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3430315,"byte_end":3430364,"line_start":325,"line_end":325,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9174},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3431039,"byte_end":3431052,"line_start":340,"line_end":340,"column_start":15,"column_end":28},"name":"_mm_fnmadd_sd","qualname":"::core_arch::x86::fma::_mm_fnmadd_sd","value":"fn (a: __m128d, b: __m128d, c: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the lower double-precision (64-bit) floating-point elements in\n `a` and `b`, and add the negated intermediate result to the lower element\n in `c`. Store the result in the lower element of the returned value, and\n copy the upper element from `a` to the upper elements of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3430890,"byte_end":3430899,"line_start":336,"line_end":336,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3430900,"byte_end":3430933,"line_start":337,"line_end":337,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3430975,"byte_end":3431024,"line_start":339,"line_end":339,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9175},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3431700,"byte_end":3431713,"line_start":354,"line_end":354,"column_start":15,"column_end":28},"name":"_mm_fnmadd_ss","qualname":"::core_arch::x86::fma::_mm_fnmadd_ss","value":"fn (a: __m128, b: __m128, c: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the lower single-precision (32-bit) floating-point elements in\n `a` and `b`, and add the negated intermediate result to the lower element\n in `c`. Store the result in the lower element of the returned value, and\n copy the 3 upper elements from `a` to the upper elements of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3431551,"byte_end":3431560,"line_start":350,"line_end":350,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3431561,"byte_end":3431594,"line_start":351,"line_end":351,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3431636,"byte_end":3431685,"line_start":353,"line_end":353,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9176},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3432218,"byte_end":3432231,"line_start":367,"line_end":367,"column_start":15,"column_end":28},"name":"_mm_fnmsub_pd","qualname":"::core_arch::x86::fma::_mm_fnmsub_pd","value":"fn (a: __m128d, b: __m128d, c: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and subtract packed elements in `c` from the negated intermediate\n result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3432069,"byte_end":3432078,"line_start":363,"line_end":363,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3432079,"byte_end":3432112,"line_start":364,"line_end":364,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3432154,"byte_end":3432203,"line_start":366,"line_end":366,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9177},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3432743,"byte_end":3432759,"line_start":380,"line_end":380,"column_start":15,"column_end":31},"name":"_mm256_fnmsub_pd","qualname":"::core_arch::x86::fma::_mm256_fnmsub_pd","value":"fn (a: __m256d, b: __m256d, c: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and subtract packed elements in `c` from the negated intermediate\n result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3432594,"byte_end":3432603,"line_start":376,"line_end":376,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3432604,"byte_end":3432637,"line_start":377,"line_end":377,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3432679,"byte_end":3432728,"line_start":379,"line_end":379,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9178},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3433271,"byte_end":3433284,"line_start":393,"line_end":393,"column_start":15,"column_end":28},"name":"_mm_fnmsub_ps","qualname":"::core_arch::x86::fma::_mm_fnmsub_ps","value":"fn (a: __m128, b: __m128, c: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and subtract packed elements in `c` from the negated intermediate\n result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3433122,"byte_end":3433131,"line_start":389,"line_end":389,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3433132,"byte_end":3433165,"line_start":390,"line_end":390,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3433207,"byte_end":3433256,"line_start":392,"line_end":392,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9179},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3433792,"byte_end":3433808,"line_start":406,"line_end":406,"column_start":15,"column_end":31},"name":"_mm256_fnmsub_ps","qualname":"::core_arch::x86::fma::_mm256_fnmsub_ps","value":"fn (a: __m256, b: __m256, c: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and subtract packed elements in `c` from the negated intermediate\n result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3433643,"byte_end":3433652,"line_start":402,"line_end":402,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3433653,"byte_end":3433686,"line_start":403,"line_end":403,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3433728,"byte_end":3433777,"line_start":405,"line_end":405,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9180},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3434461,"byte_end":3434474,"line_start":421,"line_end":421,"column_start":15,"column_end":28},"name":"_mm_fnmsub_sd","qualname":"::core_arch::x86::fma::_mm_fnmsub_sd","value":"fn (a: __m128d, b: __m128d, c: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the lower double-precision (64-bit) floating-point elements in\n `a` and `b`, and subtract packed elements in `c` from the negated\n intermediate result. Store the result in the lower element of the returned\n value, and copy the upper element from `a` to the upper elements of the\n result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3434312,"byte_end":3434321,"line_start":417,"line_end":417,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3434322,"byte_end":3434355,"line_start":418,"line_end":418,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3434397,"byte_end":3434446,"line_start":420,"line_end":420,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9181},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3435131,"byte_end":3435144,"line_start":436,"line_end":436,"column_start":15,"column_end":28},"name":"_mm_fnmsub_ss","qualname":"::core_arch::x86::fma::_mm_fnmsub_ss","value":"fn (a: __m128, b: __m128, c: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the lower single-precision (32-bit) floating-point elements in\n `a` and `b`, and subtract packed elements in `c` from the negated\n intermediate result. Store the result in the lower element of the\n returned value, and copy the 3 upper elements from `a` to the upper\n elements of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3434982,"byte_end":3434991,"line_start":432,"line_end":432,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3434992,"byte_end":3435025,"line_start":433,"line_end":433,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3435067,"byte_end":3435116,"line_start":435,"line_end":435,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9217},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/abm.rs","byte_start":3450474,"byte_end":3450484,"line_start":32,"line_end":32,"column_start":15,"column_end":25},"name":"_lzcnt_u32","qualname":"::core_arch::x86::abm::_lzcnt_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Counts the leading most significant zero bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/abm.rs","byte_start":3450325,"byte_end":3450334,"line_start":28,"line_end":28,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"lzcnt\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/abm.rs","byte_start":3450335,"byte_end":3450370,"line_start":29,"line_end":29,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/abm.rs","byte_start":3450410,"byte_end":3450459,"line_start":31,"line_end":31,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9218},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/abm.rs","byte_start":3450822,"byte_end":3450831,"line_start":43,"line_end":43,"column_start":15,"column_end":24},"name":"_popcnt32","qualname":"::core_arch::x86::abm::_popcnt32","value":"fn (x: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Counts the bits that are set.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/abm.rs","byte_start":3450671,"byte_end":3450680,"line_start":39,"line_end":39,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"popcnt\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/abm.rs","byte_start":3450681,"byte_end":3450717,"line_start":40,"line_end":40,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/abm.rs","byte_start":3450758,"byte_end":3450807,"line_start":42,"line_end":42,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9221},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3452231,"byte_end":3452241,"line_start":23,"line_end":23,"column_start":15,"column_end":25},"name":"_bextr_u32","qualname":"::core_arch::x86::bmi1::_bextr_u32","value":"fn (a: u32, start: u32, len: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Extracts bits in range [`start`, `start` + `length`) from `a` into\n the least significant bits of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3452083,"byte_end":3452092,"line_start":19,"line_end":19,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3452093,"byte_end":3452127,"line_start":20,"line_end":20,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3452167,"byte_end":3452216,"line_start":22,"line_end":22,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9222},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3452866,"byte_end":3452877,"line_start":38,"line_end":38,"column_start":15,"column_end":26},"name":"_bextr2_u32","qualname":"::core_arch::x86::bmi1::_bextr2_u32","value":"fn (a: u32, control: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Extracts bits of `a` specified by `control` into\n the least significant bits of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3452718,"byte_end":3452727,"line_start":34,"line_end":34,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3452728,"byte_end":3452762,"line_start":35,"line_end":35,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3452802,"byte_end":3452851,"line_start":37,"line_end":37,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9223},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3453254,"byte_end":3453263,"line_start":49,"line_end":49,"column_start":15,"column_end":24},"name":"_andn_u32","qualname":"::core_arch::x86::bmi1::_andn_u32","value":"fn (a: u32, b: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Bitwise logical `AND` of inverted `a` with `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3453107,"byte_end":3453116,"line_start":45,"line_end":45,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3453117,"byte_end":3453151,"line_start":46,"line_end":46,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3453190,"byte_end":3453239,"line_start":48,"line_end":48,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9224},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3453598,"byte_end":3453607,"line_start":60,"line_end":60,"column_start":15,"column_end":24},"name":"_blsi_u32","qualname":"::core_arch::x86::bmi1::_blsi_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Extracts lowest set isolated bit.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3453451,"byte_end":3453460,"line_start":56,"line_end":56,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3453461,"byte_end":3453495,"line_start":57,"line_end":57,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3453534,"byte_end":3453583,"line_start":59,"line_end":59,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9225},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3453950,"byte_end":3453961,"line_start":71,"line_end":71,"column_start":15,"column_end":26},"name":"_blsmsk_u32","qualname":"::core_arch::x86::bmi1::_blsmsk_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Gets mask up to lowest set bit.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3453801,"byte_end":3453810,"line_start":67,"line_end":67,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3453811,"byte_end":3453845,"line_start":68,"line_end":68,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3453886,"byte_end":3453935,"line_start":70,"line_end":70,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9226},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3454336,"byte_end":3454345,"line_start":84,"line_end":84,"column_start":15,"column_end":24},"name":"_blsr_u32","qualname":"::core_arch::x86::bmi1::_blsr_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Resets the lowest set bit of `x`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3454189,"byte_end":3454198,"line_start":80,"line_end":80,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3454199,"byte_end":3454233,"line_start":81,"line_end":81,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3454272,"byte_end":3454321,"line_start":83,"line_end":83,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9227},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3454785,"byte_end":3454795,"line_start":97,"line_end":97,"column_start":15,"column_end":25},"name":"_tzcnt_u32","qualname":"::core_arch::x86::bmi1::_tzcnt_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Counts the number of trailing least significant zero bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3454637,"byte_end":3454646,"line_start":93,"line_end":93,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3454647,"byte_end":3454681,"line_start":94,"line_end":94,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3454721,"byte_end":3454770,"line_start":96,"line_end":96,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9228},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3455232,"byte_end":3455244,"line_start":110,"line_end":110,"column_start":15,"column_end":27},"name":"_mm_tzcnt_32","qualname":"::core_arch::x86::bmi1::_mm_tzcnt_32","value":"fn (x: u32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Counts the number of trailing least significant zero bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3455084,"byte_end":3455093,"line_start":106,"line_end":106,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3455094,"byte_end":3455128,"line_start":107,"line_end":107,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3455168,"byte_end":3455217,"line_start":109,"line_end":109,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9233},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3458375,"byte_end":3458384,"line_start":28,"line_end":28,"column_start":15,"column_end":24},"name":"_mulx_u32","qualname":"::core_arch::x86::bmi2::_mulx_u32","value":"fn (a: u32, b: u32, hi: &mut u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Unsigned multiply without affecting flags.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3458061,"byte_end":3458070,"line_start":22,"line_end":22,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3458276,"byte_end":3458310,"line_start":26,"line_end":26,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3458311,"byte_end":3458360,"line_start":27,"line_end":27,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9234},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3458824,"byte_end":3458833,"line_start":41,"line_end":41,"column_start":15,"column_end":24},"name":"_bzhi_u32","qualname":"::core_arch::x86::bmi2::_bzhi_u32","value":"fn (a: u32, index: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Zeroes higher bits of `a` >= `index`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3458677,"byte_end":3458686,"line_start":37,"line_end":37,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3458687,"byte_end":3458721,"line_start":38,"line_end":38,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3458760,"byte_end":3458809,"line_start":40,"line_end":40,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9235},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3459259,"byte_end":3459268,"line_start":53,"line_end":53,"column_start":15,"column_end":24},"name":"_pdep_u32","qualname":"::core_arch::x86::bmi2::_pdep_u32","value":"fn (a: u32, mask: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Scatter contiguous low order bits of `a` to the result at the positions\n specified by the `mask`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3459112,"byte_end":3459121,"line_start":49,"line_end":49,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3459122,"byte_end":3459156,"line_start":50,"line_end":50,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3459195,"byte_end":3459244,"line_start":52,"line_end":52,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9236},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3459702,"byte_end":3459711,"line_start":65,"line_end":65,"column_start":15,"column_end":24},"name":"_pext_u32","qualname":"::core_arch::x86::bmi2::_pext_u32","value":"fn (a: u32, mask: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Gathers the bits of `x` specified by the `mask` into the contiguous low\n order bit positions of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3459555,"byte_end":3459564,"line_start":61,"line_end":61,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3459565,"byte_end":3459599,"line_start":62,"line_end":62,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3459638,"byte_end":3459687,"line_start":64,"line_end":64,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9253},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3462910,"byte_end":3462926,"line_start":41,"line_end":41,"column_start":15,"column_end":31},"name":"_mm_extract_si64","qualname":"::core_arch::x86::sse4a::_mm_extract_si64","value":"fn (x: __m128i, y: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Extracts the bit range specified by `y` from the lower 64 bits of `x`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3462761,"byte_end":3462770,"line_start":37,"line_end":37,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4a\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3462771,"byte_end":3462806,"line_start":38,"line_end":38,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3462846,"byte_end":3462895,"line_start":40,"line_end":40,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9254},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3463474,"byte_end":3463489,"line_start":58,"line_end":58,"column_start":15,"column_end":30},"name":"_mm_insert_si64","qualname":"::core_arch::x86::sse4a::_mm_insert_si64","value":"fn (x: __m128i, y: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Inserts the `[length:0]` bits of `y` into `x` at `index`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3463323,"byte_end":3463332,"line_start":54,"line_end":54,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4a\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3463333,"byte_end":3463368,"line_start":55,"line_end":55,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3463410,"byte_end":3463459,"line_start":57,"line_end":57,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9255},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3463852,"byte_end":3463865,"line_start":69,"line_end":69,"column_start":15,"column_end":28},"name":"_mm_stream_sd","qualname":"::core_arch::x86::sse4a::_mm_stream_sd","value":"fn (p: *mut f64, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Non-temporal store of `a.0` into `p`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3463701,"byte_end":3463710,"line_start":65,"line_end":65,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4a\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3463711,"byte_end":3463746,"line_start":66,"line_end":66,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3463788,"byte_end":3463837,"line_start":68,"line_end":68,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9256},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3464186,"byte_end":3464199,"line_start":80,"line_end":80,"column_start":15,"column_end":28},"name":"_mm_stream_ss","qualname":"::core_arch::x86::sse4a::_mm_stream_ss","value":"fn (p: *mut f32, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Non-temporal store of `a.0` into `p`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3464035,"byte_end":3464044,"line_start":76,"line_end":76,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4a\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3464045,"byte_end":3464080,"line_start":77,"line_end":77,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3464122,"byte_end":3464171,"line_start":79,"line_end":79,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9259},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3468972,"byte_end":3468984,"line_start":74,"line_end":74,"column_start":15,"column_end":27},"name":"_blcfill_u32","qualname":"::core_arch::x86::tbm::_blcfill_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Clears all bits below the least significant zero bit of `x`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3468823,"byte_end":3468832,"line_start":70,"line_end":70,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3468833,"byte_end":3468866,"line_start":71,"line_end":71,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3468908,"byte_end":3468957,"line_start":73,"line_end":73,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9260},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3469371,"byte_end":3469383,"line_start":86,"line_end":86,"column_start":15,"column_end":27},"name":"_blcfill_u64","qualname":"::core_arch::x86::tbm::_blcfill_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Clears all bits below the least significant zero bit of `x`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3469155,"byte_end":3469164,"line_start":81,"line_end":81,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3469165,"byte_end":3469198,"line_start":82,"line_end":82,"column_start":1,"column_end":34}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3469240,"byte_end":3469272,"line_start":84,"line_end":84,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3469307,"byte_end":3469356,"line_start":85,"line_end":85,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9261},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3469709,"byte_end":3469718,"line_start":97,"line_end":97,"column_start":15,"column_end":24},"name":"_blci_u32","qualname":"::core_arch::x86::tbm::_blci_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Sets all bits of `x` to 1 except for the least significant zero bit.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3469563,"byte_end":3469572,"line_start":93,"line_end":93,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3469573,"byte_end":3469606,"line_start":94,"line_end":94,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3469645,"byte_end":3469694,"line_start":96,"line_end":96,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9262},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3470112,"byte_end":3470121,"line_start":109,"line_end":109,"column_start":15,"column_end":24},"name":"_blci_u64","qualname":"::core_arch::x86::tbm::_blci_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Sets all bits of `x` to 1 except for the least significant zero bit.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3469899,"byte_end":3469908,"line_start":104,"line_end":104,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3469909,"byte_end":3469942,"line_start":105,"line_end":105,"column_start":1,"column_end":34}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3469981,"byte_end":3470013,"line_start":107,"line_end":107,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3470048,"byte_end":3470097,"line_start":108,"line_end":108,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9263},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3470449,"byte_end":3470459,"line_start":120,"line_end":120,"column_start":15,"column_end":25},"name":"_blcic_u32","qualname":"::core_arch::x86::tbm::_blcic_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Sets the least significant zero bit of `x` and clears all other bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3470302,"byte_end":3470311,"line_start":116,"line_end":116,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3470312,"byte_end":3470345,"line_start":117,"line_end":117,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3470385,"byte_end":3470434,"line_start":119,"line_end":119,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9264},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3470854,"byte_end":3470864,"line_start":132,"line_end":132,"column_start":15,"column_end":25},"name":"_blcic_u64","qualname":"::core_arch::x86::tbm::_blcic_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Sets the least significant zero bit of `x` and clears all other bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3470640,"byte_end":3470649,"line_start":127,"line_end":127,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3470650,"byte_end":3470683,"line_start":128,"line_end":128,"column_start":1,"column_end":34}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3470723,"byte_end":3470755,"line_start":130,"line_end":130,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3470790,"byte_end":3470839,"line_start":131,"line_end":131,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9265},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3471211,"byte_end":3471222,"line_start":144,"line_end":144,"column_start":15,"column_end":26},"name":"_blcmsk_u32","qualname":"::core_arch::x86::tbm::_blcmsk_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Sets the least significant zero bit of `x` and clears all bits above\n that bit.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3471063,"byte_end":3471072,"line_start":140,"line_end":140,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3471073,"byte_end":3471106,"line_start":141,"line_end":141,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3471147,"byte_end":3471196,"line_start":143,"line_end":143,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9266},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3471635,"byte_end":3471646,"line_start":157,"line_end":157,"column_start":15,"column_end":26},"name":"_blcmsk_u64","qualname":"::core_arch::x86::tbm::_blcmsk_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Sets the least significant zero bit of `x` and clears all bits above\n that bit.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3471420,"byte_end":3471429,"line_start":152,"line_end":152,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3471430,"byte_end":3471463,"line_start":153,"line_end":153,"column_start":1,"column_end":34}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3471504,"byte_end":3471536,"line_start":155,"line_end":155,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3471571,"byte_end":3471620,"line_start":156,"line_end":156,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9267},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3471945,"byte_end":3471954,"line_start":168,"line_end":168,"column_start":15,"column_end":24},"name":"_blcs_u32","qualname":"::core_arch::x86::tbm::_blcs_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Sets the least significant zero bit of `x`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3471799,"byte_end":3471808,"line_start":164,"line_end":164,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3471809,"byte_end":3471842,"line_start":165,"line_end":165,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3471881,"byte_end":3471930,"line_start":167,"line_end":167,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9268},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3472320,"byte_end":3472329,"line_start":180,"line_end":180,"column_start":15,"column_end":24},"name":"_blcs_u64","qualname":"::core_arch::x86::tbm::_blcs_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Sets the least significant zero bit of `x`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3472107,"byte_end":3472116,"line_start":175,"line_end":175,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3472117,"byte_end":3472150,"line_start":176,"line_end":176,"column_start":1,"column_end":34}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3472189,"byte_end":3472221,"line_start":178,"line_end":178,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3472256,"byte_end":3472305,"line_start":179,"line_end":179,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9269},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3472644,"byte_end":3472656,"line_start":191,"line_end":191,"column_start":15,"column_end":27},"name":"_blsfill_u32","qualname":"::core_arch::x86::tbm::_blsfill_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Sets all bits of `x` below the least significant one.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3472495,"byte_end":3472504,"line_start":187,"line_end":187,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3472505,"byte_end":3472538,"line_start":188,"line_end":188,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3472580,"byte_end":3472629,"line_start":190,"line_end":190,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9270},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3473040,"byte_end":3473052,"line_start":203,"line_end":203,"column_start":15,"column_end":27},"name":"_blsfill_u64","qualname":"::core_arch::x86::tbm::_blsfill_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Sets all bits of `x` below the least significant one.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3472824,"byte_end":3472833,"line_start":198,"line_end":198,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3472834,"byte_end":3472867,"line_start":199,"line_end":199,"column_start":1,"column_end":34}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3472909,"byte_end":3472941,"line_start":201,"line_end":201,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3472976,"byte_end":3473025,"line_start":202,"line_end":202,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9271},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3473367,"byte_end":3473377,"line_start":214,"line_end":214,"column_start":15,"column_end":25},"name":"_blsic_u32","qualname":"::core_arch::x86::tbm::_blsic_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Clears least significant bit and sets all other bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3473220,"byte_end":3473229,"line_start":210,"line_end":210,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3473230,"byte_end":3473263,"line_start":211,"line_end":211,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3473303,"byte_end":3473352,"line_start":213,"line_end":213,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9272},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3473760,"byte_end":3473770,"line_start":226,"line_end":226,"column_start":15,"column_end":25},"name":"_blsic_u64","qualname":"::core_arch::x86::tbm::_blsic_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Clears least significant bit and sets all other bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3473546,"byte_end":3473555,"line_start":221,"line_end":221,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3473556,"byte_end":3473589,"line_start":222,"line_end":222,"column_start":1,"column_end":34}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3473629,"byte_end":3473661,"line_start":224,"line_end":224,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3473696,"byte_end":3473745,"line_start":225,"line_end":225,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9273},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3474127,"byte_end":3474138,"line_start":238,"line_end":238,"column_start":15,"column_end":26},"name":"_t1mskc_u32","qualname":"::core_arch::x86::tbm::_t1mskc_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Clears all bits below the least significant zero of `x` and sets all other\n bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3473979,"byte_end":3473988,"line_start":234,"line_end":234,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3473989,"byte_end":3474022,"line_start":235,"line_end":235,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3474063,"byte_end":3474112,"line_start":237,"line_end":237,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9274},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3474562,"byte_end":3474573,"line_start":251,"line_end":251,"column_start":15,"column_end":26},"name":"_t1mskc_u64","qualname":"::core_arch::x86::tbm::_t1mskc_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Clears all bits below the least significant zero of `x` and sets all other\n bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3474347,"byte_end":3474356,"line_start":246,"line_end":246,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3474357,"byte_end":3474390,"line_start":247,"line_end":247,"column_start":1,"column_end":34}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3474431,"byte_end":3474463,"line_start":249,"line_end":249,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3474498,"byte_end":3474547,"line_start":250,"line_end":250,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9275},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3474925,"byte_end":3474935,"line_start":263,"line_end":263,"column_start":15,"column_end":25},"name":"_tzmsk_u32","qualname":"::core_arch::x86::tbm::_tzmsk_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Sets all bits below the least significant one of `x` and clears all other\n bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3474778,"byte_end":3474787,"line_start":259,"line_end":259,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3474788,"byte_end":3474821,"line_start":260,"line_end":260,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3474861,"byte_end":3474910,"line_start":262,"line_end":262,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9276},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3475354,"byte_end":3475364,"line_start":276,"line_end":276,"column_start":15,"column_end":25},"name":"_tzmsk_u64","qualname":"::core_arch::x86::tbm::_tzmsk_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Sets all bits below the least significant one of `x` and clears all other\n bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3475140,"byte_end":3475149,"line_start":271,"line_end":271,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3475150,"byte_end":3475183,"line_start":272,"line_end":272,"column_start":1,"column_end":34}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3475223,"byte_end":3475255,"line_start":274,"line_end":274,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3475290,"byte_end":3475339,"line_start":275,"line_end":275,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9284},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3481846,"byte_end":3481862,"line_start":25,"line_end":25,"column_start":15,"column_end":31},"name":"_mm_setzero_si64","qualname":"::core_arch::x86::mmx::_mm_setzero_si64","value":"fn () -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Constructs a 64-bit integer vector initialized to zero.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3481600,"byte_end":3481609,"line_start":20,"line_end":20,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3481610,"byte_end":3481643,"line_start":21,"line_end":21,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9285},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3482044,"byte_end":3482055,"line_start":33,"line_end":33,"column_start":15,"column_end":26},"name":"_mm_add_pi8","qualname":"::core_arch::x86::mmx::_mm_add_pi8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 8-bit integers in `a` and `b`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3481947,"byte_end":3481956,"line_start":30,"line_end":30,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3481957,"byte_end":3481990,"line_start":31,"line_end":31,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9286},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3482250,"byte_end":3482258,"line_start":41,"line_end":41,"column_start":15,"column_end":23},"name":"_m_paddb","qualname":"::core_arch::x86::mmx::_m_paddb","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 8-bit integers in `a` and `b`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3482153,"byte_end":3482162,"line_start":38,"line_end":38,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3482163,"byte_end":3482196,"line_start":39,"line_end":39,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9287},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3482460,"byte_end":3482472,"line_start":49,"line_end":49,"column_start":15,"column_end":27},"name":"_mm_add_pi16","qualname":"::core_arch::x86::mmx::_mm_add_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 16-bit integers in `a` and `b`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3482363,"byte_end":3482372,"line_start":46,"line_end":46,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3482373,"byte_end":3482406,"line_start":47,"line_end":47,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9288},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3482668,"byte_end":3482676,"line_start":57,"line_end":57,"column_start":15,"column_end":23},"name":"_m_paddw","qualname":"::core_arch::x86::mmx::_m_paddw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 16-bit integers in `a` and `b`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3482571,"byte_end":3482580,"line_start":54,"line_end":54,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3482581,"byte_end":3482614,"line_start":55,"line_end":55,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9289},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3482879,"byte_end":3482891,"line_start":65,"line_end":65,"column_start":15,"column_end":27},"name":"_mm_add_pi32","qualname":"::core_arch::x86::mmx::_mm_add_pi32","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 32-bit integers in `a` and `b`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3482782,"byte_end":3482791,"line_start":62,"line_end":62,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3482792,"byte_end":3482825,"line_start":63,"line_end":63,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9290},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3483087,"byte_end":3483095,"line_start":73,"line_end":73,"column_start":15,"column_end":23},"name":"_m_paddd","qualname":"::core_arch::x86::mmx::_m_paddd","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 32-bit integers in `a` and `b`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3482990,"byte_end":3482999,"line_start":70,"line_end":70,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3483000,"byte_end":3483033,"line_start":71,"line_end":71,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9291},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3483315,"byte_end":3483327,"line_start":81,"line_end":81,"column_start":15,"column_end":27},"name":"_mm_adds_pi8","qualname":"::core_arch::x86::mmx::_mm_adds_pi8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 8-bit integers in `a` and `b` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3483217,"byte_end":3483226,"line_start":78,"line_end":78,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3483227,"byte_end":3483260,"line_start":79,"line_end":79,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9292},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3483541,"byte_end":3483550,"line_start":89,"line_end":89,"column_start":15,"column_end":24},"name":"_m_paddsb","qualname":"::core_arch::x86::mmx::_m_paddsb","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 8-bit integers in `a` and `b` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3483443,"byte_end":3483452,"line_start":86,"line_end":86,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3483453,"byte_end":3483486,"line_start":87,"line_end":87,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9293},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3483771,"byte_end":3483784,"line_start":97,"line_end":97,"column_start":15,"column_end":28},"name":"_mm_adds_pi16","qualname":"::core_arch::x86::mmx::_mm_adds_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 16-bit integers in `a` and `b` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3483673,"byte_end":3483682,"line_start":94,"line_end":94,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3483683,"byte_end":3483716,"line_start":95,"line_end":95,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9294},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3483999,"byte_end":3484008,"line_start":105,"line_end":105,"column_start":15,"column_end":24},"name":"_m_paddsw","qualname":"::core_arch::x86::mmx::_m_paddsw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 16-bit integers in `a` and `b` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3483901,"byte_end":3483910,"line_start":102,"line_end":102,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3483911,"byte_end":3483944,"line_start":103,"line_end":103,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9295},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3484239,"byte_end":3484251,"line_start":113,"line_end":113,"column_start":15,"column_end":27},"name":"_mm_adds_pu8","qualname":"::core_arch::x86::mmx::_mm_adds_pu8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed unsigned 8-bit integers in `a` and `b` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3484140,"byte_end":3484149,"line_start":110,"line_end":110,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3484150,"byte_end":3484183,"line_start":111,"line_end":111,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9296},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3484476,"byte_end":3484486,"line_start":121,"line_end":121,"column_start":15,"column_end":25},"name":"_m_paddusb","qualname":"::core_arch::x86::mmx::_m_paddusb","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed unsigned 8-bit integers in `a` and `b` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3484377,"byte_end":3484386,"line_start":118,"line_end":118,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3484387,"byte_end":3484420,"line_start":119,"line_end":119,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9297},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3484717,"byte_end":3484730,"line_start":129,"line_end":129,"column_start":15,"column_end":28},"name":"_mm_adds_pu16","qualname":"::core_arch::x86::mmx::_mm_adds_pu16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed unsigned 16-bit integers in `a` and `b` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3484618,"byte_end":3484627,"line_start":126,"line_end":126,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3484628,"byte_end":3484661,"line_start":127,"line_end":127,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9298},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3484956,"byte_end":3484966,"line_start":137,"line_end":137,"column_start":15,"column_end":25},"name":"_m_paddusw","qualname":"::core_arch::x86::mmx::_m_paddusw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed unsigned 16-bit integers in `a` and `b` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3484857,"byte_end":3484866,"line_start":134,"line_end":134,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3484867,"byte_end":3484900,"line_start":135,"line_end":135,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9299},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3485199,"byte_end":3485210,"line_start":145,"line_end":145,"column_start":15,"column_end":26},"name":"_mm_sub_pi8","qualname":"::core_arch::x86::mmx::_mm_sub_pi8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3485102,"byte_end":3485111,"line_start":142,"line_end":142,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3485112,"byte_end":3485145,"line_start":143,"line_end":143,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9300},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3485435,"byte_end":3485443,"line_start":153,"line_end":153,"column_start":15,"column_end":23},"name":"_m_psubb","qualname":"::core_arch::x86::mmx::_m_psubb","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3485338,"byte_end":3485347,"line_start":150,"line_end":150,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3485348,"byte_end":3485381,"line_start":151,"line_end":151,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9301},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3485676,"byte_end":3485688,"line_start":161,"line_end":161,"column_start":15,"column_end":27},"name":"_mm_sub_pi16","qualname":"::core_arch::x86::mmx::_mm_sub_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3485579,"byte_end":3485588,"line_start":158,"line_end":158,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3485589,"byte_end":3485622,"line_start":159,"line_end":159,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9302},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3485915,"byte_end":3485923,"line_start":169,"line_end":169,"column_start":15,"column_end":23},"name":"_m_psubw","qualname":"::core_arch::x86::mmx::_m_psubw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3485818,"byte_end":3485827,"line_start":166,"line_end":166,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3485828,"byte_end":3485861,"line_start":167,"line_end":167,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9303},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3486157,"byte_end":3486169,"line_start":177,"line_end":177,"column_start":15,"column_end":27},"name":"_mm_sub_pi32","qualname":"::core_arch::x86::mmx::_mm_sub_pi32","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 32-bit integers in `b` from packed 32-bit integers in `a`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3486060,"byte_end":3486069,"line_start":174,"line_end":174,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3486070,"byte_end":3486103,"line_start":175,"line_end":175,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9304},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3486396,"byte_end":3486404,"line_start":185,"line_end":185,"column_start":15,"column_end":23},"name":"_m_psubd","qualname":"::core_arch::x86::mmx::_m_psubd","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 32-bit integers in `b` from packed 32-bit integers in `a`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3486299,"byte_end":3486308,"line_start":182,"line_end":182,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3486309,"byte_end":3486342,"line_start":183,"line_end":183,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9305},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3486658,"byte_end":3486670,"line_start":194,"line_end":194,"column_start":15,"column_end":27},"name":"_mm_subs_pi8","qualname":"::core_arch::x86::mmx::_mm_subs_pi8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a`\n using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3486560,"byte_end":3486569,"line_start":191,"line_end":191,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3486570,"byte_end":3486603,"line_start":192,"line_end":192,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9306},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3486918,"byte_end":3486927,"line_start":203,"line_end":203,"column_start":15,"column_end":24},"name":"_m_psubsb","qualname":"::core_arch::x86::mmx::_m_psubsb","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a`\n using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3486820,"byte_end":3486829,"line_start":200,"line_end":200,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3486830,"byte_end":3486863,"line_start":201,"line_end":201,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9307},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3487183,"byte_end":3487196,"line_start":212,"line_end":212,"column_start":15,"column_end":28},"name":"_mm_subs_pi16","qualname":"::core_arch::x86::mmx::_mm_subs_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a`\n using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3487085,"byte_end":3487094,"line_start":209,"line_end":209,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3487095,"byte_end":3487128,"line_start":210,"line_end":210,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9308},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3487446,"byte_end":3487455,"line_start":221,"line_end":221,"column_start":15,"column_end":24},"name":"_m_psubsw","qualname":"::core_arch::x86::mmx::_m_psubsw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a`\n using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3487348,"byte_end":3487357,"line_start":218,"line_end":218,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3487358,"byte_end":3487391,"line_start":219,"line_end":219,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9309},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3487729,"byte_end":3487741,"line_start":230,"line_end":230,"column_start":15,"column_end":27},"name":"_mm_subs_pu8","qualname":"::core_arch::x86::mmx::_mm_subs_pu8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed unsigned 8-bit integers in `b` from packed unsigned 8-bit\n integers in `a` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3487630,"byte_end":3487639,"line_start":227,"line_end":227,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3487640,"byte_end":3487673,"line_start":228,"line_end":228,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9310},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3488009,"byte_end":3488019,"line_start":239,"line_end":239,"column_start":15,"column_end":25},"name":"_m_psubusb","qualname":"::core_arch::x86::mmx::_m_psubusb","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed unsigned 8-bit integers in `b` from packed unsigned 8-bit\n integers in `a` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3487910,"byte_end":3487919,"line_start":236,"line_end":236,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3487920,"byte_end":3487953,"line_start":237,"line_end":237,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9311},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3488294,"byte_end":3488307,"line_start":248,"line_end":248,"column_start":15,"column_end":28},"name":"_mm_subs_pu16","qualname":"::core_arch::x86::mmx::_mm_subs_pu16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed unsigned 16-bit integers in `b` from packed unsigned\n 16-bit integers in `a` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3488195,"byte_end":3488204,"line_start":245,"line_end":245,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3488205,"byte_end":3488238,"line_start":246,"line_end":246,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9312},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3488577,"byte_end":3488587,"line_start":257,"line_end":257,"column_start":15,"column_end":25},"name":"_m_psubusw","qualname":"::core_arch::x86::mmx::_m_psubusw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed unsigned 16-bit integers in `b` from packed unsigned\n 16-bit integers in `a` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3488478,"byte_end":3488487,"line_start":254,"line_end":254,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3488488,"byte_end":3488521,"line_start":255,"line_end":255,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9313},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3488976,"byte_end":3488990,"line_start":269,"line_end":269,"column_start":15,"column_end":29},"name":"_mm_packs_pi16","qualname":"::core_arch::x86::mmx::_mm_packs_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers\n using signed saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3488876,"byte_end":3488885,"line_start":266,"line_end":266,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3488886,"byte_end":3488919,"line_start":267,"line_end":267,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9314},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3489375,"byte_end":3489389,"line_start":281,"line_end":281,"column_start":15,"column_end":29},"name":"_mm_packs_pi32","qualname":"::core_arch::x86::mmx::_mm_packs_pi32","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers\n using signed saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3489275,"byte_end":3489284,"line_start":278,"line_end":278,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3489285,"byte_end":3489318,"line_start":279,"line_end":279,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9315},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3489683,"byte_end":3489696,"line_start":290,"line_end":290,"column_start":15,"column_end":28},"name":"_mm_cmpgt_pi8","qualname":"::core_arch::x86::mmx::_mm_cmpgt_pi8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares whether each element of `a` is greater than the corresponding\n element of `b` returning `0` for `false` and `-1` for `true`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3489584,"byte_end":3489593,"line_start":287,"line_end":287,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3489594,"byte_end":3489627,"line_start":288,"line_end":288,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9316},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3489989,"byte_end":3490003,"line_start":299,"line_end":299,"column_start":15,"column_end":29},"name":"_mm_cmpgt_pi16","qualname":"::core_arch::x86::mmx::_mm_cmpgt_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares whether each element of `a` is greater than the corresponding\n element of `b` returning `0` for `false` and `-1` for `true`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3489890,"byte_end":3489899,"line_start":296,"line_end":296,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3489900,"byte_end":3489933,"line_start":297,"line_end":297,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9317},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3490296,"byte_end":3490310,"line_start":308,"line_end":308,"column_start":15,"column_end":29},"name":"_mm_cmpgt_pi32","qualname":"::core_arch::x86::mmx::_mm_cmpgt_pi32","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares whether each element of `a` is greater than the corresponding\n element of `b` returning `0` for `false` and `-1` for `true`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3490197,"byte_end":3490206,"line_start":305,"line_end":305,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3490207,"byte_end":3490240,"line_start":306,"line_end":306,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9318},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3490618,"byte_end":3490635,"line_start":317,"line_end":317,"column_start":15,"column_end":32},"name":"_mm_unpackhi_pi16","qualname":"::core_arch::x86::mmx::_mm_unpackhi_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Unpacks the upper two elements from two `i16x4` vectors and interleaves\n them into the result: `[a.2, b.2, a.3, b.3]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3490489,"byte_end":3490498,"line_start":314,"line_end":314,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3490499,"byte_end":3490532,"line_start":315,"line_end":315,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9319},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3490937,"byte_end":3490953,"line_start":326,"line_end":326,"column_start":15,"column_end":31},"name":"_mm_unpackhi_pi8","qualname":"::core_arch::x86::mmx::_mm_unpackhi_pi8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Unpacks the upper four elements from two `i8x8` vectors and interleaves\n them into the result: `[a.4, b.4, a.5, b.5, a.6, b.6, a.7, b.7]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3490836,"byte_end":3490845,"line_start":323,"line_end":323,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3490846,"byte_end":3490879,"line_start":324,"line_end":324,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9320},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3491255,"byte_end":3491271,"line_start":335,"line_end":335,"column_start":15,"column_end":31},"name":"_mm_unpacklo_pi8","qualname":"::core_arch::x86::mmx::_mm_unpacklo_pi8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Unpacks the lower four elements from two `i8x8` vectors and interleaves\n them into the result: `[a.0, b.0, a.1, b.1, a.2, b.2, a.3, b.3]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3491154,"byte_end":3491163,"line_start":332,"line_end":332,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3491164,"byte_end":3491197,"line_start":333,"line_end":333,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9321},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3491550,"byte_end":3491567,"line_start":344,"line_end":344,"column_start":15,"column_end":32},"name":"_mm_unpacklo_pi16","qualname":"::core_arch::x86::mmx::_mm_unpacklo_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Unpacks the lower two elements from two `i16x4` vectors and interleaves\n them into the result: `[a.0 b.0 a.1 b.1]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3491449,"byte_end":3491458,"line_start":341,"line_end":341,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3491459,"byte_end":3491492,"line_start":342,"line_end":342,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9322},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3491834,"byte_end":3491851,"line_start":353,"line_end":353,"column_start":15,"column_end":32},"name":"_mm_unpackhi_pi32","qualname":"::core_arch::x86::mmx::_mm_unpackhi_pi32","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Unpacks the upper element from two `i32x2` vectors and interleaves them\n into the result: `[a.1, b.1]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3491733,"byte_end":3491742,"line_start":350,"line_end":350,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3491743,"byte_end":3491776,"line_start":351,"line_end":351,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9323},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3492118,"byte_end":3492135,"line_start":362,"line_end":362,"column_start":15,"column_end":32},"name":"_mm_unpacklo_pi32","qualname":"::core_arch::x86::mmx::_mm_unpacklo_pi32","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Unpacks the lower element from two `i32x2` vectors and interleaves them\n into the result: `[a.0, b.0]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3492017,"byte_end":3492026,"line_start":359,"line_end":359,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3492027,"byte_end":3492060,"line_start":360,"line_end":360,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9324},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3492313,"byte_end":3492325,"line_start":369,"line_end":369,"column_start":15,"column_end":27},"name":"_mm_set_pi16","qualname":"::core_arch::x86::mmx::_mm_set_pi16","value":"fn (e3: i16, e2: i16, e1: i16, e0: i16) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 16-bit integers in dst with the supplied values.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3492255,"byte_end":3492264,"line_start":367,"line_end":367,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3492265,"byte_end":3492298,"line_start":368,"line_end":368,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9325},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3492533,"byte_end":3492545,"line_start":376,"line_end":376,"column_start":15,"column_end":27},"name":"_mm_set_pi32","qualname":"::core_arch::x86::mmx::_mm_set_pi32","value":"fn (e1: i32, e0: i32) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 32-bit integers in dst with the supplied values.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3492475,"byte_end":3492484,"line_start":374,"line_end":374,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3492485,"byte_end":3492518,"line_start":375,"line_end":375,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9326},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3492726,"byte_end":3492737,"line_start":383,"line_end":383,"column_start":15,"column_end":26},"name":"_mm_set_pi8","qualname":"::core_arch::x86::mmx::_mm_set_pi8","value":"fn (e7: i8, e6: i8, e5: i8, e4: i8, e3: i8, e2: i8, e1: i8, e0: i8) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 8-bit integers in dst with the supplied values.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3492668,"byte_end":3492677,"line_start":381,"line_end":381,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3492678,"byte_end":3492711,"line_start":382,"line_end":382,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9327},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3492983,"byte_end":3492996,"line_start":390,"line_end":390,"column_start":15,"column_end":28},"name":"_mm_set1_pi16","qualname":"::core_arch::x86::mmx::_mm_set1_pi16","value":"fn (a: i16) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 16-bit integer a to all all elements of dst.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3492925,"byte_end":3492934,"line_start":388,"line_end":388,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3492935,"byte_end":3492968,"line_start":389,"line_end":389,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9328},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3493167,"byte_end":3493180,"line_start":397,"line_end":397,"column_start":15,"column_end":28},"name":"_mm_set1_pi32","qualname":"::core_arch::x86::mmx::_mm_set1_pi32","value":"fn (a: i32) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 32-bit integer a to all all elements of dst.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3493109,"byte_end":3493118,"line_start":395,"line_end":395,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3493119,"byte_end":3493152,"line_start":396,"line_end":396,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9329},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3493344,"byte_end":3493356,"line_start":404,"line_end":404,"column_start":15,"column_end":27},"name":"_mm_set1_pi8","qualname":"::core_arch::x86::mmx::_mm_set1_pi8","value":"fn (a: i8) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 8-bit integer a to all all elements of dst.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3493286,"byte_end":3493295,"line_start":402,"line_end":402,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3493296,"byte_end":3493329,"line_start":403,"line_end":403,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9330},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3493563,"byte_end":3493576,"line_start":412,"line_end":412,"column_start":15,"column_end":28},"name":"_mm_setr_pi16","qualname":"::core_arch::x86::mmx::_mm_setr_pi16","value":"fn (e0: i16, e1: i16, e2: i16, e3: i16) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 16-bit integers in dst with the supplied values in reverse\n order.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3493505,"byte_end":3493514,"line_start":410,"line_end":410,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3493515,"byte_end":3493548,"line_start":411,"line_end":411,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9331},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3493813,"byte_end":3493826,"line_start":420,"line_end":420,"column_start":15,"column_end":28},"name":"_mm_setr_pi32","qualname":"::core_arch::x86::mmx::_mm_setr_pi32","value":"fn (e0: i32, e1: i32) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 32-bit integers in dst with the supplied values in reverse\n order.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3493755,"byte_end":3493764,"line_start":418,"line_end":418,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3493765,"byte_end":3493798,"line_start":419,"line_end":419,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9332},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3494032,"byte_end":3494044,"line_start":427,"line_end":427,"column_start":15,"column_end":27},"name":"_mm_setr_pi8","qualname":"::core_arch::x86::mmx::_mm_setr_pi8","value":"fn (e0: i8, e1: i8, e2: i8, e3: i8, e4: i8, e5: i8, e6: i8, e7: i8) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 8-bit integers in dst with the supplied values in reverse order.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3493974,"byte_end":3493983,"line_start":425,"line_end":425,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3493984,"byte_end":3494017,"line_start":426,"line_end":426,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9333},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3494495,"byte_end":3494504,"line_start":446,"line_end":446,"column_start":15,"column_end":24},"name":"_mm_empty","qualname":"::core_arch::x86::mmx::_mm_empty","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Empty the MMX state, which marks the x87 FPU registers as available for use\n by x87 instructions. This instruction must be used at the end of all MMX\n technology procedures.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3494399,"byte_end":3494408,"line_start":443,"line_end":443,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3494409,"byte_end":3494442,"line_start":444,"line_end":444,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9334},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3494803,"byte_end":3494811,"line_start":456,"line_end":456,"column_start":15,"column_end":23},"name":"_m_empty","qualname":"::core_arch::x86::mmx::_m_empty","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Empty the MMX state, which marks the x87 FPU registers as available for use\n by x87 instructions. This instruction must be used at the end of all MMX\n technology procedures.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3494707,"byte_end":3494716,"line_start":453,"line_end":453,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3494717,"byte_end":3494750,"line_start":454,"line_end":454,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9335},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3495013,"byte_end":3495029,"line_start":464,"line_end":464,"column_start":15,"column_end":31},"name":"_mm_cvtsi32_si64","qualname":"::core_arch::x86::mmx::_mm_cvtsi32_si64","value":"fn (a: i32) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Copies 32-bit integer `a` to the lower elements of the return value, and zero\n the upper element of the return value.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3494955,"byte_end":3494964,"line_start":462,"line_end":462,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3494965,"byte_end":3494998,"line_start":463,"line_end":463,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9336},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3495186,"byte_end":3495202,"line_start":471,"line_end":471,"column_start":15,"column_end":31},"name":"_mm_cvtsi64_si32","qualname":"::core_arch::x86::mmx::_mm_cvtsi64_si32","value":"fn (a: __m64) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Return the lower 32-bit integer in `a`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3495128,"byte_end":3495137,"line_start":469,"line_end":469,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3495138,"byte_end":3495171,"line_start":470,"line_end":470,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9369},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/pclmulqdq.rs","byte_start":3507958,"byte_end":3507978,"line_start":35,"line_end":35,"column_start":15,"column_end":35},"name":"_mm_clmulepi64_si128","qualname":"::core_arch::x86::pclmulqdq::_mm_clmulepi64_si128","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs a carry-less multiplication of two 64-bit polynomials over the\n finite field GF(2^k).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/pclmulqdq.rs","byte_start":3507398,"byte_end":3507407,"line_start":26,"line_end":26,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"pclmulqdq\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/pclmulqdq.rs","byte_start":3507408,"byte_end":3507447,"line_start":27,"line_end":27,"column_start":1,"column_end":40}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/pclmulqdq.rs","byte_start":3507862,"byte_end":3507893,"line_start":33,"line_end":33,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/pclmulqdq.rs","byte_start":3507894,"byte_end":3507943,"line_start":34,"line_end":34,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9381},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3511153,"byte_end":3511169,"line_start":38,"line_end":38,"column_start":15,"column_end":31},"name":"_mm_aesdec_si128","qualname":"::core_arch::x86::aes::_mm_aesdec_si128","value":"fn (a: __m128i, round_key: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs one round of an AES decryption flow on data (state) in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3511005,"byte_end":3511014,"line_start":34,"line_end":34,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"aes\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3511015,"byte_end":3511048,"line_start":35,"line_end":35,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3511089,"byte_end":3511138,"line_start":37,"line_end":37,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9382},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3511594,"byte_end":3511614,"line_start":49,"line_end":49,"column_start":15,"column_end":35},"name":"_mm_aesdeclast_si128","qualname":"::core_arch::x86::aes::_mm_aesdeclast_si128","value":"fn (a: __m128i, round_key: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs the last round of an AES decryption flow on data (state) in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3511442,"byte_end":3511451,"line_start":45,"line_end":45,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"aes\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3511452,"byte_end":3511485,"line_start":46,"line_end":46,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3511530,"byte_end":3511579,"line_start":48,"line_end":48,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9383},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3512030,"byte_end":3512046,"line_start":60,"line_end":60,"column_start":15,"column_end":31},"name":"_mm_aesenc_si128","qualname":"::core_arch::x86::aes::_mm_aesenc_si128","value":"fn (a: __m128i, round_key: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs one round of an AES encryption flow on data (state) in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3511882,"byte_end":3511891,"line_start":56,"line_end":56,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"aes\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3511892,"byte_end":3511925,"line_start":57,"line_end":57,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3511966,"byte_end":3512015,"line_start":59,"line_end":59,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9384},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3512471,"byte_end":3512491,"line_start":71,"line_end":71,"column_start":15,"column_end":35},"name":"_mm_aesenclast_si128","qualname":"::core_arch::x86::aes::_mm_aesenclast_si128","value":"fn (a: __m128i, round_key: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs the last round of an AES encryption flow on data (state) in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3512319,"byte_end":3512328,"line_start":67,"line_end":67,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"aes\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3512329,"byte_end":3512362,"line_start":68,"line_end":68,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3512407,"byte_end":3512456,"line_start":70,"line_end":70,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9385},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3512890,"byte_end":3512906,"line_start":82,"line_end":82,"column_start":15,"column_end":31},"name":"_mm_aesimc_si128","qualname":"::core_arch::x86::aes::_mm_aesimc_si128","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs the `InvMixColumns` transformation on `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3512742,"byte_end":3512751,"line_start":78,"line_end":78,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"aes\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3512752,"byte_end":3512785,"line_start":79,"line_end":79,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3512826,"byte_end":3512875,"line_start":81,"line_end":81,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9386},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3513501,"byte_end":3513526,"line_start":98,"line_end":98,"column_start":15,"column_end":40},"name":"_mm_aeskeygenassist_si128","qualname":"::core_arch::x86::aes::_mm_aeskeygenassist_si128","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Assist in expanding the AES cipher key.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3513302,"byte_end":3513311,"line_start":93,"line_end":93,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"aes\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3513312,"byte_end":3513345,"line_start":94,"line_end":94,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3513405,"byte_end":3513436,"line_start":96,"line_end":96,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3513437,"byte_end":3513486,"line_start":97,"line_end":97,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9395},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3517728,"byte_end":3517742,"line_start":29,"line_end":29,"column_start":15,"column_end":29},"name":"_rdrand16_step","qualname":"::core_arch::x86::rdrand::_rdrand16_step","value":"fn (val: &mut u16) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Read a hardware generated 16-bit random value and store the result in val.\n Returns 1 if a random value was generated, and 0 otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3517577,"byte_end":3517586,"line_start":25,"line_end":25,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"rdrand\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3517587,"byte_end":3517623,"line_start":26,"line_end":26,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3517664,"byte_end":3517713,"line_start":28,"line_end":28,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9396},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3518243,"byte_end":3518257,"line_start":43,"line_end":43,"column_start":15,"column_end":29},"name":"_rdrand32_step","qualname":"::core_arch::x86::rdrand::_rdrand32_step","value":"fn (val: &mut u32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Read a hardware generated 32-bit random value and store the result in val.\n Returns 1 if a random value was generated, and 0 otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3518092,"byte_end":3518101,"line_start":39,"line_end":39,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"rdrand\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3518102,"byte_end":3518138,"line_start":40,"line_end":40,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3518179,"byte_end":3518228,"line_start":42,"line_end":42,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9397},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3518766,"byte_end":3518780,"line_start":57,"line_end":57,"column_start":15,"column_end":29},"name":"_rdseed16_step","qualname":"::core_arch::x86::rdrand::_rdseed16_step","value":"fn (val: &mut u16) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Read a 16-bit NIST SP800-90B and SP800-90C compliant random value and store\n in val. Return 1 if a random value was generated, and 0 otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3518615,"byte_end":3518624,"line_start":53,"line_end":53,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"rdseed\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3518625,"byte_end":3518661,"line_start":54,"line_end":54,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3518702,"byte_end":3518751,"line_start":56,"line_end":56,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9398},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3519289,"byte_end":3519303,"line_start":71,"line_end":71,"column_start":15,"column_end":29},"name":"_rdseed32_step","qualname":"::core_arch::x86::rdrand::_rdseed32_step","value":"fn (val: &mut u32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Read a 32-bit NIST SP800-90B and SP800-90C compliant random value and store\n in val. Return 1 if a random value was generated, and 0 otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3519138,"byte_end":3519147,"line_start":67,"line_end":67,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"rdseed\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3519148,"byte_end":3519184,"line_start":68,"line_end":68,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3519225,"byte_end":3519274,"line_start":70,"line_end":70,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9414},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3520641,"byte_end":3520659,"line_start":36,"line_end":36,"column_start":15,"column_end":33},"name":"_mm_sha1msg1_epu32","qualname":"::core_arch::x86::sha::_mm_sha1msg1_epu32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs an intermediate calculation for the next four SHA1 message values\n (unsigned 32-bit integers) using previous message values from `a` and `b`,\n and returning the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3520491,"byte_end":3520500,"line_start":32,"line_end":32,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sha\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3520501,"byte_end":3520534,"line_start":33,"line_end":33,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3520577,"byte_end":3520626,"line_start":35,"line_end":35,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9415},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3521230,"byte_end":3521248,"line_start":49,"line_end":49,"column_start":15,"column_end":33},"name":"_mm_sha1msg2_epu32","qualname":"::core_arch::x86::sha::_mm_sha1msg2_epu32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs the final calculation for the next four SHA1 message values\n (unsigned 32-bit integers) using the intermediate result in `a` and the\n previous message values in `b`, and returns the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3521080,"byte_end":3521089,"line_start":45,"line_end":45,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sha\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3521090,"byte_end":3521123,"line_start":46,"line_end":46,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3521166,"byte_end":3521215,"line_start":48,"line_end":48,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9416},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3521827,"byte_end":3521846,"line_start":62,"line_end":62,"column_start":15,"column_end":34},"name":"_mm_sha1nexte_epu32","qualname":"::core_arch::x86::sha::_mm_sha1nexte_epu32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Calculate SHA1 state variable E after four rounds of operation from the\n current SHA1 state variable `a`, add that value to the scheduled values\n (unsigned 32-bit integers) in `b`, and returns the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3521676,"byte_end":3521685,"line_start":58,"line_end":58,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sha\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3521686,"byte_end":3521719,"line_start":59,"line_end":59,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3521763,"byte_end":3521812,"line_start":61,"line_end":61,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9417},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3522581,"byte_end":3522600,"line_start":78,"line_end":78,"column_start":15,"column_end":34},"name":"_mm_sha1rnds4_epu32","qualname":"::core_arch::x86::sha::_mm_sha1rnds4_epu32","value":"fn (a: __m128i, b: __m128i, func: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs four rounds of SHA1 operation using an initial SHA1 state (A,B,C,D)\n from `a` and some pre-computed sum of the next 4 round message values\n (unsigned 32-bit integers), and state variable E from `b`, and return the\n updated SHA1 state (A,B,C,D). `func` contains the logic functions and round\n constants.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3522388,"byte_end":3522397,"line_start":73,"line_end":73,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sha\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3522398,"byte_end":3522431,"line_start":74,"line_end":74,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3522485,"byte_end":3522516,"line_start":76,"line_end":76,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3522517,"byte_end":3522566,"line_start":77,"line_end":77,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9419},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3523327,"byte_end":3523347,"line_start":99,"line_end":99,"column_start":15,"column_end":35},"name":"_mm_sha256msg1_epu32","qualname":"::core_arch::x86::sha::_mm_sha256msg1_epu32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs an intermediate calculation for the next four SHA256 message values\n (unsigned 32-bit integers) using previous message values from `a` and `b`,\n and return the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3523175,"byte_end":3523184,"line_start":95,"line_end":95,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sha\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3523185,"byte_end":3523218,"line_start":96,"line_end":96,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3523263,"byte_end":3523312,"line_start":98,"line_end":98,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9420},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3523896,"byte_end":3523916,"line_start":112,"line_end":112,"column_start":15,"column_end":35},"name":"_mm_sha256msg2_epu32","qualname":"::core_arch::x86::sha::_mm_sha256msg2_epu32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs the final calculation for the next four SHA256 message values\n (unsigned 32-bit integers) using previous message values from `a` and `b`,\n and return the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3523744,"byte_end":3523753,"line_start":108,"line_end":108,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sha\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3523754,"byte_end":3523787,"line_start":109,"line_end":109,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3523832,"byte_end":3523881,"line_start":111,"line_end":111,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9421},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3524624,"byte_end":3524645,"line_start":127,"line_end":127,"column_start":15,"column_end":36},"name":"_mm_sha256rnds2_epu32","qualname":"::core_arch::x86::sha::_mm_sha256rnds2_epu32","value":"fn (a: __m128i, b: __m128i, k: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs 2 rounds of SHA256 operation using an initial SHA256 state\n (C,D,G,H) from `a`, an initial SHA256 state (A,B,E,F) from `b`, and a\n pre-computed sum of the next 2 round message values (unsigned 32-bit\n integers) and the corresponding round constants from `k`, and store the\n updated SHA256 state (A,B,E,F) in dst.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3524471,"byte_end":3524480,"line_start":123,"line_end":123,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sha\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3524481,"byte_end":3524514,"line_start":124,"line_end":124,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3524560,"byte_end":3524609,"line_start":126,"line_end":126,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9428},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/adx.rs","byte_start":3529267,"byte_end":3529280,"line_start":20,"line_end":20,"column_start":15,"column_end":28},"name":"_addcarry_u32","qualname":"::core_arch::x86::adx::_addcarry_u32","value":"fn (c_in: u8, a: u32, b: u32, out: &mut u32) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Adds unsigned 32-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in`\n (carry flag), and store the unsigned 32-bit result in `out`, and the carry-out\n is returned (carry or overflow flag).\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/adx.rs","byte_start":3529152,"byte_end":3529161,"line_start":17,"line_end":17,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86_adx\", since = \"1.33.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/adx.rs","byte_start":3529199,"byte_end":3529252,"line_start":19,"line_end":19,"column_start":1,"column_end":54}}]},{"kind":"Function","id":{"krate":0,"index":9429},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/adx.rs","byte_start":3529769,"byte_end":3529783,"line_start":33,"line_end":33,"column_start":15,"column_end":29},"name":"_addcarryx_u32","qualname":"::core_arch::x86::adx::_addcarryx_u32","value":"fn (c_in: u8, a: u32, b: u32, out: &mut u32) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Adds unsigned 32-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in`\n (carry or overflow flag), and store the unsigned 32-bit result in `out`, and\n the carry-out is returned (carry or overflow flag).\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/adx.rs","byte_start":3529620,"byte_end":3529629,"line_start":29,"line_end":29,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"adx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/adx.rs","byte_start":3529630,"byte_end":3529663,"line_start":30,"line_end":30,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86_adx\", since = \"1.33.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/adx.rs","byte_start":3529701,"byte_end":3529754,"line_start":32,"line_end":32,"column_start":1,"column_end":54}}]},{"kind":"Function","id":{"krate":0,"index":9430},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/adx.rs","byte_start":3530231,"byte_end":3530245,"line_start":43,"line_end":43,"column_start":15,"column_end":29},"name":"_subborrow_u32","qualname":"::core_arch::x86::adx::_subborrow_u32","value":"fn (c_in: u8, a: u32, b: u32, out: &mut u32) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Adds unsigned 32-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in`\n (carry or overflow flag), and store the unsigned 32-bit result in `out`, and\n the carry-out is returned (carry or overflow flag).\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/adx.rs","byte_start":3530116,"byte_end":3530125,"line_start":40,"line_end":40,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86_adx\", since = \"1.33.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/adx.rs","byte_start":3530163,"byte_end":3530216,"line_start":42,"line_end":42,"column_start":1,"column_end":54}}]},{"kind":"Function","id":{"krate":0,"index":9432},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2514757,"byte_end":2514760,"line_start":556,"line_end":556,"column_start":15,"column_end":18},"name":"ud2","qualname":"::core_arch::x86::ud2","value":"fn () -> !","parent":null,"children":[],"decl_id":null,"docs":" Generates the trap instruction `UD2`\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2514733,"byte_end":2514742,"line_start":555,"line_end":555,"column_start":1,"column_end":10}}]},{"kind":"Function","id":{"krate":0,"index":9442},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3533656,"byte_end":3533672,"line_start":15,"line_end":15,"column_start":15,"column_end":31},"name":"_mm512_abs_epi32","qualname":"::core_arch::x86::avx512f::_mm512_abs_epi32","value":"fn (a: __m512i) -> __m512i","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute values of packed 32-bit integers in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3533554,"byte_end":3533563,"line_start":12,"line_end":12,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512f\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3533564,"byte_end":3533601,"line_start":13,"line_end":13,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9443},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3534396,"byte_end":3534417,"line_start":32,"line_end":32,"column_start":15,"column_end":36},"name":"_mm512_mask_abs_epi32","qualname":"::core_arch::x86::avx512f::_mm512_mask_abs_epi32","value":"fn (src: __m512i, k: __mmask16, a: __m512i) -> __m512i","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute value of packed 32-bit integers in `a`, and store the\n unsigned results in `dst` using writemask `k` (elements are copied from\n `src` when the corresponding mask bit is not set).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3534294,"byte_end":3534303,"line_start":29,"line_end":29,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512f\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3534304,"byte_end":3534341,"line_start":30,"line_end":30,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9444},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3535059,"byte_end":3535081,"line_start":45,"line_end":45,"column_start":15,"column_end":37},"name":"_mm512_maskz_abs_epi32","qualname":"::core_arch::x86::avx512f::_mm512_maskz_abs_epi32","value":"fn (k: __mmask16, a: __m512i) -> __m512i","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute value of packed 32-bit integers in `a`, and store the\n unsigned results in `dst` using zeromask `k` (elements are zeroed out when\n the corresponding mask bit is not set).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3534957,"byte_end":3534966,"line_start":42,"line_end":42,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512f\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3534967,"byte_end":3535004,"line_start":43,"line_end":43,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9445},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3535600,"byte_end":3535620,"line_start":57,"line_end":57,"column_start":15,"column_end":35},"name":"_mm512_setzero_si512","qualname":"::core_arch::x86::avx512f::_mm512_setzero_si512","value":"fn () -> __m512i","parent":null,"children":[],"decl_id":null,"docs":" Returns vector of type `__m512i` with all elements set to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3535498,"byte_end":3535507,"line_start":54,"line_end":54,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512f\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3535508,"byte_end":3535545,"line_start":55,"line_end":55,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9446},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3535854,"byte_end":3535871,"line_start":66,"line_end":66,"column_start":15,"column_end":32},"name":"_mm512_setr_epi32","qualname":"::core_arch::x86::avx512f::_mm512_setr_epi32","value":"fn (e15: i32, e14: i32, e13: i32, e12: i32, e11: i32, e10: i32, e9: i32, e8: i32, e7: i32, e6: i32, e5: i32, e4: i32, e3: i32, e2: i32, e1: i32, e0: i32) -> __m512i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 32-bit integers in `dst` with the supplied values in reverse\n order.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3535792,"byte_end":3535801,"line_start":64,"line_end":64,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512f\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3535802,"byte_end":3535839,"line_start":65,"line_end":65,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9447},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3536348,"byte_end":3536365,"line_start":93,"line_end":93,"column_start":15,"column_end":32},"name":"_mm512_set1_epi64","qualname":"::core_arch::x86::avx512f::_mm512_set1_epi64","value":"fn (a: i64) -> __m512i","parent":null,"children":[],"decl_id":null,"docs":" Broadcast 64-bit integer `a` to all elements of `dst`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3536286,"byte_end":3536295,"line_start":91,"line_end":91,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512f\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3536296,"byte_end":3536333,"line_start":92,"line_end":92,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9451},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3539582,"byte_end":3539603,"line_start":16,"line_end":16,"column_start":15,"column_end":36},"name":"_mm512_madd52hi_epu64","qualname":"::core_arch::x86::avx512ifma::_mm512_madd52hi_epu64","value":"fn (a: __m512i, b: __m512i, c: __m512i) -> __m512i","parent":null,"children":[],"decl_id":null,"docs":" Multiply packed unsigned 52-bit integers in each 64-bit element of\n `b` and `c` to form a 104-bit intermediate result. Add the high 52-bit\n unsigned integer from the intermediate result with the\n corresponding unsigned 64-bit integer in `a`, and store the\n results in `dst`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3539472,"byte_end":3539481,"line_start":13,"line_end":13,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512ifma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3539482,"byte_end":3539522,"line_start":14,"line_end":14,"column_start":1,"column_end":41}}]},{"kind":"Function","id":{"krate":0,"index":9452},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3540217,"byte_end":3540238,"line_start":30,"line_end":30,"column_start":15,"column_end":36},"name":"_mm512_madd52lo_epu64","qualname":"::core_arch::x86::avx512ifma::_mm512_madd52lo_epu64","value":"fn (a: __m512i, b: __m512i, c: __m512i) -> __m512i","parent":null,"children":[],"decl_id":null,"docs":" Multiply packed unsigned 52-bit integers in each 64-bit element of\n `b` and `c` to form a 104-bit intermediate result. Add the low 52-bit\n unsigned integer from the intermediate result with the\n corresponding unsigned 64-bit integer in `a`, and store the\n results in `dst`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3540107,"byte_end":3540116,"line_start":27,"line_end":27,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512ifma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3540117,"byte_end":3540157,"line_start":28,"line_end":28,"column_start":1,"column_end":41}}]},{"kind":"Function","id":{"krate":0,"index":9453},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3540885,"byte_end":3540906,"line_start":44,"line_end":44,"column_start":15,"column_end":36},"name":"_mm256_madd52hi_epu64","qualname":"::core_arch::x86::avx512ifma::_mm256_madd52hi_epu64","value":"fn (a: __m256i, b: __m256i, c: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Multiply packed unsigned 52-bit integers in each 64-bit element of\n `b` and `c` to form a 104-bit intermediate result. Add the high 52-bit\n unsigned integer from the intermediate result with the\n corresponding unsigned 64-bit integer in `a`, and store the\n results in `dst`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3540766,"byte_end":3540775,"line_start":41,"line_end":41,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512ifma,avx512vl\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3540776,"byte_end":3540825,"line_start":42,"line_end":42,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9454},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3541552,"byte_end":3541573,"line_start":58,"line_end":58,"column_start":15,"column_end":36},"name":"_mm256_madd52lo_epu64","qualname":"::core_arch::x86::avx512ifma::_mm256_madd52lo_epu64","value":"fn (a: __m256i, b: __m256i, c: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Multiply packed unsigned 52-bit integers in each 64-bit element of\n `b` and `c` to form a 104-bit intermediate result. Add the low 52-bit\n unsigned integer from the intermediate result with the\n corresponding unsigned 64-bit integer in `a`, and store the\n results in `dst`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3541433,"byte_end":3541442,"line_start":55,"line_end":55,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512ifma,avx512vl\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3541443,"byte_end":3541492,"line_start":56,"line_end":56,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9455},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3542225,"byte_end":3542243,"line_start":72,"line_end":72,"column_start":15,"column_end":33},"name":"_mm_madd52hi_epu64","qualname":"::core_arch::x86::avx512ifma::_mm_madd52hi_epu64","value":"fn (a: __m128i, b: __m128i, c: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiply packed unsigned 52-bit integers in each 64-bit element of\n `b` and `c` to form a 104-bit intermediate result. Add the high 52-bit\n unsigned integer from the intermediate result with the\n corresponding unsigned 64-bit integer in `a`, and store the\n results in `dst`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3542106,"byte_end":3542115,"line_start":69,"line_end":69,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512ifma,avx512vl\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3542116,"byte_end":3542165,"line_start":70,"line_end":70,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9456},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3542894,"byte_end":3542912,"line_start":86,"line_end":86,"column_start":15,"column_end":33},"name":"_mm_madd52lo_epu64","qualname":"::core_arch::x86::avx512ifma::_mm_madd52lo_epu64","value":"fn (a: __m128i, b: __m128i, c: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiply packed unsigned 52-bit integers in each 64-bit element of\n `b` and `c` to form a 104-bit intermediate result. Add the low 52-bit\n unsigned integer from the intermediate result with the\n corresponding unsigned 64-bit integer in `a`, and store the\n results in `dst`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3542775,"byte_end":3542784,"line_start":83,"line_end":83,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512ifma,avx512vl\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3542785,"byte_end":3542834,"line_start":84,"line_end":84,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9466},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3546888,"byte_end":3546896,"line_start":8,"line_end":8,"column_start":15,"column_end":23},"name":"_bittest","qualname":"::core_arch::x86::bt::_bittest","value":"fn (p: *const i32, b: i32) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Returns the bit in position `b` of the memory addressed by `p`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3546769,"byte_end":3546778,"line_start":5,"line_end":5,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"simd_x86_bittest\", issue = \"59414\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3546815,"byte_end":3546873,"line_start":7,"line_end":7,"column_start":1,"column_end":59}}]},{"kind":"Function","id":{"krate":0,"index":9467},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3547277,"byte_end":3547291,"line_start":21,"line_end":21,"column_start":15,"column_end":29},"name":"_bittestandset","qualname":"::core_arch::x86::bt::_bittestandset","value":"fn (p: *mut i32, b: i32) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Returns the bit in position `b` of the memory addressed by `p`, then sets the bit to `1`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3547157,"byte_end":3547166,"line_start":18,"line_end":18,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"simd_x86_bittest\", issue = \"59414\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3547204,"byte_end":3547262,"line_start":20,"line_end":20,"column_start":1,"column_end":59}}]},{"kind":"Function","id":{"krate":0,"index":9468},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3547675,"byte_end":3547691,"line_start":34,"line_end":34,"column_start":15,"column_end":31},"name":"_bittestandreset","qualname":"::core_arch::x86::bt::_bittestandreset","value":"fn (p: *mut i32, b: i32) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Returns the bit in position `b` of the memory addressed by `p`, then resets that bit to `0`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3547555,"byte_end":3547564,"line_start":31,"line_end":31,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"simd_x86_bittest\", issue = \"59414\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3547602,"byte_end":3547660,"line_start":33,"line_end":33,"column_start":1,"column_end":59}}]},{"kind":"Function","id":{"krate":0,"index":9469},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3548069,"byte_end":3548090,"line_start":47,"line_end":47,"column_start":15,"column_end":36},"name":"_bittestandcomplement","qualname":"::core_arch::x86::bt::_bittestandcomplement","value":"fn (p: *mut i32, b: i32) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Returns the bit in position `b` of the memory addressed by `p`, then inverts that bit.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3547949,"byte_end":3547958,"line_start":44,"line_end":44,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"simd_x86_bittest\", issue = \"59414\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3547996,"byte_end":3548054,"line_start":46,"line_end":46,"column_start":1,"column_end":59}}]},{"kind":"Function","id":{"krate":0,"index":9476},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/fxsr.rs","byte_start":3551263,"byte_end":3551272,"line_start":30,"line_end":30,"column_start":15,"column_end":24},"name":"_fxsave64","qualname":"::core_arch::x86_64::fxsr::_fxsave64","value":"fn (mem_addr: *mut u8) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Saves the `x87` FPU, `MMX` technology, `XMM`, and `MXCSR` registers to the\n 512-byte-long 16-byte-aligned memory region `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/fxsr.rs","byte_start":3551112,"byte_end":3551121,"line_start":26,"line_end":26,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fxsr\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/fxsr.rs","byte_start":3551122,"byte_end":3551156,"line_start":27,"line_end":27,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/fxsr.rs","byte_start":3551199,"byte_end":3551248,"line_start":29,"line_end":29,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9477},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/fxsr.rs","byte_start":3552144,"byte_end":3552154,"line_start":54,"line_end":54,"column_start":15,"column_end":25},"name":"_fxrstor64","qualname":"::core_arch::x86_64::fxsr::_fxrstor64","value":"fn (mem_addr: *const u8) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Restores the `XMM`, `MMX`, `MXCSR`, and `x87` FPU registers from the\n 512-byte-long 16-byte-aligned memory region `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/fxsr.rs","byte_start":3551992,"byte_end":3552001,"line_start":50,"line_end":50,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fxsr\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/fxsr.rs","byte_start":3552002,"byte_end":3552036,"line_start":51,"line_end":51,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/fxsr.rs","byte_start":3552080,"byte_end":3552129,"line_start":53,"line_end":53,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9485},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3554750,"byte_end":3554764,"line_start":33,"line_end":33,"column_start":15,"column_end":29},"name":"_mm_cvtss_si64","qualname":"::core_arch::x86_64::sse::_mm_cvtss_si64","value":"fn (a: __m128) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Converts the lowest 32 bit float in the input vector to a 64 bit integer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3554600,"byte_end":3554609,"line_start":29,"line_end":29,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3554610,"byte_end":3554643,"line_start":30,"line_end":30,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3554686,"byte_end":3554735,"line_start":32,"line_end":32,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9486},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3555557,"byte_end":3555572,"line_start":52,"line_end":52,"column_start":15,"column_end":30},"name":"_mm_cvttss_si64","qualname":"::core_arch::x86_64::sse::_mm_cvttss_si64","value":"fn (a: __m128) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Converts the lowest 32 bit float in the input vector to a 64 bit integer\n with truncation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3555406,"byte_end":3555415,"line_start":48,"line_end":48,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3555416,"byte_end":3555449,"line_start":49,"line_end":49,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3555493,"byte_end":3555542,"line_start":51,"line_end":51,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9487},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3556129,"byte_end":3556143,"line_start":67,"line_end":67,"column_start":15,"column_end":29},"name":"_mm_cvtsi64_ss","qualname":"::core_arch::x86_64::sse::_mm_cvtsi64_ss","value":"fn (a: __m128, b: i64) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts a 64 bit integer to a 32 bit float. The result vector is the input\n vector `a` with the lowest 32 bit float replaced by the converted integer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3555979,"byte_end":3555988,"line_start":63,"line_end":63,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3555989,"byte_end":3556022,"line_start":64,"line_end":64,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3556065,"byte_end":3556114,"line_start":66,"line_end":66,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9498},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3559247,"byte_end":3559261,"line_start":27,"line_end":27,"column_start":15,"column_end":29},"name":"_mm_cvtsd_si64","qualname":"::core_arch::x86_64::sse2::_mm_cvtsd_si64","value":"fn (a: __m128d) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Converts the lower double-precision (64-bit) floating-point element in a to\n a 64-bit integer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3559096,"byte_end":3559105,"line_start":23,"line_end":23,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3559106,"byte_end":3559140,"line_start":24,"line_end":24,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3559183,"byte_end":3559232,"line_start":26,"line_end":26,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9499},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3559602,"byte_end":3559617,"line_start":38,"line_end":38,"column_start":15,"column_end":30},"name":"_mm_cvtsd_si64x","qualname":"::core_arch::x86_64::sse2::_mm_cvtsd_si64x","value":"fn (a: __m128d) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Alias for `_mm_cvtsd_si64`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3559451,"byte_end":3559460,"line_start":34,"line_end":34,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3559461,"byte_end":3559495,"line_start":35,"line_end":35,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3559538,"byte_end":3559587,"line_start":37,"line_end":37,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9500},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3560052,"byte_end":3560067,"line_start":50,"line_end":50,"column_start":15,"column_end":30},"name":"_mm_cvttsd_si64","qualname":"::core_arch::x86_64::sse2::_mm_cvttsd_si64","value":"fn (a: __m128d) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Converts the lower double-precision (64-bit) floating-point element in `a`\n to a 64-bit integer with truncation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3559900,"byte_end":3559909,"line_start":46,"line_end":46,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3559910,"byte_end":3559944,"line_start":47,"line_end":47,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3559988,"byte_end":3560037,"line_start":49,"line_end":49,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9501},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3560412,"byte_end":3560428,"line_start":61,"line_end":61,"column_start":15,"column_end":31},"name":"_mm_cvttsd_si64x","qualname":"::core_arch::x86_64::sse2::_mm_cvttsd_si64x","value":"fn (a: __m128d) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Alias for `_mm_cvttsd_si64`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3560260,"byte_end":3560269,"line_start":57,"line_end":57,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3560270,"byte_end":3560304,"line_start":58,"line_end":58,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3560348,"byte_end":3560397,"line_start":60,"line_end":60,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9502},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3560908,"byte_end":3560923,"line_start":74,"line_end":74,"column_start":15,"column_end":30},"name":"_mm_stream_si64","qualname":"::core_arch::x86_64::sse2::_mm_stream_si64","value":"fn (mem_addr: *mut i64, a: i64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores a 64-bit integer value in the specified memory location.\n To minimize caching, the data is flagged as non-temporal (unlikely to be\n used again soon).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3560759,"byte_end":3560768,"line_start":70,"line_end":70,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3560769,"byte_end":3560803,"line_start":71,"line_end":71,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3560844,"byte_end":3560893,"line_start":73,"line_end":73,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9503},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3561375,"byte_end":3561392,"line_start":86,"line_end":86,"column_start":15,"column_end":32},"name":"_mm_cvtsi64_si128","qualname":"::core_arch::x86_64::sse2::_mm_cvtsi64_si128","value":"fn (a: i64) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns a vector whose lowest element is `a` and all higher elements are\n `0`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3561209,"byte_end":3561218,"line_start":82,"line_end":82,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3561219,"byte_end":3561253,"line_start":83,"line_end":83,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3561311,"byte_end":3561360,"line_start":85,"line_end":85,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9504},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3561813,"byte_end":3561831,"line_start":98,"line_end":98,"column_start":15,"column_end":33},"name":"_mm_cvtsi64x_si128","qualname":"::core_arch::x86_64::sse2::_mm_cvtsi64x_si128","value":"fn (a: i64) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns a vector whose lowest element is `a` and all higher elements are\n `0`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3561647,"byte_end":3561656,"line_start":94,"line_end":94,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3561657,"byte_end":3561691,"line_start":95,"line_end":95,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3561749,"byte_end":3561798,"line_start":97,"line_end":97,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9505},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3562204,"byte_end":3562221,"line_start":109,"line_end":109,"column_start":15,"column_end":32},"name":"_mm_cvtsi128_si64","qualname":"::core_arch::x86_64::sse2::_mm_cvtsi128_si64","value":"fn (a: __m128i) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Returns the lowest element of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3562038,"byte_end":3562047,"line_start":105,"line_end":105,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3562048,"byte_end":3562082,"line_start":106,"line_end":106,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3562140,"byte_end":3562189,"line_start":108,"line_end":108,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9506},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3562604,"byte_end":3562622,"line_start":120,"line_end":120,"column_start":15,"column_end":33},"name":"_mm_cvtsi128_si64x","qualname":"::core_arch::x86_64::sse2::_mm_cvtsi128_si64x","value":"fn (a: __m128i) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Returns the lowest element of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3562438,"byte_end":3562447,"line_start":116,"line_end":116,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3562448,"byte_end":3562482,"line_start":117,"line_end":117,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3562540,"byte_end":3562589,"line_start":119,"line_end":119,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9507},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3563030,"byte_end":3563044,"line_start":132,"line_end":132,"column_start":15,"column_end":29},"name":"_mm_cvtsi64_sd","qualname":"::core_arch::x86_64::sse2::_mm_cvtsi64_sd","value":"fn (a: __m128d, b: i64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns `a` with its lower element replaced by `b` after converting it to\n an `f64`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3562879,"byte_end":3562888,"line_start":128,"line_end":128,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3562889,"byte_end":3562923,"line_start":129,"line_end":129,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3562966,"byte_end":3563015,"line_start":131,"line_end":131,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9508},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3563472,"byte_end":3563487,"line_start":144,"line_end":144,"column_start":15,"column_end":30},"name":"_mm_cvtsi64x_sd","qualname":"::core_arch::x86_64::sse2::_mm_cvtsi64x_sd","value":"fn (a: __m128d, b: i64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns `a` with its lower element replaced by `b` after converting it to\n an `f64`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3563321,"byte_end":3563330,"line_start":140,"line_end":140,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3563331,"byte_end":3563365,"line_start":141,"line_end":141,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3563408,"byte_end":3563457,"line_start":143,"line_end":143,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9516},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse41.rs","byte_start":3565870,"byte_end":3565887,"line_start":19,"line_end":19,"column_start":15,"column_end":32},"name":"_mm_extract_epi64","qualname":"::core_arch::x86_64::sse41::_mm_extract_epi64","value":"fn (a: __m128i, imm8: i32) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Extracts an 64-bit integer from `a` selected with `imm8`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse41.rs","byte_start":3565644,"byte_end":3565653,"line_start":14,"line_end":14,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse41.rs","byte_start":3565654,"byte_end":3565690,"line_start":15,"line_end":15,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse41.rs","byte_start":3565774,"byte_end":3565805,"line_start":17,"line_end":17,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse41.rs","byte_start":3565806,"byte_end":3565855,"line_start":18,"line_end":18,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9517},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse41.rs","byte_start":3566411,"byte_end":3566427,"line_start":33,"line_end":33,"column_start":15,"column_end":31},"name":"_mm_insert_epi64","qualname":"::core_arch::x86_64::sse41::_mm_insert_epi64","value":"fn (a: __m128i, i: i64, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns a copy of `a` with the 64-bit integer from `i` inserted at a\n location specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse41.rs","byte_start":3566218,"byte_end":3566227,"line_start":28,"line_end":28,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse41.rs","byte_start":3566228,"byte_end":3566264,"line_start":29,"line_end":29,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse41.rs","byte_start":3566315,"byte_end":3566346,"line_start":31,"line_end":31,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse41.rs","byte_start":3566347,"byte_end":3566396,"line_start":32,"line_end":32,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9522},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse42.rs","byte_start":3567824,"byte_end":3567837,"line_start":20,"line_end":20,"column_start":15,"column_end":28},"name":"_mm_crc32_u64","qualname":"::core_arch::x86_64::sse42::_mm_crc32_u64","value":"fn (crc: u64, v: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Starting with the initial value in `crc`, return the accumulated\n CRC32 value for unsigned 64-bit integer `v`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse42.rs","byte_start":3567674,"byte_end":3567683,"line_start":16,"line_end":16,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse42.rs","byte_start":3567684,"byte_end":3567720,"line_start":17,"line_end":17,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse42.rs","byte_start":3567760,"byte_end":3567809,"line_start":19,"line_end":19,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9532},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3569622,"byte_end":3569630,"line_start":38,"line_end":38,"column_start":15,"column_end":23},"name":"_xsave64","qualname":"::core_arch::x86_64::xsave::_xsave64","value":"fn (mem_addr: *mut u8, save_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial save of the enabled processor states to memory at\n `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3569471,"byte_end":3569480,"line_start":34,"line_end":34,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3569481,"byte_end":3569516,"line_start":35,"line_end":35,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3569558,"byte_end":3569607,"line_start":37,"line_end":37,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9533},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3570297,"byte_end":3570306,"line_start":54,"line_end":54,"column_start":15,"column_end":24},"name":"_xrstor64","qualname":"::core_arch::x86_64::xsave::_xrstor64","value":"fn (mem_addr: *const u8, rs_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial restore of the enabled processor states using\n the state information stored in memory at `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3570145,"byte_end":3570154,"line_start":50,"line_end":50,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3570155,"byte_end":3570190,"line_start":51,"line_end":51,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3570233,"byte_end":3570282,"line_start":53,"line_end":53,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9534},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3571080,"byte_end":3571091,"line_start":71,"line_end":71,"column_start":15,"column_end":26},"name":"_xsaveopt64","qualname":"::core_arch::x86_64::xsave::_xsaveopt64","value":"fn (mem_addr: *mut u8, save_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial save of the enabled processor states to memory at\n `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3570917,"byte_end":3570926,"line_start":67,"line_end":67,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave,xsaveopt\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3570927,"byte_end":3570971,"line_start":68,"line_end":68,"column_start":1,"column_end":45}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3571016,"byte_end":3571065,"line_start":70,"line_end":70,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9535},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3571795,"byte_end":3571804,"line_start":87,"line_end":87,"column_start":15,"column_end":24},"name":"_xsavec64","qualname":"::core_arch::x86_64::xsave::_xsavec64","value":"fn (mem_addr: *mut u8, save_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial save of the enabled processor states to memory\n at `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3571636,"byte_end":3571645,"line_start":83,"line_end":83,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave,xsavec\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3571646,"byte_end":3571688,"line_start":84,"line_end":84,"column_start":1,"column_end":43}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3571731,"byte_end":3571780,"line_start":86,"line_end":86,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9536},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3572571,"byte_end":3572580,"line_start":104,"line_end":104,"column_start":15,"column_end":24},"name":"_xsaves64","qualname":"::core_arch::x86_64::xsave::_xsaves64","value":"fn (mem_addr: *mut u8, save_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial save of the enabled processor states to memory at\n `mem_addr`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3572412,"byte_end":3572421,"line_start":100,"line_end":100,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave,xsaves\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3572422,"byte_end":3572464,"line_start":101,"line_end":101,"column_start":1,"column_end":43}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3572507,"byte_end":3572556,"line_start":103,"line_end":103,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9537},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3573492,"byte_end":3573502,"line_start":123,"line_end":123,"column_start":15,"column_end":25},"name":"_xrstors64","qualname":"::core_arch::x86_64::xsave::_xrstors64","value":"fn (mem_addr: *const u8, rs_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial restore of the enabled processor states using the\n state information stored in memory at `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3573332,"byte_end":3573341,"line_start":119,"line_end":119,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave,xsaves\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3573342,"byte_end":3573384,"line_start":120,"line_end":120,"column_start":1,"column_end":43}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3573428,"byte_end":3573477,"line_start":122,"line_end":122,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9540},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/abm.rs","byte_start":3577754,"byte_end":3577764,"line_start":32,"line_end":32,"column_start":15,"column_end":25},"name":"_lzcnt_u64","qualname":"::core_arch::x86_64::abm::_lzcnt_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Counts the leading most significant zero bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/abm.rs","byte_start":3577605,"byte_end":3577614,"line_start":28,"line_end":28,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"lzcnt\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/abm.rs","byte_start":3577615,"byte_end":3577650,"line_start":29,"line_end":29,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/abm.rs","byte_start":3577690,"byte_end":3577739,"line_start":31,"line_end":31,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9541},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/abm.rs","byte_start":3578109,"byte_end":3578118,"line_start":43,"line_end":43,"column_start":15,"column_end":24},"name":"_popcnt64","qualname":"::core_arch::x86_64::abm::_popcnt64","value":"fn (x: i64) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Counts the bits that are set.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/abm.rs","byte_start":3577958,"byte_end":3577967,"line_start":39,"line_end":39,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"popcnt\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/abm.rs","byte_start":3577968,"byte_end":3578004,"line_start":40,"line_end":40,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/abm.rs","byte_start":3578045,"byte_end":3578094,"line_start":42,"line_end":42,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9549},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/avx.rs","byte_start":3579717,"byte_end":3579736,"line_start":30,"line_end":30,"column_start":15,"column_end":34},"name":"_mm256_insert_epi64","qualname":"::core_arch::x86_64::avx::_mm256_insert_epi64","value":"fn (a: __m256i, i: i64, index: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Copies `a` to result, and insert the 64-bit integer `i` into result\n at the location specified by `index`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/avx.rs","byte_start":3579525,"byte_end":3579534,"line_start":25,"line_end":25,"column_start":1,"column_end":10}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/avx.rs","byte_start":3579535,"byte_end":3579566,"line_start":26,"line_end":26,"column_start":1,"column_end":32}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/avx.rs","byte_start":3579567,"byte_end":3579600,"line_start":27,"line_end":27,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/avx.rs","byte_start":3579653,"byte_end":3579702,"line_start":29,"line_end":29,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9552},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3581244,"byte_end":3581254,"line_start":24,"line_end":24,"column_start":15,"column_end":25},"name":"_bextr_u64","qualname":"::core_arch::x86_64::bmi::_bextr_u64","value":"fn (a: u64, start: u32, len: u32) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Extracts bits in range [`start`, `start` + `length`) from `a` into\n the least significant bits of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3581063,"byte_end":3581072,"line_start":19,"line_end":19,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3581073,"byte_end":3581107,"line_start":20,"line_end":20,"column_start":1,"column_end":35}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3581147,"byte_end":3581179,"line_start":22,"line_end":22,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3581180,"byte_end":3581229,"line_start":23,"line_end":23,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9553},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3581909,"byte_end":3581920,"line_start":40,"line_end":40,"column_start":15,"column_end":26},"name":"_bextr2_u64","qualname":"::core_arch::x86_64::bmi::_bextr2_u64","value":"fn (a: u64, control: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Extracts bits of `a` specified by `control` into\n the least significant bits of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3581728,"byte_end":3581737,"line_start":35,"line_end":35,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3581738,"byte_end":3581772,"line_start":36,"line_end":36,"column_start":1,"column_end":35}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3581812,"byte_end":3581844,"line_start":38,"line_end":38,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3581845,"byte_end":3581894,"line_start":39,"line_end":39,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9554},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3582297,"byte_end":3582306,"line_start":51,"line_end":51,"column_start":15,"column_end":24},"name":"_andn_u64","qualname":"::core_arch::x86_64::bmi::_andn_u64","value":"fn (a: u64, b: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Bitwise logical `AND` of inverted `a` with `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3582150,"byte_end":3582159,"line_start":47,"line_end":47,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3582160,"byte_end":3582194,"line_start":48,"line_end":48,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3582233,"byte_end":3582282,"line_start":50,"line_end":50,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9555},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3582708,"byte_end":3582717,"line_start":63,"line_end":63,"column_start":15,"column_end":24},"name":"_blsi_u64","qualname":"::core_arch::x86_64::bmi::_blsi_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Extracts lowest set isolated bit.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3582494,"byte_end":3582503,"line_start":58,"line_end":58,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3582504,"byte_end":3582538,"line_start":59,"line_end":59,"column_start":1,"column_end":35}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3582577,"byte_end":3582609,"line_start":61,"line_end":61,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3582644,"byte_end":3582693,"line_start":62,"line_end":62,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9556},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3583127,"byte_end":3583138,"line_start":75,"line_end":75,"column_start":15,"column_end":26},"name":"_blsmsk_u64","qualname":"::core_arch::x86_64::bmi::_blsmsk_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Gets mask up to lowest set bit.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3582911,"byte_end":3582920,"line_start":70,"line_end":70,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3582921,"byte_end":3582955,"line_start":71,"line_end":71,"column_start":1,"column_end":35}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3582996,"byte_end":3583028,"line_start":73,"line_end":73,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3583063,"byte_end":3583112,"line_start":74,"line_end":74,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9557},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3583580,"byte_end":3583589,"line_start":89,"line_end":89,"column_start":15,"column_end":24},"name":"_blsr_u64","qualname":"::core_arch::x86_64::bmi::_blsr_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Resets the lowest set bit of `x`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3583366,"byte_end":3583375,"line_start":84,"line_end":84,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3583376,"byte_end":3583410,"line_start":85,"line_end":85,"column_start":1,"column_end":35}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3583449,"byte_end":3583481,"line_start":87,"line_end":87,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3583516,"byte_end":3583565,"line_start":88,"line_end":88,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9558},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3584029,"byte_end":3584039,"line_start":102,"line_end":102,"column_start":15,"column_end":25},"name":"_tzcnt_u64","qualname":"::core_arch::x86_64::bmi::_tzcnt_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Counts the number of trailing least significant zero bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3583881,"byte_end":3583890,"line_start":98,"line_end":98,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3583891,"byte_end":3583925,"line_start":99,"line_end":99,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3583965,"byte_end":3584014,"line_start":101,"line_end":101,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9559},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3584483,"byte_end":3584495,"line_start":115,"line_end":115,"column_start":15,"column_end":27},"name":"_mm_tzcnt_64","qualname":"::core_arch::x86_64::bmi::_mm_tzcnt_64","value":"fn (x: u64) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Counts the number of trailing least significant zero bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3584335,"byte_end":3584344,"line_start":111,"line_end":111,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3584345,"byte_end":3584379,"line_start":112,"line_end":112,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3584419,"byte_end":3584468,"line_start":114,"line_end":114,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9564},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3587526,"byte_end":3587535,"line_start":27,"line_end":27,"column_start":15,"column_end":24},"name":"_mulx_u64","qualname":"::core_arch::x86_64::bmi2::_mulx_u64","value":"fn (a: u64, b: u64, hi: &mut u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Unsigned multiply without affecting flags.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3587325,"byte_end":3587334,"line_start":22,"line_end":22,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3587372,"byte_end":3587406,"line_start":24,"line_end":24,"column_start":1,"column_end":35}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3587407,"byte_end":3587439,"line_start":25,"line_end":25,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3587462,"byte_end":3587511,"line_start":26,"line_end":26,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9565},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3588011,"byte_end":3588020,"line_start":41,"line_end":41,"column_start":15,"column_end":24},"name":"_bzhi_u64","qualname":"::core_arch::x86_64::bmi2::_bzhi_u64","value":"fn (a: u64, index: u32) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Zeroes higher bits of `a` >= `index`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3587831,"byte_end":3587840,"line_start":36,"line_end":36,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3587841,"byte_end":3587875,"line_start":37,"line_end":37,"column_start":1,"column_end":35}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3587914,"byte_end":3587946,"line_start":39,"line_end":39,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3587947,"byte_end":3587996,"line_start":40,"line_end":40,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9566},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3588486,"byte_end":3588495,"line_start":54,"line_end":54,"column_start":15,"column_end":24},"name":"_pdep_u64","qualname":"::core_arch::x86_64::bmi2::_pdep_u64","value":"fn (a: u64, mask: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Scatter contiguous low order bits of `a` to the result at the positions\n specified by the `mask`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3588306,"byte_end":3588315,"line_start":49,"line_end":49,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3588316,"byte_end":3588350,"line_start":50,"line_end":50,"column_start":1,"column_end":35}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3588389,"byte_end":3588421,"line_start":52,"line_end":52,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3588422,"byte_end":3588471,"line_start":53,"line_end":53,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9567},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3588962,"byte_end":3588971,"line_start":67,"line_end":67,"column_start":15,"column_end":24},"name":"_pext_u64","qualname":"::core_arch::x86_64::bmi2::_pext_u64","value":"fn (a: u64, mask: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Gathers the bits of `x` specified by the `mask` into the contiguous low\n order bit positions of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3588782,"byte_end":3588791,"line_start":62,"line_end":62,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3588792,"byte_end":3588826,"line_start":63,"line_end":63,"column_start":1,"column_end":35}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3588865,"byte_end":3588897,"line_start":65,"line_end":65,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3588898,"byte_end":3588947,"line_start":66,"line_end":66,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9577},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/avx2.rs","byte_start":3592358,"byte_end":3592378,"line_start":31,"line_end":31,"column_start":15,"column_end":35},"name":"_mm256_extract_epi64","qualname":"::core_arch::x86_64::avx2::_mm256_extract_epi64","value":"fn (a: __m256i, imm8: i32) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Extracts a 64-bit integer from `a`, selected with `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/avx2.rs","byte_start":3592165,"byte_end":3592174,"line_start":26,"line_end":26,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/avx2.rs","byte_start":3592175,"byte_end":3592209,"line_start":27,"line_end":27,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/avx2.rs","byte_start":3592210,"byte_end":3592241,"line_start":28,"line_end":28,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/avx2.rs","byte_start":3592294,"byte_end":3592343,"line_start":30,"line_end":30,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9580},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bswap.rs","byte_start":3593187,"byte_end":3593195,"line_start":14,"line_end":14,"column_start":15,"column_end":23},"name":"_bswap64","qualname":"::core_arch::x86_64::bswap::_bswap64","value":"fn (x: i64) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Returns an integer with the reversed byte order of x","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bswap.rs","byte_start":3593074,"byte_end":3593083,"line_start":11,"line_end":11,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bswap.rs","byte_start":3593123,"byte_end":3593172,"line_start":13,"line_end":13,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9588},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/rdrand.rs","byte_start":3594502,"byte_end":3594516,"line_start":26,"line_end":26,"column_start":15,"column_end":29},"name":"_rdrand64_step","qualname":"::core_arch::x86_64::rdrand::_rdrand64_step","value":"fn (val: &mut u64) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Read a hardware generated 64-bit random value and store the result in val.\n Returns 1 if a random value was generated, and 0 otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/rdrand.rs","byte_start":3594351,"byte_end":3594360,"line_start":22,"line_end":22,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"rdrand\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/rdrand.rs","byte_start":3594361,"byte_end":3594397,"line_start":23,"line_end":23,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/rdrand.rs","byte_start":3594438,"byte_end":3594487,"line_start":25,"line_end":25,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9589},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/rdrand.rs","byte_start":3595025,"byte_end":3595039,"line_start":40,"line_end":40,"column_start":15,"column_end":29},"name":"_rdseed64_step","qualname":"::core_arch::x86_64::rdrand::_rdseed64_step","value":"fn (val: &mut u64) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Read a 64-bit NIST SP800-90B and SP800-90C compliant random value and store\n in val. Return 1 if a random value was generated, and 0 otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/rdrand.rs","byte_start":3594874,"byte_end":3594883,"line_start":36,"line_end":36,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"rdseed\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/rdrand.rs","byte_start":3594884,"byte_end":3594920,"line_start":37,"line_end":37,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/rdrand.rs","byte_start":3594961,"byte_end":3595010,"line_start":39,"line_end":39,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9593},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/cmpxchg16b.rs","byte_start":3597059,"byte_end":3597069,"line_start":45,"line_end":45,"column_start":15,"column_end":25},"name":"cmpxchg16b","qualname":"::core_arch::x86_64::cmpxchg16b::cmpxchg16b","value":"fn (dst: *mut u128, old: u128, new: u128, success: Ordering, failure: Ordering) -> u128","parent":null,"children":[],"decl_id":null,"docs":" Compares and exchange 16 bytes (128 bits) of data atomically.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/cmpxchg16b.rs","byte_start":3596894,"byte_end":3596903,"line_start":42,"line_end":42,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"cmpxchg16b\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/cmpxchg16b.rs","byte_start":3597004,"byte_end":3597044,"line_start":44,"line_end":44,"column_start":1,"column_end":41}}]},{"kind":"Function","id":{"krate":0,"index":9603},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/adx.rs","byte_start":3599061,"byte_end":3599074,"line_start":20,"line_end":20,"column_start":15,"column_end":28},"name":"_addcarry_u64","qualname":"::core_arch::x86_64::adx::_addcarry_u64","value":"fn (c_in: u8, a: u64, b: u64, out: &mut u64) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Adds unsigned 64-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in`\n (carry flag), and store the unsigned 64-bit result in `out`, and the carry-out\n is returned (carry or overflow flag).\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/adx.rs","byte_start":3598946,"byte_end":3598955,"line_start":17,"line_end":17,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86_adx\", since = \"1.33.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/adx.rs","byte_start":3598993,"byte_end":3599046,"line_start":19,"line_end":19,"column_start":1,"column_end":54}}]},{"kind":"Function","id":{"krate":0,"index":9604},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/adx.rs","byte_start":3599563,"byte_end":3599577,"line_start":33,"line_end":33,"column_start":15,"column_end":29},"name":"_addcarryx_u64","qualname":"::core_arch::x86_64::adx::_addcarryx_u64","value":"fn (c_in: u8, a: u64, b: u64, out: &mut u64) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Adds unsigned 64-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in`\n (carry or overflow flag), and store the unsigned 64-bit result in `out`, and\n the carry-out is returned (carry or overflow flag).\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/adx.rs","byte_start":3599414,"byte_end":3599423,"line_start":29,"line_end":29,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"adx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/adx.rs","byte_start":3599424,"byte_end":3599457,"line_start":30,"line_end":30,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86_adx\", since = \"1.33.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/adx.rs","byte_start":3599495,"byte_end":3599548,"line_start":32,"line_end":32,"column_start":1,"column_end":54}}]},{"kind":"Function","id":{"krate":0,"index":9605},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/adx.rs","byte_start":3600026,"byte_end":3600040,"line_start":43,"line_end":43,"column_start":15,"column_end":29},"name":"_subborrow_u64","qualname":"::core_arch::x86_64::adx::_subborrow_u64","value":"fn (c_in: u8, a: u64, b: u64, out: &mut u64) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Adds unsigned 64-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in`.\n (carry or overflow flag), and store the unsigned 64-bit result in `out`, and\n the carry-out is returned (carry or overflow flag).\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/adx.rs","byte_start":3599911,"byte_end":3599920,"line_start":40,"line_end":40,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86_adx\", since = \"1.33.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/adx.rs","byte_start":3599958,"byte_end":3600011,"line_start":42,"line_end":42,"column_start":1,"column_end":54}}]},{"kind":"Function","id":{"krate":0,"index":9608},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3602959,"byte_end":3602969,"line_start":8,"line_end":8,"column_start":15,"column_end":25},"name":"_bittest64","qualname":"::core_arch::x86_64::bt::_bittest64","value":"fn (p: *const i64, b: i64) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Returns the bit in position `b` of the memory addressed by `p`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3602840,"byte_end":3602849,"line_start":5,"line_end":5,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"simd_x86_bittest\", issue = \"59414\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3602886,"byte_end":3602944,"line_start":7,"line_end":7,"column_start":1,"column_end":59}}]},{"kind":"Function","id":{"krate":0,"index":9609},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3603350,"byte_end":3603366,"line_start":21,"line_end":21,"column_start":15,"column_end":31},"name":"_bittestandset64","qualname":"::core_arch::x86_64::bt::_bittestandset64","value":"fn (p: *mut i64, b: i64) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Returns the bit in position `b` of the memory addressed by `p`, then sets the bit to `1`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3603230,"byte_end":3603239,"line_start":18,"line_end":18,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"simd_x86_bittest\", issue = \"59414\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3603277,"byte_end":3603335,"line_start":20,"line_end":20,"column_start":1,"column_end":59}}]},{"kind":"Function","id":{"krate":0,"index":9610},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3603750,"byte_end":3603768,"line_start":34,"line_end":34,"column_start":15,"column_end":33},"name":"_bittestandreset64","qualname":"::core_arch::x86_64::bt::_bittestandreset64","value":"fn (p: *mut i64, b: i64) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Returns the bit in position `b` of the memory addressed by `p`, then resets that bit to `0`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3603630,"byte_end":3603639,"line_start":31,"line_end":31,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"simd_x86_bittest\", issue = \"59414\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3603677,"byte_end":3603735,"line_start":33,"line_end":33,"column_start":1,"column_end":59}}]},{"kind":"Function","id":{"krate":0,"index":9611},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3604146,"byte_end":3604169,"line_start":47,"line_end":47,"column_start":15,"column_end":38},"name":"_bittestandcomplement64","qualname":"::core_arch::x86_64::bt::_bittestandcomplement64","value":"fn (p: *mut i64, b: i64) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Returns the bit in position `b` of the memory addressed by `p`, then inverts that bit.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3604026,"byte_end":3604035,"line_start":44,"line_end":44,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"simd_x86_bittest\", issue = \"59414\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3604073,"byte_end":3604131,"line_start":46,"line_end":46,"column_start":1,"column_end":59}}]}],"impls":[{"id":26,"kind":"Direct","span":{"file_name":"src/libcore/num/mod.rs","byte_start":77487,"byte_end":77495,"line_start":169,"line_end":169,"column_start":36,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":174}],"docs":"","sig":null,"attributes":[]},{"id":27,"kind":"Direct","span":{"file_name":"src/libcore/num/mod.rs","byte_start":77692,"byte_end":77700,"line_start":176,"line_end":176,"column_start":40,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":177}],"docs":"","sig":null,"attributes":[]},{"id":28,"kind":"Direct","span":{"file_name":"src/libcore/num/mod.rs","byte_start":77891,"byte_end":77899,"line_start":183,"line_end":183,"column_start":38,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":180}],"docs":"","sig":null,"attributes":[]},{"id":29,"kind":"Direct","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78088,"byte_end":78096,"line_start":190,"line_end":190,"column_start":36,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":183}],"docs":"","sig":null,"attributes":[]},{"id":30,"kind":"Direct","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78291,"byte_end":78299,"line_start":197,"line_end":197,"column_start":42,"column_end":50},"value":"","parent":null,"children":[{"krate":0,"index":186}],"docs":"","sig":null,"attributes":[]},{"id":31,"kind":"Direct","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78494,"byte_end":78502,"line_start":204,"line_end":204,"column_start":42,"column_end":50},"value":"","parent":null,"children":[{"krate":0,"index":189}],"docs":"","sig":null,"attributes":[]},{"id":34,"kind":"Inherent","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":247721,"byte_end":247725,"line_start":174,"line_end":174,"column_start":10,"column_end":14},"value":"","parent":null,"children":[{"krate":0,"index":279},{"krate":0,"index":280}],"docs":"","sig":null,"attributes":[]},{"id":35,"kind":"Inherent","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":249458,"byte_end":249467,"line_start":223,"line_end":223,"column_start":10,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":283},{"krate":0,"index":284}],"docs":"","sig":null,"attributes":[]},{"id":36,"kind":"Inherent","span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":376511,"byte_end":376519,"line_start":36,"line_end":36,"column_start":6,"column_end":14},"value":"","parent":null,"children":[{"krate":0,"index":408}],"docs":"","sig":null,"attributes":[]},{"id":39,"kind":"Inherent","span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":389641,"byte_end":389648,"line_start":31,"line_end":31,"column_start":10,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":490}],"docs":"","sig":null,"attributes":[]},{"id":42,"kind":"Inherent","span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":326442,"byte_end":326457,"line_start":183,"line_end":183,"column_start":6,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":497}],"docs":"","sig":null,"attributes":[]},{"id":43,"kind":"Direct","span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":326983,"byte_end":326998,"line_start":198,"line_end":198,"column_start":23,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":499}],"docs":"","sig":null,"attributes":[]},{"id":47,"kind":"Inherent","span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":413013,"byte_end":413015,"line_start":20,"line_end":20,"column_start":6,"column_end":8},"value":"","parent":null,"children":[{"krate":0,"index":528},{"krate":0,"index":530},{"krate":0,"index":531}],"docs":"","sig":null,"attributes":[]},{"id":72,"kind":"Inherent","span":{"file_name":"src/libcore/num/mod.rs","byte_start":219387,"byte_end":219402,"line_start":4675,"line_end":4675,"column_start":6,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":592}],"docs":"","sig":null,"attributes":[]},{"id":73,"kind":"Direct","span":{"file_name":"src/libcore/num/mod.rs","byte_start":219813,"byte_end":219828,"line_start":4687,"line_end":4687,"column_start":23,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":594}],"docs":"","sig":null,"attributes":[]},{"id":74,"kind":"Direct","span":{"file_name":"src/libcore/num/mod.rs","byte_start":220019,"byte_end":220034,"line_start":4694,"line_end":4694,"column_start":27,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":596}],"docs":"","sig":null,"attributes":[]},{"id":75,"kind":"Direct","span":{"file_name":"src/libcore/num/mod.rs","byte_start":220183,"byte_end":220198,"line_start":4701,"line_end":4701,"column_start":18,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":598}],"docs":"","sig":null,"attributes":[]},{"id":185,"kind":"Inherent","span":{"file_name":"src/libcore/num/mod.rs","byte_start":232381,"byte_end":232394,"line_start":5058,"line_end":5058,"column_start":6,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":620},{"krate":0,"index":621}],"docs":"","sig":null,"attributes":[]},{"id":186,"kind":"Direct","span":{"file_name":"src/libcore/num/mod.rs","byte_start":233515,"byte_end":233528,"line_start":5084,"line_end":5084,"column_start":23,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":623}],"docs":"","sig":null,"attributes":[]},{"id":245,"kind":"Inherent","span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":547774,"byte_end":547786,"line_start":56,"line_end":56,"column_start":9,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":1045},{"krate":0,"index":1046},{"krate":0,"index":1047}],"docs":"","sig":null,"attributes":[]},{"id":246,"kind":"Inherent","span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":549768,"byte_end":549780,"line_start":112,"line_end":112,"column_start":17,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":1050}],"docs":"","sig":null,"attributes":[]},{"id":247,"kind":"Direct","span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":550524,"byte_end":550536,"line_start":132,"line_end":132,"column_start":27,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":1053},{"krate":0,"index":1054}],"docs":"","sig":null,"attributes":[]},{"id":248,"kind":"Direct","span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":550726,"byte_end":550738,"line_start":141,"line_end":141,"column_start":30,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":1057}],"docs":"","sig":null,"attributes":[]},{"id":249,"kind":"Direct","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":559918,"byte_end":559929,"line_start":217,"line_end":217,"column_start":25,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":1064}],"docs":"","sig":null,"attributes":[]},{"id":250,"kind":"Inherent","span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":560109,"byte_end":560120,"line_start":225,"line_end":225,"column_start":9,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":1067},{"krate":0,"index":1068},{"krate":0,"index":1069},{"krate":0,"index":1070},{"krate":0,"index":1071},{"krate":0,"index":1072},{"krate":0,"index":1073},{"krate":0,"index":1074},{"krate":0,"index":1075},{"krate":0,"index":1076},{"krate":0,"index":1077},{"krate":0,"index":1078}],"docs":"","sig":null,"attributes":[]},{"id":251,"kind":"Direct","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":543721,"byte_end":543733,"line_start":746,"line_end":746,"column_start":18,"column_end":30},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":252,"kind":"Direct","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":543826,"byte_end":543838,"line_start":749,"line_end":749,"column_start":26,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":1119}],"docs":"","sig":null,"attributes":[]},{"id":253,"kind":"Direct","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":543984,"byte_end":543996,"line_start":756,"line_end":756,"column_start":28,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":1122}],"docs":"","sig":null,"attributes":[]},{"id":254,"kind":"Direct","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":544154,"byte_end":544166,"line_start":763,"line_end":763,"column_start":21,"column_end":33},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":255,"kind":"Direct","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":544257,"byte_end":544269,"line_start":766,"line_end":766,"column_start":24,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":1127}],"docs":"","sig":null,"attributes":[]},{"id":256,"kind":"Direct","span":{"file_name":"src/libcore/mem/mod.rs","byte_start":544448,"byte_end":544460,"line_start":773,"line_end":773,"column_start":24,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":1131}],"docs":"","sig":null,"attributes":[]},{"id":257,"kind":"Direct","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":673532,"byte_end":673539,"line_start":49,"line_end":49,"column_start":27,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":258,"kind":"Direct","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":673786,"byte_end":673793,"line_start":54,"line_end":54,"column_start":27,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":259,"kind":"Inherent","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":673817,"byte_end":673824,"line_start":56,"line_end":56,"column_start":16,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":1169}],"docs":"","sig":null,"attributes":[]},{"id":260,"kind":"Inherent","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":674527,"byte_end":674534,"line_start":76,"line_end":76,"column_start":17,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":1172},{"krate":0,"index":1173},{"krate":0,"index":1174},{"krate":0,"index":1175},{"krate":0,"index":1176},{"krate":0,"index":1177}],"docs":"","sig":null,"attributes":[]},{"id":261,"kind":"Direct","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":676452,"byte_end":676459,"line_start":139,"line_end":139,"column_start":27,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":1181}],"docs":"","sig":null,"attributes":[]},{"id":262,"kind":"Direct","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":676606,"byte_end":676613,"line_start":147,"line_end":147,"column_start":26,"column_end":33},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":263,"kind":"Direct","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":676736,"byte_end":676743,"line_start":150,"line_end":150,"column_start":58,"column_end":65},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":264,"kind":"Direct","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":676886,"byte_end":676893,"line_start":153,"line_end":153,"column_start":60,"column_end":67},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":265,"kind":"Direct","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":677001,"byte_end":677008,"line_start":156,"line_end":156,"column_start":32,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":1192}],"docs":"","sig":null,"attributes":[]},{"id":266,"kind":"Direct","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":677213,"byte_end":677220,"line_start":163,"line_end":163,"column_start":34,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":1195}],"docs":"","sig":null,"attributes":[]},{"id":267,"kind":"Direct","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":677415,"byte_end":677422,"line_start":170,"line_end":170,"column_start":24,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":268,"kind":"Direct","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":677509,"byte_end":677516,"line_start":173,"line_end":173,"column_start":31,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":1200}],"docs":"","sig":null,"attributes":[]},{"id":269,"kind":"Direct","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":677699,"byte_end":677706,"line_start":181,"line_end":181,"column_start":25,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":1203}],"docs":"","sig":null,"attributes":[]},{"id":270,"kind":"Direct","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":677904,"byte_end":677911,"line_start":189,"line_end":189,"column_start":32,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":1206}],"docs":"","sig":null,"attributes":[]},{"id":271,"kind":"Direct","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":678133,"byte_end":678140,"line_start":197,"line_end":197,"column_start":32,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":1209}],"docs":"","sig":null,"attributes":[]},{"id":272,"kind":"Direct","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":678344,"byte_end":678351,"line_start":205,"line_end":205,"column_start":37,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":1213}],"docs":"","sig":null,"attributes":[]},{"id":273,"kind":"Direct","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":678562,"byte_end":678569,"line_start":213,"line_end":213,"column_start":34,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":1216}],"docs":"","sig":null,"attributes":[]},{"id":274,"kind":"Direct","span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":678777,"byte_end":678784,"line_start":221,"line_end":221,"column_start":30,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":1219}],"docs":"","sig":null,"attributes":[]},{"id":275,"kind":"Direct","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":681183,"byte_end":681189,"line_start":49,"line_end":49,"column_start":40,"column_end":46},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":276,"kind":"Direct","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":681517,"byte_end":681523,"line_start":56,"line_end":56,"column_start":40,"column_end":46},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":277,"kind":"Inherent","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":681599,"byte_end":681605,"line_start":59,"line_end":59,"column_start":16,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":1242}],"docs":"","sig":null,"attributes":[]},{"id":278,"kind":"Inherent","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":682328,"byte_end":682334,"line_start":79,"line_end":79,"column_start":17,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":1245},{"krate":0,"index":1246},{"krate":0,"index":1247},{"krate":0,"index":1248},{"krate":0,"index":1249}],"docs":"","sig":null,"attributes":[]},{"id":279,"kind":"Direct","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":683780,"byte_end":683786,"line_start":128,"line_end":128,"column_start":27,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":1252}],"docs":"","sig":null,"attributes":[]},{"id":280,"kind":"Direct","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":683936,"byte_end":683942,"line_start":136,"line_end":136,"column_start":26,"column_end":32},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":281,"kind":"Direct","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":684059,"byte_end":684065,"line_start":139,"line_end":139,"column_start":57,"column_end":63},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":282,"kind":"Direct","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":684203,"byte_end":684209,"line_start":142,"line_end":142,"column_start":59,"column_end":65},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":283,"kind":"Direct","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":684320,"byte_end":684326,"line_start":145,"line_end":145,"column_start":32,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":1263}],"docs":"","sig":null,"attributes":[]},{"id":284,"kind":"Direct","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":684534,"byte_end":684540,"line_start":152,"line_end":152,"column_start":34,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":1266}],"docs":"","sig":null,"attributes":[]},{"id":285,"kind":"Direct","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":684748,"byte_end":684754,"line_start":159,"line_end":159,"column_start":34,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":1269}],"docs":"","sig":null,"attributes":[]},{"id":286,"kind":"Direct","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":684986,"byte_end":684992,"line_start":167,"line_end":167,"column_start":30,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":1272}],"docs":"","sig":null,"attributes":[]},{"id":287,"kind":"Direct","span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":685234,"byte_end":685240,"line_start":175,"line_end":175,"column_start":42,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":1276}],"docs":"","sig":null,"attributes":[]},{"id":288,"kind":"Direct","span":{"file_name":"src/libcore/marker.rs","byte_start":712086,"byte_end":712096,"line_start":591,"line_end":591,"column_start":29,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":289,"kind":"Direct","span":{"file_name":"src/libcore/marker.rs","byte_start":712137,"byte_end":712148,"line_start":592,"line_end":592,"column_start":35,"column_end":46},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":290,"kind":"Direct","span":{"file_name":"src/libcore/marker.rs","byte_start":714576,"byte_end":714589,"line_start":650,"line_end":650,"column_start":17,"column_end":30},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":1916,"kind":"Direct","span":{"file_name":"src/libcore/ops/generator.rs","byte_start":795954,"byte_end":795957,"line_start":117,"line_end":117,"column_start":43,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":1668},{"krate":0,"index":1669},{"krate":0,"index":1670}],"docs":"","sig":null,"attributes":[]},{"id":1917,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":803185,"byte_end":803194,"line_start":47,"line_end":47,"column_start":21,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":1690}],"docs":"","sig":null,"attributes":[]},{"id":1918,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":804425,"byte_end":804430,"line_start":86,"line_end":86,"column_start":38,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":1693}],"docs":"","sig":null,"attributes":[]},{"id":1919,"kind":"Inherent","span":{"file_name":"src/libcore/ops/range.rs","byte_start":804640,"byte_end":804645,"line_start":95,"line_end":95,"column_start":28,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":1696},{"krate":0,"index":1698}],"docs":"","sig":null,"attributes":[]},{"id":1920,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":807503,"byte_end":807512,"line_start":188,"line_end":188,"column_start":38,"column_end":47},"value":"","parent":null,"children":[{"krate":0,"index":1701}],"docs":"","sig":null,"attributes":[]},{"id":1921,"kind":"Inherent","span":{"file_name":"src/libcore/ops/range.rs","byte_start":807694,"byte_end":807703,"line_start":196,"line_end":196,"column_start":28,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":1704}],"docs":"","sig":null,"attributes":[]},{"id":1922,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":809979,"byte_end":809986,"line_start":272,"line_end":272,"column_start":38,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":1708}],"docs":"","sig":null,"attributes":[]},{"id":1923,"kind":"Inherent","span":{"file_name":"src/libcore/ops/range.rs","byte_start":810166,"byte_end":810173,"line_start":280,"line_end":280,"column_start":28,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":1711}],"docs":"","sig":null,"attributes":[]},{"id":1924,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":812543,"byte_end":812544,"line_start":351,"line_end":351,"column_start":36,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":1717}],"docs":"","sig":null,"attributes":[]},{"id":1925,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":812738,"byte_end":812739,"line_start":358,"line_end":358,"column_start":48,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":1720}],"docs":"","sig":null,"attributes":[]},{"id":1926,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":812952,"byte_end":812966,"line_start":366,"line_end":366,"column_start":36,"column_end":50},"value":"","parent":null,"children":[{"krate":0,"index":1723}],"docs":"","sig":null,"attributes":[]},{"id":1927,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":813328,"byte_end":813342,"line_start":377,"line_end":377,"column_start":22,"column_end":36},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":1928,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":813434,"byte_end":813448,"line_start":380,"line_end":380,"column_start":26,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":1728}],"docs":"","sig":null,"attributes":[]},{"id":1929,"kind":"Inherent","span":{"file_name":"src/libcore/ops/range.rs","byte_start":813658,"byte_end":813672,"line_start":388,"line_end":388,"column_start":11,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":37152},{"krate":0,"index":1732},{"krate":0,"index":1733},{"krate":0,"index":1734}],"docs":"","sig":null,"attributes":[]},{"id":1930,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":816360,"byte_end":816374,"line_start":475,"line_end":475,"column_start":38,"column_end":52},"value":"","parent":null,"children":[{"krate":0,"index":1737}],"docs":"","sig":null,"attributes":[]},{"id":1931,"kind":"Inherent","span":{"file_name":"src/libcore/ops/range.rs","byte_start":816585,"byte_end":816599,"line_start":484,"line_end":484,"column_start":28,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":1740},{"krate":0,"index":1742},{"krate":0,"index":1744}],"docs":"","sig":null,"attributes":[]},{"id":1932,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":820561,"byte_end":820577,"line_start":613,"line_end":613,"column_start":38,"column_end":54},"value":"","parent":null,"children":[{"krate":0,"index":1747}],"docs":"","sig":null,"attributes":[]},{"id":1933,"kind":"Inherent","span":{"file_name":"src/libcore/ops/range.rs","byte_start":820758,"byte_end":820774,"line_start":621,"line_end":621,"column_start":28,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":1750}],"docs":"","sig":null,"attributes":[]},{"id":1934,"kind":"Inherent","span":{"file_name":"src/libcore/ops/range.rs","byte_start":823218,"byte_end":823223,"line_start":699,"line_end":699,"column_start":16,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":1754}],"docs":"","sig":null,"attributes":[]},{"id":1935,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":826164,"byte_end":826173,"line_start":797,"line_end":797,"column_start":36,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":1767},{"krate":0,"index":1768}],"docs":"","sig":null,"attributes":[]},{"id":1936,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":826393,"byte_end":826402,"line_start":807,"line_end":807,"column_start":28,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":1771},{"krate":0,"index":1772}],"docs":"","sig":null,"attributes":[]},{"id":1937,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":826637,"byte_end":826644,"line_start":817,"line_end":817,"column_start":28,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":1775},{"krate":0,"index":1776}],"docs":"","sig":null,"attributes":[]},{"id":1938,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":826877,"byte_end":826882,"line_start":827,"line_end":827,"column_start":28,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":1779},{"krate":0,"index":1780}],"docs":"","sig":null,"attributes":[]},{"id":1939,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":827127,"byte_end":827141,"line_start":837,"line_end":837,"column_start":28,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":1783},{"krate":0,"index":1784}],"docs":"","sig":null,"attributes":[]},{"id":1940,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":827386,"byte_end":827402,"line_start":847,"line_end":847,"column_start":28,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":1787},{"krate":0,"index":1788}],"docs":"","sig":null,"attributes":[]},{"id":1941,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":828466,"byte_end":828475,"line_start":887,"line_end":887,"column_start":28,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":1800},{"krate":0,"index":1801}],"docs":"","sig":null,"attributes":[]},{"id":1942,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":828710,"byte_end":828717,"line_start":897,"line_end":897,"column_start":28,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":1804},{"krate":0,"index":1805}],"docs":"","sig":null,"attributes":[]},{"id":1943,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":828950,"byte_end":828955,"line_start":907,"line_end":907,"column_start":28,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":1808},{"krate":0,"index":1809}],"docs":"","sig":null,"attributes":[]},{"id":1944,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":829199,"byte_end":829213,"line_start":917,"line_end":917,"column_start":28,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":1812},{"krate":0,"index":1813}],"docs":"","sig":null,"attributes":[]},{"id":1945,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":829457,"byte_end":829473,"line_start":927,"line_end":927,"column_start":28,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":1816},{"krate":0,"index":1817}],"docs":"","sig":null,"attributes":[]},{"id":1946,"kind":"Inherent","span":{"file_name":"src/libcore/cmp.rs","byte_start":846055,"byte_end":846063,"line_start":300,"line_end":300,"column_start":6,"column_end":14},"value":"","parent":null,"children":[{"krate":0,"index":1946},{"krate":0,"index":1947},{"krate":0,"index":1948}],"docs":"","sig":null,"attributes":[]},{"id":1947,"kind":"Direct","span":{"file_name":"src/libcore/cmp.rs","byte_start":850084,"byte_end":850091,"line_start":432,"line_end":432,"column_start":36,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":1952},{"krate":0,"index":1953},{"krate":0,"index":1954},{"krate":0,"index":1955},{"krate":0,"index":1956}],"docs":"","sig":null,"attributes":[]},{"id":1948,"kind":"Direct","span":{"file_name":"src/libcore/cmp.rs","byte_start":850602,"byte_end":850609,"line_start":449,"line_end":449,"column_start":22,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":1959}],"docs":"","sig":null,"attributes":[]},{"id":1949,"kind":"Direct","span":{"file_name":"src/libcore/cmp.rs","byte_start":855139,"byte_end":855147,"line_start":604,"line_end":604,"column_start":13,"column_end":21},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":1950,"kind":"Direct","span":{"file_name":"src/libcore/cmp.rs","byte_start":855211,"byte_end":855219,"line_start":607,"line_end":607,"column_start":14,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":1967}],"docs":"","sig":null,"attributes":[]},{"id":1951,"kind":"Direct","span":{"file_name":"src/libcore/cmp.rs","byte_start":855406,"byte_end":855414,"line_start":615,"line_end":615,"column_start":21,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":1969}],"docs":"","sig":null,"attributes":[]},{"id":2044,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":901107,"byte_end":901108,"line_start":537,"line_end":537,"column_start":24,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":2122}],"docs":"","sig":null,"attributes":[]},{"id":2045,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":901287,"byte_end":901288,"line_start":546,"line_end":546,"column_start":21,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":2125}],"docs":"","sig":null,"attributes":[]},{"id":2046,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":901427,"byte_end":901428,"line_start":553,"line_end":553,"column_start":27,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":2129},{"krate":0,"index":2130}],"docs":"","sig":null,"attributes":[]},{"id":2047,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":901750,"byte_end":901751,"line_start":565,"line_end":565,"column_start":27,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":2134},{"krate":0,"index":2135}],"docs":"","sig":null,"attributes":[]},{"id":2049,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":904837,"byte_end":904847,"line_start":660,"line_end":660,"column_start":16,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":2145}],"docs":"","sig":null,"attributes":[]},{"id":2050,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":904998,"byte_end":905008,"line_start":667,"line_end":667,"column_start":21,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":2147}],"docs":"","sig":null,"attributes":[]},{"id":2051,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":905188,"byte_end":905198,"line_start":674,"line_end":674,"column_start":23,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":2149}],"docs":"","sig":null,"attributes":[]},{"id":2052,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":905375,"byte_end":905385,"line_start":681,"line_end":681,"column_start":20,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":2151}],"docs":"","sig":null,"attributes":[]},{"id":2053,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":905535,"byte_end":905545,"line_start":688,"line_end":688,"column_start":13,"column_end":23},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2054,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":905630,"byte_end":905640,"line_start":691,"line_end":691,"column_start":21,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":2154}],"docs":"","sig":null,"attributes":[]},{"id":2055,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":905823,"byte_end":905833,"line_start":698,"line_end":698,"column_start":14,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":2156}],"docs":"","sig":null,"attributes":[]},{"id":2056,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":906004,"byte_end":906014,"line_start":705,"line_end":705,"column_start":18,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":2158}],"docs":"","sig":null,"attributes":[]},{"id":2057,"kind":"Direct","span":{"file_name":"src/libcore/borrow.rs","byte_start":914256,"byte_end":914257,"line_start":213,"line_end":213,"column_start":31,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":2168}],"docs":"","sig":null,"attributes":[]},{"id":2058,"kind":"Direct","span":{"file_name":"src/libcore/borrow.rs","byte_start":914378,"byte_end":914379,"line_start":218,"line_end":218,"column_start":34,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":2171}],"docs":"","sig":null,"attributes":[]},{"id":2059,"kind":"Direct","span":{"file_name":"src/libcore/any.rs","byte_start":918355,"byte_end":918356,"line_start":100,"line_end":100,"column_start":36,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":2188}],"docs":"","sig":null,"attributes":[]},{"id":2060,"kind":"Inherent","span":{"file_name":"src/libcore/any.rs","byte_start":927295,"byte_end":927301,"line_start":427,"line_end":427,"column_start":6,"column_end":12},"value":"","parent":null,"children":[{"krate":0,"index":2217}],"docs":"","sig":null,"attributes":[]},{"id":2061,"kind":"Direct","span":{"file_name":"src/libcore/array.rs","byte_start":929637,"byte_end":929638,"line_start":41,"line_end":41,"column_start":54,"column_end":55},"value":"","parent":null,"children":[{"krate":0,"index":2242},{"krate":0,"index":2243}],"docs":"","sig":null,"attributes":[]},{"id":2062,"kind":"Direct","span":{"file_name":"src/libcore/array.rs","byte_start":930055,"byte_end":930072,"line_start":58,"line_end":58,"column_start":23,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":2245}],"docs":"","sig":null,"attributes":[]},{"id":2063,"kind":"Inherent","span":{"file_name":"src/libcore/array.rs","byte_start":930217,"byte_end":930234,"line_start":65,"line_end":65,"column_start":6,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":2247}],"docs":"","sig":null,"attributes":[]},{"id":2064,"kind":"Direct","span":{"file_name":"src/libcore/array.rs","byte_start":930650,"byte_end":930667,"line_start":78,"line_end":78,"column_start":27,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":2249}],"docs":"","sig":null,"attributes":[]},{"id":2065,"kind":"Direct","span":{"file_name":"src/libcore/ascii.rs","byte_start":941770,"byte_end":941783,"line_start":116,"line_end":116,"column_start":19,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":2265},{"krate":0,"index":2266},{"krate":0,"index":2268}],"docs":"","sig":null,"attributes":[]},{"id":2066,"kind":"Direct","span":{"file_name":"src/libcore/ascii.rs","byte_start":942041,"byte_end":942054,"line_start":122,"line_end":122,"column_start":30,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":2270}],"docs":"","sig":null,"attributes":[]},{"id":2067,"kind":"Direct","span":{"file_name":"src/libcore/ascii.rs","byte_start":942235,"byte_end":942248,"line_start":128,"line_end":128,"column_start":28,"column_end":41},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2068,"kind":"Direct","span":{"file_name":"src/libcore/ascii.rs","byte_start":942322,"byte_end":942335,"line_start":130,"line_end":130,"column_start":24,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2069,"kind":"Direct","span":{"file_name":"src/libcore/ascii.rs","byte_start":942411,"byte_end":942424,"line_start":133,"line_end":133,"column_start":21,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":2275}],"docs":"","sig":null,"attributes":[]},{"id":2070,"kind":"Direct","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":949478,"byte_end":949488,"line_start":169,"line_end":169,"column_start":18,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":2287}],"docs":"","sig":null,"attributes":[]},{"id":2071,"kind":"Direct","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":949757,"byte_end":949767,"line_start":179,"line_end":179,"column_start":22,"column_end":32},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2072,"kind":"Direct","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":950326,"byte_end":950335,"line_start":195,"line_end":195,"column_start":21,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":2294}],"docs":"","sig":null,"attributes":[]},{"id":2073,"kind":"Direct","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":950575,"byte_end":950584,"line_start":204,"line_end":204,"column_start":25,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2074,"kind":"Direct","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":950695,"byte_end":950704,"line_start":207,"line_end":207,"column_start":25,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2075,"kind":"Inherent","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":955582,"byte_end":955592,"line_start":314,"line_end":314,"column_start":6,"column_end":16},"value":"","parent":null,"children":[{"krate":0,"index":2301},{"krate":0,"index":2302},{"krate":0,"index":2303},{"krate":0,"index":2304},{"krate":0,"index":2305},{"krate":0,"index":2306},{"krate":0,"index":2307},{"krate":0,"index":2308},{"krate":0,"index":2309},{"krate":0,"index":2310},{"krate":0,"index":2311},{"krate":0,"index":2312},{"krate":0,"index":2313}],"docs":"","sig":null,"attributes":[]},{"id":2076,"kind":"Inherent","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":974623,"byte_end":974632,"line_start":801,"line_end":801,"column_start":9,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":2316},{"krate":0,"index":2317},{"krate":0,"index":2318},{"krate":0,"index":2319},{"krate":0,"index":2320},{"krate":0,"index":2321},{"krate":0,"index":2322},{"krate":0,"index":2323},{"krate":0,"index":2324}],"docs":"","sig":null,"attributes":[]},{"id":2077,"kind":"Direct","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":986593,"byte_end":986603,"line_start":1114,"line_end":1114,"column_start":21,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":2326}],"docs":"","sig":null,"attributes":[]},{"id":2078,"kind":"Direct","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":987038,"byte_end":987047,"line_start":1130,"line_end":1130,"column_start":26,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":2329}],"docs":"","sig":null,"attributes":[]},{"id":2079,"kind":"Direct","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1039423,"byte_end":1039433,"line_start":2508,"line_end":2508,"column_start":21,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":2366}],"docs":"","sig":null,"attributes":[]},{"id":2080,"kind":"Direct","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1039675,"byte_end":1039684,"line_start":2516,"line_end":2516,"column_start":24,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":2369}],"docs":"","sig":null,"attributes":[]},{"id":2081,"kind":"Direct","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1039934,"byte_end":1039943,"line_start":2524,"line_end":2524,"column_start":26,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":2372}],"docs":"","sig":null,"attributes":[]},{"id":2082,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1049032,"byte_end":1049036,"line_start":232,"line_end":232,"column_start":14,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":2391},{"krate":0,"index":2392}],"docs":"","sig":null,"attributes":[]},{"id":2083,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1050073,"byte_end":1050077,"line_start":279,"line_end":279,"column_start":33,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2084,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1050171,"byte_end":1050175,"line_start":282,"line_end":282,"column_start":27,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2085,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1050252,"byte_end":1050256,"line_start":285,"line_end":285,"column_start":24,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":2400}],"docs":"","sig":null,"attributes":[]},{"id":2086,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1050422,"byte_end":1050426,"line_start":293,"line_end":293,"column_start":29,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":2403}],"docs":"","sig":null,"attributes":[]},{"id":2087,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1050669,"byte_end":1050673,"line_start":302,"line_end":302,"column_start":40,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":2406}],"docs":"","sig":null,"attributes":[]},{"id":2088,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1050853,"byte_end":1050857,"line_start":310,"line_end":310,"column_start":26,"column_end":30},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2089,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1050956,"byte_end":1050960,"line_start":313,"line_end":313,"column_start":42,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":2411},{"krate":0,"index":2412},{"krate":0,"index":2413},{"krate":0,"index":2414},{"krate":0,"index":2415}],"docs":"","sig":null,"attributes":[]},{"id":2090,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1051570,"byte_end":1051574,"line_start":341,"line_end":341,"column_start":28,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":2418}],"docs":"","sig":null,"attributes":[]},{"id":2091,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1051760,"byte_end":1051764,"line_start":349,"line_end":349,"column_start":21,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":2421}],"docs":"","sig":null,"attributes":[]},{"id":2092,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1051839,"byte_end":1051843,"line_start":355,"line_end":355,"column_start":9,"column_end":13},"value":"","parent":null,"children":[{"krate":0,"index":2424},{"krate":0,"index":2425},{"krate":0,"index":2426},{"krate":0,"index":2427},{"krate":0,"index":2428}],"docs":"","sig":null,"attributes":[]},{"id":2093,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1054048,"byte_end":1054052,"line_start":451,"line_end":451,"column_start":17,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":2431},{"krate":0,"index":2432},{"krate":0,"index":2433}],"docs":"","sig":null,"attributes":[]},{"id":2094,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1055585,"byte_end":1055589,"line_start":514,"line_end":514,"column_start":18,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":2436}],"docs":"","sig":null,"attributes":[]},{"id":2095,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1056154,"byte_end":1056158,"line_start":535,"line_end":535,"column_start":57,"column_end":61},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2096,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1056174,"byte_end":1056178,"line_start":537,"line_end":537,"column_start":9,"column_end":13},"value":"","parent":null,"children":[{"krate":0,"index":2442}],"docs":"","sig":null,"attributes":[]},{"id":2097,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1057291,"byte_end":1057302,"line_start":575,"line_end":575,"column_start":16,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":2450}],"docs":"","sig":null,"attributes":[]},{"id":2098,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1057493,"byte_end":1057504,"line_start":582,"line_end":582,"column_start":18,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":2452}],"docs":"","sig":null,"attributes":[]},{"id":2099,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1057896,"byte_end":1057910,"line_start":595,"line_end":595,"column_start":16,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":2456}],"docs":"","sig":null,"attributes":[]},{"id":2100,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1058104,"byte_end":1058118,"line_start":602,"line_end":602,"column_start":18,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":2458}],"docs":"","sig":null,"attributes":[]},{"id":2101,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1059301,"byte_end":1059308,"line_start":634,"line_end":634,"column_start":9,"column_end":16},"value":"","parent":null,"children":[{"krate":0,"index":2465},{"krate":0,"index":2466},{"krate":0,"index":2467},{"krate":0,"index":2468},{"krate":0,"index":2470}],"docs":"","sig":null,"attributes":[]},{"id":2102,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1062629,"byte_end":1062636,"line_start":748,"line_end":748,"column_start":17,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":2473},{"krate":0,"index":2474},{"krate":0,"index":2475},{"krate":0,"index":2476},{"krate":0,"index":2477},{"krate":0,"index":2478},{"krate":0,"index":2479}],"docs":"","sig":null,"attributes":[]},{"id":2103,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1069643,"byte_end":1069650,"line_start":994,"line_end":994,"column_start":33,"column_end":40},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2104,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1069744,"byte_end":1069751,"line_start":997,"line_end":997,"column_start":27,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2105,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1069830,"byte_end":1069837,"line_start":1000,"line_end":1000,"column_start":26,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":2486}],"docs":"","sig":null,"attributes":[]},{"id":2106,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1070104,"byte_end":1070111,"line_start":1011,"line_end":1011,"column_start":29,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":2489}],"docs":"","sig":null,"attributes":[]},{"id":2107,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1070366,"byte_end":1070373,"line_start":1020,"line_end":1020,"column_start":43,"column_end":50},"value":"","parent":null,"children":[{"krate":0,"index":2492}],"docs":"","sig":null,"attributes":[]},{"id":2108,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1070663,"byte_end":1070670,"line_start":1031,"line_end":1031,"column_start":29,"column_end":36},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2109,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1070772,"byte_end":1070779,"line_start":1034,"line_end":1034,"column_start":45,"column_end":52},"value":"","parent":null,"children":[{"krate":0,"index":2497},{"krate":0,"index":2498},{"krate":0,"index":2499},{"krate":0,"index":2500},{"krate":0,"index":2501}],"docs":"","sig":null,"attributes":[]},{"id":2110,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1071926,"byte_end":1071933,"line_start":1077,"line_end":1077,"column_start":31,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":2504}],"docs":"","sig":null,"attributes":[]},{"id":2111,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1072225,"byte_end":1072232,"line_start":1088,"line_end":1088,"column_start":21,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":2507}],"docs":"","sig":null,"attributes":[]},{"id":2112,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1072421,"byte_end":1072428,"line_start":1095,"line_end":1095,"column_start":60,"column_end":67},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2113,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1072505,"byte_end":1072514,"line_start":1101,"line_end":1101,"column_start":10,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":2516}],"docs":"","sig":null,"attributes":[]},{"id":2114,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1072963,"byte_end":1072972,"line_start":1116,"line_end":1116,"column_start":15,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":2518}],"docs":"","sig":null,"attributes":[]},{"id":2115,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1073162,"byte_end":1073171,"line_start":1125,"line_end":1125,"column_start":16,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":2520}],"docs":"","sig":null,"attributes":[]},{"id":2116,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1074023,"byte_end":1074026,"line_start":1151,"line_end":1151,"column_start":27,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":2528},{"krate":0,"index":2529}],"docs":"","sig":null,"attributes":[]},{"id":2117,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1074148,"byte_end":1074151,"line_start":1160,"line_end":1160,"column_start":21,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":2533},{"krate":0,"index":2534},{"krate":0,"index":2537}],"docs":"","sig":null,"attributes":[]},{"id":2118,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1076898,"byte_end":1076901,"line_start":1239,"line_end":1239,"column_start":74,"column_end":77},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2119,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1077018,"byte_end":1077021,"line_start":1242,"line_end":1242,"column_start":49,"column_end":52},"value":"","parent":null,"children":[{"krate":0,"index":2547}],"docs":"","sig":null,"attributes":[]},{"id":2120,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1077149,"byte_end":1077155,"line_start":1248,"line_end":1248,"column_start":21,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":2551},{"krate":0,"index":2554}],"docs":"","sig":null,"attributes":[]},{"id":2121,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1079785,"byte_end":1079797,"line_start":1327,"line_end":1327,"column_start":15,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":2562}],"docs":"","sig":null,"attributes":[]},{"id":2122,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1079981,"byte_end":1079993,"line_start":1336,"line_end":1336,"column_start":10,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":2565},{"krate":0,"index":2566}],"docs":"","sig":null,"attributes":[]},{"id":2123,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1081533,"byte_end":1081539,"line_start":1378,"line_end":1378,"column_start":27,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":2574},{"krate":0,"index":2575}],"docs":"","sig":null,"attributes":[]},{"id":2124,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1081716,"byte_end":1081722,"line_start":1388,"line_end":1388,"column_start":30,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":2578}],"docs":"","sig":null,"attributes":[]},{"id":2125,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1081947,"byte_end":1081953,"line_start":1396,"line_end":1396,"column_start":77,"column_end":83},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2126,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1082070,"byte_end":1082076,"line_start":1399,"line_end":1399,"column_start":49,"column_end":55},"value":"","parent":null,"children":[{"krate":0,"index":2585}],"docs":"","sig":null,"attributes":[]},{"id":2127,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1085431,"byte_end":1085441,"line_start":1470,"line_end":1470,"column_start":27,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2128,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1085457,"byte_end":1085467,"line_start":1472,"line_end":1472,"column_start":9,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":2593},{"krate":0,"index":2594}],"docs":"","sig":null,"attributes":[]},{"id":2129,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1086285,"byte_end":1086295,"line_start":1509,"line_end":1509,"column_start":17,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":2597}],"docs":"","sig":null,"attributes":[]},{"id":2130,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1087172,"byte_end":1087182,"line_start":1536,"line_end":1536,"column_start":30,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":2600}],"docs":"","sig":null,"attributes":[]},{"id":2131,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1087413,"byte_end":1087423,"line_start":1544,"line_end":1544,"column_start":21,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":2603}],"docs":"","sig":null,"attributes":[]},{"id":2132,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1087621,"byte_end":1087631,"line_start":1551,"line_end":1551,"column_start":63,"column_end":73},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2135,"kind":"Inherent","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1109256,"byte_end":1109270,"line_start":173,"line_end":173,"column_start":6,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":2622}],"docs":"","sig":null,"attributes":[]},{"id":2136,"kind":"Direct","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1109898,"byte_end":1109912,"line_start":195,"line_end":195,"column_start":23,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":2624}],"docs":"","sig":null,"attributes":[]},{"id":2139,"kind":"Direct","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1111203,"byte_end":1111219,"line_start":242,"line_end":242,"column_start":23,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":2632}],"docs":"","sig":null,"attributes":[]},{"id":2140,"kind":"Direct","span":{"file_name":"src/libcore/char/decode.rs","byte_start":1115170,"byte_end":1115181,"line_start":78,"line_end":78,"column_start":44,"column_end":55},"value":"","parent":null,"children":[{"krate":0,"index":2641},{"krate":0,"index":2642},{"krate":0,"index":2643}],"docs":"","sig":null,"attributes":[]},{"id":2141,"kind":"Inherent","span":{"file_name":"src/libcore/char/decode.rs","byte_start":1116658,"byte_end":1116674,"line_start":121,"line_end":121,"column_start":6,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":2645}],"docs":"","sig":null,"attributes":[]},{"id":2142,"kind":"Direct","span":{"file_name":"src/libcore/char/decode.rs","byte_start":1116946,"byte_end":1116962,"line_start":130,"line_end":130,"column_start":23,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":2647}],"docs":"","sig":null,"attributes":[]},{"id":2144,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1093850,"byte_end":1093863,"line_start":143,"line_end":143,"column_start":19,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":2723},{"krate":0,"index":2724},{"krate":0,"index":2725},{"krate":0,"index":2726},{"krate":0,"index":2727}],"docs":"","sig":null,"attributes":[]},{"id":2145,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1095646,"byte_end":1095659,"line_start":203,"line_end":203,"column_start":28,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":2729}],"docs":"","sig":null,"attributes":[]},{"id":2146,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1096182,"byte_end":1096195,"line_start":219,"line_end":219,"column_start":24,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2147,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1096283,"byte_end":1096296,"line_start":222,"line_end":222,"column_start":23,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":2732}],"docs":"","sig":null,"attributes":[]},{"id":2148,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1097084,"byte_end":1097097,"line_start":253,"line_end":253,"column_start":19,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":2734},{"krate":0,"index":2735},{"krate":0,"index":2736},{"krate":0,"index":2737},{"krate":0,"index":2738},{"krate":0,"index":2739}],"docs":"","sig":null,"attributes":[]},{"id":2149,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1099065,"byte_end":1099078,"line_start":320,"line_end":320,"column_start":28,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":2741}],"docs":"","sig":null,"attributes":[]},{"id":2150,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1099431,"byte_end":1099444,"line_start":332,"line_end":332,"column_start":24,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2151,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1099532,"byte_end":1099545,"line_start":335,"line_end":335,"column_start":23,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":2744}],"docs":"","sig":null,"attributes":[]},{"id":2152,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1100205,"byte_end":1100216,"line_start":356,"line_end":356,"column_start":19,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":2746},{"krate":0,"index":2747},{"krate":0,"index":2748}],"docs":"","sig":null,"attributes":[]},{"id":2153,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1100460,"byte_end":1100471,"line_start":363,"line_end":363,"column_start":28,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2154,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1100547,"byte_end":1100558,"line_start":366,"line_end":366,"column_start":24,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2155,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1100644,"byte_end":1100655,"line_start":369,"line_end":369,"column_start":23,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":2752}],"docs":"","sig":null,"attributes":[]},{"id":2156,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1101251,"byte_end":1101262,"line_start":387,"line_end":387,"column_start":19,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":2754},{"krate":0,"index":2755},{"krate":0,"index":2756}],"docs":"","sig":null,"attributes":[]},{"id":2157,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1101514,"byte_end":1101525,"line_start":398,"line_end":398,"column_start":24,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2158,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1101627,"byte_end":1101638,"line_start":401,"line_end":401,"column_start":28,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2159,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1102126,"byte_end":1102137,"line_start":415,"line_end":415,"column_start":19,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":2760},{"krate":0,"index":2761},{"krate":0,"index":2762}],"docs":"","sig":null,"attributes":[]},{"id":2160,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1102389,"byte_end":1102400,"line_start":426,"line_end":426,"column_start":24,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2161,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1102502,"byte_end":1102513,"line_start":429,"line_end":429,"column_start":28,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2162,"kind":"Inherent","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1102648,"byte_end":1102663,"line_start":439,"line_end":439,"column_start":6,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":2766}],"docs":"","sig":null,"attributes":[]},{"id":2163,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1103072,"byte_end":1103087,"line_start":453,"line_end":453,"column_start":19,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":2769},{"krate":0,"index":2770},{"krate":0,"index":2771}],"docs":"","sig":null,"attributes":[]},{"id":2164,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1103954,"byte_end":1103969,"line_start":484,"line_end":484,"column_start":23,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":2773}],"docs":"","sig":null,"attributes":[]},{"id":2165,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1104578,"byte_end":1104589,"line_start":505,"line_end":505,"column_start":23,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":2775}],"docs":"","sig":null,"attributes":[]},{"id":2166,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1104785,"byte_end":1104796,"line_start":512,"line_end":512,"column_start":23,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":2777}],"docs":"","sig":null,"attributes":[]},{"id":2167,"kind":"Inherent","span":{"file_name":"src/libcore/panic.rs","byte_start":1161457,"byte_end":1161466,"line_start":41,"line_end":41,"column_start":10,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":2783},{"krate":0,"index":2786},{"krate":0,"index":2787},{"krate":0,"index":2788},{"krate":0,"index":2789}],"docs":"","sig":null,"attributes":[]},{"id":2168,"kind":"Direct","span":{"file_name":"src/libcore/panic.rs","byte_start":1164364,"byte_end":1164373,"line_start":126,"line_end":126,"column_start":23,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":2791}],"docs":"","sig":null,"attributes":[]},{"id":2169,"kind":"Inherent","span":{"file_name":"src/libcore/panic.rs","byte_start":1165900,"byte_end":1165908,"line_start":173,"line_end":173,"column_start":10,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":2794},{"krate":0,"index":2795},{"krate":0,"index":2796},{"krate":0,"index":2797}],"docs":"","sig":null,"attributes":[]},{"id":2170,"kind":"Direct","span":{"file_name":"src/libcore/panic.rs","byte_start":1168254,"byte_end":1168262,"line_start":251,"line_end":251,"column_start":23,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":2799}],"docs":"","sig":null,"attributes":[]},{"id":2171,"kind":"Direct","span":{"file_name":"src/libcore/pin.rs","byte_start":1192186,"byte_end":1192189,"line_start":385,"line_end":385,"column_start":34,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":2831},{"krate":0,"index":2832}],"docs":"","sig":null,"attributes":[]},{"id":2172,"kind":"Direct","span":{"file_name":"src/libcore/pin.rs","byte_start":1192519,"byte_end":1192522,"line_start":399,"line_end":399,"column_start":35,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":2836},{"krate":0,"index":2837},{"krate":0,"index":2838},{"krate":0,"index":2839},{"krate":0,"index":2840}],"docs":"","sig":null,"attributes":[]},{"id":2173,"kind":"Inherent","span":{"file_name":"src/libcore/pin.rs","byte_start":1193048,"byte_end":1193051,"line_start":424,"line_end":424,"column_start":16,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":2843},{"krate":0,"index":2844}],"docs":"","sig":null,"attributes":[]},{"id":2174,"kind":"Inherent","span":{"file_name":"src/libcore/pin.rs","byte_start":1194136,"byte_end":1194139,"line_start":456,"line_end":456,"column_start":16,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":2847},{"krate":0,"index":2848},{"krate":0,"index":2849}],"docs":"","sig":null,"attributes":[]},{"id":2175,"kind":"Inherent","span":{"file_name":"src/libcore/pin.rs","byte_start":1199014,"byte_end":1199017,"line_start":563,"line_end":563,"column_start":19,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":2852},{"krate":0,"index":2853}],"docs":"","sig":null,"attributes":[]},{"id":2176,"kind":"Inherent","span":{"file_name":"src/libcore/pin.rs","byte_start":1200113,"byte_end":1200116,"line_start":591,"line_end":591,"column_start":21,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":2857},{"krate":0,"index":2860}],"docs":"","sig":null,"attributes":[]},{"id":2177,"kind":"Inherent","span":{"file_name":"src/libcore/pin.rs","byte_start":1202444,"byte_end":1202447,"line_start":640,"line_end":640,"column_start":21,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":2864},{"krate":0,"index":2865},{"krate":0,"index":2866},{"krate":0,"index":2867}],"docs":"","sig":null,"attributes":[]},{"id":2178,"kind":"Direct","span":{"file_name":"src/libcore/pin.rs","byte_start":1205225,"byte_end":1205228,"line_start":707,"line_end":707,"column_start":26,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":2872},{"krate":0,"index":2873}],"docs":"","sig":null,"attributes":[]},{"id":2179,"kind":"Direct","span":{"file_name":"src/libcore/pin.rs","byte_start":1205424,"byte_end":1205427,"line_start":715,"line_end":715,"column_start":32,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":2876}],"docs":"","sig":null,"attributes":[]},{"id":2180,"kind":"Direct","span":{"file_name":"src/libcore/pin.rs","byte_start":1205641,"byte_end":1205644,"line_start":725,"line_end":725,"column_start":32,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2181,"kind":"Direct","span":{"file_name":"src/libcore/pin.rs","byte_start":1205732,"byte_end":1205735,"line_start":728,"line_end":728,"column_start":36,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":2881}],"docs":"","sig":null,"attributes":[]},{"id":2182,"kind":"Direct","span":{"file_name":"src/libcore/pin.rs","byte_start":1205939,"byte_end":1205942,"line_start":735,"line_end":735,"column_start":40,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":2884}],"docs":"","sig":null,"attributes":[]},{"id":2183,"kind":"Direct","span":{"file_name":"src/libcore/pin.rs","byte_start":1206148,"byte_end":1206151,"line_start":742,"line_end":742,"column_start":40,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":2887}],"docs":"","sig":null,"attributes":[]},{"id":2184,"kind":"Direct","span":{"file_name":"src/libcore/pin.rs","byte_start":1206683,"byte_end":1206686,"line_start":754,"line_end":754,"column_start":38,"column_end":41},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2185,"kind":"Direct","span":{"file_name":"src/libcore/pin.rs","byte_start":1206813,"byte_end":1206816,"line_start":760,"line_end":760,"column_start":44,"column_end":47},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2198,"kind":"Direct","span":{"file_name":"src/libcore/iter/range.rs","byte_start":1227236,"byte_end":1227241,"line_start":201,"line_end":201,"column_start":33,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":2985},{"krate":0,"index":2986},{"krate":0,"index":2987},{"krate":0,"index":2988},{"krate":0,"index":2989},{"krate":0,"index":2990},{"krate":0,"index":2991}],"docs":"","sig":null,"attributes":[]},{"id":2199,"kind":"Direct","span":{"file_name":"src/libcore/iter/range.rs","byte_start":1229484,"byte_end":1229489,"line_start":274,"line_end":274,"column_start":44,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":2994},{"krate":0,"index":2995}],"docs":"","sig":null,"attributes":[]},{"id":2200,"kind":"Direct","span":{"file_name":"src/libcore/iter/range.rs","byte_start":1230137,"byte_end":1230142,"line_start":300,"line_end":300,"column_start":38,"column_end":43},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2201,"kind":"Direct","span":{"file_name":"src/libcore/iter/range.rs","byte_start":1230228,"byte_end":1230237,"line_start":303,"line_end":303,"column_start":33,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":3000},{"krate":0,"index":3001},{"krate":0,"index":3002},{"krate":0,"index":3003}],"docs":"","sig":null,"attributes":[]},{"id":2202,"kind":"Direct","span":{"file_name":"src/libcore/iter/range.rs","byte_start":1230821,"byte_end":1230830,"line_start":327,"line_end":327,"column_start":38,"column_end":47},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2203,"kind":"Direct","span":{"file_name":"src/libcore/iter/range.rs","byte_start":1230933,"byte_end":1230942,"line_start":330,"line_end":330,"column_start":42,"column_end":51},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2204,"kind":"Direct","span":{"file_name":"src/libcore/iter/range.rs","byte_start":1231039,"byte_end":1231053,"line_start":333,"line_end":333,"column_start":33,"column_end":47},"value":"","parent":null,"children":[{"krate":0,"index":3010},{"krate":0,"index":3011},{"krate":0,"index":3012},{"krate":0,"index":3013},{"krate":0,"index":3015},{"krate":0,"index":3019},{"krate":0,"index":3020},{"krate":0,"index":3021}],"docs":"","sig":null,"attributes":[]},{"id":2205,"kind":"Direct","span":{"file_name":"src/libcore/iter/range.rs","byte_start":1233606,"byte_end":1233620,"line_start":437,"line_end":437,"column_start":44,"column_end":58},"value":"","parent":null,"children":[{"krate":0,"index":3024},{"krate":0,"index":3025},{"krate":0,"index":3027}],"docs":"","sig":null,"attributes":[]},{"id":2206,"kind":"Direct","span":{"file_name":"src/libcore/iter/range.rs","byte_start":1235569,"byte_end":1235583,"line_start":511,"line_end":511,"column_start":38,"column_end":52},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2207,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1236050,"byte_end":1236056,"line_start":19,"line_end":19,"column_start":29,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":3042},{"krate":0,"index":3043},{"krate":0,"index":3044}],"docs":"","sig":null,"attributes":[]},{"id":2208,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1236338,"byte_end":1236344,"line_start":29,"line_end":29,"column_start":40,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":3047}],"docs":"","sig":null,"attributes":[]},{"id":2209,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1236519,"byte_end":1236525,"line_start":35,"line_end":35,"column_start":34,"column_end":40},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2210,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1236624,"byte_end":1236630,"line_start":38,"line_end":38,"column_start":38,"column_end":44},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2211,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1238703,"byte_end":1238713,"line_start":111,"line_end":111,"column_start":39,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":3057},{"krate":0,"index":3058},{"krate":0,"index":3059}],"docs":"","sig":null,"attributes":[]},{"id":2212,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1239013,"byte_end":1239023,"line_start":122,"line_end":122,"column_start":44,"column_end":54},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2213,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1239132,"byte_end":1239142,"line_start":125,"line_end":125,"column_start":48,"column_end":58},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2214,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1241593,"byte_end":1241598,"line_start":202,"line_end":202,"column_start":24,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":3075}],"docs":"","sig":null,"attributes":[]},{"id":2215,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1241771,"byte_end":1241776,"line_start":209,"line_end":209,"column_start":22,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":3078},{"krate":0,"index":3079},{"krate":0,"index":3080}],"docs":"","sig":null,"attributes":[]},{"id":2216,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1242024,"byte_end":1242029,"line_start":222,"line_end":222,"column_start":33,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":3083}],"docs":"","sig":null,"attributes":[]},{"id":2217,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1242181,"byte_end":1242186,"line_start":229,"line_end":229,"column_start":31,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":3086}],"docs":"","sig":null,"attributes":[]},{"id":2218,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1242324,"byte_end":1242329,"line_start":236,"line_end":236,"column_start":31,"column_end":36},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2219,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1242410,"byte_end":1242415,"line_start":239,"line_end":239,"column_start":27,"column_end":32},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2220,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1242573,"byte_end":1242578,"line_start":244,"line_end":244,"column_start":19,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":3093}],"docs":"","sig":null,"attributes":[]},{"id":2221,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1242816,"byte_end":1242821,"line_start":253,"line_end":253,"column_start":21,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":3096}],"docs":"","sig":null,"attributes":[]},{"id":2222,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1243690,"byte_end":1243694,"line_start":290,"line_end":290,"column_start":22,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":3101},{"krate":0,"index":3102},{"krate":0,"index":3103}],"docs":"","sig":null,"attributes":[]},{"id":2223,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1243965,"byte_end":1243969,"line_start":303,"line_end":303,"column_start":33,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":3106}],"docs":"","sig":null,"attributes":[]},{"id":2224,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1244138,"byte_end":1244142,"line_start":310,"line_end":310,"column_start":31,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":3109}],"docs":"","sig":null,"attributes":[]},{"id":2225,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1244295,"byte_end":1244299,"line_start":317,"line_end":317,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2226,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1244380,"byte_end":1244384,"line_start":320,"line_end":320,"column_start":27,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2227,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1246503,"byte_end":1246511,"line_start":392,"line_end":392,"column_start":40,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":3119},{"krate":0,"index":3120},{"krate":0,"index":3122}],"docs":"","sig":null,"attributes":[]},{"id":2228,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1246851,"byte_end":1246859,"line_start":407,"line_end":407,"column_start":51,"column_end":59},"value":"","parent":null,"children":[{"krate":0,"index":3126}],"docs":"","sig":null,"attributes":[]},{"id":2229,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1247042,"byte_end":1247050,"line_start":414,"line_end":414,"column_start":49,"column_end":57},"value":"","parent":null,"children":[{"krate":0,"index":3130}],"docs":"","sig":null,"attributes":[]},{"id":2230,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1247225,"byte_end":1247233,"line_start":421,"line_end":421,"column_start":45,"column_end":53},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2231,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1247346,"byte_end":1247354,"line_start":424,"line_end":424,"column_start":49,"column_end":57},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2232,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1251240,"byte_end":1251246,"line_start":548,"line_end":548,"column_start":25,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":3146},{"krate":0,"index":3147}],"docs":"","sig":null,"attributes":[]},{"id":2233,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1251472,"byte_end":1251478,"line_start":560,"line_end":560,"column_start":24,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":3150}],"docs":"","sig":null,"attributes":[]},{"id":2234,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1252959,"byte_end":1252969,"line_start":604,"line_end":604,"column_start":25,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":3157},{"krate":0,"index":3158},{"krate":0,"index":3160}],"docs":"","sig":null,"attributes":[]},{"id":2235,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1253480,"byte_end":1253490,"line_start":628,"line_end":628,"column_start":30,"column_end":40},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2236,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1253632,"byte_end":1253642,"line_start":633,"line_end":633,"column_start":39,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":3167}],"docs":"","sig":null,"attributes":[]},{"id":2237,"kind":"Direct","span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1361517,"byte_end":1361518,"line_start":241,"line_end":241,"column_start":36,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":3398},{"krate":0,"index":3399},{"krate":0,"index":3400}],"docs":"","sig":null,"attributes":[]},{"id":2286,"kind":"Inherent","span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1369197,"byte_end":1369208,"line_start":127,"line_end":127,"column_start":15,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":3432},{"krate":0,"index":3435},{"krate":0,"index":3436}],"docs":"","sig":null,"attributes":[]},{"id":2287,"kind":"Direct","span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1370126,"byte_end":1370137,"line_start":159,"line_end":159,"column_start":28,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":3442},{"krate":0,"index":3443},{"krate":0,"index":3444}],"docs":"","sig":null,"attributes":[]},{"id":2288,"kind":"Direct","span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1370793,"byte_end":1370799,"line_start":186,"line_end":186,"column_start":37,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":3449}],"docs":"","sig":null,"attributes":[]},{"id":2289,"kind":"Direct","span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1371689,"byte_end":1371695,"line_start":214,"line_end":214,"column_start":41,"column_end":47},"value":"","parent":null,"children":[{"krate":0,"index":3456}],"docs":"","sig":null,"attributes":[]},{"id":2290,"kind":"Inherent","span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1372281,"byte_end":1372292,"line_start":234,"line_end":234,"column_start":12,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":3466},{"krate":0,"index":3469},{"krate":0,"index":3470}],"docs":"","sig":null,"attributes":[]},{"id":2291,"kind":"Direct","span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1373119,"byte_end":1373130,"line_start":267,"line_end":267,"column_start":25,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":3475},{"krate":0,"index":3476},{"krate":0,"index":3477}],"docs":"","sig":null,"attributes":[]},{"id":2292,"kind":"Direct","span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1373778,"byte_end":1373784,"line_start":295,"line_end":295,"column_start":31,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":3481}],"docs":"","sig":null,"attributes":[]},{"id":2293,"kind":"Direct","span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1374652,"byte_end":1374658,"line_start":322,"line_end":322,"column_start":35,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":3487}],"docs":"","sig":null,"attributes":[]},{"id":2294,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1436231,"byte_end":1436236,"line_start":21,"line_end":21,"column_start":12,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":3534}],"docs":"","sig":null,"attributes":[]},{"id":2295,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1437138,"byte_end":1437143,"line_start":51,"line_end":51,"column_start":25,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":3538},{"krate":0,"index":3539},{"krate":0,"index":3540},{"krate":0,"index":3541},{"krate":0,"index":3545},{"krate":0,"index":3548},{"krate":0,"index":3549},{"krate":0,"index":3551},{"krate":0,"index":3552}],"docs":"","sig":null,"attributes":[]},{"id":2296,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1441146,"byte_end":1441151,"line_start":191,"line_end":191,"column_start":36,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":3556},{"krate":0,"index":3557},{"krate":0,"index":3561}],"docs":"","sig":null,"attributes":[]},{"id":2297,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1442986,"byte_end":1442991,"line_start":252,"line_end":252,"column_start":30,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2298,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1443159,"byte_end":1443164,"line_start":258,"line_end":258,"column_start":34,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2299,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1443953,"byte_end":1443960,"line_start":20,"line_end":20,"column_start":60,"column_end":67},"value":"","parent":null,"children":[{"krate":0,"index":3587}],"docs":"","sig":null,"attributes":[]},{"id":2300,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1444215,"byte_end":1444222,"line_start":27,"line_end":27,"column_start":61,"column_end":68},"value":"","parent":null,"children":[{"krate":0,"index":3592}],"docs":"","sig":null,"attributes":[]},{"id":2301,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1444465,"byte_end":1444472,"line_start":34,"line_end":34,"column_start":56,"column_end":63},"value":"","parent":null,"children":[{"krate":0,"index":3597}],"docs":"","sig":null,"attributes":[]},{"id":2302,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1444758,"byte_end":1444765,"line_start":43,"line_end":43,"column_start":52,"column_end":59},"value":"","parent":null,"children":[{"krate":0,"index":3602},{"krate":0,"index":3603},{"krate":0,"index":3604},{"krate":0,"index":3605},{"krate":0,"index":3609}],"docs":"","sig":null,"attributes":[]},{"id":2303,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1445501,"byte_end":1445508,"line_start":70,"line_end":70,"column_start":60,"column_end":67},"value":"","parent":null,"children":[{"krate":0,"index":3616},{"krate":0,"index":3617},{"krate":0,"index":3621}],"docs":"","sig":null,"attributes":[]},{"id":2304,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1446184,"byte_end":1446191,"line_start":94,"line_end":94,"column_start":33,"column_end":40},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2305,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1446866,"byte_end":1446873,"line_start":111,"line_end":111,"column_start":19,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":3633}],"docs":"","sig":null,"attributes":[]},{"id":2306,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1447109,"byte_end":1447116,"line_start":119,"line_end":119,"column_start":27,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":3637}],"docs":"","sig":null,"attributes":[]},{"id":2307,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1447469,"byte_end":1447476,"line_start":129,"line_end":129,"column_start":22,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":3641}],"docs":"","sig":null,"attributes":[]},{"id":2308,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1447752,"byte_end":1447759,"line_start":137,"line_end":137,"column_start":25,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":3645},{"krate":0,"index":3646},{"krate":0,"index":3647},{"krate":0,"index":3648},{"krate":0,"index":3652}],"docs":"","sig":null,"attributes":[]},{"id":2309,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1448541,"byte_end":1448548,"line_start":165,"line_end":165,"column_start":36,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":3658},{"krate":0,"index":3659},{"krate":0,"index":3663}],"docs":"","sig":null,"attributes":[]},{"id":2310,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1449242,"byte_end":1449249,"line_start":188,"line_end":188,"column_start":30,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2311,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1449577,"byte_end":1449590,"line_start":200,"line_end":200,"column_start":12,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":3672}],"docs":"","sig":null,"attributes":[]},{"id":2312,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1449827,"byte_end":1449840,"line_start":207,"line_end":207,"column_start":25,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":3676},{"krate":0,"index":3677},{"krate":0,"index":3679},{"krate":0,"index":3682},{"krate":0,"index":3687}],"docs":"","sig":null,"attributes":[]},{"id":2313,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1452063,"byte_end":1452076,"line_start":276,"line_end":276,"column_start":36,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":3694},{"krate":0,"index":3696},{"krate":0,"index":3701}],"docs":"","sig":null,"attributes":[]},{"id":2314,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1454518,"byte_end":1454521,"line_start":22,"line_end":22,"column_start":32,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":3716},{"krate":0,"index":3717}],"docs":"","sig":null,"attributes":[]},{"id":2315,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1454910,"byte_end":1454913,"line_start":36,"line_end":36,"column_start":25,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":3721},{"krate":0,"index":3722},{"krate":0,"index":3723},{"krate":0,"index":3724}],"docs":"","sig":null,"attributes":[]},{"id":2316,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1455382,"byte_end":1455385,"line_start":57,"line_end":57,"column_start":36,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":3728}],"docs":"","sig":null,"attributes":[]},{"id":2317,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1456109,"byte_end":1456112,"line_start":82,"line_end":82,"column_start":30,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":3741},{"krate":0,"index":3742},{"krate":0,"index":3743},{"krate":0,"index":3746},{"krate":0,"index":3747},{"krate":0,"index":3748}],"docs":"","sig":null,"attributes":[]},{"id":2318,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1457944,"byte_end":1457947,"line_start":150,"line_end":150,"column_start":30,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":3752},{"krate":0,"index":3753},{"krate":0,"index":3754},{"krate":0,"index":3755},{"krate":0,"index":3756}],"docs":"","sig":null,"attributes":[]},{"id":2319,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1460507,"byte_end":1460510,"line_start":242,"line_end":242,"column_start":34,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2320,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1460631,"byte_end":1460634,"line_start":246,"line_end":246,"column_start":43,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":3763},{"krate":0,"index":3764}],"docs":"","sig":null,"attributes":[]},{"id":2321,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1461038,"byte_end":1461041,"line_start":260,"line_end":260,"column_start":30,"column_end":33},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2322,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1461185,"byte_end":1461188,"line_start":264,"line_end":264,"column_start":34,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2323,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1378002,"byte_end":1378005,"line_start":33,"line_end":33,"column_start":9,"column_end":12},"value":"","parent":null,"children":[{"krate":0,"index":3782}],"docs":"","sig":null,"attributes":[]},{"id":2324,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1378151,"byte_end":1378154,"line_start":40,"line_end":40,"column_start":22,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":3785},{"krate":0,"index":3786},{"krate":0,"index":3787},{"krate":0,"index":3788},{"krate":0,"index":3789},{"krate":0,"index":3793},{"krate":0,"index":3796},{"krate":0,"index":3798}],"docs":"","sig":null,"attributes":[]},{"id":2325,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1379260,"byte_end":1379263,"line_start":79,"line_end":79,"column_start":33,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":3802},{"krate":0,"index":3803},{"krate":0,"index":3804},{"krate":0,"index":3808},{"krate":0,"index":3811}],"docs":"","sig":null,"attributes":[]},{"id":2326,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1380053,"byte_end":1380056,"line_start":106,"line_end":106,"column_start":31,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":3815},{"krate":0,"index":3816}],"docs":"","sig":null,"attributes":[]},{"id":2327,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1380319,"byte_end":1380322,"line_start":119,"line_end":119,"column_start":27,"column_end":30},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2328,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1380463,"byte_end":1380466,"line_start":123,"line_end":123,"column_start":31,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2329,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1380979,"byte_end":1380985,"line_start":140,"line_end":140,"column_start":9,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":3823}],"docs":"","sig":null,"attributes":[]},{"id":2330,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1381151,"byte_end":1381157,"line_start":147,"line_end":147,"column_start":33,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":3828},{"krate":0,"index":3829},{"krate":0,"index":3830},{"krate":0,"index":3831},{"krate":0,"index":3836}],"docs":"","sig":null,"attributes":[]},{"id":2331,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1381864,"byte_end":1381870,"line_start":174,"line_end":174,"column_start":44,"column_end":50},"value":"","parent":null,"children":[{"krate":0,"index":3844},{"krate":0,"index":3845},{"krate":0,"index":3850}],"docs":"","sig":null,"attributes":[]},{"id":2332,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1382493,"byte_end":1382499,"line_start":195,"line_end":195,"column_start":42,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":3858},{"krate":0,"index":3859}],"docs":"","sig":null,"attributes":[]},{"id":2333,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1382774,"byte_end":1382780,"line_start":208,"line_end":208,"column_start":38,"column_end":44},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2334,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1382901,"byte_end":1382907,"line_start":213,"line_end":213,"column_start":51,"column_end":57},"value":"","parent":null,"children":[{"krate":0,"index":3868},{"krate":0,"index":3869}],"docs":"","sig":null,"attributes":[]},{"id":2335,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1383264,"byte_end":1383270,"line_start":227,"line_end":227,"column_start":42,"column_end":48},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2336,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1383790,"byte_end":1383796,"line_start":245,"line_end":245,"column_start":9,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":3876}],"docs":"","sig":null,"attributes":[]},{"id":2337,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1383961,"byte_end":1383967,"line_start":252,"line_end":252,"column_start":33,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":3881},{"krate":0,"index":3882},{"krate":0,"index":3883},{"krate":0,"index":3884},{"krate":0,"index":3889}],"docs":"","sig":null,"attributes":[]},{"id":2338,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1384688,"byte_end":1384694,"line_start":279,"line_end":279,"column_start":44,"column_end":50},"value":"","parent":null,"children":[{"krate":0,"index":3897},{"krate":0,"index":3898},{"krate":0,"index":3903}],"docs":"","sig":null,"attributes":[]},{"id":2339,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1385331,"byte_end":1385337,"line_start":300,"line_end":300,"column_start":42,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":3911},{"krate":0,"index":3912}],"docs":"","sig":null,"attributes":[]},{"id":2340,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1385607,"byte_end":1385613,"line_start":313,"line_end":313,"column_start":38,"column_end":44},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2341,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1385735,"byte_end":1385741,"line_start":318,"line_end":318,"column_start":51,"column_end":57},"value":"","parent":null,"children":[{"krate":0,"index":3921},{"krate":0,"index":3922}],"docs":"","sig":null,"attributes":[]},{"id":2342,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1386060,"byte_end":1386066,"line_start":330,"line_end":330,"column_start":51,"column_end":57},"value":"","parent":null,"children":[{"krate":0,"index":3927},{"krate":0,"index":3928}],"docs":"","sig":null,"attributes":[]},{"id":2343,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1386424,"byte_end":1386430,"line_start":344,"line_end":344,"column_start":42,"column_end":48},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2344,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1386935,"byte_end":1386940,"line_start":363,"line_end":363,"column_start":16,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":3935}],"docs":"","sig":null,"attributes":[]},{"id":2345,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1387110,"byte_end":1387115,"line_start":370,"line_end":370,"column_start":22,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":3938},{"krate":0,"index":3939},{"krate":0,"index":3940}],"docs":"","sig":null,"attributes":[]},{"id":2346,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1387760,"byte_end":1387765,"line_start":393,"line_end":393,"column_start":27,"column_end":32},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2347,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1388297,"byte_end":1388303,"line_start":410,"line_end":410,"column_start":9,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":3945}],"docs":"","sig":null,"attributes":[]},{"id":2348,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1388542,"byte_end":1388548,"line_start":418,"line_end":418,"column_start":22,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":3948},{"krate":0,"index":3949},{"krate":0,"index":3950},{"krate":0,"index":3953}],"docs":"","sig":null,"attributes":[]},{"id":2349,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1390814,"byte_end":1390820,"line_start":490,"line_end":490,"column_start":31,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2350,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1392706,"byte_end":1392709,"line_start":549,"line_end":549,"column_start":12,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":3959}],"docs":"","sig":null,"attributes":[]},{"id":2351,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1392897,"byte_end":1392900,"line_start":556,"line_end":556,"column_start":39,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":3963}],"docs":"","sig":null,"attributes":[]},{"id":2352,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1393155,"byte_end":1393158,"line_start":565,"line_end":565,"column_start":38,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":3968},{"krate":0,"index":3969},{"krate":0,"index":3970},{"krate":0,"index":3971},{"krate":0,"index":3976}],"docs":"","sig":null,"attributes":[]},{"id":2353,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1393976,"byte_end":1393979,"line_start":594,"line_end":594,"column_start":60,"column_end":63},"value":"","parent":null,"children":[{"krate":0,"index":3984},{"krate":0,"index":3985},{"krate":0,"index":3990}],"docs":"","sig":null,"attributes":[]},{"id":2354,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1394689,"byte_end":1394692,"line_start":618,"line_end":618,"column_start":56,"column_end":59},"value":"","parent":null,"children":[{"krate":0,"index":3998},{"krate":0,"index":3999}],"docs":"","sig":null,"attributes":[]},{"id":2355,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1394959,"byte_end":1394962,"line_start":631,"line_end":631,"column_start":48,"column_end":51},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2356,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1395096,"byte_end":1395099,"line_start":635,"line_end":635,"column_start":37,"column_end":40},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2357,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1395228,"byte_end":1395231,"line_start":640,"line_end":640,"column_start":46,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":4012},{"krate":0,"index":4013}],"docs":"","sig":null,"attributes":[]},{"id":2358,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1395960,"byte_end":1395966,"line_start":665,"line_end":665,"column_start":12,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":4017}],"docs":"","sig":null,"attributes":[]},{"id":2359,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1396176,"byte_end":1396182,"line_start":672,"line_end":672,"column_start":39,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":4021}],"docs":"","sig":null,"attributes":[]},{"id":2360,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1396437,"byte_end":1396443,"line_start":681,"line_end":681,"column_start":35,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":4025},{"krate":0,"index":4026},{"krate":0,"index":4027},{"krate":0,"index":4028},{"krate":0,"index":4030},{"krate":0,"index":4035}],"docs":"","sig":null,"attributes":[]},{"id":2361,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1398454,"byte_end":1398460,"line_start":738,"line_end":738,"column_start":57,"column_end":63},"value":"","parent":null,"children":[{"krate":0,"index":4042},{"krate":0,"index":4044},{"krate":0,"index":4049}],"docs":"","sig":null,"attributes":[]},{"id":2362,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1399427,"byte_end":1399433,"line_start":772,"line_end":772,"column_start":45,"column_end":51},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2363,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1399965,"byte_end":1399974,"line_start":789,"line_end":789,"column_start":12,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":4059}],"docs":"","sig":null,"attributes":[]},{"id":2364,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1400174,"byte_end":1400183,"line_start":796,"line_end":796,"column_start":39,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":4063}],"docs":"","sig":null,"attributes":[]},{"id":2365,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1400444,"byte_end":1400453,"line_start":805,"line_end":805,"column_start":38,"column_end":47},"value":"","parent":null,"children":[{"krate":0,"index":4068},{"krate":0,"index":4069},{"krate":0,"index":4070},{"krate":0,"index":4071},{"krate":0,"index":4076}],"docs":"","sig":null,"attributes":[]},{"id":2366,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1401580,"byte_end":1401589,"line_start":845,"line_end":845,"column_start":60,"column_end":69},"value":"","parent":null,"children":[{"krate":0,"index":4084},{"krate":0,"index":4086},{"krate":0,"index":4091}],"docs":"","sig":null,"attributes":[]},{"id":2367,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1402515,"byte_end":1402524,"line_start":877,"line_end":877,"column_start":48,"column_end":57},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2368,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1403071,"byte_end":1403080,"line_start":894,"line_end":894,"column_start":9,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":4101}],"docs":"","sig":null,"attributes":[]},{"id":2369,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1403248,"byte_end":1403257,"line_start":901,"line_end":901,"column_start":22,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":4104},{"krate":0,"index":4105},{"krate":0,"index":4107},{"krate":0,"index":4108},{"krate":0,"index":4110},{"krate":0,"index":4111},{"krate":0,"index":4116}],"docs":"","sig":null,"attributes":[]},{"id":2370,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1405263,"byte_end":1405272,"line_start":972,"line_end":972,"column_start":33,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":4122},{"krate":0,"index":4124},{"krate":0,"index":4126},{"krate":0,"index":4131}],"docs":"","sig":null,"attributes":[]},{"id":2371,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1407058,"byte_end":1407067,"line_start":1023,"line_end":1023,"column_start":31,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":4137},{"krate":0,"index":4138}],"docs":"","sig":null,"attributes":[]},{"id":2372,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1407285,"byte_end":1407294,"line_start":1034,"line_end":1034,"column_start":40,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":4141},{"krate":0,"index":4142}],"docs":"","sig":null,"attributes":[]},{"id":2373,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1407620,"byte_end":1407629,"line_start":1047,"line_end":1047,"column_start":27,"column_end":36},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2374,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1407744,"byte_end":1407753,"line_start":1050,"line_end":1050,"column_start":31,"column_end":40},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2375,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1408383,"byte_end":1408391,"line_start":1071,"line_end":1071,"column_start":19,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":4149}],"docs":"","sig":null,"attributes":[]},{"id":2376,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1408815,"byte_end":1408823,"line_start":1082,"line_end":1082,"column_start":32,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":4152},{"krate":0,"index":4153},{"krate":0,"index":4154},{"krate":0,"index":4155},{"krate":0,"index":4156},{"krate":0,"index":4157},{"krate":0,"index":4159},{"krate":0,"index":4163}],"docs":"","sig":null,"attributes":[]},{"id":2377,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1411022,"byte_end":1411030,"line_start":1162,"line_end":1162,"column_start":50,"column_end":58},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2378,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1411126,"byte_end":1411134,"line_start":1165,"line_end":1165,"column_start":42,"column_end":50},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2379,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1411160,"byte_end":1411168,"line_start":1167,"line_end":1167,"column_start":19,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":4172}],"docs":"","sig":null,"attributes":[]},{"id":2380,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1413165,"byte_end":1413174,"line_start":1228,"line_end":1228,"column_start":12,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":4177}],"docs":"","sig":null,"attributes":[]},{"id":2381,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1413403,"byte_end":1413412,"line_start":1235,"line_end":1235,"column_start":39,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":4181}],"docs":"","sig":null,"attributes":[]},{"id":2382,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1413709,"byte_end":1413718,"line_start":1245,"line_end":1245,"column_start":35,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":4185},{"krate":0,"index":4186},{"krate":0,"index":4188},{"krate":0,"index":4189},{"krate":0,"index":4193}],"docs":"","sig":null,"attributes":[]},{"id":2383,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1415137,"byte_end":1415146,"line_start":1298,"line_end":1298,"column_start":30,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2384,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1415722,"byte_end":1415731,"line_start":1316,"line_end":1316,"column_start":12,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":4202}],"docs":"","sig":null,"attributes":[]},{"id":2385,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1415960,"byte_end":1415969,"line_start":1323,"line_end":1323,"column_start":39,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":4206}],"docs":"","sig":null,"attributes":[]},{"id":2386,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1416266,"byte_end":1416275,"line_start":1333,"line_end":1333,"column_start":35,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":4210},{"krate":0,"index":4211},{"krate":0,"index":4213},{"krate":0,"index":4214}],"docs":"","sig":null,"attributes":[]},{"id":2387,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1417695,"byte_end":1417704,"line_start":1386,"line_end":1386,"column_start":30,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2388,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1418216,"byte_end":1418220,"line_start":1403,"line_end":1403,"column_start":9,"column_end":13},"value":"","parent":null,"children":[{"krate":0,"index":4224}],"docs":"","sig":null,"attributes":[]},{"id":2389,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1418381,"byte_end":1418385,"line_start":1410,"line_end":1410,"column_start":22,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":4227},{"krate":0,"index":4228},{"krate":0,"index":4229},{"krate":0,"index":4230},{"krate":0,"index":4231},{"krate":0,"index":4232},{"krate":0,"index":4234},{"krate":0,"index":4238}],"docs":"","sig":null,"attributes":[]},{"id":2390,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1420655,"byte_end":1420659,"line_start":1500,"line_end":1500,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2391,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1420793,"byte_end":1420797,"line_start":1503,"line_end":1503,"column_start":33,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":4245},{"krate":0,"index":4246},{"krate":0,"index":4247}],"docs":"","sig":null,"attributes":[]},{"id":2392,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1421945,"byte_end":1421949,"line_start":1544,"line_end":1544,"column_start":27,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2393,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1422468,"byte_end":1422472,"line_start":1560,"line_end":1560,"column_start":9,"column_end":13},"value":"","parent":null,"children":[{"krate":0,"index":4256}],"docs":"","sig":null,"attributes":[]},{"id":2394,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1422633,"byte_end":1422637,"line_start":1567,"line_end":1567,"column_start":22,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":4259},{"krate":0,"index":4260},{"krate":0,"index":4261},{"krate":0,"index":4262},{"krate":0,"index":4263}],"docs":"","sig":null,"attributes":[]},{"id":2395,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1424213,"byte_end":1424217,"line_start":1631,"line_end":1631,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2396,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1424325,"byte_end":1424329,"line_start":1634,"line_end":1634,"column_start":27,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2397,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1424456,"byte_end":1424460,"line_start":1637,"line_end":1637,"column_start":43,"column_end":47},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2398,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1424945,"byte_end":1424949,"line_start":1654,"line_end":1654,"column_start":16,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":4278}],"docs":"","sig":null,"attributes":[]},{"id":2399,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1425181,"byte_end":1425185,"line_start":1661,"line_end":1661,"column_start":55,"column_end":59},"value":"","parent":null,"children":[{"krate":0,"index":4283}],"docs":"","sig":null,"attributes":[]},{"id":2400,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1425480,"byte_end":1425484,"line_start":1671,"line_end":1671,"column_start":32,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":4289},{"krate":0,"index":4290},{"krate":0,"index":4292},{"krate":0,"index":4293}],"docs":"","sig":null,"attributes":[]},{"id":2401,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1426880,"byte_end":1426884,"line_start":1718,"line_end":1718,"column_start":9,"column_end":13},"value":"","parent":null,"children":[{"krate":0,"index":4300}],"docs":"","sig":null,"attributes":[]},{"id":2402,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1427051,"byte_end":1427055,"line_start":1725,"line_end":1725,"column_start":27,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2403,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1427148,"byte_end":1427152,"line_start":1728,"line_end":1728,"column_start":22,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":4305},{"krate":0,"index":4306},{"krate":0,"index":4307},{"krate":0,"index":4308},{"krate":0,"index":4309},{"krate":0,"index":4310},{"krate":0,"index":4311},{"krate":0,"index":4315}],"docs":"","sig":null,"attributes":[]},{"id":2404,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1428927,"byte_end":1428931,"line_start":1806,"line_end":1806,"column_start":33,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":4320},{"krate":0,"index":4321},{"krate":0,"index":4322},{"krate":0,"index":4326}],"docs":"","sig":null,"attributes":[]},{"id":2405,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1430169,"byte_end":1430173,"line_start":1854,"line_end":1854,"column_start":40,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":4331},{"krate":0,"index":4332}],"docs":"","sig":null,"attributes":[]},{"id":2406,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1430468,"byte_end":1430472,"line_start":1867,"line_end":1867,"column_start":22,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":4335},{"krate":0,"index":4336},{"krate":0,"index":4337},{"krate":0,"index":4338},{"krate":0,"index":4339},{"krate":0,"index":4340},{"krate":0,"index":4344}],"docs":"","sig":null,"attributes":[]},{"id":2407,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1431434,"byte_end":1431438,"line_start":1909,"line_end":1909,"column_start":33,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":4349},{"krate":0,"index":4350},{"krate":0,"index":4351},{"krate":0,"index":4355}],"docs":"","sig":null,"attributes":[]},{"id":2408,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1432197,"byte_end":1432201,"line_start":1939,"line_end":1939,"column_start":31,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":4360},{"krate":0,"index":4361}],"docs":"","sig":null,"attributes":[]},{"id":2409,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1432858,"byte_end":1432865,"line_start":1964,"line_end":1964,"column_start":12,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":4365}],"docs":"","sig":null,"attributes":[]},{"id":2410,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1433061,"byte_end":1433068,"line_start":1971,"line_end":1971,"column_start":39,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":4369}],"docs":"","sig":null,"attributes":[]},{"id":2411,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1433265,"byte_end":1433272,"line_start":1979,"line_end":1979,"column_start":22,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":4373}],"docs":"","sig":null,"attributes":[]},{"id":2412,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1433564,"byte_end":1433571,"line_start":1991,"line_end":1991,"column_start":35,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":4377},{"krate":0,"index":4378},{"krate":0,"index":4379},{"krate":0,"index":4380},{"krate":0,"index":4385}],"docs":"","sig":null,"attributes":[]},{"id":2413,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1434503,"byte_end":1434510,"line_start":2023,"line_end":2023,"column_start":57,"column_end":64},"value":"","parent":null,"children":[{"krate":0,"index":4392},{"krate":0,"index":4393},{"krate":0,"index":4398}],"docs":"","sig":null,"attributes":[]},{"id":2414,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1435328,"byte_end":1435335,"line_start":2050,"line_end":2050,"column_start":53,"column_end":60},"value":"","parent":null,"children":[{"krate":0,"index":4405},{"krate":0,"index":4406}],"docs":"","sig":null,"attributes":[]},{"id":2415,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1435595,"byte_end":1435602,"line_start":2063,"line_end":2063,"column_start":45,"column_end":52},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2416,"kind":"Direct","span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1219549,"byte_end":1219558,"line_start":377,"line_end":377,"column_start":20,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":4413},{"krate":0,"index":4414},{"krate":0,"index":4415},{"krate":0,"index":4416},{"krate":0,"index":4417}],"docs":"","sig":null,"attributes":[]},{"id":2417,"kind":"Inherent","span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1219974,"byte_end":1219983,"line_start":393,"line_end":393,"column_start":12,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":4421}],"docs":"","sig":null,"attributes":[]},{"id":2418,"kind":"Inherent","span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1220188,"byte_end":1220197,"line_start":403,"line_end":403,"column_start":14,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":4424},{"krate":0,"index":4425}],"docs":"","sig":null,"attributes":[]},{"id":2419,"kind":"Inherent","span":{"file_name":"src/libcore/option.rs","byte_start":1467438,"byte_end":1467444,"line_start":163,"line_end":163,"column_start":9,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":4441},{"krate":0,"index":4442},{"krate":0,"index":4443},{"krate":0,"index":4444},{"krate":0,"index":4445},{"krate":0,"index":4448},{"krate":0,"index":4451},{"krate":0,"index":4452},{"krate":0,"index":4453},{"krate":0,"index":4454},{"krate":0,"index":4456},{"krate":0,"index":4459},{"krate":0,"index":4462},{"krate":0,"index":4466},{"krate":0,"index":4468},{"krate":0,"index":4471},{"krate":0,"index":4472},{"krate":0,"index":4473},{"krate":0,"index":4475},{"krate":0,"index":4478},{"krate":0,"index":4480},{"krate":0,"index":4481},{"krate":0,"index":4483},{"krate":0,"index":4484},{"krate":0,"index":4485},{"krate":0,"index":4487},{"krate":0,"index":4488}],"docs":"","sig":null,"attributes":[]},{"id":2420,"kind":"Inherent","span":{"file_name":"src/libcore/option.rs","byte_start":1488420,"byte_end":1488426,"line_start":877,"line_end":877,"column_start":15,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":4491}],"docs":"","sig":null,"attributes":[]},{"id":2421,"kind":"Inherent","span":{"file_name":"src/libcore/option.rs","byte_start":1488888,"byte_end":1488894,"line_start":896,"line_end":896,"column_start":15,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":4495}],"docs":"","sig":null,"attributes":[]},{"id":2422,"kind":"Inherent","span":{"file_name":"src/libcore/option.rs","byte_start":1489381,"byte_end":1489387,"line_start":915,"line_end":915,"column_start":16,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":4499}],"docs":"","sig":null,"attributes":[]},{"id":2423,"kind":"Inherent","span":{"file_name":"src/libcore/option.rs","byte_start":1489855,"byte_end":1489861,"line_start":934,"line_end":934,"column_start":16,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":4503}],"docs":"","sig":null,"attributes":[]},{"id":2424,"kind":"Inherent","span":{"file_name":"src/libcore/option.rs","byte_start":1490368,"byte_end":1490374,"line_start":953,"line_end":953,"column_start":18,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":4507}],"docs":"","sig":null,"attributes":[]},{"id":2425,"kind":"Inherent","span":{"file_name":"src/libcore/option.rs","byte_start":1491798,"byte_end":1491804,"line_start":993,"line_end":993,"column_start":16,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":4510}],"docs":"","sig":null,"attributes":[]},{"id":2426,"kind":"Inherent","span":{"file_name":"src/libcore/option.rs","byte_start":1492145,"byte_end":1492151,"line_start":1003,"line_end":1003,"column_start":12,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":4515}],"docs":"","sig":null,"attributes":[]},{"id":2427,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1493361,"byte_end":1493367,"line_start":1042,"line_end":1042,"column_start":26,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":4519},{"krate":0,"index":4520}],"docs":"","sig":null,"attributes":[]},{"id":2428,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1493802,"byte_end":1493808,"line_start":1061,"line_end":1061,"column_start":21,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":4523}],"docs":"","sig":null,"attributes":[]},{"id":2429,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1493981,"byte_end":1493987,"line_start":1068,"line_end":1068,"column_start":26,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":4526},{"krate":0,"index":4527},{"krate":0,"index":4528}],"docs":"","sig":null,"attributes":[]},{"id":2430,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1495056,"byte_end":1495062,"line_start":1112,"line_end":1112,"column_start":21,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":4543}],"docs":"","sig":null,"attributes":[]},{"id":2431,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1495234,"byte_end":1495240,"line_start":1119,"line_end":1119,"column_start":37,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":4547}],"docs":"","sig":null,"attributes":[]},{"id":2432,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1495435,"byte_end":1495441,"line_start":1126,"line_end":1126,"column_start":41,"column_end":47},"value":"","parent":null,"children":[{"krate":0,"index":4551}],"docs":"","sig":null,"attributes":[]},{"id":2433,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1495805,"byte_end":1495809,"line_start":1141,"line_end":1141,"column_start":22,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":4554},{"krate":0,"index":4555},{"krate":0,"index":4556}],"docs":"","sig":null,"attributes":[]},{"id":2434,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1496131,"byte_end":1496135,"line_start":1158,"line_end":1158,"column_start":33,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":4559}],"docs":"","sig":null,"attributes":[]},{"id":2435,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1496261,"byte_end":1496265,"line_start":1165,"line_end":1165,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2436,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1496298,"byte_end":1496302,"line_start":1166,"line_end":1166,"column_start":27,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2437,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1496339,"byte_end":1496343,"line_start":1167,"line_end":1167,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2438,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1496897,"byte_end":1496901,"line_start":1183,"line_end":1183,"column_start":26,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":4569},{"krate":0,"index":4570},{"krate":0,"index":4571}],"docs":"","sig":null,"attributes":[]},{"id":2439,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1497187,"byte_end":1497191,"line_start":1193,"line_end":1193,"column_start":37,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":4575}],"docs":"","sig":null,"attributes":[]},{"id":2440,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1497366,"byte_end":1497370,"line_start":1199,"line_end":1199,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2441,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1497455,"byte_end":1497459,"line_start":1202,"line_end":1202,"column_start":27,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2442,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1497555,"byte_end":1497559,"line_start":1205,"line_end":1205,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2443,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1497635,"byte_end":1497639,"line_start":1208,"line_end":1208,"column_start":19,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":4584}],"docs":"","sig":null,"attributes":[]},{"id":2444,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1498318,"byte_end":1498325,"line_start":1229,"line_end":1229,"column_start":26,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":4588},{"krate":0,"index":4589},{"krate":0,"index":4590}],"docs":"","sig":null,"attributes":[]},{"id":2445,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1498619,"byte_end":1498626,"line_start":1239,"line_end":1239,"column_start":37,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":4594}],"docs":"","sig":null,"attributes":[]},{"id":2446,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1498805,"byte_end":1498812,"line_start":1245,"line_end":1245,"column_start":31,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2447,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1498897,"byte_end":1498904,"line_start":1248,"line_end":1248,"column_start":27,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2448,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1498999,"byte_end":1499006,"line_start":1250,"line_end":1250,"column_start":31,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2449,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1499568,"byte_end":1499576,"line_start":1266,"line_end":1266,"column_start":22,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":4603},{"krate":0,"index":4604},{"krate":0,"index":4605}],"docs":"","sig":null,"attributes":[]},{"id":2450,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1499846,"byte_end":1499854,"line_start":1276,"line_end":1276,"column_start":33,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":4608}],"docs":"","sig":null,"attributes":[]},{"id":2451,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1500021,"byte_end":1500029,"line_start":1282,"line_end":1282,"column_start":31,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2452,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1500110,"byte_end":1500118,"line_start":1285,"line_end":1285,"column_start":27,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2453,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1500210,"byte_end":1500218,"line_start":1288,"line_end":1288,"column_start":31,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2454,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1500501,"byte_end":1500507,"line_start":1295,"line_end":1295,"column_start":57,"column_end":63},"value":"","parent":null,"children":[{"krate":0,"index":4618}],"docs":"","sig":null,"attributes":[]},{"id":2455,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1502913,"byte_end":1502920,"line_start":1368,"line_end":1368,"column_start":62,"column_end":69},"value":"","parent":null,"children":[{"krate":0,"index":4627},{"krate":0,"index":4628},{"krate":0,"index":4629}],"docs":"","sig":null,"attributes":[]},{"id":2456,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1504483,"byte_end":1504489,"line_start":1414,"line_end":1414,"column_start":22,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":4632},{"krate":0,"index":4633},{"krate":0,"index":4634},{"krate":0,"index":4635},{"krate":0,"index":4636}],"docs":"","sig":null,"attributes":[]},{"id":2457,"kind":"Inherent","span":{"file_name":"src/libcore/option.rs","byte_start":1504797,"byte_end":1504803,"line_start":1434,"line_end":1434,"column_start":9,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":4639}],"docs":"","sig":null,"attributes":[]},{"id":2458,"kind":"Inherent","span":{"file_name":"src/libcore/result.rs","byte_start":1516936,"byte_end":1516942,"line_start":260,"line_end":260,"column_start":12,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":4653},{"krate":0,"index":4654},{"krate":0,"index":4655},{"krate":0,"index":4656},{"krate":0,"index":4657},{"krate":0,"index":4658},{"krate":0,"index":4659},{"krate":0,"index":4662},{"krate":0,"index":4666},{"krate":0,"index":4669},{"krate":0,"index":4670},{"krate":0,"index":4671},{"krate":0,"index":4673},{"krate":0,"index":4676},{"krate":0,"index":4678},{"krate":0,"index":4681},{"krate":0,"index":4682}],"docs":"","sig":null,"attributes":[]},{"id":2459,"kind":"Inherent","span":{"file_name":"src/libcore/result.rs","byte_start":1532313,"byte_end":1532319,"line_start":771,"line_end":771,"column_start":24,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":4687},{"krate":0,"index":4688}],"docs":"","sig":null,"attributes":[]},{"id":2460,"kind":"Inherent","span":{"file_name":"src/libcore/result.rs","byte_start":1534020,"byte_end":1534026,"line_start":832,"line_end":832,"column_start":24,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":4692},{"krate":0,"index":4693}],"docs":"","sig":null,"attributes":[]},{"id":2461,"kind":"Inherent","span":{"file_name":"src/libcore/result.rs","byte_start":1535713,"byte_end":1535719,"line_start":892,"line_end":892,"column_start":21,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":4697}],"docs":"","sig":null,"attributes":[]},{"id":2462,"kind":"Inherent","span":{"file_name":"src/libcore/result.rs","byte_start":1537110,"byte_end":1537116,"line_start":931,"line_end":931,"column_start":19,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":4701}],"docs":"","sig":null,"attributes":[]},{"id":2463,"kind":"Inherent","span":{"file_name":"src/libcore/result.rs","byte_start":1537581,"byte_end":1537587,"line_start":943,"line_end":943,"column_start":19,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":4706}],"docs":"","sig":null,"attributes":[]},{"id":2464,"kind":"Inherent","span":{"file_name":"src/libcore/result.rs","byte_start":1538069,"byte_end":1538075,"line_start":956,"line_end":956,"column_start":26,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":4711}],"docs":"","sig":null,"attributes":[]},{"id":2465,"kind":"Inherent","span":{"file_name":"src/libcore/result.rs","byte_start":1538511,"byte_end":1538517,"line_start":968,"line_end":968,"column_start":12,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":4717}],"docs":"","sig":null,"attributes":[]},{"id":2466,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1539769,"byte_end":1539775,"line_start":1007,"line_end":1007,"column_start":36,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":4723},{"krate":0,"index":4724}],"docs":"","sig":null,"attributes":[]},{"id":2467,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1540283,"byte_end":1540289,"line_start":1028,"line_end":1028,"column_start":29,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":4728},{"krate":0,"index":4729},{"krate":0,"index":4730}],"docs":"","sig":null,"attributes":[]},{"id":2468,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1542126,"byte_end":1542130,"line_start":1093,"line_end":1093,"column_start":26,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":4748},{"krate":0,"index":4749},{"krate":0,"index":4750}],"docs":"","sig":null,"attributes":[]},{"id":2469,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1542472,"byte_end":1542476,"line_start":1106,"line_end":1106,"column_start":37,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":4754}],"docs":"","sig":null,"attributes":[]},{"id":2470,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1542646,"byte_end":1542650,"line_start":1112,"line_end":1112,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2471,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1542735,"byte_end":1542739,"line_start":1115,"line_end":1115,"column_start":27,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2472,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1542835,"byte_end":1542839,"line_start":1118,"line_end":1118,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2473,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1542915,"byte_end":1542919,"line_start":1121,"line_end":1121,"column_start":19,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":4763}],"docs":"","sig":null,"attributes":[]},{"id":2474,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1543456,"byte_end":1543463,"line_start":1138,"line_end":1138,"column_start":26,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":4767},{"krate":0,"index":4768},{"krate":0,"index":4769}],"docs":"","sig":null,"attributes":[]},{"id":2475,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1543813,"byte_end":1543820,"line_start":1151,"line_end":1151,"column_start":37,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":4773}],"docs":"","sig":null,"attributes":[]},{"id":2476,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1543994,"byte_end":1544001,"line_start":1157,"line_end":1157,"column_start":31,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2477,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1544086,"byte_end":1544093,"line_start":1160,"line_end":1160,"column_start":27,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2478,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1544189,"byte_end":1544196,"line_start":1163,"line_end":1163,"column_start":31,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2479,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1544867,"byte_end":1544875,"line_start":1181,"line_end":1181,"column_start":22,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":4782},{"krate":0,"index":4783},{"krate":0,"index":4784}],"docs":"","sig":null,"attributes":[]},{"id":2480,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1545201,"byte_end":1545209,"line_start":1194,"line_end":1194,"column_start":33,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":4787}],"docs":"","sig":null,"attributes":[]},{"id":2481,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1545371,"byte_end":1545379,"line_start":1200,"line_end":1200,"column_start":31,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2482,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1545460,"byte_end":1545468,"line_start":1203,"line_end":1203,"column_start":27,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2483,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1545560,"byte_end":1545568,"line_start":1206,"line_end":1206,"column_start":31,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2484,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1545857,"byte_end":1545863,"line_start":1213,"line_end":1213,"column_start":63,"column_end":69},"value":"","parent":null,"children":[{"krate":0,"index":4798}],"docs":"","sig":null,"attributes":[]},{"id":2485,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1547861,"byte_end":1547868,"line_start":1266,"line_end":1266,"column_start":68,"column_end":75},"value":"","parent":null,"children":[{"krate":0,"index":4809},{"krate":0,"index":4810},{"krate":0,"index":4811}],"docs":"","sig":null,"attributes":[]},{"id":2486,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1548760,"byte_end":1548766,"line_start":1298,"line_end":1298,"column_start":24,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":4815},{"krate":0,"index":4816},{"krate":0,"index":4817},{"krate":0,"index":4818},{"krate":0,"index":4819}],"docs":"","sig":null,"attributes":[]},{"id":2487,"kind":"Direct","span":{"file_name":"src/libcore/ffi.rs","byte_start":1550794,"byte_end":1550800,"line_start":43,"line_end":43,"column_start":21,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":4832}],"docs":"","sig":null,"attributes":[]},{"id":2488,"kind":"Inherent","span":{"file_name":"src/libcore/ffi.rs","byte_start":1557254,"byte_end":1557264,"line_start":219,"line_end":219,"column_start":10,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":4835}],"docs":"","sig":null,"attributes":[]},{"id":2489,"kind":"Direct","span":{"file_name":"src/libcore/ffi.rs","byte_start":1557751,"byte_end":1557757,"line_start":234,"line_end":234,"column_start":28,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":4840},{"krate":0,"index":4841}],"docs":"","sig":null,"attributes":[]},{"id":2490,"kind":"Direct","span":{"file_name":"src/libcore/ffi.rs","byte_start":1558108,"byte_end":1558114,"line_start":247,"line_end":247,"column_start":31,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":4845}],"docs":"","sig":null,"attributes":[]},{"id":2502,"kind":"Inherent","span":{"file_name":"src/libcore/ffi.rs","byte_start":1560370,"byte_end":1560380,"line_start":306,"line_end":306,"column_start":10,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":4855},{"krate":0,"index":4857}],"docs":"","sig":null,"attributes":[]},{"id":2503,"kind":"Direct","span":{"file_name":"src/libcore/ffi.rs","byte_start":1561053,"byte_end":1561063,"line_start":328,"line_end":328,"column_start":20,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":4863}],"docs":"","sig":null,"attributes":[]},{"id":2504,"kind":"Direct","span":{"file_name":"src/libcore/ffi.rs","byte_start":1561517,"byte_end":1561527,"line_start":344,"line_end":344,"column_start":19,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":4866}],"docs":"","sig":null,"attributes":[]},{"id":2505,"kind":"Inherent","span":{"file_name":"src/libcore/slice/rotate.rs","byte_start":1747655,"byte_end":1747663,"line_start":18,"line_end":18,"column_start":9,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":4938}],"docs":"","sig":null,"attributes":[]},{"id":2506,"kind":"Direct","span":{"file_name":"src/libcore/slice/sort.rs","byte_start":1750483,"byte_end":1750493,"line_start":19,"line_end":19,"column_start":18,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":4954}],"docs":"","sig":null,"attributes":[]},{"id":2508,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1652022,"byte_end":1652027,"line_start":2578,"line_end":2578,"column_start":26,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2509,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1652124,"byte_end":1652131,"line_start":2580,"line_end":2580,"column_start":26,"column_end":33},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2510,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1652228,"byte_end":1652237,"line_start":2582,"line_end":2582,"column_start":26,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2511,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1652334,"byte_end":1652343,"line_start":2584,"line_end":2584,"column_start":26,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2512,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1652433,"byte_end":1652447,"line_start":2586,"line_end":2586,"column_start":26,"column_end":40},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2513,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1652544,"byte_end":1652560,"line_start":2588,"line_end":2588,"column_start":26,"column_end":42},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2515,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1655951,"byte_end":1655956,"line_start":2692,"line_end":2692,"column_start":35,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":5188},{"krate":0,"index":5189},{"krate":0,"index":5190},{"krate":0,"index":5191},{"krate":0,"index":5192},{"krate":0,"index":5193},{"krate":0,"index":5194}],"docs":"","sig":null,"attributes":[]},{"id":2516,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1657628,"byte_end":1657635,"line_start":2753,"line_end":2753,"column_start":34,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":5197},{"krate":0,"index":5198},{"krate":0,"index":5199},{"krate":0,"index":5200},{"krate":0,"index":5201},{"krate":0,"index":5202},{"krate":0,"index":5203}],"docs":"","sig":null,"attributes":[]},{"id":2517,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1658457,"byte_end":1658466,"line_start":2788,"line_end":2788,"column_start":34,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":5206},{"krate":0,"index":5207},{"krate":0,"index":5208},{"krate":0,"index":5209},{"krate":0,"index":5210},{"krate":0,"index":5211},{"krate":0,"index":5212}],"docs":"","sig":null,"attributes":[]},{"id":2518,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1659360,"byte_end":1659369,"line_start":2823,"line_end":2823,"column_start":34,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":5215},{"krate":0,"index":5216},{"krate":0,"index":5217},{"krate":0,"index":5218},{"krate":0,"index":5219},{"krate":0,"index":5220},{"krate":0,"index":5221}],"docs":"","sig":null,"attributes":[]},{"id":2519,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1660041,"byte_end":1660055,"line_start":2859,"line_end":2859,"column_start":34,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":5224},{"krate":0,"index":5225},{"krate":0,"index":5226},{"krate":0,"index":5227},{"krate":0,"index":5228},{"krate":0,"index":5229},{"krate":0,"index":5230}],"docs":"","sig":null,"attributes":[]},{"id":2520,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1661261,"byte_end":1661277,"line_start":2898,"line_end":2898,"column_start":34,"column_end":50},"value":"","parent":null,"children":[{"krate":0,"index":5233},{"krate":0,"index":5234},{"krate":0,"index":5235},{"krate":0,"index":5236},{"krate":0,"index":5237},{"krate":0,"index":5238},{"krate":0,"index":5239}],"docs":"","sig":null,"attributes":[]},{"id":2521,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1676293,"byte_end":1676297,"line_start":3327,"line_end":3327,"column_start":36,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":5271}],"docs":"","sig":null,"attributes":[]},{"id":2522,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1676544,"byte_end":1676548,"line_start":3336,"line_end":3336,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2523,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1676635,"byte_end":1676639,"line_start":3338,"line_end":3338,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2524,"kind":"Inherent","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1676663,"byte_end":1676667,"line_start":3340,"line_end":3340,"column_start":13,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":5279}],"docs":"","sig":null,"attributes":[]},{"id":2525,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1678077,"byte_end":1678081,"line_start":3384,"line_end":3384,"column_start":19,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":5282}],"docs":"","sig":null,"attributes":[]},{"id":2526,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1678269,"byte_end":1678273,"line_start":3389,"line_end":3389,"column_start":24,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":5285}],"docs":"","sig":null,"attributes":[]},{"id":2527,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1679432,"byte_end":1679439,"line_start":3429,"line_end":3429,"column_start":36,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":5294}],"docs":"","sig":null,"attributes":[]},{"id":2528,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1679691,"byte_end":1679698,"line_start":3438,"line_end":3438,"column_start":31,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2529,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1679785,"byte_end":1679792,"line_start":3440,"line_end":3440,"column_start":31,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2530,"kind":"Inherent","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1679816,"byte_end":1679823,"line_start":3442,"line_end":3442,"column_start":13,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":5302},{"krate":0,"index":5303}],"docs":"","sig":null,"attributes":[]},{"id":2531,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1683031,"byte_end":1683036,"line_start":3536,"line_end":3536,"column_start":39,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":5316}],"docs":"","sig":null,"attributes":[]},{"id":2532,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1683404,"byte_end":1683409,"line_start":3547,"line_end":3547,"column_start":22,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":5320}],"docs":"","sig":null,"attributes":[]},{"id":2533,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1683693,"byte_end":1683698,"line_start":3558,"line_end":3558,"column_start":29,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":5325},{"krate":0,"index":5326},{"krate":0,"index":5328}],"docs":"","sig":null,"attributes":[]},{"id":2534,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1684409,"byte_end":1684414,"line_start":3586,"line_end":3586,"column_start":40,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":5333}],"docs":"","sig":null,"attributes":[]},{"id":2535,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1684857,"byte_end":1684862,"line_start":3602,"line_end":3602,"column_start":30,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":5339}],"docs":"","sig":null,"attributes":[]},{"id":2536,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1685125,"byte_end":1685130,"line_start":3610,"line_end":3610,"column_start":30,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2537,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1685721,"byte_end":1685729,"line_start":3627,"line_end":3627,"column_start":39,"column_end":47},"value":"","parent":null,"children":[{"krate":0,"index":5353}],"docs":"","sig":null,"attributes":[]},{"id":2538,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1686007,"byte_end":1686015,"line_start":3636,"line_end":3636,"column_start":30,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":5358}],"docs":"","sig":null,"attributes":[]},{"id":2539,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1686360,"byte_end":1686368,"line_start":3649,"line_end":3649,"column_start":29,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":5363},{"krate":0,"index":5364},{"krate":0,"index":5366}],"docs":"","sig":null,"attributes":[]},{"id":2540,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1687436,"byte_end":1687444,"line_start":3684,"line_end":3684,"column_start":40,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":5371}],"docs":"","sig":null,"attributes":[]},{"id":2541,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1688144,"byte_end":1688152,"line_start":3708,"line_end":3708,"column_start":30,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2542,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1688815,"byte_end":1688821,"line_start":3724,"line_end":3724,"column_start":39,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":5379}],"docs":"","sig":null,"attributes":[]},{"id":2543,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1689162,"byte_end":1689168,"line_start":3734,"line_end":3734,"column_start":29,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":5384},{"krate":0,"index":5385},{"krate":0,"index":5386}],"docs":"","sig":null,"attributes":[]},{"id":2544,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1689529,"byte_end":1689535,"line_start":3749,"line_end":3749,"column_start":40,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":5391}],"docs":"","sig":null,"attributes":[]},{"id":2545,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1689756,"byte_end":1689762,"line_start":3757,"line_end":3757,"column_start":30,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":5396}],"docs":"","sig":null,"attributes":[]},{"id":2546,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1689982,"byte_end":1689988,"line_start":3765,"line_end":3765,"column_start":30,"column_end":36},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2547,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1690603,"byte_end":1690612,"line_start":3780,"line_end":3780,"column_start":39,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":5408}],"docs":"","sig":null,"attributes":[]},{"id":2548,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1690957,"byte_end":1690966,"line_start":3790,"line_end":3790,"column_start":30,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":5413}],"docs":"","sig":null,"attributes":[]},{"id":2549,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1691189,"byte_end":1691198,"line_start":3798,"line_end":3798,"column_start":29,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":5418},{"krate":0,"index":5419},{"krate":0,"index":5420}],"docs":"","sig":null,"attributes":[]},{"id":2550,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1691567,"byte_end":1691576,"line_start":3813,"line_end":3813,"column_start":40,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":5425}],"docs":"","sig":null,"attributes":[]},{"id":2551,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1691806,"byte_end":1691815,"line_start":3823,"line_end":3823,"column_start":30,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2552,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1692122,"byte_end":1692135,"line_start":3834,"line_end":3834,"column_start":44,"column_end":57},"value":"","parent":null,"children":[{"krate":0,"index":5432},{"krate":0,"index":5433},{"krate":0,"index":5434}],"docs":"","sig":null,"attributes":[]},{"id":2553,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1693143,"byte_end":1693149,"line_start":3866,"line_end":3866,"column_start":39,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":5444}],"docs":"","sig":null,"attributes":[]},{"id":2554,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1693954,"byte_end":1693961,"line_start":3888,"line_end":3888,"column_start":39,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":5453}],"docs":"","sig":null,"attributes":[]},{"id":2555,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1694740,"byte_end":1694749,"line_start":3909,"line_end":3909,"column_start":39,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":5462}],"docs":"","sig":null,"attributes":[]},{"id":2556,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1695575,"byte_end":1695585,"line_start":3931,"line_end":3931,"column_start":39,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":5471}],"docs":"","sig":null,"attributes":[]},{"id":2557,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1697189,"byte_end":1697196,"line_start":3984,"line_end":3984,"column_start":19,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":5475}],"docs":"","sig":null,"attributes":[]},{"id":2558,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1697396,"byte_end":1697403,"line_start":3994,"line_end":3994,"column_start":26,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":5479},{"krate":0,"index":5480},{"krate":0,"index":5481},{"krate":0,"index":5482},{"krate":0,"index":5483},{"krate":0,"index":5484}],"docs":"","sig":null,"attributes":[]},{"id":2559,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1698667,"byte_end":1698674,"line_start":4048,"line_end":4048,"column_start":37,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":5488},{"krate":0,"index":5489}],"docs":"","sig":null,"attributes":[]},{"id":2560,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1699409,"byte_end":1699416,"line_start":4075,"line_end":4075,"column_start":31,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2561,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1699512,"byte_end":1699519,"line_start":4078,"line_end":4078,"column_start":31,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2562,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1699604,"byte_end":1699611,"line_start":4081,"line_end":4081,"column_start":27,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2563,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1699681,"byte_end":1699688,"line_start":4084,"line_end":4084,"column_start":44,"column_end":51},"value":"","parent":null,"children":[{"krate":0,"index":5499},{"krate":0,"index":5500}],"docs":"","sig":null,"attributes":[]},{"id":2564,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1700570,"byte_end":1700576,"line_start":4110,"line_end":4110,"column_start":19,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":5503}],"docs":"","sig":null,"attributes":[]},{"id":2565,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1700787,"byte_end":1700793,"line_start":4120,"line_end":4120,"column_start":26,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":5507},{"krate":0,"index":5508},{"krate":0,"index":5509},{"krate":0,"index":5510},{"krate":0,"index":5511},{"krate":0,"index":5512}],"docs":"","sig":null,"attributes":[]},{"id":2566,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1702424,"byte_end":1702430,"line_start":4181,"line_end":4181,"column_start":37,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":5516},{"krate":0,"index":5517}],"docs":"","sig":null,"attributes":[]},{"id":2567,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1703476,"byte_end":1703482,"line_start":4215,"line_end":4215,"column_start":31,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2568,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1703578,"byte_end":1703584,"line_start":4218,"line_end":4218,"column_start":31,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2569,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1703669,"byte_end":1703675,"line_start":4221,"line_end":4221,"column_start":27,"column_end":33},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2570,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1703745,"byte_end":1703751,"line_start":4224,"line_end":4224,"column_start":44,"column_end":50},"value":"","parent":null,"children":[{"krate":0,"index":5527},{"krate":0,"index":5528}],"docs":"","sig":null,"attributes":[]},{"id":2571,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1704819,"byte_end":1704828,"line_start":4254,"line_end":4254,"column_start":26,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":5532},{"krate":0,"index":5533},{"krate":0,"index":5534},{"krate":0,"index":5535},{"krate":0,"index":5536},{"krate":0,"index":5537}],"docs":"","sig":null,"attributes":[]},{"id":2572,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1706644,"byte_end":1706653,"line_start":4318,"line_end":4318,"column_start":37,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":5541}],"docs":"","sig":null,"attributes":[]},{"id":2573,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1707237,"byte_end":1707246,"line_start":4336,"line_end":4336,"column_start":31,"column_end":40},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2574,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1707342,"byte_end":1707351,"line_start":4339,"line_end":4339,"column_start":31,"column_end":40},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2575,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1707436,"byte_end":1707445,"line_start":4342,"line_end":4342,"column_start":27,"column_end":36},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2576,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1707515,"byte_end":1707524,"line_start":4345,"line_end":4345,"column_start":44,"column_end":53},"value":"","parent":null,"children":[{"krate":0,"index":5551},{"krate":0,"index":5552}],"docs":"","sig":null,"attributes":[]},{"id":2577,"kind":"Inherent","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1708719,"byte_end":1708730,"line_start":4377,"line_end":4377,"column_start":13,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":5556}],"docs":"","sig":null,"attributes":[]},{"id":2578,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1709166,"byte_end":1709177,"line_start":4389,"line_end":4389,"column_start":19,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":5559}],"docs":"","sig":null,"attributes":[]},{"id":2579,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1709428,"byte_end":1709439,"line_start":4400,"line_end":4400,"column_start":26,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":5563},{"krate":0,"index":5564},{"krate":0,"index":5565},{"krate":0,"index":5566},{"krate":0,"index":5567},{"krate":0,"index":5568}],"docs":"","sig":null,"attributes":[]},{"id":2580,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1710498,"byte_end":1710509,"line_start":4445,"line_end":4445,"column_start":37,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":5572}],"docs":"","sig":null,"attributes":[]},{"id":2581,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1710889,"byte_end":1710900,"line_start":4459,"line_end":4459,"column_start":31,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":5575}],"docs":"","sig":null,"attributes":[]},{"id":2582,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1711062,"byte_end":1711073,"line_start":4466,"line_end":4466,"column_start":31,"column_end":42},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2583,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1711165,"byte_end":1711176,"line_start":4469,"line_end":4469,"column_start":27,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2584,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1711300,"byte_end":1711311,"line_start":4473,"line_end":4473,"column_start":44,"column_end":55},"value":"","parent":null,"children":[{"krate":0,"index":5583},{"krate":0,"index":5584}],"docs":"","sig":null,"attributes":[]},{"id":2585,"kind":"Inherent","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1712387,"byte_end":1712401,"line_start":4501,"line_end":4501,"column_start":13,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":5588}],"docs":"","sig":null,"attributes":[]},{"id":2586,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1712797,"byte_end":1712811,"line_start":4512,"line_end":4512,"column_start":26,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":5592},{"krate":0,"index":5593},{"krate":0,"index":5594},{"krate":0,"index":5595},{"krate":0,"index":5596},{"krate":0,"index":5597}],"docs":"","sig":null,"attributes":[]},{"id":2587,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1714005,"byte_end":1714019,"line_start":4559,"line_end":4559,"column_start":37,"column_end":51},"value":"","parent":null,"children":[{"krate":0,"index":5601}],"docs":"","sig":null,"attributes":[]},{"id":2588,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1714498,"byte_end":1714512,"line_start":4575,"line_end":4575,"column_start":31,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":5604}],"docs":"","sig":null,"attributes":[]},{"id":2589,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1714674,"byte_end":1714688,"line_start":4582,"line_end":4582,"column_start":31,"column_end":45},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2590,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1714780,"byte_end":1714794,"line_start":4585,"line_end":4585,"column_start":27,"column_end":41},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2591,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1714918,"byte_end":1714932,"line_start":4589,"line_end":4589,"column_start":44,"column_end":58},"value":"","parent":null,"children":[{"krate":0,"index":5612},{"krate":0,"index":5613}],"docs":"","sig":null,"attributes":[]},{"id":2592,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1715881,"byte_end":1715888,"line_start":4616,"line_end":4616,"column_start":19,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":5616}],"docs":"","sig":null,"attributes":[]},{"id":2593,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1716103,"byte_end":1716110,"line_start":4626,"line_end":4626,"column_start":26,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":5620},{"krate":0,"index":5621},{"krate":0,"index":5622},{"krate":0,"index":5623},{"krate":0,"index":5624},{"krate":0,"index":5625}],"docs":"","sig":null,"attributes":[]},{"id":2594,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1717864,"byte_end":1717871,"line_start":4690,"line_end":4690,"column_start":37,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":5629},{"krate":0,"index":5630}],"docs":"","sig":null,"attributes":[]},{"id":2595,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1718901,"byte_end":1718908,"line_start":4723,"line_end":4723,"column_start":31,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2596,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1719004,"byte_end":1719011,"line_start":4726,"line_end":4726,"column_start":31,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2597,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1719098,"byte_end":1719105,"line_start":4729,"line_end":4729,"column_start":27,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2598,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1719224,"byte_end":1719231,"line_start":4733,"line_end":4733,"column_start":44,"column_end":51},"value":"","parent":null,"children":[{"krate":0,"index":5640},{"krate":0,"index":5641}],"docs":"","sig":null,"attributes":[]},{"id":2599,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1720285,"byte_end":1720295,"line_start":4763,"line_end":4763,"column_start":26,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":5645},{"krate":0,"index":5646},{"krate":0,"index":5647},{"krate":0,"index":5648},{"krate":0,"index":5649},{"krate":0,"index":5650}],"docs":"","sig":null,"attributes":[]},{"id":2600,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1722270,"byte_end":1722280,"line_start":4831,"line_end":4831,"column_start":37,"column_end":47},"value":"","parent":null,"children":[{"krate":0,"index":5654},{"krate":0,"index":5655}],"docs":"","sig":null,"attributes":[]},{"id":2601,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1723454,"byte_end":1723464,"line_start":4866,"line_end":4866,"column_start":31,"column_end":41},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2602,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1723560,"byte_end":1723570,"line_start":4869,"line_end":4869,"column_start":31,"column_end":41},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2603,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1723657,"byte_end":1723667,"line_start":4872,"line_end":4872,"column_start":27,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2604,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1723786,"byte_end":1723796,"line_start":4876,"line_end":4876,"column_start":44,"column_end":54},"value":"","parent":null,"children":[{"krate":0,"index":5665},{"krate":0,"index":5666}],"docs":"","sig":null,"attributes":[]},{"id":2605,"kind":"Inherent","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1724966,"byte_end":1724978,"line_start":4908,"line_end":4908,"column_start":13,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":5670}],"docs":"","sig":null,"attributes":[]},{"id":2606,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1725408,"byte_end":1725420,"line_start":4920,"line_end":4920,"column_start":23,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":5674}],"docs":"","sig":null,"attributes":[]},{"id":2607,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1725682,"byte_end":1725694,"line_start":4931,"line_end":4931,"column_start":26,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":5678},{"krate":0,"index":5679},{"krate":0,"index":5680},{"krate":0,"index":5681},{"krate":0,"index":5682},{"krate":0,"index":5683}],"docs":"","sig":null,"attributes":[]},{"id":2608,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1726772,"byte_end":1726784,"line_start":4976,"line_end":4976,"column_start":37,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":5687},{"krate":0,"index":5688}],"docs":"","sig":null,"attributes":[]},{"id":2609,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1727740,"byte_end":1727752,"line_start":5008,"line_end":5008,"column_start":35,"column_end":47},"value":"","parent":null,"children":[{"krate":0,"index":5692}],"docs":"","sig":null,"attributes":[]},{"id":2610,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1727914,"byte_end":1727926,"line_start":5015,"line_end":5015,"column_start":31,"column_end":43},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2611,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1728013,"byte_end":1728025,"line_start":5018,"line_end":5018,"column_start":27,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2612,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1728144,"byte_end":1728156,"line_start":5022,"line_end":5022,"column_start":44,"column_end":56},"value":"","parent":null,"children":[{"krate":0,"index":5700},{"krate":0,"index":5701}],"docs":"","sig":null,"attributes":[]},{"id":2613,"kind":"Inherent","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1729281,"byte_end":1729296,"line_start":5051,"line_end":5051,"column_start":13,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":5705}],"docs":"","sig":null,"attributes":[]},{"id":2614,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1729682,"byte_end":1729697,"line_start":5062,"line_end":5062,"column_start":26,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":5709},{"krate":0,"index":5710},{"krate":0,"index":5711},{"krate":0,"index":5712},{"krate":0,"index":5713},{"krate":0,"index":5714}],"docs":"","sig":null,"attributes":[]},{"id":2615,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1730974,"byte_end":1730989,"line_start":5111,"line_end":5111,"column_start":37,"column_end":52},"value":"","parent":null,"children":[{"krate":0,"index":5718},{"krate":0,"index":5719}],"docs":"","sig":null,"attributes":[]},{"id":2616,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1732095,"byte_end":1732110,"line_start":5145,"line_end":5145,"column_start":31,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":5722}],"docs":"","sig":null,"attributes":[]},{"id":2617,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1732272,"byte_end":1732287,"line_start":5152,"line_end":5152,"column_start":31,"column_end":46},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2618,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1732374,"byte_end":1732389,"line_start":5155,"line_end":5155,"column_start":27,"column_end":42},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2619,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1732508,"byte_end":1732523,"line_start":5159,"line_end":5159,"column_start":44,"column_end":59},"value":"","parent":null,"children":[{"krate":0,"index":5730},{"krate":0,"index":5731}],"docs":"","sig":null,"attributes":[]},{"id":2634,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1741628,"byte_end":1741632,"line_start":5459,"line_end":5459,"column_start":44,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":5793},{"krate":0,"index":5794}],"docs":"","sig":null,"attributes":[]},{"id":2635,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1741843,"byte_end":1741850,"line_start":5467,"line_end":5467,"column_start":44,"column_end":51},"value":"","parent":null,"children":[{"krate":0,"index":5798},{"krate":0,"index":5799}],"docs":"","sig":null,"attributes":[]},{"id":2636,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1742119,"byte_end":1742120,"line_start":5478,"line_end":5478,"column_start":27,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":5804}],"docs":"","sig":null,"attributes":[]},{"id":2639,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1929607,"byte_end":1929619,"line_start":269,"line_end":269,"column_start":34,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":5865},{"krate":0,"index":5866},{"krate":0,"index":5867}],"docs":"","sig":null,"attributes":[]},{"id":2640,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1932926,"byte_end":1932938,"line_start":343,"line_end":343,"column_start":41,"column_end":53},"value":"","parent":null,"children":[{"krate":0,"index":5870},{"krate":0,"index":5871}],"docs":"","sig":null,"attributes":[]},{"id":2641,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1936645,"byte_end":1936657,"line_start":419,"line_end":419,"column_start":38,"column_end":50},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2643,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1938221,"byte_end":1938222,"line_start":478,"line_end":478,"column_start":25,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":5887}],"docs":"","sig":null,"attributes":[]},{"id":2644,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1938714,"byte_end":1938732,"line_start":499,"line_end":499,"column_start":42,"column_end":60},"value":"","parent":null,"children":[{"krate":0,"index":5898},{"krate":0,"index":5899}],"docs":"","sig":null,"attributes":[]},{"id":2645,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1939079,"byte_end":1939098,"line_start":512,"line_end":512,"column_start":50,"column_end":69},"value":"","parent":null,"children":[{"krate":0,"index":5903},{"krate":0,"index":5904}],"docs":"","sig":null,"attributes":[]},{"id":2646,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1939845,"byte_end":1939864,"line_start":537,"line_end":537,"column_start":57,"column_end":76},"value":"","parent":null,"children":[{"krate":0,"index":5908}],"docs":"","sig":null,"attributes":[]},{"id":2647,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1940539,"byte_end":1940558,"line_start":557,"line_end":557,"column_start":54,"column_end":73},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2648,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1942720,"byte_end":1942737,"line_start":634,"line_end":634,"column_start":38,"column_end":55},"value":"","parent":null,"children":[{"krate":0,"index":33370},{"krate":0,"index":33371},{"krate":0,"index":33372},{"krate":0,"index":33373}],"docs":"","sig":null,"attributes":[]},{"id":2649,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1942827,"byte_end":1942844,"line_start":638,"line_end":638,"column_start":45,"column_end":62},"value":"","parent":null,"children":[{"krate":0,"index":33374},{"krate":0,"index":33375},{"krate":0,"index":33376}],"docs":"","sig":null,"attributes":[]},{"id":2650,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1942931,"byte_end":1942948,"line_start":642,"line_end":642,"column_start":42,"column_end":59},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2651,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1943578,"byte_end":1943599,"line_start":658,"line_end":658,"column_start":24,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":5928}],"docs":"","sig":null,"attributes":[]},{"id":2652,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1943925,"byte_end":1943946,"line_start":668,"line_end":668,"column_start":37,"column_end":58},"value":"","parent":null,"children":[{"krate":0,"index":33391},{"krate":0,"index":33392},{"krate":0,"index":33393},{"krate":0,"index":33394}],"docs":"","sig":null,"attributes":[]},{"id":2653,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1944067,"byte_end":1944088,"line_start":674,"line_end":674,"column_start":44,"column_end":65},"value":"","parent":null,"children":[{"krate":0,"index":33395},{"krate":0,"index":33396},{"krate":0,"index":33397}],"docs":"","sig":null,"attributes":[]},{"id":2654,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1944206,"byte_end":1944227,"line_start":680,"line_end":680,"column_start":41,"column_end":62},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2655,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1944354,"byte_end":1944355,"line_start":684,"line_end":684,"column_start":29,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":33398},{"krate":0,"index":33399},{"krate":0,"index":33400},{"krate":0,"index":33401},{"krate":0,"index":33402}],"docs":"","sig":null,"attributes":[]},{"id":2656,"kind":"Inherent","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1946513,"byte_end":1946524,"line_start":757,"line_end":757,"column_start":14,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":5955}],"docs":"","sig":null,"attributes":[]},{"id":2657,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1947271,"byte_end":1947282,"line_start":782,"line_end":782,"column_start":38,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":5959},{"krate":0,"index":5960},{"krate":0,"index":5961}],"docs":"","sig":null,"attributes":[]},{"id":2658,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1950762,"byte_end":1950773,"line_start":863,"line_end":863,"column_start":45,"column_end":56},"value":"","parent":null,"children":[{"krate":0,"index":5965},{"krate":0,"index":5966}],"docs":"","sig":null,"attributes":[]},{"id":2659,"kind":"Inherent","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1957681,"byte_end":1957695,"line_start":1028,"line_end":1028,"column_start":6,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":5968},{"krate":0,"index":5969},{"krate":0,"index":5971},{"krate":0,"index":5972},{"krate":0,"index":5974},{"krate":0,"index":5976},{"krate":0,"index":5977}],"docs":"","sig":null,"attributes":[]},{"id":2660,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1971807,"byte_end":1971816,"line_start":1379,"line_end":1379,"column_start":25,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":5985},{"krate":0,"index":5986},{"krate":0,"index":5987},{"krate":0,"index":5988}],"docs":"","sig":null,"attributes":[]},{"id":2661,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1972160,"byte_end":1972174,"line_start":1393,"line_end":1393,"column_start":25,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":5991},{"krate":0,"index":5992},{"krate":0,"index":5993},{"krate":0,"index":5994}],"docs":"","sig":null,"attributes":[]},{"id":2662,"kind":"Inherent","span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1972674,"byte_end":1972683,"line_start":12,"line_end":12,"column_start":6,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":6005},{"krate":0,"index":6006},{"krate":0,"index":6007}],"docs":"","sig":null,"attributes":[]},{"id":2663,"kind":"Direct","span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1973546,"byte_end":1973565,"line_start":45,"line_end":45,"column_start":23,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":6013},{"krate":0,"index":6014}],"docs":"","sig":null,"attributes":[]},{"id":2664,"kind":"Direct","span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1976672,"byte_end":1976681,"line_start":140,"line_end":140,"column_start":23,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":6019}],"docs":"","sig":null,"attributes":[]},{"id":2665,"kind":"Direct","span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1977580,"byte_end":1977589,"line_start":166,"line_end":166,"column_start":21,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":6021}],"docs":"","sig":null,"attributes":[]},{"id":2667,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1783053,"byte_end":1783067,"line_start":150,"line_end":150,"column_start":23,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":6029}],"docs":"","sig":null,"attributes":[]},{"id":2668,"kind":"Inherent","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1784800,"byte_end":1784809,"line_start":208,"line_end":208,"column_start":6,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":6031},{"krate":0,"index":6032}],"docs":"","sig":null,"attributes":[]},{"id":2669,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1791933,"byte_end":1791942,"line_start":443,"line_end":443,"column_start":23,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":6039}],"docs":"","sig":null,"attributes":[]},{"id":2670,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1795684,"byte_end":1795689,"line_start":563,"line_end":563,"column_start":23,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":6052},{"krate":0,"index":6053},{"krate":0,"index":6055},{"krate":0,"index":6056},{"krate":0,"index":6057}],"docs":"","sig":null,"attributes":[]},{"id":2671,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1796897,"byte_end":1796902,"line_start":604,"line_end":604,"column_start":34,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":6060}],"docs":"","sig":null,"attributes":[]},{"id":2672,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1797269,"byte_end":1797274,"line_start":617,"line_end":617,"column_start":24,"column_end":29},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2673,"kind":"Inherent","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1797292,"byte_end":1797297,"line_start":619,"line_end":619,"column_start":10,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":6065}],"docs":"","sig":null,"attributes":[]},{"id":2674,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1798554,"byte_end":1798565,"line_start":661,"line_end":661,"column_start":23,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":6068},{"krate":0,"index":6069},{"krate":0,"index":6070},{"krate":0,"index":6071},{"krate":0,"index":6072}],"docs":"","sig":null,"attributes":[]},{"id":2675,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1799417,"byte_end":1799428,"line_start":696,"line_end":696,"column_start":34,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":6075}],"docs":"","sig":null,"attributes":[]},{"id":2676,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1799725,"byte_end":1799736,"line_start":707,"line_end":707,"column_start":24,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2677,"kind":"Inherent","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1799754,"byte_end":1799765,"line_start":709,"line_end":709,"column_start":10,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":6080}],"docs":"","sig":null,"attributes":[]},{"id":2678,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1800567,"byte_end":1800572,"line_start":733,"line_end":733,"column_start":19,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":6082},{"krate":0,"index":6083},{"krate":0,"index":6084},{"krate":0,"index":6085},{"krate":0,"index":6086},{"krate":0,"index":6087},{"krate":0,"index":6088},{"krate":0,"index":6090},{"krate":0,"index":6092},{"krate":0,"index":6094},{"krate":0,"index":6096}],"docs":"","sig":null,"attributes":[]},{"id":2679,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1801853,"byte_end":1801858,"line_start":794,"line_end":794,"column_start":30,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":6099},{"krate":0,"index":6100},{"krate":0,"index":6101}],"docs":"","sig":null,"attributes":[]},{"id":2680,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1802307,"byte_end":1802312,"line_start":814,"line_end":814,"column_start":28,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":6104},{"krate":0,"index":6105}],"docs":"","sig":null,"attributes":[]},{"id":2681,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1802542,"byte_end":1802547,"line_start":827,"line_end":827,"column_start":24,"column_end":29},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2682,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1802637,"byte_end":1802642,"line_start":830,"line_end":830,"column_start":28,"column_end":33},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2683,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1802702,"byte_end":1802707,"line_start":833,"line_end":833,"column_start":37,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":6109},{"krate":0,"index":6110}],"docs":"","sig":null,"attributes":[]},{"id":2684,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1809933,"byte_end":1809946,"line_start":1042,"line_end":1042,"column_start":41,"column_end":54},"value":"","parent":null,"children":[{"krate":0,"index":6124}],"docs":"","sig":null,"attributes":[]},{"id":2685,"kind":"Inherent","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1810386,"byte_end":1810399,"line_start":1054,"line_end":1054,"column_start":26,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":6128},{"krate":0,"index":6129},{"krate":0,"index":6130}],"docs":"","sig":null,"attributes":[]},{"id":2686,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1813459,"byte_end":1813473,"line_start":1159,"line_end":1159,"column_start":41,"column_end":55},"value":"","parent":null,"children":[{"krate":0,"index":6139}],"docs":"","sig":null,"attributes":[]},{"id":2687,"kind":"Inherent","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1813753,"byte_end":1813767,"line_start":1168,"line_end":1168,"column_start":26,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":6143},{"krate":0,"index":6144}],"docs":"","sig":null,"attributes":[]},{"id":2688,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1815037,"byte_end":1815057,"line_start":1215,"line_end":1215,"column_start":41,"column_end":61},"value":"","parent":null,"children":[{"krate":0,"index":6153}],"docs":"","sig":null,"attributes":[]},{"id":2689,"kind":"Inherent","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1815290,"byte_end":1815310,"line_start":1223,"line_end":1223,"column_start":26,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":6157},{"krate":0,"index":6159}],"docs":"","sig":null,"attributes":[]},{"id":2690,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1816584,"byte_end":1816599,"line_start":1266,"line_end":1266,"column_start":41,"column_end":56},"value":"","parent":null,"children":[{"krate":0,"index":6169}],"docs":"","sig":null,"attributes":[]},{"id":2691,"kind":"Inherent","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1816827,"byte_end":1816842,"line_start":1274,"line_end":1274,"column_start":26,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":6173},{"krate":0,"index":6175}],"docs":"","sig":null,"attributes":[]},{"id":2692,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1818390,"byte_end":1818395,"line_start":1324,"line_end":1324,"column_start":23,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":6179},{"krate":0,"index":6180},{"krate":0,"index":6181}],"docs":"","sig":null,"attributes":[]},{"id":2693,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1818696,"byte_end":1818701,"line_start":1339,"line_end":1339,"column_start":34,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":6184}],"docs":"","sig":null,"attributes":[]},{"id":2694,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1818877,"byte_end":1818882,"line_start":1347,"line_end":1347,"column_start":24,"column_end":29},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2695,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1819577,"byte_end":1819585,"line_start":1370,"line_end":1370,"column_start":23,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":6188},{"krate":0,"index":6189},{"krate":0,"index":6190}],"docs":"","sig":null,"attributes":[]},{"id":2696,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1819907,"byte_end":1819915,"line_start":1386,"line_end":1386,"column_start":34,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":6193}],"docs":"","sig":null,"attributes":[]},{"id":2697,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1820112,"byte_end":1820120,"line_start":1395,"line_end":1395,"column_start":24,"column_end":32},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2704,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1829328,"byte_end":1829337,"line_start":1657,"line_end":1657,"column_start":35,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":6228},{"krate":0,"index":6229},{"krate":0,"index":6230},{"krate":0,"index":6231},{"krate":0,"index":6232},{"krate":0,"index":6233},{"krate":0,"index":6234}],"docs":"","sig":null,"attributes":[]},{"id":2705,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1831199,"byte_end":1831204,"line_start":1721,"line_end":1721,"column_start":35,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":6236},{"krate":0,"index":6237},{"krate":0,"index":6238},{"krate":0,"index":6239},{"krate":0,"index":6240},{"krate":0,"index":6241},{"krate":0,"index":6243}],"docs":"","sig":null,"attributes":[]},{"id":2706,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1833997,"byte_end":1834004,"line_start":1790,"line_end":1790,"column_start":35,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":6245},{"krate":0,"index":6246},{"krate":0,"index":6247},{"krate":0,"index":6248},{"krate":0,"index":6249},{"krate":0,"index":6250},{"krate":0,"index":6252}],"docs":"","sig":null,"attributes":[]},{"id":2707,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1836329,"byte_end":1836338,"line_start":1851,"line_end":1851,"column_start":35,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":6254},{"krate":0,"index":6255},{"krate":0,"index":6256},{"krate":0,"index":6257},{"krate":0,"index":6258},{"krate":0,"index":6259},{"krate":0,"index":6261}],"docs":"","sig":null,"attributes":[]},{"id":2708,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1838924,"byte_end":1838938,"line_start":1914,"line_end":1914,"column_start":35,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":6263},{"krate":0,"index":6264},{"krate":0,"index":6265},{"krate":0,"index":6266},{"krate":0,"index":6267},{"krate":0,"index":6268},{"krate":0,"index":6269}],"docs":"","sig":null,"attributes":[]},{"id":2709,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1840878,"byte_end":1840894,"line_start":1961,"line_end":1961,"column_start":35,"column_end":51},"value":"","parent":null,"children":[{"krate":0,"index":6271},{"krate":0,"index":6272},{"krate":0,"index":6273},{"krate":0,"index":6274},{"krate":0,"index":6275},{"krate":0,"index":6276},{"krate":0,"index":6277}],"docs":"","sig":null,"attributes":[]},{"id":2712,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1914327,"byte_end":1914342,"line_start":4232,"line_end":4232,"column_start":23,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":6402},{"krate":0,"index":6403},{"krate":0,"index":6404}],"docs":"","sig":null,"attributes":[]},{"id":2713,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1914662,"byte_end":1914677,"line_start":4247,"line_end":4247,"column_start":34,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":6407}],"docs":"","sig":null,"attributes":[]},{"id":2714,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1914857,"byte_end":1914872,"line_start":4255,"line_end":4255,"column_start":24,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2715,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1914967,"byte_end":1914987,"line_start":4258,"line_end":4258,"column_start":23,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":6411},{"krate":0,"index":6412},{"krate":0,"index":6413}],"docs":"","sig":null,"attributes":[]},{"id":2716,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1915314,"byte_end":1915334,"line_start":4273,"line_end":4273,"column_start":34,"column_end":54},"value":"","parent":null,"children":[{"krate":0,"index":6416}],"docs":"","sig":null,"attributes":[]},{"id":2717,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1915531,"byte_end":1915551,"line_start":4281,"line_end":4281,"column_start":24,"column_end":44},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2718,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1916113,"byte_end":1916124,"line_start":4300,"line_end":4300,"column_start":21,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":6419}],"docs":"","sig":null,"attributes":[]},{"id":2719,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1916314,"byte_end":1916325,"line_start":4307,"line_end":4307,"column_start":23,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":6422},{"krate":0,"index":6423},{"krate":0,"index":6426}],"docs":"","sig":null,"attributes":[]},{"id":2720,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1917171,"byte_end":1917182,"line_start":4339,"line_end":4339,"column_start":24,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2721,"kind":"Inherent","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2003261,"byte_end":2003270,"line_start":134,"line_end":134,"column_start":6,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":6444},{"krate":0,"index":6445}],"docs":"","sig":null,"attributes":[]},{"id":2722,"kind":"Inherent","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2004055,"byte_end":2004066,"line_start":156,"line_end":156,"column_start":6,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":6447},{"krate":0,"index":6448}],"docs":"","sig":null,"attributes":[]},{"id":2723,"kind":"Inherent","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2004878,"byte_end":2004884,"line_start":178,"line_end":178,"column_start":14,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":6451},{"krate":0,"index":6452},{"krate":0,"index":6453}],"docs":"","sig":null,"attributes":[]},{"id":2724,"kind":"Direct","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2006974,"byte_end":2006983,"line_start":242,"line_end":242,"column_start":24,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":6455},{"krate":0,"index":6456}],"docs":"","sig":null,"attributes":[]},{"id":2725,"kind":"Direct","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2007241,"byte_end":2007252,"line_start":255,"line_end":255,"column_start":24,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":6458},{"krate":0,"index":6459}],"docs":"","sig":null,"attributes":[]},{"id":2726,"kind":"Direct","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2007458,"byte_end":2007464,"line_start":267,"line_end":267,"column_start":32,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":6462},{"krate":0,"index":6463},{"krate":0,"index":6464},{"krate":0,"index":6465}],"docs":"","sig":null,"attributes":[]},{"id":2727,"kind":"Direct","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2009353,"byte_end":2009359,"line_start":340,"line_end":340,"column_start":24,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":6468}],"docs":"","sig":null,"attributes":[]},{"id":2728,"kind":"Direct","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2009684,"byte_end":2009690,"line_start":355,"line_end":355,"column_start":26,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":6471}],"docs":"","sig":null,"attributes":[]},{"id":2729,"kind":"Direct","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2010014,"byte_end":2010025,"line_start":372,"line_end":372,"column_start":14,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":6476},{"krate":0,"index":6477}],"docs":"","sig":null,"attributes":[]},{"id":2730,"kind":"Direct","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2010317,"byte_end":2010328,"line_start":389,"line_end":389,"column_start":14,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":6479},{"krate":0,"index":6480}],"docs":"","sig":null,"attributes":[]},{"id":2731,"kind":"Direct","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1992888,"byte_end":1992906,"line_start":502,"line_end":502,"column_start":24,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":6526}],"docs":"","sig":null,"attributes":[]},{"id":2732,"kind":"Direct","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1993115,"byte_end":1993133,"line_start":509,"line_end":509,"column_start":43,"column_end":61},"value":"","parent":null,"children":[{"krate":0,"index":6529},{"krate":0,"index":6530}],"docs":"","sig":null,"attributes":[]},{"id":2733,"kind":"Direct","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1993296,"byte_end":1993314,"line_start":518,"line_end":518,"column_start":19,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":6533}],"docs":"","sig":null,"attributes":[]},{"id":2734,"kind":"Direct","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1993497,"byte_end":1993515,"line_start":525,"line_end":525,"column_start":21,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":6536}],"docs":"","sig":null,"attributes":[]},{"id":2735,"kind":"Direct","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1993701,"byte_end":1993719,"line_start":532,"line_end":532,"column_start":23,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":6539}],"docs":"","sig":null,"attributes":[]},{"id":2736,"kind":"Direct","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1993878,"byte_end":1993896,"line_start":539,"line_end":539,"column_start":16,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2740,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2094709,"byte_end":2094719,"line_start":8,"line_end":8,"column_start":10,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":6668}],"docs":"","sig":null,"attributes":[]},{"id":2741,"kind":"Direct","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2095080,"byte_end":2095090,"line_start":21,"line_end":21,"column_start":21,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":6673}],"docs":"","sig":null,"attributes":[]},{"id":2742,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2097156,"byte_end":2097167,"line_start":99,"line_end":99,"column_start":18,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":6686},{"krate":0,"index":6688},{"krate":0,"index":6690}],"docs":"","sig":null,"attributes":[]},{"id":2743,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2101707,"byte_end":2101717,"line_start":250,"line_end":250,"column_start":18,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":6704},{"krate":0,"index":6706},{"krate":0,"index":6708}],"docs":"","sig":null,"attributes":[]},{"id":2744,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2104500,"byte_end":2104510,"line_start":344,"line_end":344,"column_start":18,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":6718},{"krate":0,"index":6720}],"docs":"","sig":null,"attributes":[]},{"id":2745,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2106451,"byte_end":2106459,"line_start":416,"line_end":416,"column_start":18,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":6731},{"krate":0,"index":6732},{"krate":0,"index":6735}],"docs":"","sig":null,"attributes":[]},{"id":2746,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2110228,"byte_end":2110237,"line_start":553,"line_end":553,"column_start":18,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":6747},{"krate":0,"index":6748},{"krate":0,"index":6751}],"docs":"","sig":null,"attributes":[]},{"id":2747,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2114039,"byte_end":2114047,"line_start":690,"line_end":690,"column_start":18,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":6765},{"krate":0,"index":6767},{"krate":0,"index":6771},{"krate":0,"index":6773}],"docs":"","sig":null,"attributes":[]},{"id":2748,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2019312,"byte_end":2019322,"line_start":269,"line_end":269,"column_start":10,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":6808},{"krate":0,"index":6809},{"krate":0,"index":6812},{"krate":0,"index":6813}],"docs":"","sig":null,"attributes":[]},{"id":2749,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2020505,"byte_end":2020514,"line_start":308,"line_end":308,"column_start":10,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":6816},{"krate":0,"index":6817},{"krate":0,"index":6818}],"docs":"","sig":null,"attributes":[]},{"id":2750,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2024500,"byte_end":2024509,"line_start":408,"line_end":408,"column_start":16,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":6821}],"docs":"","sig":null,"attributes":[]},{"id":2751,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2024675,"byte_end":2024684,"line_start":415,"line_end":415,"column_start":18,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":6823}],"docs":"","sig":null,"attributes":[]},{"id":2752,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2041468,"byte_end":2041479,"line_start":1046,"line_end":1046,"column_start":6,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":6847},{"krate":0,"index":6848}],"docs":"","sig":null,"attributes":[]},{"id":2753,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2041786,"byte_end":2041795,"line_start":1060,"line_end":1060,"column_start":10,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":6851},{"krate":0,"index":6855},{"krate":0,"index":6856},{"krate":0,"index":6857},{"krate":0,"index":6859},{"krate":0,"index":6860},{"krate":0,"index":6861},{"krate":0,"index":6862},{"krate":0,"index":6866},{"krate":0,"index":6867},{"krate":0,"index":6868},{"krate":0,"index":6869},{"krate":0,"index":6870},{"krate":0,"index":6871},{"krate":0,"index":6872},{"krate":0,"index":6873},{"krate":0,"index":6874},{"krate":0,"index":6875},{"krate":0,"index":6876},{"krate":0,"index":6877},{"krate":0,"index":6878},{"krate":0,"index":6879},{"krate":0,"index":6881},{"krate":0,"index":6883},{"krate":0,"index":6885},{"krate":0,"index":6887}],"docs":"","sig":null,"attributes":[]},{"id":2754,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2070231,"byte_end":2070240,"line_start":1886,"line_end":1886,"column_start":16,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":6890},{"krate":0,"index":6891},{"krate":0,"index":6892}],"docs":"","sig":null,"attributes":[]},{"id":2755,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2070584,"byte_end":2070589,"line_start":1901,"line_end":1901,"column_start":18,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":6894}],"docs":"","sig":null,"attributes":[]},{"id":2762,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2076489,"byte_end":2076500,"line_start":2111,"line_end":2111,"column_start":27,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":6941}],"docs":"","sig":null,"attributes":[]},{"id":2763,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2076675,"byte_end":2076679,"line_start":2118,"line_end":2118,"column_start":33,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":6944}],"docs":"","sig":null,"attributes":[]},{"id":2764,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2076921,"byte_end":2076928,"line_start":2127,"line_end":2127,"column_start":35,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":6947}],"docs":"","sig":null,"attributes":[]},{"id":2765,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2077414,"byte_end":2077433,"line_start":2140,"line_end":2140,"column_start":32,"column_end":51},"value":"","parent":null,"children":[{"krate":0,"index":6951}],"docs":"","sig":null,"attributes":[]},{"id":2766,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2077839,"byte_end":2077842,"line_start":2155,"line_end":2155,"column_start":35,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":6954}],"docs":"","sig":null,"attributes":[]},{"id":2767,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2078025,"byte_end":2078031,"line_start":2162,"line_end":2162,"column_start":35,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":6957}],"docs":"","sig":null,"attributes":[]},{"id":2768,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2078233,"byte_end":2078243,"line_start":2169,"line_end":2169,"column_start":35,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":6960}],"docs":"","sig":null,"attributes":[]},{"id":2769,"kind":"Inherent","span":{"file_name":"src/libcore/time.rs","byte_start":2120615,"byte_end":2120623,"line_start":60,"line_end":60,"column_start":6,"column_end":14},"value":"","parent":null,"children":[{"krate":0,"index":6981},{"krate":0,"index":6982},{"krate":0,"index":6983},{"krate":0,"index":6984},{"krate":0,"index":6985},{"krate":0,"index":37151},{"krate":0,"index":37150},{"krate":0,"index":37149},{"krate":0,"index":37148},{"krate":0,"index":6986},{"krate":0,"index":6987},{"krate":0,"index":6988},{"krate":0,"index":6989},{"krate":0,"index":6990},{"krate":0,"index":6991},{"krate":0,"index":6992},{"krate":0,"index":6993},{"krate":0,"index":6994},{"krate":0,"index":6995},{"krate":0,"index":6997},{"krate":0,"index":6998},{"krate":0,"index":6999},{"krate":0,"index":7000},{"krate":0,"index":7002},{"krate":0,"index":7004},{"krate":0,"index":7005},{"krate":0,"index":7006},{"krate":0,"index":7007},{"krate":0,"index":7008},{"krate":0,"index":7009}],"docs":"","sig":null,"attributes":[]},{"id":2770,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2142650,"byte_end":2142658,"line_start":732,"line_end":732,"column_start":14,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":7011},{"krate":0,"index":7012}],"docs":"","sig":null,"attributes":[]},{"id":2771,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2142901,"byte_end":2142909,"line_start":741,"line_end":741,"column_start":20,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":7014}],"docs":"","sig":null,"attributes":[]},{"id":2772,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2143058,"byte_end":2143066,"line_start":748,"line_end":748,"column_start":14,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":7016},{"krate":0,"index":7017}],"docs":"","sig":null,"attributes":[]},{"id":2773,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2143314,"byte_end":2143322,"line_start":757,"line_end":757,"column_start":20,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":7019}],"docs":"","sig":null,"attributes":[]},{"id":2774,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2143476,"byte_end":2143484,"line_start":764,"line_end":764,"column_start":19,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":7021},{"krate":0,"index":7022}],"docs":"","sig":null,"attributes":[]},{"id":2776,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2143941,"byte_end":2143949,"line_start":782,"line_end":782,"column_start":25,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":7027}],"docs":"","sig":null,"attributes":[]},{"id":2777,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2144098,"byte_end":2144106,"line_start":789,"line_end":789,"column_start":19,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":7029},{"krate":0,"index":7030}],"docs":"","sig":null,"attributes":[]},{"id":2778,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2144372,"byte_end":2144380,"line_start":798,"line_end":798,"column_start":25,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":7032}],"docs":"","sig":null,"attributes":[]},{"id":2779,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2145594,"byte_end":2145602,"line_start":835,"line_end":835,"column_start":14,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":7035}],"docs":"","sig":null,"attributes":[]},{"id":2780,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2145790,"byte_end":2145798,"line_start":842,"line_end":842,"column_start":32,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":7039}],"docs":"","sig":null,"attributes":[]},{"id":2781,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2145986,"byte_end":2145994,"line_start":849,"line_end":849,"column_start":21,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":7042}],"docs":"","sig":null,"attributes":[]},{"id":2782,"kind":"Inherent","span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2153188,"byte_end":2153196,"line_start":33,"line_end":33,"column_start":6,"column_end":14},"value":"","parent":null,"children":[{"krate":0,"index":7059}],"docs":"","sig":null,"attributes":[]},{"id":2783,"kind":"Inherent","span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2153866,"byte_end":2153879,"line_start":54,"line_end":54,"column_start":6,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":7064}],"docs":"","sig":null,"attributes":[]},{"id":2784,"kind":"Direct","span":{"file_name":"src/libcore/future/future.rs","byte_start":2400040,"byte_end":2400043,"line_start":110,"line_end":110,"column_start":20,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":7148},{"krate":0,"index":7149}],"docs":"","sig":null,"attributes":[]},{"id":2785,"kind":"Inherent","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2401588,"byte_end":2401592,"line_start":28,"line_end":28,"column_start":9,"column_end":13},"value":"","parent":null,"children":[{"krate":0,"index":7157},{"krate":0,"index":7160},{"krate":0,"index":7161}],"docs":"","sig":null,"attributes":[]},{"id":2786,"kind":"Inherent","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2402414,"byte_end":2402418,"line_start":58,"line_end":58,"column_start":12,"column_end":16},"value":"","parent":null,"children":[{"krate":0,"index":7165},{"krate":0,"index":7168}],"docs":"","sig":null,"attributes":[]},{"id":2787,"kind":"Direct","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2403357,"byte_end":2403361,"line_start":85,"line_end":85,"column_start":21,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":7173}],"docs":"","sig":null,"attributes":[]},{"id":2788,"kind":"Direct","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2403502,"byte_end":2403506,"line_start":92,"line_end":92,"column_start":20,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":7177},{"krate":0,"index":7178},{"krate":0,"index":7179},{"krate":0,"index":7180},{"krate":0,"index":7181}],"docs":"","sig":null,"attributes":[]},{"id":2789,"kind":"Direct","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2404068,"byte_end":2404072,"line_start":117,"line_end":117,"column_start":20,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":7185},{"krate":0,"index":7186},{"krate":0,"index":7187},{"krate":0,"index":7188},{"krate":0,"index":7189}],"docs":"","sig":null,"attributes":[]},{"id":2790,"kind":"Inherent","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2405733,"byte_end":2405741,"line_start":28,"line_end":28,"column_start":6,"column_end":14},"value":"","parent":null,"children":[{"krate":0,"index":37147}],"docs":"","sig":null,"attributes":[]},{"id":2791,"kind":"Inherent","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2409128,"byte_end":2409142,"line_start":108,"line_end":108,"column_start":6,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":37146}],"docs":"","sig":null,"attributes":[]},{"id":2792,"kind":"Inherent","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2412095,"byte_end":2412102,"line_start":186,"line_end":186,"column_start":10,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":7205},{"krate":0,"index":7206}],"docs":"","sig":null,"attributes":[]},{"id":2793,"kind":"Direct","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2412643,"byte_end":2412650,"line_start":206,"line_end":206,"column_start":21,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":7208}],"docs":"","sig":null,"attributes":[]},{"id":2794,"kind":"Direct","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2413328,"byte_end":2413333,"line_start":230,"line_end":230,"column_start":16,"column_end":21},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2795,"kind":"Direct","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2413411,"byte_end":2413416,"line_start":232,"line_end":232,"column_start":22,"column_end":27},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2796,"kind":"Direct","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2413494,"byte_end":2413499,"line_start":234,"line_end":234,"column_start":22,"column_end":27},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2797,"kind":"Inherent","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2413509,"byte_end":2413514,"line_start":236,"line_end":236,"column_start":6,"column_end":11},"value":"","parent":null,"children":[{"krate":0,"index":7215},{"krate":0,"index":7216},{"krate":0,"index":7217},{"krate":0,"index":7218}],"docs":"","sig":null,"attributes":[]},{"id":2798,"kind":"Direct","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2416085,"byte_end":2416090,"line_start":301,"line_end":301,"column_start":16,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":7220}],"docs":"","sig":null,"attributes":[]},{"id":2799,"kind":"Direct","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2416533,"byte_end":2416538,"line_start":314,"line_end":314,"column_start":15,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":7222}],"docs":"","sig":null,"attributes":[]},{"id":2800,"kind":"Direct","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2416928,"byte_end":2416933,"line_start":325,"line_end":325,"column_start":21,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":7224}],"docs":"","sig":null,"attributes":[]},{"id":2801,"kind":"Inherent","span":{"file_name":"src/libcore/alloc.rs","byte_start":2418991,"byte_end":2418997,"line_start":52,"line_end":52,"column_start":6,"column_end":12},"value":"","parent":null,"children":[{"krate":0,"index":7242},{"krate":0,"index":7243},{"krate":0,"index":7244},{"krate":0,"index":7245},{"krate":0,"index":7246},{"krate":0,"index":7248},{"krate":0,"index":7250},{"krate":0,"index":7251},{"krate":0,"index":7252},{"krate":0,"index":7253},{"krate":0,"index":7254},{"krate":0,"index":7255},{"krate":0,"index":7256},{"krate":0,"index":7257}],"docs":"","sig":null,"attributes":[]},{"id":2802,"kind":"Direct","span":{"file_name":"src/libcore/alloc.rs","byte_start":2431164,"byte_end":2431173,"line_start":340,"line_end":340,"column_start":23,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":7261}],"docs":"","sig":null,"attributes":[]},{"id":2803,"kind":"Direct","span":{"file_name":"src/libcore/alloc.rs","byte_start":2431757,"byte_end":2431765,"line_start":356,"line_end":356,"column_start":23,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":7263}],"docs":"","sig":null,"attributes":[]},{"id":2804,"kind":"Inherent","span":{"file_name":"src/libcore/alloc.rs","byte_start":2432241,"byte_end":2432261,"line_start":370,"line_end":370,"column_start":6,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":7265}],"docs":"","sig":null,"attributes":[]},{"id":2805,"kind":"Direct","span":{"file_name":"src/libcore/alloc.rs","byte_start":2432500,"byte_end":2432520,"line_start":378,"line_end":378,"column_start":23,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":7267}],"docs":"","sig":null,"attributes":[]},{"id":2806,"kind":"Direct","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2511889,"byte_end":2511896,"line_start":400,"line_end":400,"column_start":19,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":7469}],"docs":"","sig":null,"attributes":[]},{"id":2807,"kind":"Direct","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2513138,"byte_end":2513145,"line_start":453,"line_end":453,"column_start":19,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":7481}],"docs":"","sig":null,"attributes":[]},{"id":2808,"kind":"Direct","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2513517,"byte_end":2513524,"line_start":471,"line_end":471,"column_start":19,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":7486}],"docs":"","sig":null,"attributes":[]}],"refs":[{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5362,"byte_end":5367,"line_start":148,"line_end":148,"column_start":34,"column_end":39},"ref_id":{"krate":0,"index":34}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5402,"byte_end":5404,"line_start":149,"line_end":149,"column_start":34,"column_end":36},"ref_id":{"krate":0,"index":35}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5439,"byte_end":5442,"line_start":150,"line_end":150,"column_start":34,"column_end":37},"ref_id":{"krate":0,"index":36}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5477,"byte_end":5480,"line_start":151,"line_end":151,"column_start":34,"column_end":37},"ref_id":{"krate":0,"index":37}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5515,"byte_end":5518,"line_start":152,"line_end":152,"column_start":34,"column_end":37},"ref_id":{"krate":0,"index":38}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5553,"byte_end":5557,"line_start":153,"line_end":153,"column_start":34,"column_end":38},"ref_id":{"krate":0,"index":39}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5593,"byte_end":5598,"line_start":155,"line_end":155,"column_start":34,"column_end":39},"ref_id":{"krate":0,"index":40}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5633,"byte_end":5635,"line_start":156,"line_end":156,"column_start":34,"column_end":36},"ref_id":{"krate":0,"index":41}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5670,"byte_end":5673,"line_start":157,"line_end":157,"column_start":34,"column_end":37},"ref_id":{"krate":0,"index":42}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5708,"byte_end":5711,"line_start":158,"line_end":158,"column_start":34,"column_end":37},"ref_id":{"krate":0,"index":43}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5746,"byte_end":5749,"line_start":159,"line_end":159,"column_start":34,"column_end":37},"ref_id":{"krate":0,"index":44}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5784,"byte_end":5788,"line_start":160,"line_end":160,"column_start":34,"column_end":38},"ref_id":{"krate":0,"index":45}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5824,"byte_end":5827,"line_start":162,"line_end":162,"column_start":34,"column_end":37},"ref_id":{"krate":0,"index":46}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5862,"byte_end":5865,"line_start":163,"line_end":163,"column_start":34,"column_end":37},"ref_id":{"krate":0,"index":102}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5889,"byte_end":5892,"line_start":166,"line_end":166,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":159}},{"kind":"Mod","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78687,"byte_end":78694,"line_start":211,"line_end":211,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":190}},{"kind":"Mod","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":246271,"byte_end":246280,"line_start":126,"line_end":126,"column_start":9,"column_end":18},"ref_id":{"krate":0,"index":197}},{"kind":"Mod","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":246290,"byte_end":246297,"line_start":127,"line_end":127,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":199}},{"kind":"Mod","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":246364,"byte_end":246370,"line_start":131,"line_end":131,"column_start":13,"column_end":19},"ref_id":{"krate":0,"index":214}},{"kind":"Mod","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":246384,"byte_end":246389,"line_start":132,"line_end":132,"column_start":13,"column_end":18},"ref_id":{"krate":0,"index":243}},{"kind":"Mod","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78704,"byte_end":78711,"line_start":212,"line_end":212,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":307}},{"kind":"Mod","span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":323671,"byte_end":323676,"line_start":96,"line_end":96,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":379}},{"kind":"Mod","span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":323686,"byte_end":323691,"line_start":97,"line_end":97,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":481}},{"kind":"Mod","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78721,"byte_end":78727,"line_start":213,"line_end":213,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":512}},{"kind":"Mod","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78737,"byte_end":78746,"line_start":214,"line_end":214,"column_start":9,"column_end":18},"ref_id":{"krate":0,"index":526}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5977,"byte_end":5984,"line_start":170,"line_end":170,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":627}},{"kind":"Mod","span":{"file_name":"src/libcore/prelude/mod.rs","byte_start":442842,"byte_end":442844,"line_start":5,"line_end":5,"column_start":9,"column_end":11},"ref_id":{"krate":0,"index":628}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6040,"byte_end":6050,"line_start":174,"line_end":174,"column_start":9,"column_end":19},"ref_id":{"krate":0,"index":668}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6060,"byte_end":6063,"line_start":175,"line_end":175,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":1027}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6073,"byte_end":6076,"line_start":176,"line_end":176,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":1134}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6086,"byte_end":6090,"line_start":177,"line_end":177,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":1426}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6129,"byte_end":6135,"line_start":181,"line_end":181,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":1432}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6145,"byte_end":6148,"line_start":182,"line_end":182,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":1491}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6158,"byte_end":6161,"line_start":183,"line_end":183,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":1934}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6171,"byte_end":6176,"line_start":184,"line_end":184,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":2055}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6186,"byte_end":6193,"line_start":185,"line_end":185,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":2079}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6203,"byte_end":6210,"line_start":186,"line_end":186,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":2083}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6220,"byte_end":6226,"line_start":187,"line_end":187,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":2159}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6281,"byte_end":6284,"line_start":191,"line_end":191,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":2181}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6294,"byte_end":6299,"line_start":192,"line_end":192,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":2219}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6309,"byte_end":6314,"line_start":193,"line_end":193,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":2254}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6324,"byte_end":6328,"line_start":194,"line_end":194,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":2276}},{"kind":"Mod","span":{"file_name":"src/libcore/sync/mod.rs","byte_start":942625,"byte_end":942631,"line_start":5,"line_end":5,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":2277}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6338,"byte_end":6342,"line_start":195,"line_end":195,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":2373}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6352,"byte_end":6356,"line_start":196,"line_end":196,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":2608}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6366,"byte_end":6371,"line_start":197,"line_end":197,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":2778}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6381,"byte_end":6390,"line_start":198,"line_end":198,"column_start":9,"column_end":18},"ref_id":{"krate":0,"index":2803}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6400,"byte_end":6403,"line_start":199,"line_end":199,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":2813}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6413,"byte_end":6417,"line_start":200,"line_end":200,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":2895}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6427,"byte_end":6433,"line_start":201,"line_end":201,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":4426}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6443,"byte_end":6446,"line_start":202,"line_end":202,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":4640}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6456,"byte_end":6462,"line_start":203,"line_end":203,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":4641}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6472,"byte_end":6475,"line_start":204,"line_end":204,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":4820}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6486,"byte_end":6491,"line_start":206,"line_end":206,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":4873}},{"kind":"Mod","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1564185,"byte_end":1564191,"line_start":43,"line_end":43,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":4907}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6501,"byte_end":6504,"line_start":207,"line_end":207,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":5810}},{"kind":"Mod","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1779014,"byte_end":1779021,"line_start":21,"line_end":21,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":5838}},{"kind":"Mod","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1779107,"byte_end":1779112,"line_start":25,"line_end":25,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":5995}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6514,"byte_end":6518,"line_start":208,"line_end":208,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":6430}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6528,"byte_end":6531,"line_start":209,"line_end":209,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":6581}},{"kind":"Mod","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2011770,"byte_end":2011772,"line_start":40,"line_end":40,"column_start":13,"column_end":15},"ref_id":{"krate":0,"index":6781}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6541,"byte_end":6545,"line_start":210,"line_end":210,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":6961}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6556,"byte_end":6563,"line_start":212,"line_end":212,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":7046}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6586,"byte_end":6592,"line_start":215,"line_end":215,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":7131}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6602,"byte_end":6606,"line_start":216,"line_end":216,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":7151}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6674,"byte_end":6679,"line_start":220,"line_end":220,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":7230}}],"macro_refs":[],"relations":[{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":77487,"byte_end":77495,"line_start":169,"line_end":169,"column_start":36,"column_end":44},"kind":{"Impl":{"id":26}},"from":{"krate":0,"index":10154},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":77692,"byte_end":77700,"line_start":176,"line_end":176,"column_start":40,"column_end":48},"kind":{"Impl":{"id":27}},"from":{"krate":0,"index":10154},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":77891,"byte_end":77899,"line_start":183,"line_end":183,"column_start":38,"column_end":46},"kind":{"Impl":{"id":28}},"from":{"krate":0,"index":10154},"to":{"krate":0,"index":6830}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":78088,"byte_end":78096,"line_start":190,"line_end":190,"column_start":36,"column_end":44},"kind":{"Impl":{"id":29}},"from":{"krate":0,"index":10154},"to":{"krate":0,"index":6828}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":78291,"byte_end":78299,"line_start":197,"line_end":197,"column_start":42,"column_end":50},"kind":{"Impl":{"id":30}},"from":{"krate":0,"index":10154},"to":{"krate":0,"index":6832}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":78494,"byte_end":78502,"line_start":204,"line_end":204,"column_start":42,"column_end":50},"kind":{"Impl":{"id":31}},"from":{"krate":0,"index":10154},"to":{"krate":0,"index":6834}},{"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":270710,"byte_end":270718,"line_start":44,"line_end":44,"column_start":27,"column_end":35},"kind":"SuperTrait","from":{"krate":0,"index":409},"to":{"krate":0,"index":205}},{"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":270721,"byte_end":270725,"line_start":44,"line_end":44,"column_start":38,"column_end":42},"kind":"SuperTrait","from":{"krate":0,"index":1445},"to":{"krate":0,"index":205}},{"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":247721,"byte_end":247725,"line_start":174,"line_end":174,"column_start":10,"column_end":14},"kind":{"Impl":{"id":34}},"from":{"krate":0,"index":10223},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":249458,"byte_end":249467,"line_start":223,"line_end":223,"column_start":10,"column_end":19},"kind":{"Impl":{"id":35}},"from":{"krate":0,"index":10249},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":376511,"byte_end":376519,"line_start":36,"line_end":36,"column_start":6,"column_end":14},"kind":{"Impl":{"id":36}},"from":{"krate":0,"index":10274},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":376893,"byte_end":376897,"line_start":48,"line_end":48,"column_start":7,"column_end":11},"kind":"SuperTrait","from":{"krate":0,"index":1445},"to":{"krate":0,"index":409}},{"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":376904,"byte_end":376909,"line_start":49,"line_end":49,"column_start":7,"column_end":12},"kind":"SuperTrait","from":{"krate":0,"index":6824},"to":{"krate":0,"index":409}},{"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":376916,"byte_end":376924,"line_start":50,"line_end":50,"column_start":7,"column_end":15},"kind":"SuperTrait","from":{"krate":0,"index":6838},"to":{"krate":0,"index":409}},{"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":376931,"byte_end":376934,"line_start":51,"line_end":51,"column_start":7,"column_end":10},"kind":"SuperTrait","from":{"krate":0,"index":1503},"to":{"krate":0,"index":409}},{"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":376954,"byte_end":376957,"line_start":52,"line_end":52,"column_start":7,"column_end":10},"kind":"SuperTrait","from":{"krate":0,"index":1508},"to":{"krate":0,"index":409}},{"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":376977,"byte_end":376980,"line_start":53,"line_end":53,"column_start":7,"column_end":10},"kind":"SuperTrait","from":{"krate":0,"index":1520},"to":{"krate":0,"index":409}},{"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":389641,"byte_end":389648,"line_start":31,"line_end":31,"column_start":10,"column_end":17},"kind":{"Impl":{"id":39}},"from":{"krate":0,"index":10309},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":326442,"byte_end":326457,"line_start":183,"line_end":183,"column_start":6,"column_end":21},"kind":{"Impl":{"id":42}},"from":{"krate":0,"index":10351},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":326983,"byte_end":326998,"line_start":198,"line_end":198,"column_start":23,"column_end":38},"kind":{"Impl":{"id":43}},"from":{"krate":0,"index":10351},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":393853,"byte_end":393858,"line_start":24,"line_end":24,"column_start":20,"column_end":25},"kind":"SuperTrait","from":{"krate":0,"index":1442},"to":{"krate":0,"index":515}},{"span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":413013,"byte_end":413015,"line_start":20,"line_end":20,"column_start":6,"column_end":8},"kind":{"Impl":{"id":47}},"from":{"krate":0,"index":10512},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":219387,"byte_end":219402,"line_start":4675,"line_end":4675,"column_start":6,"column_end":21},"kind":{"Impl":{"id":72}},"from":{"krate":0,"index":13630},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":219813,"byte_end":219828,"line_start":4687,"line_end":4687,"column_start":23,"column_end":38},"kind":{"Impl":{"id":73}},"from":{"krate":0,"index":13630},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":220019,"byte_end":220034,"line_start":4694,"line_end":4694,"column_start":27,"column_end":42},"kind":{"Impl":{"id":74}},"from":{"krate":0,"index":13630},"to":{"krate":0,"index":2096}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":220183,"byte_end":220198,"line_start":4701,"line_end":4701,"column_start":18,"column_end":33},"kind":{"Impl":{"id":75}},"from":{"krate":0,"index":13630},"to":{"krate":0,"index":2096}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":227308,"byte_end":227318,"line_start":4911,"line_end":4911,"column_start":27,"column_end":37},"kind":"SuperTrait","from":{"krate":0,"index":1970},"to":{"krate":0,"index":607}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":227321,"byte_end":227325,"line_start":4911,"line_end":4911,"column_start":40,"column_end":44},"kind":"SuperTrait","from":{"krate":0,"index":1445},"to":{"krate":0,"index":607}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":232381,"byte_end":232394,"line_start":5058,"line_end":5058,"column_start":6,"column_end":19},"kind":{"Impl":{"id":185}},"from":{"krate":0,"index":14018},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":233515,"byte_end":233528,"line_start":5084,"line_end":5084,"column_start":23,"column_end":36},"kind":{"Impl":{"id":186}},"from":{"krate":0,"index":14018},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":547774,"byte_end":547786,"line_start":56,"line_end":56,"column_start":9,"column_end":21},"kind":{"Impl":{"id":245}},"from":{"krate":0,"index":14164},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":549768,"byte_end":549780,"line_start":112,"line_end":112,"column_start":17,"column_end":29},"kind":{"Impl":{"id":246}},"from":{"krate":0,"index":14164},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":550524,"byte_end":550536,"line_start":132,"line_end":132,"column_start":27,"column_end":39},"kind":{"Impl":{"id":247}},"from":{"krate":0,"index":14164},"to":{"krate":0,"index":1601}},{"span":{"file_name":"src/libcore/mem/manually_drop.rs","byte_start":550726,"byte_end":550738,"line_start":141,"line_end":141,"column_start":30,"column_end":42},"kind":{"Impl":{"id":248}},"from":{"krate":0,"index":14164},"to":{"krate":0,"index":1612}},{"span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":559918,"byte_end":559929,"line_start":217,"line_end":217,"column_start":25,"column_end":36},"kind":{"Impl":{"id":249}},"from":{"krate":0,"index":14199},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/mem/maybe_uninit.rs","byte_start":560109,"byte_end":560120,"line_start":225,"line_end":225,"column_start":9,"column_end":20},"kind":{"Impl":{"id":250}},"from":{"krate":0,"index":14199},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":543721,"byte_end":543733,"line_start":746,"line_end":746,"column_start":18,"column_end":30},"kind":{"Impl":{"id":251}},"from":{"krate":0,"index":1110},"to":{"krate":0,"index":1445}},{"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":543826,"byte_end":543838,"line_start":749,"line_end":749,"column_start":26,"column_end":38},"kind":{"Impl":{"id":252}},"from":{"krate":0,"index":1110},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":543984,"byte_end":543996,"line_start":756,"line_end":756,"column_start":28,"column_end":40},"kind":{"Impl":{"id":253}},"from":{"krate":0,"index":1110},"to":{"krate":0,"index":1936}},{"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":544154,"byte_end":544166,"line_start":763,"line_end":763,"column_start":21,"column_end":33},"kind":{"Impl":{"id":254}},"from":{"krate":0,"index":1110},"to":{"krate":0,"index":1940}},{"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":544257,"byte_end":544269,"line_start":766,"line_end":766,"column_start":24,"column_end":36},"kind":{"Impl":{"id":255}},"from":{"krate":0,"index":1110},"to":{"krate":0,"index":6481}},{"span":{"file_name":"src/libcore/mem/mod.rs","byte_start":544448,"byte_end":544460,"line_start":773,"line_end":773,"column_start":24,"column_end":36},"kind":{"Impl":{"id":256}},"from":{"krate":0,"index":1110},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":673532,"byte_end":673539,"line_start":49,"line_end":49,"column_start":27,"column_end":34},"kind":{"Impl":{"id":257}},"from":{"krate":0,"index":1160},"to":{"krate":0,"index":1437}},{"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":673786,"byte_end":673793,"line_start":54,"line_end":54,"column_start":27,"column_end":34},"kind":{"Impl":{"id":258}},"from":{"krate":0,"index":1160},"to":{"krate":0,"index":1446}},{"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":673817,"byte_end":673824,"line_start":56,"line_end":56,"column_start":16,"column_end":23},"kind":{"Impl":{"id":259}},"from":{"krate":0,"index":1160},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":674527,"byte_end":674534,"line_start":76,"line_end":76,"column_start":17,"column_end":24},"kind":{"Impl":{"id":260}},"from":{"krate":0,"index":1160},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":676452,"byte_end":676459,"line_start":139,"line_end":139,"column_start":27,"column_end":34},"kind":{"Impl":{"id":261}},"from":{"krate":0,"index":1160},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":676606,"byte_end":676613,"line_start":147,"line_end":147,"column_start":26,"column_end":33},"kind":{"Impl":{"id":262}},"from":{"krate":0,"index":1160},"to":{"krate":0,"index":1445}},{"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":676736,"byte_end":676743,"line_start":150,"line_end":150,"column_start":58,"column_end":65},"kind":{"Impl":{"id":263}},"from":{"krate":0,"index":1160},"to":{"krate":0,"index":1827}},{"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":676886,"byte_end":676893,"line_start":153,"line_end":153,"column_start":60,"column_end":67},"kind":{"Impl":{"id":264}},"from":{"krate":0,"index":1160},"to":{"krate":0,"index":1864}},{"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":677001,"byte_end":677008,"line_start":156,"line_end":156,"column_start":32,"column_end":39},"kind":{"Impl":{"id":265}},"from":{"krate":0,"index":1160},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":677213,"byte_end":677220,"line_start":163,"line_end":163,"column_start":34,"column_end":41},"kind":{"Impl":{"id":266}},"from":{"krate":0,"index":1160},"to":{"krate":0,"index":6836}},{"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":677415,"byte_end":677422,"line_start":170,"line_end":170,"column_start":24,"column_end":31},"kind":{"Impl":{"id":267}},"from":{"krate":0,"index":1160},"to":{"krate":0,"index":1940}},{"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":677509,"byte_end":677516,"line_start":173,"line_end":173,"column_start":31,"column_end":38},"kind":{"Impl":{"id":268}},"from":{"krate":0,"index":1160},"to":{"krate":0,"index":1936}},{"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":677699,"byte_end":677706,"line_start":181,"line_end":181,"column_start":25,"column_end":32},"kind":{"Impl":{"id":269}},"from":{"krate":0,"index":1160},"to":{"krate":0,"index":1960}},{"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":677904,"byte_end":677911,"line_start":189,"line_end":189,"column_start":32,"column_end":39},"kind":{"Impl":{"id":270}},"from":{"krate":0,"index":1160},"to":{"krate":0,"index":1970}},{"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":678133,"byte_end":678140,"line_start":197,"line_end":197,"column_start":32,"column_end":39},"kind":{"Impl":{"id":271}},"from":{"krate":0,"index":1160},"to":{"krate":0,"index":6481}},{"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":678344,"byte_end":678351,"line_start":205,"line_end":205,"column_start":37,"column_end":44},"kind":{"Impl":{"id":272}},"from":{"krate":0,"index":1160},"to":{"krate":0,"index":2096}},{"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":678562,"byte_end":678569,"line_start":213,"line_end":213,"column_start":34,"column_end":41},"kind":{"Impl":{"id":273}},"from":{"krate":0,"index":1160},"to":{"krate":0,"index":2096}},{"span":{"file_name":"src/libcore/ptr/non_null.rs","byte_start":678777,"byte_end":678784,"line_start":221,"line_end":221,"column_start":30,"column_end":37},"kind":{"Impl":{"id":274}},"from":{"krate":0,"index":1160},"to":{"krate":0,"index":2096}},{"span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":681183,"byte_end":681189,"line_start":49,"line_end":49,"column_start":40,"column_end":46},"kind":{"Impl":{"id":275}},"from":{"krate":0,"index":1232},"to":{"krate":0,"index":1437}},{"span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":681517,"byte_end":681523,"line_start":56,"line_end":56,"column_start":40,"column_end":46},"kind":{"Impl":{"id":276}},"from":{"krate":0,"index":1232},"to":{"krate":0,"index":1446}},{"span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":681599,"byte_end":681605,"line_start":59,"line_end":59,"column_start":16,"column_end":22},"kind":{"Impl":{"id":277}},"from":{"krate":0,"index":1232},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":682328,"byte_end":682334,"line_start":79,"line_end":79,"column_start":17,"column_end":23},"kind":{"Impl":{"id":278}},"from":{"krate":0,"index":1232},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":683780,"byte_end":683786,"line_start":128,"line_end":128,"column_start":27,"column_end":33},"kind":{"Impl":{"id":279}},"from":{"krate":0,"index":1232},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":683936,"byte_end":683942,"line_start":136,"line_end":136,"column_start":26,"column_end":32},"kind":{"Impl":{"id":280}},"from":{"krate":0,"index":1232},"to":{"krate":0,"index":1445}},{"span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":684059,"byte_end":684065,"line_start":139,"line_end":139,"column_start":57,"column_end":63},"kind":{"Impl":{"id":281}},"from":{"krate":0,"index":1232},"to":{"krate":0,"index":1827}},{"span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":684203,"byte_end":684209,"line_start":142,"line_end":142,"column_start":59,"column_end":65},"kind":{"Impl":{"id":282}},"from":{"krate":0,"index":1232},"to":{"krate":0,"index":1864}},{"span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":684320,"byte_end":684326,"line_start":145,"line_end":145,"column_start":32,"column_end":38},"kind":{"Impl":{"id":283}},"from":{"krate":0,"index":1232},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":684534,"byte_end":684540,"line_start":152,"line_end":152,"column_start":34,"column_end":40},"kind":{"Impl":{"id":284}},"from":{"krate":0,"index":1232},"to":{"krate":0,"index":6836}},{"span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":684748,"byte_end":684754,"line_start":159,"line_end":159,"column_start":34,"column_end":40},"kind":{"Impl":{"id":285}},"from":{"krate":0,"index":1232},"to":{"krate":0,"index":2096}},{"span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":684986,"byte_end":684992,"line_start":167,"line_end":167,"column_start":30,"column_end":36},"kind":{"Impl":{"id":286}},"from":{"krate":0,"index":1232},"to":{"krate":0,"index":2096}},{"span":{"file_name":"src/libcore/ptr/unique.rs","byte_start":685234,"byte_end":685240,"line_start":175,"line_end":175,"column_start":42,"column_end":48},"kind":{"Impl":{"id":287}},"from":{"krate":0,"index":1232},"to":{"krate":0,"index":2096}},{"span":{"file_name":"src/libcore/marker.rs","byte_start":700942,"byte_end":700947,"line_start":287,"line_end":287,"column_start":18,"column_end":23},"kind":"SuperTrait","from":{"krate":0,"index":2056},"to":{"krate":0,"index":1445}},{"span":{"file_name":"src/libcore/marker.rs","byte_start":712086,"byte_end":712096,"line_start":591,"line_end":591,"column_start":29,"column_end":39},"kind":{"Impl":{"id":288}},"from":{"krate":0,"index":2586},"to":{"krate":0,"index":1460}},{"span":{"file_name":"src/libcore/marker.rs","byte_start":712137,"byte_end":712148,"line_start":592,"line_end":592,"column_start":35,"column_end":46},"kind":{"Impl":{"id":289}},"from":{"krate":0,"index":1452},"to":{"krate":0,"index":1460}},{"span":{"file_name":"src/libcore/marker.rs","byte_start":714576,"byte_end":714589,"line_start":650,"line_end":650,"column_start":17,"column_end":30},"kind":{"Impl":{"id":290}},"from":{"krate":0,"index":19100},"to":{"krate":0,"index":1473}},{"span":{"file_name":"src/libcore/ops/deref.rs","byte_start":777655,"byte_end":777660,"line_start":160,"line_end":160,"column_start":21,"column_end":26},"kind":"SuperTrait","from":{"krate":0,"index":1601},"to":{"krate":0,"index":1612}},{"span":{"file_name":"src/libcore/ops/function.rs","byte_start":783931,"byte_end":783936,"line_start":66,"line_end":66,"column_start":22,"column_end":27},"kind":"SuperTrait","from":{"krate":0,"index":1629},"to":{"krate":0,"index":1626}},{"span":{"file_name":"src/libcore/ops/function.rs","byte_start":786654,"byte_end":786660,"line_start":145,"line_end":145,"column_start":25,"column_end":31},"kind":"SuperTrait","from":{"krate":0,"index":1632},"to":{"krate":0,"index":1629}},{"span":{"file_name":"src/libcore/ops/generator.rs","byte_start":795954,"byte_end":795957,"line_start":117,"line_end":117,"column_start":43,"column_end":46},"kind":{"Impl":{"id":1916}},"from":{"krate":0,"index":32035},"to":{"krate":0,"index":1662}},{"span":{"file_name":"src/libcore/ops/index.rs","byte_start":801661,"byte_end":801666,"line_start":166,"line_end":166,"column_start":34,"column_end":39},"kind":"SuperTrait","from":{"krate":0,"index":1677},"to":{"krate":0,"index":1681}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":803185,"byte_end":803194,"line_start":47,"line_end":47,"column_start":21,"column_end":30},"kind":{"Impl":{"id":1917}},"from":{"krate":0,"index":26055},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":804425,"byte_end":804430,"line_start":86,"line_end":86,"column_start":38,"column_end":43},"kind":{"Impl":{"id":1918}},"from":{"krate":0,"index":26067},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":804640,"byte_end":804645,"line_start":95,"line_end":95,"column_start":28,"column_end":33},"kind":{"Impl":{"id":1919}},"from":{"krate":0,"index":26067},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":807503,"byte_end":807512,"line_start":188,"line_end":188,"column_start":38,"column_end":47},"kind":{"Impl":{"id":1920}},"from":{"krate":0,"index":26085},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":807694,"byte_end":807703,"line_start":196,"line_end":196,"column_start":28,"column_end":37},"kind":{"Impl":{"id":1921}},"from":{"krate":0,"index":26085},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":809979,"byte_end":809986,"line_start":272,"line_end":272,"column_start":38,"column_end":45},"kind":{"Impl":{"id":1922}},"from":{"krate":0,"index":26102},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":810166,"byte_end":810173,"line_start":280,"line_end":280,"column_start":28,"column_end":35},"kind":{"Impl":{"id":1923}},"from":{"krate":0,"index":26102},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":812428,"byte_end":812433,"line_start":347,"line_end":347,"column_start":31,"column_end":36},"kind":"SuperTrait","from":{"krate":0,"index":1442},"to":{"krate":0,"index":1713}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":812543,"byte_end":812544,"line_start":351,"line_end":351,"column_start":36,"column_end":37},"kind":{"Impl":{"id":1924}},"from":{"krate":0,"index":1716},"to":{"krate":0,"index":1713}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":812738,"byte_end":812739,"line_start":358,"line_end":358,"column_start":48,"column_end":49},"kind":{"Impl":{"id":1925}},"from":{"krate":0,"index":1719},"to":{"krate":0,"index":1713}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":812952,"byte_end":812966,"line_start":366,"line_end":366,"column_start":36,"column_end":50},"kind":{"Impl":{"id":1926}},"from":{"krate":0,"index":26121},"to":{"krate":0,"index":1936}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":813328,"byte_end":813342,"line_start":377,"line_end":377,"column_start":22,"column_end":36},"kind":{"Impl":{"id":1927}},"from":{"krate":0,"index":26121},"to":{"krate":0,"index":1940}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":813434,"byte_end":813448,"line_start":380,"line_end":380,"column_start":26,"column_end":40},"kind":{"Impl":{"id":1928}},"from":{"krate":0,"index":26121},"to":{"krate":0,"index":6481}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":813658,"byte_end":813672,"line_start":388,"line_end":388,"column_start":11,"column_end":25},"kind":{"Impl":{"id":1929}},"from":{"krate":0,"index":26121},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":816360,"byte_end":816374,"line_start":475,"line_end":475,"column_start":38,"column_end":52},"kind":{"Impl":{"id":1930}},"from":{"krate":0,"index":26121},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":816585,"byte_end":816599,"line_start":484,"line_end":484,"column_start":28,"column_end":42},"kind":{"Impl":{"id":1931}},"from":{"krate":0,"index":26121},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":820561,"byte_end":820577,"line_start":613,"line_end":613,"column_start":38,"column_end":54},"kind":{"Impl":{"id":1932}},"from":{"krate":0,"index":26129},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":820758,"byte_end":820774,"line_start":621,"line_end":621,"column_start":28,"column_end":44},"kind":{"Impl":{"id":1933}},"from":{"krate":0,"index":26129},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":823218,"byte_end":823223,"line_start":699,"line_end":699,"column_start":16,"column_end":21},"kind":{"Impl":{"id":1934}},"from":{"krate":0,"index":26148},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":826164,"byte_end":826173,"line_start":797,"line_end":797,"column_start":36,"column_end":45},"kind":{"Impl":{"id":1935}},"from":{"krate":0,"index":26055},"to":{"krate":0,"index":1755}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":826393,"byte_end":826402,"line_start":807,"line_end":807,"column_start":28,"column_end":37},"kind":{"Impl":{"id":1936}},"from":{"krate":0,"index":26085},"to":{"krate":0,"index":1755}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":826637,"byte_end":826644,"line_start":817,"line_end":817,"column_start":28,"column_end":35},"kind":{"Impl":{"id":1937}},"from":{"krate":0,"index":26102},"to":{"krate":0,"index":1755}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":826877,"byte_end":826882,"line_start":827,"line_end":827,"column_start":28,"column_end":33},"kind":{"Impl":{"id":1938}},"from":{"krate":0,"index":26067},"to":{"krate":0,"index":1755}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":827127,"byte_end":827141,"line_start":837,"line_end":837,"column_start":28,"column_end":42},"kind":{"Impl":{"id":1939}},"from":{"krate":0,"index":26121},"to":{"krate":0,"index":1755}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":827386,"byte_end":827402,"line_start":847,"line_end":847,"column_start":28,"column_end":44},"kind":{"Impl":{"id":1940}},"from":{"krate":0,"index":26129},"to":{"krate":0,"index":1755}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":828466,"byte_end":828475,"line_start":887,"line_end":887,"column_start":28,"column_end":37},"kind":{"Impl":{"id":1941}},"from":{"krate":0,"index":26085},"to":{"krate":0,"index":1755}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":828710,"byte_end":828717,"line_start":897,"line_end":897,"column_start":28,"column_end":35},"kind":{"Impl":{"id":1942}},"from":{"krate":0,"index":26102},"to":{"krate":0,"index":1755}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":828950,"byte_end":828955,"line_start":907,"line_end":907,"column_start":28,"column_end":33},"kind":{"Impl":{"id":1943}},"from":{"krate":0,"index":26067},"to":{"krate":0,"index":1755}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":829199,"byte_end":829213,"line_start":917,"line_end":917,"column_start":28,"column_end":42},"kind":{"Impl":{"id":1944}},"from":{"krate":0,"index":26121},"to":{"krate":0,"index":1755}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":829457,"byte_end":829473,"line_start":927,"line_end":927,"column_start":28,"column_end":44},"kind":{"Impl":{"id":1945}},"from":{"krate":0,"index":26129},"to":{"krate":0,"index":1755}},{"span":{"file_name":"src/libcore/cmp.rs","byte_start":844289,"byte_end":844298,"line_start":245,"line_end":245,"column_start":15,"column_end":24},"kind":"SuperTrait","from":{"krate":0,"index":1936},"to":{"krate":0,"index":1940}},{"span":{"file_name":"src/libcore/cmp.rs","byte_start":846055,"byte_end":846063,"line_start":300,"line_end":300,"column_start":6,"column_end":14},"kind":{"Impl":{"id":1946}},"from":{"krate":0,"index":26177},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cmp.rs","byte_start":850084,"byte_end":850091,"line_start":432,"line_end":432,"column_start":36,"column_end":43},"kind":{"Impl":{"id":1947}},"from":{"krate":0,"index":26197},"to":{"krate":0,"index":1970}},{"span":{"file_name":"src/libcore/cmp.rs","byte_start":850602,"byte_end":850609,"line_start":449,"line_end":449,"column_start":22,"column_end":29},"kind":{"Impl":{"id":1948}},"from":{"krate":0,"index":26197},"to":{"krate":0,"index":1960}},{"span":{"file_name":"src/libcore/cmp.rs","byte_start":852828,"byte_end":852830,"line_start":519,"line_end":519,"column_start":16,"column_end":18},"kind":"SuperTrait","from":{"krate":0,"index":1940},"to":{"krate":0,"index":1960}},{"span":{"file_name":"src/libcore/cmp.rs","byte_start":852833,"byte_end":852843,"line_start":519,"line_end":519,"column_start":21,"column_end":31},"kind":"SuperTrait","from":{"krate":0,"index":1970},"to":{"krate":0,"index":1960}},{"span":{"file_name":"src/libcore/cmp.rs","byte_start":855139,"byte_end":855147,"line_start":604,"line_end":604,"column_start":13,"column_end":21},"kind":{"Impl":{"id":1949}},"from":{"krate":0,"index":26177},"to":{"krate":0,"index":1940}},{"span":{"file_name":"src/libcore/cmp.rs","byte_start":855211,"byte_end":855219,"line_start":607,"line_end":607,"column_start":14,"column_end":22},"kind":{"Impl":{"id":1950}},"from":{"krate":0,"index":26177},"to":{"krate":0,"index":1960}},{"span":{"file_name":"src/libcore/cmp.rs","byte_start":855406,"byte_end":855414,"line_start":615,"line_end":615,"column_start":21,"column_end":29},"kind":{"Impl":{"id":1951}},"from":{"krate":0,"index":26177},"to":{"krate":0,"index":1970}},{"span":{"file_name":"src/libcore/cmp.rs","byte_start":858920,"byte_end":858929,"line_start":730,"line_end":730,"column_start":43,"column_end":52},"kind":"SuperTrait","from":{"krate":0,"index":1936},"to":{"krate":0,"index":1970}},{"span":{"file_name":"src/libcore/clone.rs","byte_start":874728,"byte_end":874733,"line_start":110,"line_end":110,"column_start":19,"column_end":24},"kind":"SuperTrait","from":{"krate":0,"index":1442},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/default.rs","byte_start":879646,"byte_end":879651,"line_start":84,"line_end":84,"column_start":20,"column_end":25},"kind":"SuperTrait","from":{"krate":0,"index":1442},"to":{"krate":0,"index":2080}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":892009,"byte_end":892014,"line_start":278,"line_end":278,"column_start":20,"column_end":25},"kind":"SuperTrait","from":{"krate":0,"index":1442},"to":{"krate":0,"index":2093}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":895625,"byte_end":895630,"line_start":374,"line_end":374,"column_start":20,"column_end":25},"kind":"SuperTrait","from":{"krate":0,"index":1442},"to":{"krate":0,"index":2096}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":896489,"byte_end":896494,"line_start":398,"line_end":398,"column_start":23,"column_end":28},"kind":"SuperTrait","from":{"krate":0,"index":1442},"to":{"krate":0,"index":2099}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":899353,"byte_end":899358,"line_start":478,"line_end":478,"column_start":23,"column_end":28},"kind":"SuperTrait","from":{"krate":0,"index":1442},"to":{"krate":0,"index":2103}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":901107,"byte_end":901108,"line_start":537,"line_end":537,"column_start":24,"column_end":25},"kind":{"Impl":{"id":2044}},"from":{"krate":0,"index":2120},"to":{"krate":0,"index":2093}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":901287,"byte_end":901288,"line_start":546,"line_end":546,"column_start":21,"column_end":22},"kind":{"Impl":{"id":2045}},"from":{"krate":0,"index":2124},"to":{"krate":0,"index":2096}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":901427,"byte_end":901428,"line_start":553,"line_end":553,"column_start":27,"column_end":28},"kind":{"Impl":{"id":2046}},"from":{"krate":0,"index":2127},"to":{"krate":0,"index":2099}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":901750,"byte_end":901751,"line_start":565,"line_end":565,"column_start":27,"column_end":28},"kind":{"Impl":{"id":2047}},"from":{"krate":0,"index":2132},"to":{"krate":0,"index":2103}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":904837,"byte_end":904847,"line_start":660,"line_end":660,"column_start":16,"column_end":26},"kind":{"Impl":{"id":2049}},"from":{"krate":0,"index":26468},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":904998,"byte_end":905008,"line_start":667,"line_end":667,"column_start":21,"column_end":31},"kind":{"Impl":{"id":2050}},"from":{"krate":0,"index":26468},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":905188,"byte_end":905198,"line_start":674,"line_end":674,"column_start":23,"column_end":33},"kind":{"Impl":{"id":2051}},"from":{"krate":0,"index":26468},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":905375,"byte_end":905385,"line_start":681,"line_end":681,"column_start":20,"column_end":30},"kind":{"Impl":{"id":2052}},"from":{"krate":0,"index":26468},"to":{"krate":0,"index":1936}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":905535,"byte_end":905545,"line_start":688,"line_end":688,"column_start":13,"column_end":23},"kind":{"Impl":{"id":2053}},"from":{"krate":0,"index":26468},"to":{"krate":0,"index":1940}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":905630,"byte_end":905640,"line_start":691,"line_end":691,"column_start":21,"column_end":31},"kind":{"Impl":{"id":2054}},"from":{"krate":0,"index":26468},"to":{"krate":0,"index":1970}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":905823,"byte_end":905833,"line_start":698,"line_end":698,"column_start":14,"column_end":24},"kind":{"Impl":{"id":2055}},"from":{"krate":0,"index":26468},"to":{"krate":0,"index":1960}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":906004,"byte_end":906014,"line_start":705,"line_end":705,"column_start":18,"column_end":28},"kind":{"Impl":{"id":2056}},"from":{"krate":0,"index":26468},"to":{"krate":0,"index":2096}},{"span":{"file_name":"src/libcore/borrow.rs","byte_start":913732,"byte_end":913738,"line_start":192,"line_end":192,"column_start":41,"column_end":47},"kind":"SuperTrait","from":{"krate":0,"index":2160},"to":{"krate":0,"index":2163}},{"span":{"file_name":"src/libcore/borrow.rs","byte_start":914256,"byte_end":914257,"line_start":213,"line_end":213,"column_start":31,"column_end":32},"kind":{"Impl":{"id":2057}},"from":{"krate":0,"index":2167},"to":{"krate":0,"index":2160}},{"span":{"file_name":"src/libcore/borrow.rs","byte_start":914378,"byte_end":914379,"line_start":218,"line_end":218,"column_start":34,"column_end":35},"kind":{"Impl":{"id":2058}},"from":{"krate":0,"index":2170},"to":{"krate":0,"index":2163}},{"span":{"file_name":"src/libcore/any.rs","byte_start":918355,"byte_end":918356,"line_start":100,"line_end":100,"column_start":36,"column_end":37},"kind":{"Impl":{"id":2059}},"from":{"krate":0,"index":2187},"to":{"krate":0,"index":2184}},{"span":{"file_name":"src/libcore/any.rs","byte_start":927295,"byte_end":927301,"line_start":427,"line_end":427,"column_start":6,"column_end":12},"kind":{"Impl":{"id":2060}},"from":{"krate":0,"index":26470},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/array.rs","byte_start":929637,"byte_end":929638,"line_start":41,"line_end":41,"column_start":54,"column_end":55},"kind":{"Impl":{"id":2061}},"from":{"krate":0,"index":2241},"to":{"krate":0,"index":2235}},{"span":{"file_name":"src/libcore/array.rs","byte_start":930055,"byte_end":930072,"line_start":58,"line_end":58,"column_start":23,"column_end":40},"kind":{"Impl":{"id":2062}},"from":{"krate":0,"index":26493},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/array.rs","byte_start":930217,"byte_end":930234,"line_start":65,"line_end":65,"column_start":6,"column_end":23},"kind":{"Impl":{"id":2063}},"from":{"krate":0,"index":26493},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/array.rs","byte_start":930650,"byte_end":930667,"line_start":78,"line_end":78,"column_start":27,"column_end":44},"kind":{"Impl":{"id":2064}},"from":{"krate":0,"index":26493},"to":{"krate":0,"index":2096}},{"span":{"file_name":"src/libcore/ascii.rs","byte_start":941770,"byte_end":941783,"line_start":116,"line_end":116,"column_start":19,"column_end":32},"kind":{"Impl":{"id":2065}},"from":{"krate":0,"index":2258},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/ascii.rs","byte_start":942041,"byte_end":942054,"line_start":122,"line_end":122,"column_start":30,"column_end":43},"kind":{"Impl":{"id":2066}},"from":{"krate":0,"index":2258},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/ascii.rs","byte_start":942235,"byte_end":942248,"line_start":128,"line_end":128,"column_start":28,"column_end":41},"kind":{"Impl":{"id":2067}},"from":{"krate":0,"index":2258},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/ascii.rs","byte_start":942322,"byte_end":942335,"line_start":130,"line_end":130,"column_start":24,"column_end":37},"kind":{"Impl":{"id":2068}},"from":{"krate":0,"index":2258},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/ascii.rs","byte_start":942411,"byte_end":942424,"line_start":133,"line_end":133,"column_start":21,"column_end":34},"kind":{"Impl":{"id":2069}},"from":{"krate":0,"index":2258},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":949478,"byte_end":949488,"line_start":169,"line_end":169,"column_start":18,"column_end":28},"kind":{"Impl":{"id":2070}},"from":{"krate":0,"index":2284},"to":{"krate":0,"index":2080}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":949757,"byte_end":949767,"line_start":179,"line_end":179,"column_start":22,"column_end":32},"kind":{"Impl":{"id":2071}},"from":{"krate":0,"index":2284},"to":{"krate":0,"index":1446}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":950326,"byte_end":950335,"line_start":195,"line_end":195,"column_start":21,"column_end":30},"kind":{"Impl":{"id":2072}},"from":{"krate":0,"index":2289},"to":{"krate":0,"index":2080}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":950575,"byte_end":950584,"line_start":204,"line_end":204,"column_start":25,"column_end":34},"kind":{"Impl":{"id":2073}},"from":{"krate":0,"index":2289},"to":{"krate":0,"index":1437}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":950695,"byte_end":950704,"line_start":207,"line_end":207,"column_start":25,"column_end":34},"kind":{"Impl":{"id":2074}},"from":{"krate":0,"index":2289},"to":{"krate":0,"index":1446}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":955582,"byte_end":955592,"line_start":314,"line_end":314,"column_start":6,"column_end":16},"kind":{"Impl":{"id":2075}},"from":{"krate":0,"index":2284},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":974623,"byte_end":974632,"line_start":801,"line_end":801,"column_start":9,"column_end":18},"kind":{"Impl":{"id":2076}},"from":{"krate":0,"index":2289},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":986593,"byte_end":986603,"line_start":1114,"line_end":1114,"column_start":21,"column_end":31},"kind":{"Impl":{"id":2077}},"from":{"krate":0,"index":2284},"to":{"krate":0,"index":2096}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":987038,"byte_end":987047,"line_start":1130,"line_end":1130,"column_start":26,"column_end":35},"kind":{"Impl":{"id":2078}},"from":{"krate":0,"index":2289},"to":{"krate":0,"index":2096}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1039423,"byte_end":1039433,"line_start":2508,"line_end":2508,"column_start":21,"column_end":31},"kind":{"Impl":{"id":2079}},"from":{"krate":0,"index":2284},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1039675,"byte_end":1039684,"line_start":2516,"line_end":2516,"column_start":24,"column_end":33},"kind":{"Impl":{"id":2080}},"from":{"krate":0,"index":2289},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1039934,"byte_end":1039943,"line_start":2524,"line_end":2524,"column_start":26,"column_end":35},"kind":{"Impl":{"id":2081}},"from":{"krate":0,"index":2289},"to":{"krate":0,"index":6836}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1049032,"byte_end":1049036,"line_start":232,"line_end":232,"column_start":14,"column_end":18},"kind":{"Impl":{"id":2082}},"from":{"krate":0,"index":2386},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1050073,"byte_end":1050077,"line_start":279,"line_end":279,"column_start":33,"column_end":37},"kind":{"Impl":{"id":2083}},"from":{"krate":0,"index":2386},"to":{"krate":0,"index":1437}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1050171,"byte_end":1050175,"line_start":282,"line_end":282,"column_start":27,"column_end":31},"kind":{"Impl":{"id":2084}},"from":{"krate":0,"index":2386},"to":{"krate":0,"index":1446}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1050252,"byte_end":1050256,"line_start":285,"line_end":285,"column_start":24,"column_end":28},"kind":{"Impl":{"id":2085}},"from":{"krate":0,"index":2386},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1050422,"byte_end":1050426,"line_start":293,"line_end":293,"column_start":29,"column_end":33},"kind":{"Impl":{"id":2086}},"from":{"krate":0,"index":2386},"to":{"krate":0,"index":2080}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1050669,"byte_end":1050673,"line_start":302,"line_end":302,"column_start":40,"column_end":44},"kind":{"Impl":{"id":2087}},"from":{"krate":0,"index":2386},"to":{"krate":0,"index":1936}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1050853,"byte_end":1050857,"line_start":310,"line_end":310,"column_start":26,"column_end":30},"kind":{"Impl":{"id":2088}},"from":{"krate":0,"index":2386},"to":{"krate":0,"index":1940}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1050956,"byte_end":1050960,"line_start":313,"line_end":313,"column_start":42,"column_end":46},"kind":{"Impl":{"id":2089}},"from":{"krate":0,"index":2386},"to":{"krate":0,"index":1970}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1051570,"byte_end":1051574,"line_start":341,"line_end":341,"column_start":28,"column_end":32},"kind":{"Impl":{"id":2090}},"from":{"krate":0,"index":2386},"to":{"krate":0,"index":1960}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1051760,"byte_end":1051764,"line_start":349,"line_end":349,"column_start":21,"column_end":25},"kind":{"Impl":{"id":2091}},"from":{"krate":0,"index":2386},"to":{"krate":0,"index":2096}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1051839,"byte_end":1051843,"line_start":355,"line_end":355,"column_start":9,"column_end":13},"kind":{"Impl":{"id":2092}},"from":{"krate":0,"index":2386},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1054048,"byte_end":1054052,"line_start":451,"line_end":451,"column_start":17,"column_end":21},"kind":{"Impl":{"id":2093}},"from":{"krate":0,"index":2386},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1055585,"byte_end":1055589,"line_start":514,"line_end":514,"column_start":18,"column_end":22},"kind":{"Impl":{"id":2094}},"from":{"krate":0,"index":2386},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1056154,"byte_end":1056158,"line_start":535,"line_end":535,"column_start":57,"column_end":61},"kind":{"Impl":{"id":2095}},"from":{"krate":0,"index":2386},"to":{"krate":0,"index":1827}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1056174,"byte_end":1056178,"line_start":537,"line_end":537,"column_start":9,"column_end":13},"kind":{"Impl":{"id":2096}},"from":{"krate":0,"index":2386},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1057291,"byte_end":1057302,"line_start":575,"line_end":575,"column_start":16,"column_end":27},"kind":{"Impl":{"id":2097}},"from":{"krate":0,"index":2447},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1057493,"byte_end":1057504,"line_start":582,"line_end":582,"column_start":18,"column_end":29},"kind":{"Impl":{"id":2098}},"from":{"krate":0,"index":2447},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1057896,"byte_end":1057910,"line_start":595,"line_end":595,"column_start":16,"column_end":30},"kind":{"Impl":{"id":2099}},"from":{"krate":0,"index":2453},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1058104,"byte_end":1058118,"line_start":602,"line_end":602,"column_start":18,"column_end":32},"kind":{"Impl":{"id":2100}},"from":{"krate":0,"index":2453},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1059301,"byte_end":1059308,"line_start":634,"line_end":634,"column_start":9,"column_end":16},"kind":{"Impl":{"id":2101}},"from":{"krate":0,"index":2443},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1062629,"byte_end":1062636,"line_start":748,"line_end":748,"column_start":17,"column_end":24},"kind":{"Impl":{"id":2102}},"from":{"krate":0,"index":2443},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1069643,"byte_end":1069650,"line_start":994,"line_end":994,"column_start":33,"column_end":40},"kind":{"Impl":{"id":2103}},"from":{"krate":0,"index":2443},"to":{"krate":0,"index":1437}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1069744,"byte_end":1069751,"line_start":997,"line_end":997,"column_start":27,"column_end":34},"kind":{"Impl":{"id":2104}},"from":{"krate":0,"index":2443},"to":{"krate":0,"index":1446}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1069830,"byte_end":1069837,"line_start":1000,"line_end":1000,"column_start":26,"column_end":33},"kind":{"Impl":{"id":2105}},"from":{"krate":0,"index":2443},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1070104,"byte_end":1070111,"line_start":1011,"line_end":1011,"column_start":29,"column_end":36},"kind":{"Impl":{"id":2106}},"from":{"krate":0,"index":2443},"to":{"krate":0,"index":2080}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1070366,"byte_end":1070373,"line_start":1020,"line_end":1020,"column_start":43,"column_end":50},"kind":{"Impl":{"id":2107}},"from":{"krate":0,"index":2443},"to":{"krate":0,"index":1936}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1070663,"byte_end":1070670,"line_start":1031,"line_end":1031,"column_start":29,"column_end":36},"kind":{"Impl":{"id":2108}},"from":{"krate":0,"index":2443},"to":{"krate":0,"index":1940}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1070772,"byte_end":1070779,"line_start":1034,"line_end":1034,"column_start":45,"column_end":52},"kind":{"Impl":{"id":2109}},"from":{"krate":0,"index":2443},"to":{"krate":0,"index":1970}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1071926,"byte_end":1071933,"line_start":1077,"line_end":1077,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2110}},"from":{"krate":0,"index":2443},"to":{"krate":0,"index":1960}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1072225,"byte_end":1072232,"line_start":1088,"line_end":1088,"column_start":21,"column_end":28},"kind":{"Impl":{"id":2111}},"from":{"krate":0,"index":2443},"to":{"krate":0,"index":2096}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1072421,"byte_end":1072428,"line_start":1095,"line_end":1095,"column_start":60,"column_end":67},"kind":{"Impl":{"id":2112}},"from":{"krate":0,"index":2443},"to":{"krate":0,"index":1827}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1072505,"byte_end":1072514,"line_start":1101,"line_end":1101,"column_start":10,"column_end":19},"kind":{"Impl":{"id":2113}},"from":{"krate":0,"index":2511},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1072963,"byte_end":1072972,"line_start":1116,"line_end":1116,"column_start":15,"column_end":24},"kind":{"Impl":{"id":2114}},"from":{"krate":0,"index":2511},"to":{"krate":0,"index":1623}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1073162,"byte_end":1073171,"line_start":1125,"line_end":1125,"column_start":16,"column_end":25},"kind":{"Impl":{"id":2115}},"from":{"krate":0,"index":2511},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1074023,"byte_end":1074026,"line_start":1151,"line_end":1151,"column_start":27,"column_end":30},"kind":{"Impl":{"id":2116}},"from":{"krate":0,"index":2521},"to":{"krate":0,"index":1601}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1074148,"byte_end":1074151,"line_start":1160,"line_end":1160,"column_start":21,"column_end":24},"kind":{"Impl":{"id":2117}},"from":{"krate":0,"index":2521},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1076898,"byte_end":1076901,"line_start":1239,"line_end":1239,"column_start":74,"column_end":77},"kind":{"Impl":{"id":2118}},"from":{"krate":0,"index":2521},"to":{"krate":0,"index":1827}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1077018,"byte_end":1077021,"line_start":1242,"line_end":1242,"column_start":49,"column_end":52},"kind":{"Impl":{"id":2119}},"from":{"krate":0,"index":2521},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1077149,"byte_end":1077155,"line_start":1248,"line_end":1248,"column_start":21,"column_end":27},"kind":{"Impl":{"id":2120}},"from":{"krate":0,"index":2567},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1079785,"byte_end":1079797,"line_start":1327,"line_end":1327,"column_start":15,"column_end":27},"kind":{"Impl":{"id":2121}},"from":{"krate":0,"index":2558},"to":{"krate":0,"index":1623}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1079981,"byte_end":1079993,"line_start":1336,"line_end":1336,"column_start":10,"column_end":22},"kind":{"Impl":{"id":2122}},"from":{"krate":0,"index":2558},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1081533,"byte_end":1081539,"line_start":1378,"line_end":1378,"column_start":27,"column_end":33},"kind":{"Impl":{"id":2123}},"from":{"krate":0,"index":2567},"to":{"krate":0,"index":1601}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1081716,"byte_end":1081722,"line_start":1388,"line_end":1388,"column_start":30,"column_end":36},"kind":{"Impl":{"id":2124}},"from":{"krate":0,"index":2567},"to":{"krate":0,"index":1612}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1081947,"byte_end":1081953,"line_start":1396,"line_end":1396,"column_start":77,"column_end":83},"kind":{"Impl":{"id":2125}},"from":{"krate":0,"index":2567},"to":{"krate":0,"index":1827}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1082070,"byte_end":1082076,"line_start":1399,"line_end":1399,"column_start":49,"column_end":55},"kind":{"Impl":{"id":2126}},"from":{"krate":0,"index":2567},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1085431,"byte_end":1085441,"line_start":1470,"line_end":1470,"column_start":27,"column_end":37},"kind":{"Impl":{"id":2127}},"from":{"krate":0,"index":2586},"to":{"krate":0,"index":1446}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1085457,"byte_end":1085467,"line_start":1472,"line_end":1472,"column_start":9,"column_end":19},"kind":{"Impl":{"id":2128}},"from":{"krate":0,"index":2586},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1086285,"byte_end":1086295,"line_start":1509,"line_end":1509,"column_start":17,"column_end":27},"kind":{"Impl":{"id":2129}},"from":{"krate":0,"index":2586},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1087172,"byte_end":1087182,"line_start":1536,"line_end":1536,"column_start":30,"column_end":40},"kind":{"Impl":{"id":2130}},"from":{"krate":0,"index":2586},"to":{"krate":0,"index":2080}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1087413,"byte_end":1087423,"line_start":1544,"line_end":1544,"column_start":21,"column_end":31},"kind":{"Impl":{"id":2131}},"from":{"krate":0,"index":2586},"to":{"krate":0,"index":2096}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1087621,"byte_end":1087631,"line_start":1551,"line_end":1551,"column_start":63,"column_end":73},"kind":{"Impl":{"id":2132}},"from":{"krate":0,"index":2586},"to":{"krate":0,"index":1827}},{"span":{"file_name":"src/libcore/char/convert.rs","byte_start":1109256,"byte_end":1109270,"line_start":173,"line_end":173,"column_start":6,"column_end":20},"kind":{"Impl":{"id":2135}},"from":{"krate":0,"index":31873},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/char/convert.rs","byte_start":1109898,"byte_end":1109912,"line_start":195,"line_end":195,"column_start":23,"column_end":37},"kind":{"Impl":{"id":2136}},"from":{"krate":0,"index":31873},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/char/convert.rs","byte_start":1111203,"byte_end":1111219,"line_start":242,"line_end":242,"column_start":23,"column_end":39},"kind":{"Impl":{"id":2139}},"from":{"krate":0,"index":31898},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/char/decode.rs","byte_start":1115170,"byte_end":1115181,"line_start":78,"line_end":78,"column_start":44,"column_end":55},"kind":{"Impl":{"id":2140}},"from":{"krate":0,"index":31911},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/char/decode.rs","byte_start":1116658,"byte_end":1116674,"line_start":121,"line_end":121,"column_start":6,"column_end":22},"kind":{"Impl":{"id":2141}},"from":{"krate":0,"index":31921},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/char/decode.rs","byte_start":1116946,"byte_end":1116962,"line_start":130,"line_end":130,"column_start":23,"column_end":39},"kind":{"Impl":{"id":2142}},"from":{"krate":0,"index":31921},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1093850,"byte_end":1093863,"line_start":143,"line_end":143,"column_start":19,"column_end":32},"kind":{"Impl":{"id":2144}},"from":{"krate":0,"index":31932},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1095646,"byte_end":1095659,"line_start":203,"line_end":203,"column_start":28,"column_end":41},"kind":{"Impl":{"id":2145}},"from":{"krate":0,"index":31932},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1096182,"byte_end":1096195,"line_start":219,"line_end":219,"column_start":24,"column_end":37},"kind":{"Impl":{"id":2146}},"from":{"krate":0,"index":31932},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1096283,"byte_end":1096296,"line_start":222,"line_end":222,"column_start":23,"column_end":36},"kind":{"Impl":{"id":2147}},"from":{"krate":0,"index":31932},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1097084,"byte_end":1097097,"line_start":253,"line_end":253,"column_start":19,"column_end":32},"kind":{"Impl":{"id":2148}},"from":{"krate":0,"index":31957},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1099065,"byte_end":1099078,"line_start":320,"line_end":320,"column_start":28,"column_end":41},"kind":{"Impl":{"id":2149}},"from":{"krate":0,"index":31957},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1099431,"byte_end":1099444,"line_start":332,"line_end":332,"column_start":24,"column_end":37},"kind":{"Impl":{"id":2150}},"from":{"krate":0,"index":31957},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1099532,"byte_end":1099545,"line_start":335,"line_end":335,"column_start":23,"column_end":36},"kind":{"Impl":{"id":2151}},"from":{"krate":0,"index":31957},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1100205,"byte_end":1100216,"line_start":356,"line_end":356,"column_start":19,"column_end":30},"kind":{"Impl":{"id":2152}},"from":{"krate":0,"index":31979},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1100460,"byte_end":1100471,"line_start":363,"line_end":363,"column_start":28,"column_end":39},"kind":{"Impl":{"id":2153}},"from":{"krate":0,"index":31979},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1100547,"byte_end":1100558,"line_start":366,"line_end":366,"column_start":24,"column_end":35},"kind":{"Impl":{"id":2154}},"from":{"krate":0,"index":31979},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1100644,"byte_end":1100655,"line_start":369,"line_end":369,"column_start":23,"column_end":34},"kind":{"Impl":{"id":2155}},"from":{"krate":0,"index":31979},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1101251,"byte_end":1101262,"line_start":387,"line_end":387,"column_start":19,"column_end":30},"kind":{"Impl":{"id":2156}},"from":{"krate":0,"index":31986},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1101514,"byte_end":1101525,"line_start":398,"line_end":398,"column_start":24,"column_end":35},"kind":{"Impl":{"id":2157}},"from":{"krate":0,"index":31986},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1101627,"byte_end":1101638,"line_start":401,"line_end":401,"column_start":28,"column_end":39},"kind":{"Impl":{"id":2158}},"from":{"krate":0,"index":31986},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1102126,"byte_end":1102137,"line_start":415,"line_end":415,"column_start":19,"column_end":30},"kind":{"Impl":{"id":2159}},"from":{"krate":0,"index":31993},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1102389,"byte_end":1102400,"line_start":426,"line_end":426,"column_start":24,"column_end":35},"kind":{"Impl":{"id":2160}},"from":{"krate":0,"index":31993},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1102502,"byte_end":1102513,"line_start":429,"line_end":429,"column_start":28,"column_end":39},"kind":{"Impl":{"id":2161}},"from":{"krate":0,"index":31993},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1102648,"byte_end":1102663,"line_start":439,"line_end":439,"column_start":6,"column_end":21},"kind":{"Impl":{"id":2162}},"from":{"krate":0,"index":32000},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1103072,"byte_end":1103087,"line_start":453,"line_end":453,"column_start":19,"column_end":34},"kind":{"Impl":{"id":2163}},"from":{"krate":0,"index":32000},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1103954,"byte_end":1103969,"line_start":484,"line_end":484,"column_start":23,"column_end":38},"kind":{"Impl":{"id":2164}},"from":{"krate":0,"index":32000},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1104578,"byte_end":1104589,"line_start":505,"line_end":505,"column_start":23,"column_end":34},"kind":{"Impl":{"id":2165}},"from":{"krate":0,"index":31986},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1104785,"byte_end":1104796,"line_start":512,"line_end":512,"column_start":23,"column_end":34},"kind":{"Impl":{"id":2166}},"from":{"krate":0,"index":31993},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/panic.rs","byte_start":1161457,"byte_end":1161466,"line_start":41,"line_end":41,"column_start":10,"column_end":19},"kind":{"Impl":{"id":2167}},"from":{"krate":0,"index":32019},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/panic.rs","byte_start":1164364,"byte_end":1164373,"line_start":126,"line_end":126,"column_start":23,"column_end":32},"kind":{"Impl":{"id":2168}},"from":{"krate":0,"index":32019},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/panic.rs","byte_start":1165900,"byte_end":1165908,"line_start":173,"line_end":173,"column_start":10,"column_end":18},"kind":{"Impl":{"id":2169}},"from":{"krate":0,"index":32027},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/panic.rs","byte_start":1168254,"byte_end":1168262,"line_start":251,"line_end":251,"column_start":23,"column_end":31},"kind":{"Impl":{"id":2170}},"from":{"krate":0,"index":32027},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1192186,"byte_end":1192189,"line_start":385,"line_end":385,"column_start":34,"column_end":37},"kind":{"Impl":{"id":2171}},"from":{"krate":0,"index":32035},"to":{"krate":0,"index":1936}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1192519,"byte_end":1192522,"line_start":399,"line_end":399,"column_start":35,"column_end":38},"kind":{"Impl":{"id":2172}},"from":{"krate":0,"index":32035},"to":{"krate":0,"index":1970}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1193048,"byte_end":1193051,"line_start":424,"line_end":424,"column_start":16,"column_end":19},"kind":{"Impl":{"id":2173}},"from":{"krate":0,"index":32035},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1194136,"byte_end":1194139,"line_start":456,"line_end":456,"column_start":16,"column_end":19},"kind":{"Impl":{"id":2174}},"from":{"krate":0,"index":32035},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1199014,"byte_end":1199017,"line_start":563,"line_end":563,"column_start":19,"column_end":22},"kind":{"Impl":{"id":2175}},"from":{"krate":0,"index":32035},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1200113,"byte_end":1200116,"line_start":591,"line_end":591,"column_start":21,"column_end":24},"kind":{"Impl":{"id":2176}},"from":{"krate":0,"index":32035},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1202444,"byte_end":1202447,"line_start":640,"line_end":640,"column_start":21,"column_end":24},"kind":{"Impl":{"id":2177}},"from":{"krate":0,"index":32035},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1205225,"byte_end":1205228,"line_start":707,"line_end":707,"column_start":26,"column_end":29},"kind":{"Impl":{"id":2178}},"from":{"krate":0,"index":32035},"to":{"krate":0,"index":1601}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1205424,"byte_end":1205427,"line_start":715,"line_end":715,"column_start":32,"column_end":35},"kind":{"Impl":{"id":2179}},"from":{"krate":0,"index":32035},"to":{"krate":0,"index":1612}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1205641,"byte_end":1205644,"line_start":725,"line_end":725,"column_start":32,"column_end":35},"kind":{"Impl":{"id":2180}},"from":{"krate":0,"index":32035},"to":{"krate":0,"index":1617}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1205732,"byte_end":1205735,"line_start":728,"line_end":728,"column_start":36,"column_end":39},"kind":{"Impl":{"id":2181}},"from":{"krate":0,"index":32035},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1205939,"byte_end":1205942,"line_start":735,"line_end":735,"column_start":40,"column_end":43},"kind":{"Impl":{"id":2182}},"from":{"krate":0,"index":32035},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1206148,"byte_end":1206151,"line_start":742,"line_end":742,"column_start":40,"column_end":43},"kind":{"Impl":{"id":2183}},"from":{"krate":0,"index":32035},"to":{"krate":0,"index":6836}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1206683,"byte_end":1206686,"line_start":754,"line_end":754,"column_start":38,"column_end":41},"kind":{"Impl":{"id":2184}},"from":{"krate":0,"index":32035},"to":{"krate":0,"index":1827}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1206813,"byte_end":1206816,"line_start":760,"line_end":760,"column_start":44,"column_end":47},"kind":{"Impl":{"id":2185}},"from":{"krate":0,"index":32035},"to":{"krate":0,"index":1864}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1221038,"byte_end":1221043,"line_start":15,"line_end":15,"column_start":17,"column_end":22},"kind":"SuperTrait","from":{"krate":0,"index":2056},"to":{"krate":0,"index":2968}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1221046,"byte_end":1221056,"line_start":15,"line_end":15,"column_start":25,"column_end":35},"kind":"SuperTrait","from":{"krate":0,"index":1970},"to":{"krate":0,"index":2968}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1221059,"byte_end":1221064,"line_start":15,"line_end":15,"column_start":38,"column_end":43},"kind":"SuperTrait","from":{"krate":0,"index":1442},"to":{"krate":0,"index":2968}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1227236,"byte_end":1227241,"line_start":201,"line_end":201,"column_start":33,"column_end":38},"kind":{"Impl":{"id":2198}},"from":{"krate":0,"index":26067},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1229484,"byte_end":1229489,"line_start":274,"line_end":274,"column_start":44,"column_end":49},"kind":{"Impl":{"id":2199}},"from":{"krate":0,"index":26067},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1230137,"byte_end":1230142,"line_start":300,"line_end":300,"column_start":38,"column_end":43},"kind":{"Impl":{"id":2200}},"from":{"krate":0,"index":26067},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1230228,"byte_end":1230237,"line_start":303,"line_end":303,"column_start":33,"column_end":42},"kind":{"Impl":{"id":2201}},"from":{"krate":0,"index":26085},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1230821,"byte_end":1230830,"line_start":327,"line_end":327,"column_start":38,"column_end":47},"kind":{"Impl":{"id":2202}},"from":{"krate":0,"index":26085},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1230933,"byte_end":1230942,"line_start":330,"line_end":330,"column_start":42,"column_end":51},"kind":{"Impl":{"id":2203}},"from":{"krate":0,"index":26085},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1231039,"byte_end":1231053,"line_start":333,"line_end":333,"column_start":33,"column_end":47},"kind":{"Impl":{"id":2204}},"from":{"krate":0,"index":26121},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1233606,"byte_end":1233620,"line_start":437,"line_end":437,"column_start":44,"column_end":58},"kind":{"Impl":{"id":2205}},"from":{"krate":0,"index":26121},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1235569,"byte_end":1235583,"line_start":511,"line_end":511,"column_start":38,"column_end":52},"kind":{"Impl":{"id":2206}},"from":{"krate":0,"index":26121},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1236050,"byte_end":1236056,"line_start":19,"line_end":19,"column_start":29,"column_end":35},"kind":{"Impl":{"id":2207}},"from":{"krate":0,"index":32185},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1236338,"byte_end":1236344,"line_start":29,"line_end":29,"column_start":40,"column_end":46},"kind":{"Impl":{"id":2208}},"from":{"krate":0,"index":32185},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1236519,"byte_end":1236525,"line_start":35,"line_end":35,"column_start":34,"column_end":40},"kind":{"Impl":{"id":2209}},"from":{"krate":0,"index":32185},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1236624,"byte_end":1236630,"line_start":38,"line_end":38,"column_start":38,"column_end":44},"kind":{"Impl":{"id":2210}},"from":{"krate":0,"index":32185},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1238703,"byte_end":1238713,"line_start":111,"line_end":111,"column_start":39,"column_end":49},"kind":{"Impl":{"id":2211}},"from":{"krate":0,"index":32194},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1239013,"byte_end":1239023,"line_start":122,"line_end":122,"column_start":44,"column_end":54},"kind":{"Impl":{"id":2212}},"from":{"krate":0,"index":32194},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1239132,"byte_end":1239142,"line_start":125,"line_end":125,"column_start":48,"column_end":58},"kind":{"Impl":{"id":2213}},"from":{"krate":0,"index":32194},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1241593,"byte_end":1241598,"line_start":202,"line_end":202,"column_start":24,"column_end":29},"kind":{"Impl":{"id":2214}},"from":{"krate":0,"index":3069},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1241771,"byte_end":1241776,"line_start":209,"line_end":209,"column_start":22,"column_end":27},"kind":{"Impl":{"id":2215}},"from":{"krate":0,"index":3069},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1242024,"byte_end":1242029,"line_start":222,"line_end":222,"column_start":33,"column_end":38},"kind":{"Impl":{"id":2216}},"from":{"krate":0,"index":3069},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1242181,"byte_end":1242186,"line_start":229,"line_end":229,"column_start":31,"column_end":36},"kind":{"Impl":{"id":2217}},"from":{"krate":0,"index":3069},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1242324,"byte_end":1242329,"line_start":236,"line_end":236,"column_start":31,"column_end":36},"kind":{"Impl":{"id":2218}},"from":{"krate":0,"index":3069},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1242410,"byte_end":1242415,"line_start":239,"line_end":239,"column_start":27,"column_end":32},"kind":{"Impl":{"id":2219}},"from":{"krate":0,"index":3069},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1242573,"byte_end":1242578,"line_start":244,"line_end":244,"column_start":19,"column_end":24},"kind":{"Impl":{"id":2220}},"from":{"krate":0,"index":3069},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1242816,"byte_end":1242821,"line_start":253,"line_end":253,"column_start":21,"column_end":26},"kind":{"Impl":{"id":2221}},"from":{"krate":0,"index":3069},"to":{"krate":0,"index":2080}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1243690,"byte_end":1243694,"line_start":290,"line_end":290,"column_start":22,"column_end":26},"kind":{"Impl":{"id":2222}},"from":{"krate":0,"index":32205},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1243965,"byte_end":1243969,"line_start":303,"line_end":303,"column_start":33,"column_end":37},"kind":{"Impl":{"id":2223}},"from":{"krate":0,"index":32205},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1244138,"byte_end":1244142,"line_start":310,"line_end":310,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2224}},"from":{"krate":0,"index":32205},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1244295,"byte_end":1244299,"line_start":317,"line_end":317,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2225}},"from":{"krate":0,"index":32205},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1244380,"byte_end":1244384,"line_start":320,"line_end":320,"column_start":27,"column_end":31},"kind":{"Impl":{"id":2226}},"from":{"krate":0,"index":32205},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1246503,"byte_end":1246511,"line_start":392,"line_end":392,"column_start":40,"column_end":48},"kind":{"Impl":{"id":2227}},"from":{"krate":0,"index":32214},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1246851,"byte_end":1246859,"line_start":407,"line_end":407,"column_start":51,"column_end":59},"kind":{"Impl":{"id":2228}},"from":{"krate":0,"index":32214},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1247042,"byte_end":1247050,"line_start":414,"line_end":414,"column_start":49,"column_end":57},"kind":{"Impl":{"id":2229}},"from":{"krate":0,"index":32214},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1247225,"byte_end":1247233,"line_start":421,"line_end":421,"column_start":45,"column_end":53},"kind":{"Impl":{"id":2230}},"from":{"krate":0,"index":32214},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1247346,"byte_end":1247354,"line_start":424,"line_end":424,"column_start":49,"column_end":57},"kind":{"Impl":{"id":2231}},"from":{"krate":0,"index":32214},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1251240,"byte_end":1251246,"line_start":548,"line_end":548,"column_start":25,"column_end":31},"kind":{"Impl":{"id":2232}},"from":{"krate":0,"index":32225},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1251472,"byte_end":1251478,"line_start":560,"line_end":560,"column_start":24,"column_end":30},"kind":{"Impl":{"id":2233}},"from":{"krate":0,"index":32225},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1252959,"byte_end":1252969,"line_start":604,"line_end":604,"column_start":25,"column_end":35},"kind":{"Impl":{"id":2234}},"from":{"krate":0,"index":32232},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1253480,"byte_end":1253490,"line_start":628,"line_end":628,"column_start":30,"column_end":40},"kind":{"Impl":{"id":2235}},"from":{"krate":0,"index":32232},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1253632,"byte_end":1253642,"line_start":633,"line_end":633,"column_start":39,"column_end":49},"kind":{"Impl":{"id":2236}},"from":{"krate":0,"index":32232},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1342623,"byte_end":1342631,"line_start":39,"line_end":39,"column_start":32,"column_end":40},"kind":"SuperTrait","from":{"krate":0,"index":3202},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/traits/exact_size.rs","byte_start":1352891,"byte_end":1352899,"line_start":71,"line_end":71,"column_start":30,"column_end":38},"kind":"SuperTrait","from":{"krate":0,"index":3202},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1357666,"byte_end":1357671,"line_start":98,"line_end":98,"column_start":28,"column_end":33},"kind":"SuperTrait","from":{"krate":0,"index":1442},"to":{"krate":0,"index":3388}},{"span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1361517,"byte_end":1361518,"line_start":241,"line_end":241,"column_start":36,"column_end":37},"kind":{"Impl":{"id":2237}},"from":{"krate":0,"index":3397},"to":{"krate":0,"index":3392}},{"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1365348,"byte_end":1365353,"line_start":15,"line_end":15,"column_start":26,"column_end":31},"kind":"SuperTrait","from":{"krate":0,"index":1442},"to":{"krate":0,"index":3413}},{"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1366266,"byte_end":1366271,"line_start":34,"line_end":34,"column_start":30,"column_end":35},"kind":"SuperTrait","from":{"krate":0,"index":1442},"to":{"krate":0,"index":3417}},{"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1369197,"byte_end":1369208,"line_start":127,"line_end":127,"column_start":15,"column_end":26},"kind":{"Impl":{"id":2286}},"from":{"krate":0,"index":3423},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1370126,"byte_end":1370137,"line_start":159,"line_end":159,"column_start":28,"column_end":39},"kind":{"Impl":{"id":2287}},"from":{"krate":0,"index":3423},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1370793,"byte_end":1370799,"line_start":186,"line_end":186,"column_start":37,"column_end":43},"kind":{"Impl":{"id":2288}},"from":{"krate":0,"index":32938},"to":{"krate":0,"index":3413}},{"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1371689,"byte_end":1371695,"line_start":214,"line_end":214,"column_start":41,"column_end":47},"kind":{"Impl":{"id":2289}},"from":{"krate":0,"index":32938},"to":{"krate":0,"index":3417}},{"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1372281,"byte_end":1372292,"line_start":234,"line_end":234,"column_start":12,"column_end":23},"kind":{"Impl":{"id":2290}},"from":{"krate":0,"index":3459},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1373119,"byte_end":1373130,"line_start":267,"line_end":267,"column_start":25,"column_end":36},"kind":{"Impl":{"id":2291}},"from":{"krate":0,"index":3459},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1373778,"byte_end":1373784,"line_start":295,"line_end":295,"column_start":31,"column_end":37},"kind":{"Impl":{"id":2292}},"from":{"krate":0,"index":32847},"to":{"krate":0,"index":3413}},{"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1374652,"byte_end":1374658,"line_start":322,"line_end":322,"column_start":35,"column_end":41},"kind":{"Impl":{"id":2293}},"from":{"krate":0,"index":32847},"to":{"krate":0,"index":3417}},{"span":{"file_name":"src/libcore/iter/traits/marker.rs","byte_start":1375911,"byte_end":1375919,"line_start":16,"line_end":16,"column_start":26,"column_end":34},"kind":"SuperTrait","from":{"krate":0,"index":3202},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/traits/marker.rs","byte_start":1377013,"byte_end":1377021,"line_start":41,"line_end":41,"column_start":31,"column_end":39},"kind":"SuperTrait","from":{"krate":0,"index":3202},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1436231,"byte_end":1436236,"line_start":21,"line_end":21,"column_start":12,"column_end":17},"kind":{"Impl":{"id":2294}},"from":{"krate":0,"index":32613},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1437138,"byte_end":1437143,"line_start":51,"line_end":51,"column_start":25,"column_end":30},"kind":{"Impl":{"id":2295}},"from":{"krate":0,"index":32613},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1441146,"byte_end":1441151,"line_start":191,"line_end":191,"column_start":36,"column_end":41},"kind":{"Impl":{"id":2296}},"from":{"krate":0,"index":32613},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1442986,"byte_end":1442991,"line_start":252,"line_end":252,"column_start":30,"column_end":35},"kind":{"Impl":{"id":2297}},"from":{"krate":0,"index":32613},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1443159,"byte_end":1443164,"line_start":258,"line_end":258,"column_start":34,"column_end":39},"kind":{"Impl":{"id":2298}},"from":{"krate":0,"index":32613},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1443953,"byte_end":1443960,"line_start":20,"line_end":20,"column_start":60,"column_end":67},"kind":{"Impl":{"id":2299}},"from":{"krate":0,"index":3578},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1444215,"byte_end":1444222,"line_start":27,"line_end":27,"column_start":61,"column_end":68},"kind":{"Impl":{"id":2300}},"from":{"krate":0,"index":3578},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1444465,"byte_end":1444472,"line_start":34,"line_end":34,"column_start":56,"column_end":63},"kind":{"Impl":{"id":2301}},"from":{"krate":0,"index":3578},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1444758,"byte_end":1444765,"line_start":43,"line_end":43,"column_start":52,"column_end":59},"kind":{"Impl":{"id":2302}},"from":{"krate":0,"index":3578},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1445501,"byte_end":1445508,"line_start":70,"line_end":70,"column_start":60,"column_end":67},"kind":{"Impl":{"id":2303}},"from":{"krate":0,"index":3578},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1446184,"byte_end":1446191,"line_start":94,"line_end":94,"column_start":33,"column_end":40},"kind":{"Impl":{"id":2304}},"from":{"krate":0,"index":3578},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1446866,"byte_end":1446873,"line_start":111,"line_end":111,"column_start":19,"column_end":26},"kind":{"Impl":{"id":2305}},"from":{"krate":0,"index":3628},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1447109,"byte_end":1447116,"line_start":119,"line_end":119,"column_start":27,"column_end":34},"kind":{"Impl":{"id":2306}},"from":{"krate":0,"index":3628},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1447469,"byte_end":1447476,"line_start":129,"line_end":129,"column_start":22,"column_end":29},"kind":{"Impl":{"id":2307}},"from":{"krate":0,"index":3628},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1447752,"byte_end":1447759,"line_start":137,"line_end":137,"column_start":25,"column_end":32},"kind":{"Impl":{"id":2308}},"from":{"krate":0,"index":3628},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1448541,"byte_end":1448548,"line_start":165,"line_end":165,"column_start":36,"column_end":43},"kind":{"Impl":{"id":2309}},"from":{"krate":0,"index":3628},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1449242,"byte_end":1449249,"line_start":188,"line_end":188,"column_start":30,"column_end":37},"kind":{"Impl":{"id":2310}},"from":{"krate":0,"index":3628},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1449577,"byte_end":1449590,"line_start":200,"line_end":200,"column_start":12,"column_end":25},"kind":{"Impl":{"id":2311}},"from":{"krate":0,"index":32638},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1449827,"byte_end":1449840,"line_start":207,"line_end":207,"column_start":25,"column_end":38},"kind":{"Impl":{"id":2312}},"from":{"krate":0,"index":32638},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1452063,"byte_end":1452076,"line_start":276,"line_end":276,"column_start":36,"column_end":49},"kind":{"Impl":{"id":2313}},"from":{"krate":0,"index":32638},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1454518,"byte_end":1454521,"line_start":22,"line_end":22,"column_start":32,"column_end":35},"kind":{"Impl":{"id":2314}},"from":{"krate":0,"index":32652},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1454910,"byte_end":1454913,"line_start":36,"line_end":36,"column_start":25,"column_end":28},"kind":{"Impl":{"id":2315}},"from":{"krate":0,"index":32652},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1455382,"byte_end":1455385,"line_start":57,"line_end":57,"column_start":36,"column_end":39},"kind":{"Impl":{"id":2316}},"from":{"krate":0,"index":32652},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1456109,"byte_end":1456112,"line_start":82,"line_end":82,"column_start":30,"column_end":33},"kind":{"Impl":{"id":2317}},"from":{"krate":0,"index":32652},"to":{"krate":0,"index":3729}},{"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1457944,"byte_end":1457947,"line_start":150,"line_end":150,"column_start":30,"column_end":33},"kind":{"Impl":{"id":2318}},"from":{"krate":0,"index":32652},"to":{"krate":0,"index":3729}},{"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1460507,"byte_end":1460510,"line_start":242,"line_end":242,"column_start":34,"column_end":37},"kind":{"Impl":{"id":2319}},"from":{"krate":0,"index":32652},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1460631,"byte_end":1460634,"line_start":246,"line_end":246,"column_start":43,"column_end":46},"kind":{"Impl":{"id":2320}},"from":{"krate":0,"index":32652},"to":{"krate":0,"index":3771}},{"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1461038,"byte_end":1461041,"line_start":260,"line_end":260,"column_start":30,"column_end":33},"kind":{"Impl":{"id":2321}},"from":{"krate":0,"index":32652},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1461185,"byte_end":1461188,"line_start":264,"line_end":264,"column_start":34,"column_end":37},"kind":{"Impl":{"id":2322}},"from":{"krate":0,"index":32652},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1461636,"byte_end":1461653,"line_start":278,"line_end":278,"column_start":47,"column_end":64},"kind":"SuperTrait","from":{"krate":0,"index":3380},"to":{"krate":0,"index":3771}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1378002,"byte_end":1378005,"line_start":33,"line_end":33,"column_start":9,"column_end":12},"kind":{"Impl":{"id":2323}},"from":{"krate":0,"index":32667},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1378151,"byte_end":1378154,"line_start":40,"line_end":40,"column_start":22,"column_end":25},"kind":{"Impl":{"id":2324}},"from":{"krate":0,"index":32667},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1379260,"byte_end":1379263,"line_start":79,"line_end":79,"column_start":33,"column_end":36},"kind":{"Impl":{"id":2325}},"from":{"krate":0,"index":32667},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1380053,"byte_end":1380056,"line_start":106,"line_end":106,"column_start":31,"column_end":34},"kind":{"Impl":{"id":2326}},"from":{"krate":0,"index":32667},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1380319,"byte_end":1380322,"line_start":119,"line_end":119,"column_start":27,"column_end":30},"kind":{"Impl":{"id":2327}},"from":{"krate":0,"index":32667},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1380463,"byte_end":1380466,"line_start":123,"line_end":123,"column_start":31,"column_end":34},"kind":{"Impl":{"id":2328}},"from":{"krate":0,"index":32667},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1380979,"byte_end":1380985,"line_start":140,"line_end":140,"column_start":9,"column_end":15},"kind":{"Impl":{"id":2329}},"from":{"krate":0,"index":32676},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1381151,"byte_end":1381157,"line_start":147,"line_end":147,"column_start":33,"column_end":39},"kind":{"Impl":{"id":2330}},"from":{"krate":0,"index":32676},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1381864,"byte_end":1381870,"line_start":174,"line_end":174,"column_start":44,"column_end":50},"kind":{"Impl":{"id":2331}},"from":{"krate":0,"index":32676},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1382493,"byte_end":1382499,"line_start":195,"line_end":195,"column_start":42,"column_end":48},"kind":{"Impl":{"id":2332}},"from":{"krate":0,"index":32676},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1382774,"byte_end":1382780,"line_start":208,"line_end":208,"column_start":38,"column_end":44},"kind":{"Impl":{"id":2333}},"from":{"krate":0,"index":32676},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1382901,"byte_end":1382907,"line_start":213,"line_end":213,"column_start":51,"column_end":57},"kind":{"Impl":{"id":2334}},"from":{"krate":0,"index":32676},"to":{"krate":0,"index":3771}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1383264,"byte_end":1383270,"line_start":227,"line_end":227,"column_start":42,"column_end":48},"kind":{"Impl":{"id":2335}},"from":{"krate":0,"index":32676},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1383790,"byte_end":1383796,"line_start":245,"line_end":245,"column_start":9,"column_end":15},"kind":{"Impl":{"id":2336}},"from":{"krate":0,"index":32685},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1383961,"byte_end":1383967,"line_start":252,"line_end":252,"column_start":33,"column_end":39},"kind":{"Impl":{"id":2337}},"from":{"krate":0,"index":32685},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1384688,"byte_end":1384694,"line_start":279,"line_end":279,"column_start":44,"column_end":50},"kind":{"Impl":{"id":2338}},"from":{"krate":0,"index":32685},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1385331,"byte_end":1385337,"line_start":300,"line_end":300,"column_start":42,"column_end":48},"kind":{"Impl":{"id":2339}},"from":{"krate":0,"index":32685},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1385607,"byte_end":1385613,"line_start":313,"line_end":313,"column_start":38,"column_end":44},"kind":{"Impl":{"id":2340}},"from":{"krate":0,"index":32685},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1385735,"byte_end":1385741,"line_start":318,"line_end":318,"column_start":51,"column_end":57},"kind":{"Impl":{"id":2341}},"from":{"krate":0,"index":32685},"to":{"krate":0,"index":3771}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1386060,"byte_end":1386066,"line_start":330,"line_end":330,"column_start":51,"column_end":57},"kind":{"Impl":{"id":2342}},"from":{"krate":0,"index":32685},"to":{"krate":0,"index":3771}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1386424,"byte_end":1386430,"line_start":344,"line_end":344,"column_start":42,"column_end":48},"kind":{"Impl":{"id":2343}},"from":{"krate":0,"index":32685},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1386935,"byte_end":1386940,"line_start":363,"line_end":363,"column_start":16,"column_end":21},"kind":{"Impl":{"id":2344}},"from":{"krate":0,"index":32694},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1387110,"byte_end":1387115,"line_start":370,"line_end":370,"column_start":22,"column_end":27},"kind":{"Impl":{"id":2345}},"from":{"krate":0,"index":32694},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1387760,"byte_end":1387765,"line_start":393,"line_end":393,"column_start":27,"column_end":32},"kind":{"Impl":{"id":2346}},"from":{"krate":0,"index":32694},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1388297,"byte_end":1388303,"line_start":410,"line_end":410,"column_start":9,"column_end":15},"kind":{"Impl":{"id":2347}},"from":{"krate":0,"index":32704},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1388542,"byte_end":1388548,"line_start":418,"line_end":418,"column_start":22,"column_end":28},"kind":{"Impl":{"id":2348}},"from":{"krate":0,"index":32704},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1390814,"byte_end":1390820,"line_start":490,"line_end":490,"column_start":31,"column_end":37},"kind":{"Impl":{"id":2349}},"from":{"krate":0,"index":32704},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1392706,"byte_end":1392709,"line_start":549,"line_end":549,"column_start":12,"column_end":15},"kind":{"Impl":{"id":2350}},"from":{"krate":0,"index":32715},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1392897,"byte_end":1392900,"line_start":556,"line_end":556,"column_start":39,"column_end":42},"kind":{"Impl":{"id":2351}},"from":{"krate":0,"index":32715},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1393155,"byte_end":1393158,"line_start":565,"line_end":565,"column_start":38,"column_end":41},"kind":{"Impl":{"id":2352}},"from":{"krate":0,"index":32715},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1393976,"byte_end":1393979,"line_start":594,"line_end":594,"column_start":60,"column_end":63},"kind":{"Impl":{"id":2353}},"from":{"krate":0,"index":32715},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1394689,"byte_end":1394692,"line_start":618,"line_end":618,"column_start":56,"column_end":59},"kind":{"Impl":{"id":2354}},"from":{"krate":0,"index":32715},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1394959,"byte_end":1394962,"line_start":631,"line_end":631,"column_start":48,"column_end":51},"kind":{"Impl":{"id":2355}},"from":{"krate":0,"index":32715},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1395096,"byte_end":1395099,"line_start":635,"line_end":635,"column_start":37,"column_end":40},"kind":{"Impl":{"id":2356}},"from":{"krate":0,"index":32715},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1395228,"byte_end":1395231,"line_start":640,"line_end":640,"column_start":46,"column_end":49},"kind":{"Impl":{"id":2357}},"from":{"krate":0,"index":32715},"to":{"krate":0,"index":3771}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1395960,"byte_end":1395966,"line_start":665,"line_end":665,"column_start":12,"column_end":18},"kind":{"Impl":{"id":2358}},"from":{"krate":0,"index":32724},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1396176,"byte_end":1396182,"line_start":672,"line_end":672,"column_start":39,"column_end":45},"kind":{"Impl":{"id":2359}},"from":{"krate":0,"index":32724},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1396437,"byte_end":1396443,"line_start":681,"line_end":681,"column_start":35,"column_end":41},"kind":{"Impl":{"id":2360}},"from":{"krate":0,"index":32724},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1398454,"byte_end":1398460,"line_start":738,"line_end":738,"column_start":57,"column_end":63},"kind":{"Impl":{"id":2361}},"from":{"krate":0,"index":32724},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1399427,"byte_end":1399433,"line_start":772,"line_end":772,"column_start":45,"column_end":51},"kind":{"Impl":{"id":2362}},"from":{"krate":0,"index":32724},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1399965,"byte_end":1399974,"line_start":789,"line_end":789,"column_start":12,"column_end":21},"kind":{"Impl":{"id":2363}},"from":{"krate":0,"index":32733},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1400174,"byte_end":1400183,"line_start":796,"line_end":796,"column_start":39,"column_end":48},"kind":{"Impl":{"id":2364}},"from":{"krate":0,"index":32733},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1400444,"byte_end":1400453,"line_start":805,"line_end":805,"column_start":38,"column_end":47},"kind":{"Impl":{"id":2365}},"from":{"krate":0,"index":32733},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1401580,"byte_end":1401589,"line_start":845,"line_end":845,"column_start":60,"column_end":69},"kind":{"Impl":{"id":2366}},"from":{"krate":0,"index":32733},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1402515,"byte_end":1402524,"line_start":877,"line_end":877,"column_start":48,"column_end":57},"kind":{"Impl":{"id":2367}},"from":{"krate":0,"index":32733},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1403071,"byte_end":1403080,"line_start":894,"line_end":894,"column_start":9,"column_end":18},"kind":{"Impl":{"id":2368}},"from":{"krate":0,"index":32742},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1403248,"byte_end":1403257,"line_start":901,"line_end":901,"column_start":22,"column_end":31},"kind":{"Impl":{"id":2369}},"from":{"krate":0,"index":32742},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1405263,"byte_end":1405272,"line_start":972,"line_end":972,"column_start":33,"column_end":42},"kind":{"Impl":{"id":2370}},"from":{"krate":0,"index":32742},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1407058,"byte_end":1407067,"line_start":1023,"line_end":1023,"column_start":31,"column_end":40},"kind":{"Impl":{"id":2371}},"from":{"krate":0,"index":32742},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1407285,"byte_end":1407294,"line_start":1034,"line_end":1034,"column_start":40,"column_end":49},"kind":{"Impl":{"id":2372}},"from":{"krate":0,"index":32742},"to":{"krate":0,"index":3771}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1407620,"byte_end":1407629,"line_start":1047,"line_end":1047,"column_start":27,"column_end":36},"kind":{"Impl":{"id":2373}},"from":{"krate":0,"index":32742},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1407744,"byte_end":1407753,"line_start":1050,"line_end":1050,"column_start":31,"column_end":40},"kind":{"Impl":{"id":2374}},"from":{"krate":0,"index":32742},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1408383,"byte_end":1408391,"line_start":1071,"line_end":1071,"column_start":19,"column_end":27},"kind":{"Impl":{"id":2375}},"from":{"krate":0,"index":32752},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1408815,"byte_end":1408823,"line_start":1082,"line_end":1082,"column_start":32,"column_end":40},"kind":{"Impl":{"id":2376}},"from":{"krate":0,"index":32752},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1411022,"byte_end":1411030,"line_start":1162,"line_end":1162,"column_start":50,"column_end":58},"kind":{"Impl":{"id":2377}},"from":{"krate":0,"index":32752},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1411126,"byte_end":1411134,"line_start":1165,"line_end":1165,"column_start":42,"column_end":50},"kind":{"Impl":{"id":2378}},"from":{"krate":0,"index":32752},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1411160,"byte_end":1411168,"line_start":1167,"line_end":1167,"column_start":19,"column_end":27},"kind":{"Impl":{"id":2379}},"from":{"krate":0,"index":32752},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1413165,"byte_end":1413174,"line_start":1228,"line_end":1228,"column_start":12,"column_end":21},"kind":{"Impl":{"id":2380}},"from":{"krate":0,"index":32762},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1413403,"byte_end":1413412,"line_start":1235,"line_end":1235,"column_start":39,"column_end":48},"kind":{"Impl":{"id":2381}},"from":{"krate":0,"index":32762},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1413709,"byte_end":1413718,"line_start":1245,"line_end":1245,"column_start":35,"column_end":44},"kind":{"Impl":{"id":2382}},"from":{"krate":0,"index":32762},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1415137,"byte_end":1415146,"line_start":1298,"line_end":1298,"column_start":30,"column_end":39},"kind":{"Impl":{"id":2383}},"from":{"krate":0,"index":32762},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1415722,"byte_end":1415731,"line_start":1316,"line_end":1316,"column_start":12,"column_end":21},"kind":{"Impl":{"id":2384}},"from":{"krate":0,"index":32772},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1415960,"byte_end":1415969,"line_start":1323,"line_end":1323,"column_start":39,"column_end":48},"kind":{"Impl":{"id":2385}},"from":{"krate":0,"index":32772},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1416266,"byte_end":1416275,"line_start":1333,"line_end":1333,"column_start":35,"column_end":44},"kind":{"Impl":{"id":2386}},"from":{"krate":0,"index":32772},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1417695,"byte_end":1417704,"line_start":1386,"line_end":1386,"column_start":30,"column_end":39},"kind":{"Impl":{"id":2387}},"from":{"krate":0,"index":32772},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1418216,"byte_end":1418220,"line_start":1403,"line_end":1403,"column_start":9,"column_end":13},"kind":{"Impl":{"id":2388}},"from":{"krate":0,"index":32782},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1418381,"byte_end":1418385,"line_start":1410,"line_end":1410,"column_start":22,"column_end":26},"kind":{"Impl":{"id":2389}},"from":{"krate":0,"index":32782},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1420655,"byte_end":1420659,"line_start":1500,"line_end":1500,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2390}},"from":{"krate":0,"index":32782},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1420793,"byte_end":1420797,"line_start":1503,"line_end":1503,"column_start":33,"column_end":37},"kind":{"Impl":{"id":2391}},"from":{"krate":0,"index":32782},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1421945,"byte_end":1421949,"line_start":1544,"line_end":1544,"column_start":27,"column_end":31},"kind":{"Impl":{"id":2392}},"from":{"krate":0,"index":32782},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1422468,"byte_end":1422472,"line_start":1560,"line_end":1560,"column_start":9,"column_end":13},"kind":{"Impl":{"id":2393}},"from":{"krate":0,"index":32792},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1422633,"byte_end":1422637,"line_start":1567,"line_end":1567,"column_start":22,"column_end":26},"kind":{"Impl":{"id":2394}},"from":{"krate":0,"index":32792},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1424213,"byte_end":1424217,"line_start":1631,"line_end":1631,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2395}},"from":{"krate":0,"index":32792},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1424325,"byte_end":1424329,"line_start":1634,"line_end":1634,"column_start":27,"column_end":31},"kind":{"Impl":{"id":2396}},"from":{"krate":0,"index":32792},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1424456,"byte_end":1424460,"line_start":1637,"line_end":1637,"column_start":43,"column_end":47},"kind":{"Impl":{"id":2397}},"from":{"krate":0,"index":32792},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1424945,"byte_end":1424949,"line_start":1654,"line_end":1654,"column_start":16,"column_end":20},"kind":{"Impl":{"id":2398}},"from":{"krate":0,"index":32802},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1425181,"byte_end":1425185,"line_start":1661,"line_end":1661,"column_start":55,"column_end":59},"kind":{"Impl":{"id":2399}},"from":{"krate":0,"index":32802},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1425480,"byte_end":1425484,"line_start":1671,"line_end":1671,"column_start":32,"column_end":36},"kind":{"Impl":{"id":2400}},"from":{"krate":0,"index":32802},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1426880,"byte_end":1426884,"line_start":1718,"line_end":1718,"column_start":9,"column_end":13},"kind":{"Impl":{"id":2401}},"from":{"krate":0,"index":32814},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1427051,"byte_end":1427055,"line_start":1725,"line_end":1725,"column_start":27,"column_end":31},"kind":{"Impl":{"id":2402}},"from":{"krate":0,"index":32814},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1427148,"byte_end":1427152,"line_start":1728,"line_end":1728,"column_start":22,"column_end":26},"kind":{"Impl":{"id":2403}},"from":{"krate":0,"index":32814},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1428927,"byte_end":1428931,"line_start":1806,"line_end":1806,"column_start":33,"column_end":37},"kind":{"Impl":{"id":2404}},"from":{"krate":0,"index":32814},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1430169,"byte_end":1430173,"line_start":1854,"line_end":1854,"column_start":40,"column_end":44},"kind":{"Impl":{"id":2405}},"from":{"krate":0,"index":32814},"to":{"krate":0,"index":3771}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1430468,"byte_end":1430472,"line_start":1867,"line_end":1867,"column_start":22,"column_end":26},"kind":{"Impl":{"id":2406}},"from":{"krate":0,"index":32814},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1431434,"byte_end":1431438,"line_start":1909,"line_end":1909,"column_start":33,"column_end":37},"kind":{"Impl":{"id":2407}},"from":{"krate":0,"index":32814},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1432197,"byte_end":1432201,"line_start":1939,"line_end":1939,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2408}},"from":{"krate":0,"index":32814},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1432858,"byte_end":1432865,"line_start":1964,"line_end":1964,"column_start":12,"column_end":19},"kind":{"Impl":{"id":2409}},"from":{"krate":0,"index":32824},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1433061,"byte_end":1433068,"line_start":1971,"line_end":1971,"column_start":39,"column_end":46},"kind":{"Impl":{"id":2410}},"from":{"krate":0,"index":32824},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1433265,"byte_end":1433272,"line_start":1979,"line_end":1979,"column_start":22,"column_end":29},"kind":{"Impl":{"id":2411}},"from":{"krate":0,"index":32824},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1433564,"byte_end":1433571,"line_start":1991,"line_end":1991,"column_start":35,"column_end":42},"kind":{"Impl":{"id":2412}},"from":{"krate":0,"index":32824},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1434503,"byte_end":1434510,"line_start":2023,"line_end":2023,"column_start":57,"column_end":64},"kind":{"Impl":{"id":2413}},"from":{"krate":0,"index":32824},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1435328,"byte_end":1435335,"line_start":2050,"line_end":2050,"column_start":53,"column_end":60},"kind":{"Impl":{"id":2414}},"from":{"krate":0,"index":32824},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1435595,"byte_end":1435602,"line_start":2063,"line_end":2063,"column_start":45,"column_end":52},"kind":{"Impl":{"id":2415}},"from":{"krate":0,"index":32824},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1219549,"byte_end":1219558,"line_start":377,"line_end":377,"column_start":20,"column_end":29},"kind":{"Impl":{"id":2416}},"from":{"krate":0,"index":32833},"to":{"krate":0,"index":1819}},{"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1219974,"byte_end":1219983,"line_start":393,"line_end":393,"column_start":12,"column_end":21},"kind":{"Impl":{"id":2417}},"from":{"krate":0,"index":32833},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1220188,"byte_end":1220197,"line_start":403,"line_end":403,"column_start":14,"column_end":23},"kind":{"Impl":{"id":2418}},"from":{"krate":0,"index":32833},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1467438,"byte_end":1467444,"line_start":163,"line_end":163,"column_start":9,"column_end":15},"kind":{"Impl":{"id":2419}},"from":{"krate":0,"index":32847},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1488420,"byte_end":1488426,"line_start":877,"line_end":877,"column_start":15,"column_end":21},"kind":{"Impl":{"id":2420}},"from":{"krate":0,"index":32847},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1488888,"byte_end":1488894,"line_start":896,"line_end":896,"column_start":15,"column_end":21},"kind":{"Impl":{"id":2421}},"from":{"krate":0,"index":32847},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1489381,"byte_end":1489387,"line_start":915,"line_end":915,"column_start":16,"column_end":22},"kind":{"Impl":{"id":2422}},"from":{"krate":0,"index":32847},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1489855,"byte_end":1489861,"line_start":934,"line_end":934,"column_start":16,"column_end":22},"kind":{"Impl":{"id":2423}},"from":{"krate":0,"index":32847},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1490368,"byte_end":1490374,"line_start":953,"line_end":953,"column_start":18,"column_end":24},"kind":{"Impl":{"id":2424}},"from":{"krate":0,"index":32847},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1491798,"byte_end":1491804,"line_start":993,"line_end":993,"column_start":16,"column_end":22},"kind":{"Impl":{"id":2425}},"from":{"krate":0,"index":32847},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1492145,"byte_end":1492151,"line_start":1003,"line_end":1003,"column_start":12,"column_end":18},"kind":{"Impl":{"id":2426}},"from":{"krate":0,"index":32847},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1493361,"byte_end":1493367,"line_start":1042,"line_end":1042,"column_start":26,"column_end":32},"kind":{"Impl":{"id":2427}},"from":{"krate":0,"index":32847},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1493802,"byte_end":1493808,"line_start":1061,"line_end":1061,"column_start":21,"column_end":27},"kind":{"Impl":{"id":2428}},"from":{"krate":0,"index":32847},"to":{"krate":0,"index":2080}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1493981,"byte_end":1493987,"line_start":1068,"line_end":1068,"column_start":26,"column_end":32},"kind":{"Impl":{"id":2429}},"from":{"krate":0,"index":32847},"to":{"krate":0,"index":3392}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1495056,"byte_end":1495062,"line_start":1112,"line_end":1112,"column_start":21,"column_end":27},"kind":{"Impl":{"id":2430}},"from":{"krate":0,"index":32847},"to":{"krate":0,"index":2096}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1495234,"byte_end":1495240,"line_start":1119,"line_end":1119,"column_start":37,"column_end":43},"kind":{"Impl":{"id":2431}},"from":{"krate":0,"index":32847},"to":{"krate":0,"index":2096}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1495435,"byte_end":1495441,"line_start":1126,"line_end":1126,"column_start":41,"column_end":47},"kind":{"Impl":{"id":2432}},"from":{"krate":0,"index":32847},"to":{"krate":0,"index":2096}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1495805,"byte_end":1495809,"line_start":1141,"line_end":1141,"column_start":22,"column_end":26},"kind":{"Impl":{"id":2433}},"from":{"krate":0,"index":32880},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1496131,"byte_end":1496135,"line_start":1158,"line_end":1158,"column_start":33,"column_end":37},"kind":{"Impl":{"id":2434}},"from":{"krate":0,"index":32880},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1496261,"byte_end":1496265,"line_start":1165,"line_end":1165,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2435}},"from":{"krate":0,"index":32880},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1496298,"byte_end":1496302,"line_start":1166,"line_end":1166,"column_start":27,"column_end":31},"kind":{"Impl":{"id":2436}},"from":{"krate":0,"index":32880},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1496339,"byte_end":1496343,"line_start":1167,"line_end":1167,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2437}},"from":{"krate":0,"index":32880},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1496897,"byte_end":1496901,"line_start":1183,"line_end":1183,"column_start":26,"column_end":30},"kind":{"Impl":{"id":2438}},"from":{"krate":0,"index":32889},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1497187,"byte_end":1497191,"line_start":1193,"line_end":1193,"column_start":37,"column_end":41},"kind":{"Impl":{"id":2439}},"from":{"krate":0,"index":32889},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1497366,"byte_end":1497370,"line_start":1199,"line_end":1199,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2440}},"from":{"krate":0,"index":32889},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1497455,"byte_end":1497459,"line_start":1202,"line_end":1202,"column_start":27,"column_end":31},"kind":{"Impl":{"id":2441}},"from":{"krate":0,"index":32889},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1497555,"byte_end":1497559,"line_start":1205,"line_end":1205,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2442}},"from":{"krate":0,"index":32889},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1497635,"byte_end":1497639,"line_start":1208,"line_end":1208,"column_start":19,"column_end":23},"kind":{"Impl":{"id":2443}},"from":{"krate":0,"index":32889},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1498318,"byte_end":1498325,"line_start":1229,"line_end":1229,"column_start":26,"column_end":33},"kind":{"Impl":{"id":2444}},"from":{"krate":0,"index":32897},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1498619,"byte_end":1498626,"line_start":1239,"line_end":1239,"column_start":37,"column_end":44},"kind":{"Impl":{"id":2445}},"from":{"krate":0,"index":32897},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1498805,"byte_end":1498812,"line_start":1245,"line_end":1245,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2446}},"from":{"krate":0,"index":32897},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1498897,"byte_end":1498904,"line_start":1248,"line_end":1248,"column_start":27,"column_end":34},"kind":{"Impl":{"id":2447}},"from":{"krate":0,"index":32897},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1498999,"byte_end":1499006,"line_start":1250,"line_end":1250,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2448}},"from":{"krate":0,"index":32897},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1499568,"byte_end":1499576,"line_start":1266,"line_end":1266,"column_start":22,"column_end":30},"kind":{"Impl":{"id":2449}},"from":{"krate":0,"index":32905},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1499846,"byte_end":1499854,"line_start":1276,"line_end":1276,"column_start":33,"column_end":41},"kind":{"Impl":{"id":2450}},"from":{"krate":0,"index":32905},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1500021,"byte_end":1500029,"line_start":1282,"line_end":1282,"column_start":31,"column_end":39},"kind":{"Impl":{"id":2451}},"from":{"krate":0,"index":32905},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1500110,"byte_end":1500118,"line_start":1285,"line_end":1285,"column_start":27,"column_end":35},"kind":{"Impl":{"id":2452}},"from":{"krate":0,"index":32905},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1500210,"byte_end":1500218,"line_start":1288,"line_end":1288,"column_start":31,"column_end":39},"kind":{"Impl":{"id":2453}},"from":{"krate":0,"index":32905},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1500501,"byte_end":1500507,"line_start":1295,"line_end":1295,"column_start":57,"column_end":63},"kind":{"Impl":{"id":2454}},"from":{"krate":0,"index":32847},"to":{"krate":0,"index":3388}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1502913,"byte_end":1502920,"line_start":1368,"line_end":1368,"column_start":62,"column_end":69},"kind":{"Impl":{"id":2455}},"from":{"krate":0,"index":4620},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1504483,"byte_end":1504489,"line_start":1414,"line_end":1414,"column_start":22,"column_end":28},"kind":{"Impl":{"id":2456}},"from":{"krate":0,"index":32847},"to":{"krate":0,"index":1819}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1504797,"byte_end":1504803,"line_start":1434,"line_end":1434,"column_start":9,"column_end":15},"kind":{"Impl":{"id":2457}},"from":{"krate":0,"index":32847},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1516936,"byte_end":1516942,"line_start":260,"line_end":260,"column_start":12,"column_end":18},"kind":{"Impl":{"id":2458}},"from":{"krate":0,"index":32938},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1532313,"byte_end":1532319,"line_start":771,"line_end":771,"column_start":24,"column_end":30},"kind":{"Impl":{"id":2459}},"from":{"krate":0,"index":32938},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1534020,"byte_end":1534026,"line_start":832,"line_end":832,"column_start":24,"column_end":30},"kind":{"Impl":{"id":2460}},"from":{"krate":0,"index":32938},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1535713,"byte_end":1535719,"line_start":892,"line_end":892,"column_start":21,"column_end":27},"kind":{"Impl":{"id":2461}},"from":{"krate":0,"index":32938},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1537110,"byte_end":1537116,"line_start":931,"line_end":931,"column_start":19,"column_end":25},"kind":{"Impl":{"id":2462}},"from":{"krate":0,"index":32938},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1537581,"byte_end":1537587,"line_start":943,"line_end":943,"column_start":19,"column_end":25},"kind":{"Impl":{"id":2463}},"from":{"krate":0,"index":32938},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1538069,"byte_end":1538075,"line_start":956,"line_end":956,"column_start":26,"column_end":32},"kind":{"Impl":{"id":2464}},"from":{"krate":0,"index":32938},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1538511,"byte_end":1538517,"line_start":968,"line_end":968,"column_start":12,"column_end":18},"kind":{"Impl":{"id":2465}},"from":{"krate":0,"index":32938},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1539769,"byte_end":1539775,"line_start":1007,"line_end":1007,"column_start":36,"column_end":42},"kind":{"Impl":{"id":2466}},"from":{"krate":0,"index":32938},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1540283,"byte_end":1540289,"line_start":1028,"line_end":1028,"column_start":29,"column_end":35},"kind":{"Impl":{"id":2467}},"from":{"krate":0,"index":32938},"to":{"krate":0,"index":3392}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1542126,"byte_end":1542130,"line_start":1093,"line_end":1093,"column_start":26,"column_end":30},"kind":{"Impl":{"id":2468}},"from":{"krate":0,"index":32980},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1542472,"byte_end":1542476,"line_start":1106,"line_end":1106,"column_start":37,"column_end":41},"kind":{"Impl":{"id":2469}},"from":{"krate":0,"index":32980},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1542646,"byte_end":1542650,"line_start":1112,"line_end":1112,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2470}},"from":{"krate":0,"index":32980},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1542735,"byte_end":1542739,"line_start":1115,"line_end":1115,"column_start":27,"column_end":31},"kind":{"Impl":{"id":2471}},"from":{"krate":0,"index":32980},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1542835,"byte_end":1542839,"line_start":1118,"line_end":1118,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2472}},"from":{"krate":0,"index":32980},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1542915,"byte_end":1542919,"line_start":1121,"line_end":1121,"column_start":19,"column_end":23},"kind":{"Impl":{"id":2473}},"from":{"krate":0,"index":32980},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1543456,"byte_end":1543463,"line_start":1138,"line_end":1138,"column_start":26,"column_end":33},"kind":{"Impl":{"id":2474}},"from":{"krate":0,"index":32988},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1543813,"byte_end":1543820,"line_start":1151,"line_end":1151,"column_start":37,"column_end":44},"kind":{"Impl":{"id":2475}},"from":{"krate":0,"index":32988},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1543994,"byte_end":1544001,"line_start":1157,"line_end":1157,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2476}},"from":{"krate":0,"index":32988},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1544086,"byte_end":1544093,"line_start":1160,"line_end":1160,"column_start":27,"column_end":34},"kind":{"Impl":{"id":2477}},"from":{"krate":0,"index":32988},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1544189,"byte_end":1544196,"line_start":1163,"line_end":1163,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2478}},"from":{"krate":0,"index":32988},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1544867,"byte_end":1544875,"line_start":1181,"line_end":1181,"column_start":22,"column_end":30},"kind":{"Impl":{"id":2479}},"from":{"krate":0,"index":32996},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1545201,"byte_end":1545209,"line_start":1194,"line_end":1194,"column_start":33,"column_end":41},"kind":{"Impl":{"id":2480}},"from":{"krate":0,"index":32996},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1545371,"byte_end":1545379,"line_start":1200,"line_end":1200,"column_start":31,"column_end":39},"kind":{"Impl":{"id":2481}},"from":{"krate":0,"index":32996},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1545460,"byte_end":1545468,"line_start":1203,"line_end":1203,"column_start":27,"column_end":35},"kind":{"Impl":{"id":2482}},"from":{"krate":0,"index":32996},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1545560,"byte_end":1545568,"line_start":1206,"line_end":1206,"column_start":31,"column_end":39},"kind":{"Impl":{"id":2483}},"from":{"krate":0,"index":32996},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1545857,"byte_end":1545863,"line_start":1213,"line_end":1213,"column_start":63,"column_end":69},"kind":{"Impl":{"id":2484}},"from":{"krate":0,"index":32938},"to":{"krate":0,"index":3388}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1547861,"byte_end":1547868,"line_start":1266,"line_end":1266,"column_start":68,"column_end":75},"kind":{"Impl":{"id":2485}},"from":{"krate":0,"index":4800},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1548760,"byte_end":1548766,"line_start":1298,"line_end":1298,"column_start":24,"column_end":30},"kind":{"Impl":{"id":2486}},"from":{"krate":0,"index":32938},"to":{"krate":0,"index":1819}},{"span":{"file_name":"src/libcore/ffi.rs","byte_start":1550794,"byte_end":1550800,"line_start":43,"line_end":43,"column_start":21,"column_end":27},"kind":{"Impl":{"id":2487}},"from":{"krate":0,"index":4826},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/ffi.rs","byte_start":1557254,"byte_end":1557264,"line_start":219,"line_end":219,"column_start":10,"column_end":20},"kind":{"Impl":{"id":2488}},"from":{"krate":0,"index":33005},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ffi.rs","byte_start":1557751,"byte_end":1557757,"line_start":234,"line_end":234,"column_start":28,"column_end":34},"kind":{"Impl":{"id":2489}},"from":{"krate":0,"index":33015},"to":{"krate":0,"index":1601}},{"span":{"file_name":"src/libcore/ffi.rs","byte_start":1558108,"byte_end":1558114,"line_start":247,"line_end":247,"column_start":31,"column_end":37},"kind":{"Impl":{"id":2490}},"from":{"krate":0,"index":33015},"to":{"krate":0,"index":1612}},{"span":{"file_name":"src/libcore/ffi.rs","byte_start":1560370,"byte_end":1560380,"line_start":306,"line_end":306,"column_start":10,"column_end":20},"kind":{"Impl":{"id":2502}},"from":{"krate":0,"index":33005},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ffi.rs","byte_start":1561053,"byte_end":1561063,"line_start":328,"line_end":328,"column_start":20,"column_end":30},"kind":{"Impl":{"id":2503}},"from":{"krate":0,"index":33005},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/ffi.rs","byte_start":1561517,"byte_end":1561527,"line_start":344,"line_end":344,"column_start":19,"column_end":29},"kind":{"Impl":{"id":2504}},"from":{"krate":0,"index":33005},"to":{"krate":0,"index":1623}},{"span":{"file_name":"src/libcore/slice/rotate.rs","byte_start":1747655,"byte_end":1747663,"line_start":18,"line_end":18,"column_start":9,"column_end":17},"kind":{"Impl":{"id":2505}},"from":{"krate":0,"index":4930},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/slice/sort.rs","byte_start":1750483,"byte_end":1750493,"line_start":19,"line_end":19,"column_start":18,"column_end":28},"kind":{"Impl":{"id":2506}},"from":{"krate":0,"index":4948},"to":{"krate":0,"index":1623}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1652022,"byte_end":1652027,"line_start":2578,"line_end":2578,"column_start":26,"column_end":31},"kind":{"Impl":{"id":2508}},"from":{"krate":0,"index":26067},"to":{"krate":0,"index":5160}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1652124,"byte_end":1652131,"line_start":2580,"line_end":2580,"column_start":26,"column_end":33},"kind":{"Impl":{"id":2509}},"from":{"krate":0,"index":26102},"to":{"krate":0,"index":5160}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1652228,"byte_end":1652237,"line_start":2582,"line_end":2582,"column_start":26,"column_end":35},"kind":{"Impl":{"id":2510}},"from":{"krate":0,"index":26085},"to":{"krate":0,"index":5160}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1652334,"byte_end":1652343,"line_start":2584,"line_end":2584,"column_start":26,"column_end":35},"kind":{"Impl":{"id":2511}},"from":{"krate":0,"index":26055},"to":{"krate":0,"index":5160}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1652433,"byte_end":1652447,"line_start":2586,"line_end":2586,"column_start":26,"column_end":40},"kind":{"Impl":{"id":2512}},"from":{"krate":0,"index":26121},"to":{"krate":0,"index":5160}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1652544,"byte_end":1652560,"line_start":2588,"line_end":2588,"column_start":26,"column_end":42},"kind":{"Impl":{"id":2513}},"from":{"krate":0,"index":26129},"to":{"krate":0,"index":5160}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1653251,"byte_end":1653257,"line_start":2606,"line_end":2606,"column_start":55,"column_end":61},"kind":"SuperTrait","from":{"krate":0,"index":5160},"to":{"krate":0,"index":5168}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1655951,"byte_end":1655956,"line_start":2692,"line_end":2692,"column_start":35,"column_end":40},"kind":{"Impl":{"id":2515}},"from":{"krate":0,"index":26067},"to":{"krate":0,"index":5168}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1657628,"byte_end":1657635,"line_start":2753,"line_end":2753,"column_start":34,"column_end":41},"kind":{"Impl":{"id":2516}},"from":{"krate":0,"index":26102},"to":{"krate":0,"index":5168}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1658457,"byte_end":1658466,"line_start":2788,"line_end":2788,"column_start":34,"column_end":43},"kind":{"Impl":{"id":2517}},"from":{"krate":0,"index":26085},"to":{"krate":0,"index":5168}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1659360,"byte_end":1659369,"line_start":2823,"line_end":2823,"column_start":34,"column_end":43},"kind":{"Impl":{"id":2518}},"from":{"krate":0,"index":26055},"to":{"krate":0,"index":5168}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1660041,"byte_end":1660055,"line_start":2859,"line_end":2859,"column_start":34,"column_end":48},"kind":{"Impl":{"id":2519}},"from":{"krate":0,"index":26121},"to":{"krate":0,"index":5168}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1661261,"byte_end":1661277,"line_start":2898,"line_end":2898,"column_start":34,"column_end":50},"kind":{"Impl":{"id":2520}},"from":{"krate":0,"index":26129},"to":{"krate":0,"index":5168}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1676293,"byte_end":1676297,"line_start":3327,"line_end":3327,"column_start":36,"column_end":40},"kind":{"Impl":{"id":2521}},"from":{"krate":0,"index":5263},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1676544,"byte_end":1676548,"line_start":3336,"line_end":3336,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2522}},"from":{"krate":0,"index":5263},"to":{"krate":0,"index":1446}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1676635,"byte_end":1676639,"line_start":3338,"line_end":3338,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2523}},"from":{"krate":0,"index":5263},"to":{"krate":0,"index":1437}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1676663,"byte_end":1676667,"line_start":3340,"line_end":3340,"column_start":13,"column_end":17},"kind":{"Impl":{"id":2524}},"from":{"krate":0,"index":5263},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1678077,"byte_end":1678081,"line_start":3384,"line_end":3384,"column_start":19,"column_end":23},"kind":{"Impl":{"id":2525}},"from":{"krate":0,"index":5263},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1678269,"byte_end":1678273,"line_start":3389,"line_end":3389,"column_start":24,"column_end":28},"kind":{"Impl":{"id":2526}},"from":{"krate":0,"index":5263},"to":{"krate":0,"index":2087}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1679432,"byte_end":1679439,"line_start":3429,"line_end":3429,"column_start":36,"column_end":43},"kind":{"Impl":{"id":2527}},"from":{"krate":0,"index":5286},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1679691,"byte_end":1679698,"line_start":3438,"line_end":3438,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2528}},"from":{"krate":0,"index":5286},"to":{"krate":0,"index":1446}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1679785,"byte_end":1679792,"line_start":3440,"line_end":3440,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2529}},"from":{"krate":0,"index":5286},"to":{"krate":0,"index":1437}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1679816,"byte_end":1679823,"line_start":3442,"line_end":3442,"column_start":13,"column_end":20},"kind":{"Impl":{"id":2530}},"from":{"krate":0,"index":5286},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1682336,"byte_end":1682355,"line_start":3515,"line_end":3515,"column_start":18,"column_end":37},"kind":"SuperTrait","from":{"krate":0,"index":3360},"to":{"krate":0,"index":5304}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1683031,"byte_end":1683036,"line_start":3536,"line_end":3536,"column_start":39,"column_end":44},"kind":{"Impl":{"id":2531}},"from":{"krate":0,"index":5306},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1683404,"byte_end":1683409,"line_start":3547,"line_end":3547,"column_start":22,"column_end":27},"kind":{"Impl":{"id":2532}},"from":{"krate":0,"index":5306},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1683693,"byte_end":1683698,"line_start":3558,"line_end":3558,"column_start":29,"column_end":34},"kind":{"Impl":{"id":2533}},"from":{"krate":0,"index":5306},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1684409,"byte_end":1684414,"line_start":3586,"line_end":3586,"column_start":40,"column_end":45},"kind":{"Impl":{"id":2534}},"from":{"krate":0,"index":5306},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1684857,"byte_end":1684862,"line_start":3602,"line_end":3602,"column_start":30,"column_end":35},"kind":{"Impl":{"id":2535}},"from":{"krate":0,"index":5306},"to":{"krate":0,"index":5304}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1685125,"byte_end":1685130,"line_start":3610,"line_end":3610,"column_start":30,"column_end":35},"kind":{"Impl":{"id":2536}},"from":{"krate":0,"index":5306},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1685721,"byte_end":1685729,"line_start":3627,"line_end":3627,"column_start":39,"column_end":47},"kind":{"Impl":{"id":2537}},"from":{"krate":0,"index":5343},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1686007,"byte_end":1686015,"line_start":3636,"line_end":3636,"column_start":30,"column_end":38},"kind":{"Impl":{"id":2538}},"from":{"krate":0,"index":5343},"to":{"krate":0,"index":5304}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1686360,"byte_end":1686368,"line_start":3649,"line_end":3649,"column_start":29,"column_end":37},"kind":{"Impl":{"id":2539}},"from":{"krate":0,"index":5343},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1687436,"byte_end":1687444,"line_start":3684,"line_end":3684,"column_start":40,"column_end":48},"kind":{"Impl":{"id":2540}},"from":{"krate":0,"index":5343},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1688144,"byte_end":1688152,"line_start":3708,"line_end":3708,"column_start":30,"column_end":38},"kind":{"Impl":{"id":2541}},"from":{"krate":0,"index":5343},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1688815,"byte_end":1688821,"line_start":3724,"line_end":3724,"column_start":39,"column_end":45},"kind":{"Impl":{"id":2542}},"from":{"krate":0,"index":33147},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1689162,"byte_end":1689168,"line_start":3734,"line_end":3734,"column_start":29,"column_end":35},"kind":{"Impl":{"id":2543}},"from":{"krate":0,"index":33147},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1689529,"byte_end":1689535,"line_start":3749,"line_end":3749,"column_start":40,"column_end":46},"kind":{"Impl":{"id":2544}},"from":{"krate":0,"index":33147},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1689756,"byte_end":1689762,"line_start":3757,"line_end":3757,"column_start":30,"column_end":36},"kind":{"Impl":{"id":2545}},"from":{"krate":0,"index":33147},"to":{"krate":0,"index":5304}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1689982,"byte_end":1689988,"line_start":3765,"line_end":3765,"column_start":30,"column_end":36},"kind":{"Impl":{"id":2546}},"from":{"krate":0,"index":33147},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1690603,"byte_end":1690612,"line_start":3780,"line_end":3780,"column_start":39,"column_end":48},"kind":{"Impl":{"id":2547}},"from":{"krate":0,"index":5400},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1690957,"byte_end":1690966,"line_start":3790,"line_end":3790,"column_start":30,"column_end":39},"kind":{"Impl":{"id":2548}},"from":{"krate":0,"index":5400},"to":{"krate":0,"index":5304}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1691189,"byte_end":1691198,"line_start":3798,"line_end":3798,"column_start":29,"column_end":38},"kind":{"Impl":{"id":2549}},"from":{"krate":0,"index":5400},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1691567,"byte_end":1691576,"line_start":3813,"line_end":3813,"column_start":40,"column_end":49},"kind":{"Impl":{"id":2550}},"from":{"krate":0,"index":5400},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1691806,"byte_end":1691815,"line_start":3823,"line_end":3823,"column_start":30,"column_end":39},"kind":{"Impl":{"id":2551}},"from":{"krate":0,"index":5400},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1692122,"byte_end":1692135,"line_start":3834,"line_end":3834,"column_start":44,"column_end":57},"kind":{"Impl":{"id":2552}},"from":{"krate":0,"index":33157},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1693143,"byte_end":1693149,"line_start":3866,"line_end":3866,"column_start":39,"column_end":45},"kind":{"Impl":{"id":2553}},"from":{"krate":0,"index":5436},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1693954,"byte_end":1693961,"line_start":3888,"line_end":3888,"column_start":39,"column_end":46},"kind":{"Impl":{"id":2554}},"from":{"krate":0,"index":5445},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1694740,"byte_end":1694749,"line_start":3909,"line_end":3909,"column_start":39,"column_end":48},"kind":{"Impl":{"id":2555}},"from":{"krate":0,"index":5454},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1695575,"byte_end":1695585,"line_start":3931,"line_end":3931,"column_start":39,"column_end":49},"kind":{"Impl":{"id":2556}},"from":{"krate":0,"index":5463},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1697189,"byte_end":1697196,"line_start":3984,"line_end":3984,"column_start":19,"column_end":26},"kind":{"Impl":{"id":2557}},"from":{"krate":0,"index":33208},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1697396,"byte_end":1697403,"line_start":3994,"line_end":3994,"column_start":26,"column_end":33},"kind":{"Impl":{"id":2558}},"from":{"krate":0,"index":33208},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1698667,"byte_end":1698674,"line_start":4048,"line_end":4048,"column_start":37,"column_end":44},"kind":{"Impl":{"id":2559}},"from":{"krate":0,"index":33208},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1699409,"byte_end":1699416,"line_start":4075,"line_end":4075,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2560}},"from":{"krate":0,"index":33208},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1699512,"byte_end":1699519,"line_start":4078,"line_end":4078,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2561}},"from":{"krate":0,"index":33208},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1699604,"byte_end":1699611,"line_start":4081,"line_end":4081,"column_start":27,"column_end":34},"kind":{"Impl":{"id":2562}},"from":{"krate":0,"index":33208},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1699681,"byte_end":1699688,"line_start":4084,"line_end":4084,"column_start":44,"column_end":51},"kind":{"Impl":{"id":2563}},"from":{"krate":0,"index":33208},"to":{"krate":0,"index":3771}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1700570,"byte_end":1700576,"line_start":4110,"line_end":4110,"column_start":19,"column_end":25},"kind":{"Impl":{"id":2564}},"from":{"krate":0,"index":33217},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1700787,"byte_end":1700793,"line_start":4120,"line_end":4120,"column_start":26,"column_end":32},"kind":{"Impl":{"id":2565}},"from":{"krate":0,"index":33217},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1702424,"byte_end":1702430,"line_start":4181,"line_end":4181,"column_start":37,"column_end":43},"kind":{"Impl":{"id":2566}},"from":{"krate":0,"index":33217},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1703476,"byte_end":1703482,"line_start":4215,"line_end":4215,"column_start":31,"column_end":37},"kind":{"Impl":{"id":2567}},"from":{"krate":0,"index":33217},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1703578,"byte_end":1703584,"line_start":4218,"line_end":4218,"column_start":31,"column_end":37},"kind":{"Impl":{"id":2568}},"from":{"krate":0,"index":33217},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1703669,"byte_end":1703675,"line_start":4221,"line_end":4221,"column_start":27,"column_end":33},"kind":{"Impl":{"id":2569}},"from":{"krate":0,"index":33217},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1703745,"byte_end":1703751,"line_start":4224,"line_end":4224,"column_start":44,"column_end":50},"kind":{"Impl":{"id":2570}},"from":{"krate":0,"index":33217},"to":{"krate":0,"index":3771}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1704819,"byte_end":1704828,"line_start":4254,"line_end":4254,"column_start":26,"column_end":35},"kind":{"Impl":{"id":2571}},"from":{"krate":0,"index":33226},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1706644,"byte_end":1706653,"line_start":4318,"line_end":4318,"column_start":37,"column_end":46},"kind":{"Impl":{"id":2572}},"from":{"krate":0,"index":33226},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1707237,"byte_end":1707246,"line_start":4336,"line_end":4336,"column_start":31,"column_end":40},"kind":{"Impl":{"id":2573}},"from":{"krate":0,"index":33226},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1707342,"byte_end":1707351,"line_start":4339,"line_end":4339,"column_start":31,"column_end":40},"kind":{"Impl":{"id":2574}},"from":{"krate":0,"index":33226},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1707436,"byte_end":1707445,"line_start":4342,"line_end":4342,"column_start":27,"column_end":36},"kind":{"Impl":{"id":2575}},"from":{"krate":0,"index":33226},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1707515,"byte_end":1707524,"line_start":4345,"line_end":4345,"column_start":44,"column_end":53},"kind":{"Impl":{"id":2576}},"from":{"krate":0,"index":33226},"to":{"krate":0,"index":3771}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1708719,"byte_end":1708730,"line_start":4377,"line_end":4377,"column_start":13,"column_end":24},"kind":{"Impl":{"id":2577}},"from":{"krate":0,"index":33235},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1709166,"byte_end":1709177,"line_start":4389,"line_end":4389,"column_start":19,"column_end":30},"kind":{"Impl":{"id":2578}},"from":{"krate":0,"index":33235},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1709428,"byte_end":1709439,"line_start":4400,"line_end":4400,"column_start":26,"column_end":37},"kind":{"Impl":{"id":2579}},"from":{"krate":0,"index":33235},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1710498,"byte_end":1710509,"line_start":4445,"line_end":4445,"column_start":37,"column_end":48},"kind":{"Impl":{"id":2580}},"from":{"krate":0,"index":33235},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1710889,"byte_end":1710900,"line_start":4459,"line_end":4459,"column_start":31,"column_end":42},"kind":{"Impl":{"id":2581}},"from":{"krate":0,"index":33235},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1711062,"byte_end":1711073,"line_start":4466,"line_end":4466,"column_start":31,"column_end":42},"kind":{"Impl":{"id":2582}},"from":{"krate":0,"index":33235},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1711165,"byte_end":1711176,"line_start":4469,"line_end":4469,"column_start":27,"column_end":38},"kind":{"Impl":{"id":2583}},"from":{"krate":0,"index":33235},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1711300,"byte_end":1711311,"line_start":4473,"line_end":4473,"column_start":44,"column_end":55},"kind":{"Impl":{"id":2584}},"from":{"krate":0,"index":33235},"to":{"krate":0,"index":3771}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1712387,"byte_end":1712401,"line_start":4501,"line_end":4501,"column_start":13,"column_end":27},"kind":{"Impl":{"id":2585}},"from":{"krate":0,"index":33245},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1712797,"byte_end":1712811,"line_start":4512,"line_end":4512,"column_start":26,"column_end":40},"kind":{"Impl":{"id":2586}},"from":{"krate":0,"index":33245},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1714005,"byte_end":1714019,"line_start":4559,"line_end":4559,"column_start":37,"column_end":51},"kind":{"Impl":{"id":2587}},"from":{"krate":0,"index":33245},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1714498,"byte_end":1714512,"line_start":4575,"line_end":4575,"column_start":31,"column_end":45},"kind":{"Impl":{"id":2588}},"from":{"krate":0,"index":33245},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1714674,"byte_end":1714688,"line_start":4582,"line_end":4582,"column_start":31,"column_end":45},"kind":{"Impl":{"id":2589}},"from":{"krate":0,"index":33245},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1714780,"byte_end":1714794,"line_start":4585,"line_end":4585,"column_start":27,"column_end":41},"kind":{"Impl":{"id":2590}},"from":{"krate":0,"index":33245},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1714918,"byte_end":1714932,"line_start":4589,"line_end":4589,"column_start":44,"column_end":58},"kind":{"Impl":{"id":2591}},"from":{"krate":0,"index":33245},"to":{"krate":0,"index":3771}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1715881,"byte_end":1715888,"line_start":4616,"line_end":4616,"column_start":19,"column_end":26},"kind":{"Impl":{"id":2592}},"from":{"krate":0,"index":33255},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1716103,"byte_end":1716110,"line_start":4626,"line_end":4626,"column_start":26,"column_end":33},"kind":{"Impl":{"id":2593}},"from":{"krate":0,"index":33255},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1717864,"byte_end":1717871,"line_start":4690,"line_end":4690,"column_start":37,"column_end":44},"kind":{"Impl":{"id":2594}},"from":{"krate":0,"index":33255},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1718901,"byte_end":1718908,"line_start":4723,"line_end":4723,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2595}},"from":{"krate":0,"index":33255},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1719004,"byte_end":1719011,"line_start":4726,"line_end":4726,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2596}},"from":{"krate":0,"index":33255},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1719098,"byte_end":1719105,"line_start":4729,"line_end":4729,"column_start":27,"column_end":34},"kind":{"Impl":{"id":2597}},"from":{"krate":0,"index":33255},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1719224,"byte_end":1719231,"line_start":4733,"line_end":4733,"column_start":44,"column_end":51},"kind":{"Impl":{"id":2598}},"from":{"krate":0,"index":33255},"to":{"krate":0,"index":3771}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1720285,"byte_end":1720295,"line_start":4763,"line_end":4763,"column_start":26,"column_end":36},"kind":{"Impl":{"id":2599}},"from":{"krate":0,"index":33264},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1722270,"byte_end":1722280,"line_start":4831,"line_end":4831,"column_start":37,"column_end":47},"kind":{"Impl":{"id":2600}},"from":{"krate":0,"index":33264},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1723454,"byte_end":1723464,"line_start":4866,"line_end":4866,"column_start":31,"column_end":41},"kind":{"Impl":{"id":2601}},"from":{"krate":0,"index":33264},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1723560,"byte_end":1723570,"line_start":4869,"line_end":4869,"column_start":31,"column_end":41},"kind":{"Impl":{"id":2602}},"from":{"krate":0,"index":33264},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1723657,"byte_end":1723667,"line_start":4872,"line_end":4872,"column_start":27,"column_end":37},"kind":{"Impl":{"id":2603}},"from":{"krate":0,"index":33264},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1723786,"byte_end":1723796,"line_start":4876,"line_end":4876,"column_start":44,"column_end":54},"kind":{"Impl":{"id":2604}},"from":{"krate":0,"index":33264},"to":{"krate":0,"index":3771}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1724966,"byte_end":1724978,"line_start":4908,"line_end":4908,"column_start":13,"column_end":25},"kind":{"Impl":{"id":2605}},"from":{"krate":0,"index":33273},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1725408,"byte_end":1725420,"line_start":4920,"line_end":4920,"column_start":23,"column_end":35},"kind":{"Impl":{"id":2606}},"from":{"krate":0,"index":33273},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1725682,"byte_end":1725694,"line_start":4931,"line_end":4931,"column_start":26,"column_end":38},"kind":{"Impl":{"id":2607}},"from":{"krate":0,"index":33273},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1726772,"byte_end":1726784,"line_start":4976,"line_end":4976,"column_start":37,"column_end":49},"kind":{"Impl":{"id":2608}},"from":{"krate":0,"index":33273},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1727740,"byte_end":1727752,"line_start":5008,"line_end":5008,"column_start":35,"column_end":47},"kind":{"Impl":{"id":2609}},"from":{"krate":0,"index":33273},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1727914,"byte_end":1727926,"line_start":5015,"line_end":5015,"column_start":31,"column_end":43},"kind":{"Impl":{"id":2610}},"from":{"krate":0,"index":33273},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1728013,"byte_end":1728025,"line_start":5018,"line_end":5018,"column_start":27,"column_end":39},"kind":{"Impl":{"id":2611}},"from":{"krate":0,"index":33273},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1728144,"byte_end":1728156,"line_start":5022,"line_end":5022,"column_start":44,"column_end":56},"kind":{"Impl":{"id":2612}},"from":{"krate":0,"index":33273},"to":{"krate":0,"index":3771}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1729281,"byte_end":1729296,"line_start":5051,"line_end":5051,"column_start":13,"column_end":28},"kind":{"Impl":{"id":2613}},"from":{"krate":0,"index":33283},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1729682,"byte_end":1729697,"line_start":5062,"line_end":5062,"column_start":26,"column_end":41},"kind":{"Impl":{"id":2614}},"from":{"krate":0,"index":33283},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1730974,"byte_end":1730989,"line_start":5111,"line_end":5111,"column_start":37,"column_end":52},"kind":{"Impl":{"id":2615}},"from":{"krate":0,"index":33283},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1732095,"byte_end":1732110,"line_start":5145,"line_end":5145,"column_start":31,"column_end":46},"kind":{"Impl":{"id":2616}},"from":{"krate":0,"index":33283},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1732272,"byte_end":1732287,"line_start":5152,"line_end":5152,"column_start":31,"column_end":46},"kind":{"Impl":{"id":2617}},"from":{"krate":0,"index":33283},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1732374,"byte_end":1732389,"line_start":5155,"line_end":5155,"column_start":27,"column_end":42},"kind":{"Impl":{"id":2618}},"from":{"krate":0,"index":33283},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1732508,"byte_end":1732523,"line_start":5159,"line_end":5159,"column_start":44,"column_end":59},"kind":{"Impl":{"id":2619}},"from":{"krate":0,"index":33283},"to":{"krate":0,"index":3771}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1741628,"byte_end":1741632,"line_start":5459,"line_end":5459,"column_start":44,"column_end":48},"kind":{"Impl":{"id":2634}},"from":{"krate":0,"index":5263},"to":{"krate":0,"index":3771}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1741843,"byte_end":1741850,"line_start":5467,"line_end":5467,"column_start":44,"column_end":51},"kind":{"Impl":{"id":2635}},"from":{"krate":0,"index":5286},"to":{"krate":0,"index":3771}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1742032,"byte_end":1742037,"line_start":5474,"line_end":5474,"column_start":22,"column_end":27},"kind":"SuperTrait","from":{"krate":0,"index":1442},"to":{"krate":0,"index":5800}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1742119,"byte_end":1742120,"line_start":5478,"line_end":5478,"column_start":27,"column_end":28},"kind":{"Impl":{"id":2636}},"from":{"krate":0,"index":5803},"to":{"krate":0,"index":5800}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1920375,"byte_end":1920380,"line_start":28,"line_end":28,"column_start":24,"column_end":29},"kind":"SuperTrait","from":{"krate":0,"index":1442},"to":{"krate":0,"index":5843}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1925518,"byte_end":1925526,"line_start":167,"line_end":167,"column_start":39,"column_end":47},"kind":"SuperTrait","from":{"krate":0,"index":5850},"to":{"krate":0,"index":5856}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1928114,"byte_end":1928129,"line_start":234,"line_end":234,"column_start":36,"column_end":51},"kind":"SuperTrait","from":{"krate":0,"index":5856},"to":{"krate":0,"index":5861}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1929607,"byte_end":1929619,"line_start":269,"line_end":269,"column_start":34,"column_end":46},"kind":{"Impl":{"id":2639}},"from":{"krate":0,"index":33328},"to":{"krate":0,"index":5850}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1932926,"byte_end":1932938,"line_start":343,"line_end":343,"column_start":41,"column_end":53},"kind":{"Impl":{"id":2640}},"from":{"krate":0,"index":33328},"to":{"krate":0,"index":5856}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1936645,"byte_end":1936657,"line_start":419,"line_end":419,"column_start":38,"column_end":50},"kind":{"Impl":{"id":2641}},"from":{"krate":0,"index":33328},"to":{"krate":0,"index":5861}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1938221,"byte_end":1938222,"line_start":478,"line_end":478,"column_start":25,"column_end":26},"kind":{"Impl":{"id":2643}},"from":{"krate":0,"index":5886},"to":{"krate":0,"index":5883}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1938714,"byte_end":1938732,"line_start":499,"line_end":499,"column_start":42,"column_end":60},"kind":{"Impl":{"id":2644}},"from":{"krate":0,"index":5891},"to":{"krate":0,"index":5843}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1939079,"byte_end":1939098,"line_start":512,"line_end":512,"column_start":50,"column_end":69},"kind":{"Impl":{"id":2645}},"from":{"krate":0,"index":33343},"to":{"krate":0,"index":5850}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1939845,"byte_end":1939864,"line_start":537,"line_end":537,"column_start":57,"column_end":76},"kind":{"Impl":{"id":2646}},"from":{"krate":0,"index":33343},"to":{"krate":0,"index":5856}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1940539,"byte_end":1940558,"line_start":557,"line_end":557,"column_start":54,"column_end":73},"kind":{"Impl":{"id":2647}},"from":{"krate":0,"index":33343},"to":{"krate":0,"index":5861}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1942720,"byte_end":1942737,"line_start":634,"line_end":634,"column_start":38,"column_end":55},"kind":{"Impl":{"id":2648}},"from":{"krate":0,"index":33357},"to":{"krate":0,"index":5850}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1942827,"byte_end":1942844,"line_start":638,"line_end":638,"column_start":45,"column_end":62},"kind":{"Impl":{"id":2649}},"from":{"krate":0,"index":33357},"to":{"krate":0,"index":5856}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1942931,"byte_end":1942948,"line_start":642,"line_end":642,"column_start":42,"column_end":59},"kind":{"Impl":{"id":2650}},"from":{"krate":0,"index":33357},"to":{"krate":0,"index":5861}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1943578,"byte_end":1943599,"line_start":658,"line_end":658,"column_start":24,"column_end":45},"kind":{"Impl":{"id":2651}},"from":{"krate":0,"index":33382},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1943925,"byte_end":1943946,"line_start":668,"line_end":668,"column_start":37,"column_end":58},"kind":{"Impl":{"id":2652}},"from":{"krate":0,"index":33382},"to":{"krate":0,"index":5850}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1944067,"byte_end":1944088,"line_start":674,"line_end":674,"column_start":44,"column_end":65},"kind":{"Impl":{"id":2653}},"from":{"krate":0,"index":33382},"to":{"krate":0,"index":5856}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1944206,"byte_end":1944227,"line_start":680,"line_end":680,"column_start":41,"column_end":62},"kind":{"Impl":{"id":2654}},"from":{"krate":0,"index":33382},"to":{"krate":0,"index":5861}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1944354,"byte_end":1944355,"line_start":684,"line_end":684,"column_start":29,"column_end":30},"kind":{"Impl":{"id":2655}},"from":{"krate":0,"index":5940},"to":{"krate":0,"index":5843}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1946513,"byte_end":1946524,"line_start":757,"line_end":757,"column_start":14,"column_end":25},"kind":{"Impl":{"id":2656}},"from":{"krate":0,"index":33413},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1947271,"byte_end":1947282,"line_start":782,"line_end":782,"column_start":38,"column_end":49},"kind":{"Impl":{"id":2657}},"from":{"krate":0,"index":33413},"to":{"krate":0,"index":5850}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1950762,"byte_end":1950773,"line_start":863,"line_end":863,"column_start":45,"column_end":56},"kind":{"Impl":{"id":2658}},"from":{"krate":0,"index":33413},"to":{"krate":0,"index":5856}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1957681,"byte_end":1957695,"line_start":1028,"line_end":1028,"column_start":6,"column_end":20},"kind":{"Impl":{"id":2659}},"from":{"krate":0,"index":33447},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1971807,"byte_end":1971816,"line_start":1379,"line_end":1379,"column_start":25,"column_end":34},"kind":{"Impl":{"id":2660}},"from":{"krate":0,"index":5983},"to":{"krate":0,"index":5978}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1972160,"byte_end":1972174,"line_start":1393,"line_end":1393,"column_start":25,"column_end":39},"kind":{"Impl":{"id":2661}},"from":{"krate":0,"index":5989},"to":{"krate":0,"index":5978}},{"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1972674,"byte_end":1972683,"line_start":12,"line_end":12,"column_start":6,"column_end":15},"kind":{"Impl":{"id":2662}},"from":{"krate":0,"index":6002},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1973546,"byte_end":1973565,"line_start":45,"line_end":45,"column_start":23,"column_end":42},"kind":{"Impl":{"id":2663}},"from":{"krate":0,"index":6008},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1976672,"byte_end":1976681,"line_start":140,"line_end":140,"column_start":23,"column_end":32},"kind":{"Impl":{"id":2664}},"from":{"krate":0,"index":6002},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1977580,"byte_end":1977589,"line_start":166,"line_end":166,"column_start":21,"column_end":30},"kind":{"Impl":{"id":2665}},"from":{"krate":0,"index":6002},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1780653,"byte_end":1780658,"line_start":74,"line_end":74,"column_start":20,"column_end":25},"kind":"SuperTrait","from":{"krate":0,"index":1442},"to":{"krate":0,"index":6022}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1783053,"byte_end":1783067,"line_start":150,"line_end":150,"column_start":23,"column_end":37},"kind":{"Impl":{"id":2667}},"from":{"krate":0,"index":33474},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1784800,"byte_end":1784809,"line_start":208,"line_end":208,"column_start":6,"column_end":15},"kind":{"Impl":{"id":2668}},"from":{"krate":0,"index":33485},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1791933,"byte_end":1791942,"line_start":443,"line_end":443,"column_start":23,"column_end":32},"kind":{"Impl":{"id":2669}},"from":{"krate":0,"index":33485},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1795684,"byte_end":1795689,"line_start":563,"line_end":563,"column_start":23,"column_end":28},"kind":{"Impl":{"id":2670}},"from":{"krate":0,"index":33498},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1796897,"byte_end":1796902,"line_start":604,"line_end":604,"column_start":34,"column_end":39},"kind":{"Impl":{"id":2671}},"from":{"krate":0,"index":33498},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1797269,"byte_end":1797274,"line_start":617,"line_end":617,"column_start":24,"column_end":29},"kind":{"Impl":{"id":2672}},"from":{"krate":0,"index":33498},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1797292,"byte_end":1797297,"line_start":619,"line_end":619,"column_start":10,"column_end":15},"kind":{"Impl":{"id":2673}},"from":{"krate":0,"index":33498},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1798554,"byte_end":1798565,"line_start":661,"line_end":661,"column_start":23,"column_end":34},"kind":{"Impl":{"id":2674}},"from":{"krate":0,"index":33507},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1799417,"byte_end":1799428,"line_start":696,"line_end":696,"column_start":34,"column_end":45},"kind":{"Impl":{"id":2675}},"from":{"krate":0,"index":33507},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1799725,"byte_end":1799736,"line_start":707,"line_end":707,"column_start":24,"column_end":35},"kind":{"Impl":{"id":2676}},"from":{"krate":0,"index":33507},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1799754,"byte_end":1799765,"line_start":709,"line_end":709,"column_start":10,"column_end":21},"kind":{"Impl":{"id":2677}},"from":{"krate":0,"index":33507},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1800567,"byte_end":1800572,"line_start":733,"line_end":733,"column_start":19,"column_end":24},"kind":{"Impl":{"id":2678}},"from":{"krate":0,"index":33517},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1801853,"byte_end":1801858,"line_start":794,"line_end":794,"column_start":30,"column_end":35},"kind":{"Impl":{"id":2679}},"from":{"krate":0,"index":33517},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1802307,"byte_end":1802312,"line_start":814,"line_end":814,"column_start":28,"column_end":33},"kind":{"Impl":{"id":2680}},"from":{"krate":0,"index":33517},"to":{"krate":0,"index":3380}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1802542,"byte_end":1802547,"line_start":827,"line_end":827,"column_start":24,"column_end":29},"kind":{"Impl":{"id":2681}},"from":{"krate":0,"index":33517},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1802637,"byte_end":1802642,"line_start":830,"line_end":830,"column_start":28,"column_end":33},"kind":{"Impl":{"id":2682}},"from":{"krate":0,"index":33517},"to":{"krate":0,"index":3494}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1802702,"byte_end":1802707,"line_start":833,"line_end":833,"column_start":37,"column_end":42},"kind":{"Impl":{"id":2683}},"from":{"krate":0,"index":33517},"to":{"krate":0,"index":3771}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1809933,"byte_end":1809946,"line_start":1042,"line_end":1042,"column_start":41,"column_end":54},"kind":{"Impl":{"id":2684}},"from":{"krate":0,"index":6113},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1810386,"byte_end":1810399,"line_start":1054,"line_end":1054,"column_start":26,"column_end":39},"kind":{"Impl":{"id":2685}},"from":{"krate":0,"index":6113},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1813459,"byte_end":1813473,"line_start":1159,"line_end":1159,"column_start":41,"column_end":55},"kind":{"Impl":{"id":2686}},"from":{"krate":0,"index":6131},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1813753,"byte_end":1813767,"line_start":1168,"line_end":1168,"column_start":26,"column_end":40},"kind":{"Impl":{"id":2687}},"from":{"krate":0,"index":6131},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1815037,"byte_end":1815057,"line_start":1215,"line_end":1215,"column_start":41,"column_end":61},"kind":{"Impl":{"id":2688}},"from":{"krate":0,"index":6145},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1815290,"byte_end":1815310,"line_start":1223,"line_end":1223,"column_start":26,"column_end":46},"kind":{"Impl":{"id":2689}},"from":{"krate":0,"index":6145},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1816584,"byte_end":1816599,"line_start":1266,"line_end":1266,"column_start":41,"column_end":56},"kind":{"Impl":{"id":2690}},"from":{"krate":0,"index":6161},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1816827,"byte_end":1816842,"line_start":1274,"line_end":1274,"column_start":26,"column_end":41},"kind":{"Impl":{"id":2691}},"from":{"krate":0,"index":6161},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1818390,"byte_end":1818395,"line_start":1324,"line_end":1324,"column_start":23,"column_end":28},"kind":{"Impl":{"id":2692}},"from":{"krate":0,"index":33785},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1818696,"byte_end":1818701,"line_start":1339,"line_end":1339,"column_start":34,"column_end":39},"kind":{"Impl":{"id":2693}},"from":{"krate":0,"index":33785},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1818877,"byte_end":1818882,"line_start":1347,"line_end":1347,"column_start":24,"column_end":29},"kind":{"Impl":{"id":2694}},"from":{"krate":0,"index":33785},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1819577,"byte_end":1819585,"line_start":1370,"line_end":1370,"column_start":23,"column_end":31},"kind":{"Impl":{"id":2695}},"from":{"krate":0,"index":33795},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1819907,"byte_end":1819915,"line_start":1386,"line_end":1386,"column_start":34,"column_end":42},"kind":{"Impl":{"id":2696}},"from":{"krate":0,"index":33795},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1820112,"byte_end":1820120,"line_start":1395,"line_end":1395,"column_start":24,"column_end":32},"kind":{"Impl":{"id":2697}},"from":{"krate":0,"index":33795},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1829328,"byte_end":1829337,"line_start":1657,"line_end":1657,"column_start":35,"column_end":44},"kind":{"Impl":{"id":2704}},"from":{"krate":0,"index":26055},"to":{"krate":0,"index":5168}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1831199,"byte_end":1831204,"line_start":1721,"line_end":1721,"column_start":35,"column_end":40},"kind":{"Impl":{"id":2705}},"from":{"krate":0,"index":26067},"to":{"krate":0,"index":5168}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1833997,"byte_end":1834004,"line_start":1790,"line_end":1790,"column_start":35,"column_end":42},"kind":{"Impl":{"id":2706}},"from":{"krate":0,"index":26102},"to":{"krate":0,"index":5168}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1836329,"byte_end":1836338,"line_start":1851,"line_end":1851,"column_start":35,"column_end":44},"kind":{"Impl":{"id":2707}},"from":{"krate":0,"index":26085},"to":{"krate":0,"index":5168}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1838924,"byte_end":1838938,"line_start":1914,"line_end":1914,"column_start":35,"column_end":49},"kind":{"Impl":{"id":2708}},"from":{"krate":0,"index":26121},"to":{"krate":0,"index":5168}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1840878,"byte_end":1840894,"line_start":1961,"line_end":1961,"column_start":35,"column_end":51},"kind":{"Impl":{"id":2709}},"from":{"krate":0,"index":26129},"to":{"krate":0,"index":5168}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1914327,"byte_end":1914342,"line_start":4232,"line_end":4232,"column_start":23,"column_end":38},"kind":{"Impl":{"id":2712}},"from":{"krate":0,"index":33852},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1914662,"byte_end":1914677,"line_start":4247,"line_end":4247,"column_start":34,"column_end":49},"kind":{"Impl":{"id":2713}},"from":{"krate":0,"index":33852},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1914857,"byte_end":1914872,"line_start":4255,"line_end":4255,"column_start":24,"column_end":39},"kind":{"Impl":{"id":2714}},"from":{"krate":0,"index":33852},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1914967,"byte_end":1914987,"line_start":4258,"line_end":4258,"column_start":23,"column_end":43},"kind":{"Impl":{"id":2715}},"from":{"krate":0,"index":33861},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1915314,"byte_end":1915334,"line_start":4273,"line_end":4273,"column_start":34,"column_end":54},"kind":{"Impl":{"id":2716}},"from":{"krate":0,"index":33861},"to":{"krate":0,"index":3360}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1915531,"byte_end":1915551,"line_start":4281,"line_end":4281,"column_start":24,"column_end":44},"kind":{"Impl":{"id":2717}},"from":{"krate":0,"index":33861},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1916113,"byte_end":1916124,"line_start":4300,"line_end":4300,"column_start":21,"column_end":32},"kind":{"Impl":{"id":2718}},"from":{"krate":0,"index":33940},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1916314,"byte_end":1916325,"line_start":4307,"line_end":4307,"column_start":23,"column_end":34},"kind":{"Impl":{"id":2719}},"from":{"krate":0,"index":33940},"to":{"krate":0,"index":3202}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1917171,"byte_end":1917182,"line_start":4339,"line_end":4339,"column_start":24,"column_end":35},"kind":{"Impl":{"id":2720}},"from":{"krate":0,"index":33940},"to":{"krate":0,"index":3491}},{"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2003261,"byte_end":2003270,"line_start":134,"line_end":134,"column_start":6,"column_end":15},"kind":{"Impl":{"id":2721}},"from":{"krate":0,"index":34044},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2004055,"byte_end":2004066,"line_start":156,"line_end":156,"column_start":6,"column_end":17},"kind":{"Impl":{"id":2722}},"from":{"krate":0,"index":34028},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2004878,"byte_end":2004884,"line_start":178,"line_end":178,"column_start":14,"column_end":20},"kind":{"Impl":{"id":2723}},"from":{"krate":0,"index":34053},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2006974,"byte_end":2006983,"line_start":242,"line_end":242,"column_start":24,"column_end":33},"kind":{"Impl":{"id":2724}},"from":{"krate":0,"index":34044},"to":{"krate":0,"index":6486}},{"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2007241,"byte_end":2007252,"line_start":255,"line_end":255,"column_start":24,"column_end":35},"kind":{"Impl":{"id":2725}},"from":{"krate":0,"index":34028},"to":{"krate":0,"index":6486}},{"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2007458,"byte_end":2007464,"line_start":267,"line_end":267,"column_start":32,"column_end":38},"kind":{"Impl":{"id":2726}},"from":{"krate":0,"index":34053},"to":{"krate":0,"index":6486}},{"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2009353,"byte_end":2009359,"line_start":340,"line_end":340,"column_start":24,"column_end":30},"kind":{"Impl":{"id":2727}},"from":{"krate":0,"index":34053},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2009684,"byte_end":2009690,"line_start":355,"line_end":355,"column_start":26,"column_end":32},"kind":{"Impl":{"id":2728}},"from":{"krate":0,"index":34053},"to":{"krate":0,"index":2080}},{"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2010014,"byte_end":2010025,"line_start":372,"line_end":372,"column_start":14,"column_end":25},"kind":{"Impl":{"id":2729}},"from":{"krate":0,"index":34075},"to":{"krate":0,"index":6472}},{"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":2010317,"byte_end":2010328,"line_start":389,"line_end":389,"column_start":14,"column_end":25},"kind":{"Impl":{"id":2730}},"from":{"krate":0,"index":34083},"to":{"krate":0,"index":6472}},{"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1992888,"byte_end":1992906,"line_start":502,"line_end":502,"column_start":24,"column_end":42},"kind":{"Impl":{"id":2731}},"from":{"krate":0,"index":6520},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1993115,"byte_end":1993133,"line_start":509,"line_end":509,"column_start":43,"column_end":61},"kind":{"Impl":{"id":2732}},"from":{"krate":0,"index":6520},"to":{"krate":0,"index":6517}},{"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1993296,"byte_end":1993314,"line_start":518,"line_end":518,"column_start":19,"column_end":37},"kind":{"Impl":{"id":2733}},"from":{"krate":0,"index":6520},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1993497,"byte_end":1993515,"line_start":525,"line_end":525,"column_start":21,"column_end":39},"kind":{"Impl":{"id":2734}},"from":{"krate":0,"index":6520},"to":{"krate":0,"index":2080}},{"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1993701,"byte_end":1993719,"line_start":532,"line_end":532,"column_start":23,"column_end":41},"kind":{"Impl":{"id":2735}},"from":{"krate":0,"index":6520},"to":{"krate":0,"index":1936}},{"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1993878,"byte_end":1993896,"line_start":539,"line_end":539,"column_start":16,"column_end":34},"kind":{"Impl":{"id":2736}},"from":{"krate":0,"index":6520},"to":{"krate":0,"index":1940}},{"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2085058,"byte_end":2085067,"line_start":12,"line_end":12,"column_start":12,"column_end":21},"kind":"SuperTrait","from":{"krate":0,"index":1936},"to":{"krate":0,"index":6636}},{"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2085070,"byte_end":2085080,"line_start":12,"line_end":12,"column_start":24,"column_end":34},"kind":"SuperTrait","from":{"krate":0,"index":1970},"to":{"krate":0,"index":6636}},{"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2085083,"byte_end":2085086,"line_start":12,"line_end":12,"column_start":37,"column_end":40},"kind":"SuperTrait","from":{"krate":0,"index":1508},"to":{"krate":0,"index":6636}},{"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2085102,"byte_end":2085105,"line_start":12,"line_end":12,"column_start":56,"column_end":59},"kind":"SuperTrait","from":{"krate":0,"index":1514},"to":{"krate":0,"index":6636}},{"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2085132,"byte_end":2085135,"line_start":13,"line_end":13,"column_start":12,"column_end":15},"kind":"SuperTrait","from":{"krate":0,"index":1498},"to":{"krate":0,"index":6636}},{"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2085151,"byte_end":2085155,"line_start":13,"line_end":13,"column_start":31,"column_end":35},"kind":"SuperTrait","from":{"krate":0,"index":1445},"to":{"krate":0,"index":6636}},{"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2094709,"byte_end":2094719,"line_start":8,"line_end":8,"column_start":10,"column_end":20},"kind":{"Impl":{"id":2740}},"from":{"krate":0,"index":6662},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2095080,"byte_end":2095090,"line_start":21,"line_end":21,"column_start":21,"column_end":31},"kind":{"Impl":{"id":2741}},"from":{"krate":0,"index":6662},"to":{"krate":0,"index":6783}},{"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2097156,"byte_end":2097167,"line_start":99,"line_end":99,"column_start":18,"column_end":29},"kind":{"Impl":{"id":2742}},"from":{"krate":0,"index":6674},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2101707,"byte_end":2101717,"line_start":250,"line_end":250,"column_start":18,"column_end":28},"kind":{"Impl":{"id":2743}},"from":{"krate":0,"index":6691},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2104500,"byte_end":2104510,"line_start":344,"line_end":344,"column_start":18,"column_end":28},"kind":{"Impl":{"id":2744}},"from":{"krate":0,"index":6709},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2106451,"byte_end":2106459,"line_start":416,"line_end":416,"column_start":18,"column_end":26},"kind":{"Impl":{"id":2745}},"from":{"krate":0,"index":6721},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2110228,"byte_end":2110237,"line_start":553,"line_end":553,"column_start":18,"column_end":27},"kind":{"Impl":{"id":2746}},"from":{"krate":0,"index":6737},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2114039,"byte_end":2114047,"line_start":690,"line_end":690,"column_start":18,"column_end":26},"kind":{"Impl":{"id":2747}},"from":{"krate":0,"index":6753},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2019312,"byte_end":2019322,"line_start":269,"line_end":269,"column_start":10,"column_end":20},"kind":{"Impl":{"id":2748}},"from":{"krate":0,"index":34652},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2020505,"byte_end":2020514,"line_start":308,"line_end":308,"column_start":10,"column_end":19},"kind":{"Impl":{"id":2749}},"from":{"krate":0,"index":34677},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2024500,"byte_end":2024509,"line_start":408,"line_end":408,"column_start":16,"column_end":25},"kind":{"Impl":{"id":2750}},"from":{"krate":0,"index":34677},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2024675,"byte_end":2024684,"line_start":415,"line_end":415,"column_start":18,"column_end":27},"kind":{"Impl":{"id":2751}},"from":{"krate":0,"index":34677},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2041468,"byte_end":2041479,"line_start":1046,"line_end":1046,"column_start":6,"column_end":17},"kind":{"Impl":{"id":2752}},"from":{"krate":0,"index":6843},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2041786,"byte_end":2041795,"line_start":1060,"line_end":1060,"column_start":10,"column_end":19},"kind":{"Impl":{"id":2753}},"from":{"krate":0,"index":6793},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2070231,"byte_end":2070240,"line_start":1886,"line_end":1886,"column_start":16,"column_end":25},"kind":{"Impl":{"id":2754}},"from":{"krate":0,"index":6793},"to":{"krate":0,"index":6783}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2070584,"byte_end":2070589,"line_start":1901,"line_end":1901,"column_start":18,"column_end":23},"kind":{"Impl":{"id":2755}},"from":{"krate":0,"index":34632},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2076489,"byte_end":2076500,"line_start":2111,"line_end":2111,"column_start":27,"column_end":38},"kind":{"Impl":{"id":2762}},"from":{"krate":0,"index":1452},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2076675,"byte_end":2076679,"line_start":2118,"line_end":2118,"column_start":33,"column_end":37},"kind":{"Impl":{"id":2763}},"from":{"krate":0,"index":2386},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2076921,"byte_end":2076928,"line_start":2127,"line_end":2127,"column_start":35,"column_end":42},"kind":{"Impl":{"id":2764}},"from":{"krate":0,"index":2443},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2077414,"byte_end":2077433,"line_start":2140,"line_end":2140,"column_start":32,"column_end":51},"kind":{"Impl":{"id":2765}},"from":{"krate":0,"index":6948},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2077839,"byte_end":2077842,"line_start":2155,"line_end":2155,"column_start":35,"column_end":38},"kind":{"Impl":{"id":2766}},"from":{"krate":0,"index":2521},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2078025,"byte_end":2078031,"line_start":2162,"line_end":2162,"column_start":35,"column_end":41},"kind":{"Impl":{"id":2767}},"from":{"krate":0,"index":2567},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2078233,"byte_end":2078243,"line_start":2169,"line_end":2169,"column_start":35,"column_end":45},"kind":{"Impl":{"id":2768}},"from":{"krate":0,"index":2586},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2120615,"byte_end":2120623,"line_start":60,"line_end":60,"column_start":6,"column_end":14},"kind":{"Impl":{"id":2769}},"from":{"krate":0,"index":34837},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2142650,"byte_end":2142658,"line_start":732,"line_end":732,"column_start":14,"column_end":22},"kind":{"Impl":{"id":2770}},"from":{"krate":0,"index":34837},"to":{"krate":0,"index":1493}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2142901,"byte_end":2142909,"line_start":741,"line_end":741,"column_start":20,"column_end":28},"kind":{"Impl":{"id":2771}},"from":{"krate":0,"index":34837},"to":{"krate":0,"index":1526}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2143058,"byte_end":2143066,"line_start":748,"line_end":748,"column_start":14,"column_end":22},"kind":{"Impl":{"id":2772}},"from":{"krate":0,"index":34837},"to":{"krate":0,"index":1498}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2143314,"byte_end":2143322,"line_start":757,"line_end":757,"column_start":20,"column_end":28},"kind":{"Impl":{"id":2773}},"from":{"krate":0,"index":34837},"to":{"krate":0,"index":1530}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2143476,"byte_end":2143484,"line_start":764,"line_end":764,"column_start":19,"column_end":27},"kind":{"Impl":{"id":2774}},"from":{"krate":0,"index":34837},"to":{"krate":0,"index":1503}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2143941,"byte_end":2143949,"line_start":782,"line_end":782,"column_start":25,"column_end":33},"kind":{"Impl":{"id":2776}},"from":{"krate":0,"index":34837},"to":{"krate":0,"index":1534}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2144098,"byte_end":2144106,"line_start":789,"line_end":789,"column_start":19,"column_end":27},"kind":{"Impl":{"id":2777}},"from":{"krate":0,"index":34837},"to":{"krate":0,"index":1508}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2144372,"byte_end":2144380,"line_start":798,"line_end":798,"column_start":25,"column_end":33},"kind":{"Impl":{"id":2778}},"from":{"krate":0,"index":34837},"to":{"krate":0,"index":1538}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2145594,"byte_end":2145602,"line_start":835,"line_end":835,"column_start":14,"column_end":22},"kind":{"Impl":{"id":2779}},"from":{"krate":0,"index":34837},"to":{"krate":0,"index":3413}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2145790,"byte_end":2145798,"line_start":842,"line_end":842,"column_start":32,"column_end":40},"kind":{"Impl":{"id":2780}},"from":{"krate":0,"index":34837},"to":{"krate":0,"index":3413}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2145986,"byte_end":2145994,"line_start":849,"line_end":849,"column_start":21,"column_end":29},"kind":{"Impl":{"id":2781}},"from":{"krate":0,"index":34837},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2153188,"byte_end":2153196,"line_start":33,"line_end":33,"column_start":6,"column_end":14},"kind":{"Impl":{"id":2782}},"from":{"krate":0,"index":7048},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2153866,"byte_end":2153879,"line_start":54,"line_end":54,"column_start":6,"column_end":19},"kind":{"Impl":{"id":2783}},"from":{"krate":0,"index":7060},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/future/future.rs","byte_start":2400040,"byte_end":2400043,"line_start":110,"line_end":110,"column_start":20,"column_end":23},"kind":{"Impl":{"id":2784}},"from":{"krate":0,"index":32035},"to":{"krate":0,"index":7139}},{"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2401588,"byte_end":2401592,"line_start":28,"line_end":28,"column_start":9,"column_end":13},"kind":{"Impl":{"id":2785}},"from":{"krate":0,"index":34900},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2402414,"byte_end":2402418,"line_start":58,"line_end":58,"column_start":12,"column_end":16},"kind":{"Impl":{"id":2786}},"from":{"krate":0,"index":34900},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2403357,"byte_end":2403361,"line_start":85,"line_end":85,"column_start":21,"column_end":25},"kind":{"Impl":{"id":2787}},"from":{"krate":0,"index":34900},"to":{"krate":0,"index":2096}},{"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2403502,"byte_end":2403506,"line_start":92,"line_end":92,"column_start":20,"column_end":24},"kind":{"Impl":{"id":2788}},"from":{"krate":0,"index":34900},"to":{"krate":0,"index":1819}},{"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2404068,"byte_end":2404072,"line_start":117,"line_end":117,"column_start":20,"column_end":24},"kind":{"Impl":{"id":2789}},"from":{"krate":0,"index":34900},"to":{"krate":0,"index":1819}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2405733,"byte_end":2405741,"line_start":28,"line_end":28,"column_start":6,"column_end":14},"kind":{"Impl":{"id":2790}},"from":{"krate":0,"index":34936},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2409128,"byte_end":2409142,"line_start":108,"line_end":108,"column_start":6,"column_end":20},"kind":{"Impl":{"id":2791}},"from":{"krate":0,"index":34944},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2412095,"byte_end":2412102,"line_start":186,"line_end":186,"column_start":10,"column_end":17},"kind":{"Impl":{"id":2792}},"from":{"krate":0,"index":7199},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2412643,"byte_end":2412650,"line_start":206,"line_end":206,"column_start":21,"column_end":28},"kind":{"Impl":{"id":2793}},"from":{"krate":0,"index":7199},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2413328,"byte_end":2413333,"line_start":230,"line_end":230,"column_start":16,"column_end":21},"kind":{"Impl":{"id":2794}},"from":{"krate":0,"index":7209},"to":{"krate":0,"index":1473}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2413411,"byte_end":2413416,"line_start":232,"line_end":232,"column_start":22,"column_end":27},"kind":{"Impl":{"id":2795}},"from":{"krate":0,"index":7209},"to":{"krate":0,"index":1437}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2413494,"byte_end":2413499,"line_start":234,"line_end":234,"column_start":22,"column_end":27},"kind":{"Impl":{"id":2796}},"from":{"krate":0,"index":7209},"to":{"krate":0,"index":1446}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2413509,"byte_end":2413514,"line_start":236,"line_end":236,"column_start":6,"column_end":11},"kind":{"Impl":{"id":2797}},"from":{"krate":0,"index":7209},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2416085,"byte_end":2416090,"line_start":301,"line_end":301,"column_start":16,"column_end":21},"kind":{"Impl":{"id":2798}},"from":{"krate":0,"index":7209},"to":{"krate":0,"index":2056}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2416533,"byte_end":2416538,"line_start":314,"line_end":314,"column_start":15,"column_end":20},"kind":{"Impl":{"id":2799}},"from":{"krate":0,"index":7209},"to":{"krate":0,"index":1623}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2416928,"byte_end":2416933,"line_start":325,"line_end":325,"column_start":21,"column_end":26},"kind":{"Impl":{"id":2800}},"from":{"krate":0,"index":7209},"to":{"krate":0,"index":6824}},{"span":{"file_name":"src/libcore/alloc.rs","byte_start":2418991,"byte_end":2418997,"line_start":52,"line_end":52,"column_start":6,"column_end":12},"kind":{"Impl":{"id":2801}},"from":{"krate":0,"index":34963},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/alloc.rs","byte_start":2431164,"byte_end":2431173,"line_start":340,"line_end":340,"column_start":23,"column_end":32},"kind":{"Impl":{"id":2802}},"from":{"krate":0,"index":34976},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/alloc.rs","byte_start":2431757,"byte_end":2431765,"line_start":356,"line_end":356,"column_start":23,"column_end":31},"kind":{"Impl":{"id":2803}},"from":{"krate":0,"index":34987},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/alloc.rs","byte_start":2432241,"byte_end":2432261,"line_start":370,"line_end":370,"column_start":6,"column_end":26},"kind":{"Impl":{"id":2804}},"from":{"krate":0,"index":34997},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/alloc.rs","byte_start":2432500,"byte_end":2432520,"line_start":378,"line_end":378,"column_start":23,"column_end":43},"kind":{"Impl":{"id":2805}},"from":{"krate":0,"index":34997},"to":{"krate":0,"index":6826}},{"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2510834,"byte_end":2510839,"line_start":356,"line_end":356,"column_start":28,"column_end":33},"kind":"SuperTrait","from":{"krate":0,"index":1442},"to":{"krate":0,"index":7458}},{"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2511889,"byte_end":2511896,"line_start":400,"line_end":400,"column_start":19,"column_end":26},"kind":{"Impl":{"id":2806}},"from":{"krate":0,"index":36990},"to":{"krate":0,"index":7458}},{"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2512079,"byte_end":2512084,"line_start":409,"line_end":409,"column_start":28,"column_end":33},"kind":"SuperTrait","from":{"krate":0,"index":1442},"to":{"krate":0,"index":7470}},{"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2513138,"byte_end":2513145,"line_start":453,"line_end":453,"column_start":19,"column_end":26},"kind":{"Impl":{"id":2807}},"from":{"krate":0,"index":37019},"to":{"krate":0,"index":7470}},{"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2513328,"byte_end":2513333,"line_start":462,"line_end":462,"column_start":28,"column_end":33},"kind":"SuperTrait","from":{"krate":0,"index":1442},"to":{"krate":0,"index":7482}},{"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2513517,"byte_end":2513524,"line_start":471,"line_end":471,"column_start":19,"column_end":26},"kind":{"Impl":{"id":2808}},"from":{"krate":0,"index":37056},"to":{"krate":0,"index":7482}}]}